From af1f04d5d7d6e3a077b41b15687c1fe0893bd31d Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 13 Feb 2018 19:51:26 +0000
Subject: [PATCH 093/220] rtl8192cu: Updates for 4.15

---
 .../realtek/rtl8192cu/core/efuse/rtw_efuse.c       |  160 +-
 .../net/wireless/realtek/rtl8192cu/core/rtw_ap.c   |  852 +++---
 .../wireless/realtek/rtl8192cu/core/rtw_br_ext.c   |  102 +-
 .../net/wireless/realtek/rtl8192cu/core/rtw_cmd.c  |  797 ++---
 .../wireless/realtek/rtl8192cu/core/rtw_debug.c    |  363 +--
 .../wireless/realtek/rtl8192cu/core/rtw_eeprom.c   |   89 +-
 .../realtek/rtl8192cu/core/rtw_ieee80211.c         |  366 +--
 .../net/wireless/realtek/rtl8192cu/core/rtw_io.c   |   28 +-
 .../realtek/rtl8192cu/core/rtw_ioctl_query.c       |   59 +-
 .../realtek/rtl8192cu/core/rtw_ioctl_rtl.c         |  234 +-
 .../realtek/rtl8192cu/core/rtw_ioctl_set.c         |  440 +--
 .../net/wireless/realtek/rtl8192cu/core/rtw_iol.c  |   23 +-
 .../net/wireless/realtek/rtl8192cu/core/rtw_mlme.c | 1115 +++----
 .../wireless/realtek/rtl8192cu/core/rtw_mlme_ext.c | 1723 +++++------
 .../net/wireless/realtek/rtl8192cu/core/rtw_mp.c   |   17 +-
 .../wireless/realtek/rtl8192cu/core/rtw_mp_ioctl.c |    7 +-
 .../net/wireless/realtek/rtl8192cu/core/rtw_p2p.c  |  669 +++--
 .../wireless/realtek/rtl8192cu/core/rtw_pwrctrl.c  |  155 +-
 .../net/wireless/realtek/rtl8192cu/core/rtw_recv.c |  340 ++-
 .../net/wireless/realtek/rtl8192cu/core/rtw_rf.c   |    3 +-
 .../wireless/realtek/rtl8192cu/core/rtw_security.c |  331 +--
 .../wireless/realtek/rtl8192cu/core/rtw_sreset.c   |   11 +-
 .../wireless/realtek/rtl8192cu/core/rtw_sta_mgt.c  |  247 +-
 .../net/wireless/realtek/rtl8192cu/core/rtw_tdls.c |  323 +--
 .../realtek/rtl8192cu/core/rtw_wlan_util.c         |  437 +--
 .../net/wireless/realtek/rtl8192cu/core/rtw_xmit.c |  707 ++---
 .../wireless/realtek/rtl8192cu/hal/HalPwrSeqCmd.c  |    2 +
 drivers/net/wireless/realtek/rtl8192cu/hal/dm.c    |   31 +-
 drivers/net/wireless/realtek/rtl8192cu/hal/dm.h    |    2 +-
 .../net/wireless/realtek/rtl8192cu/hal/hal_com.c   |   83 +-
 .../net/wireless/realtek/rtl8192cu/hal/hal_intf.c  |   59 +-
 .../realtek/rtl8192cu/hal/rtl8192c/rtl8192c_cmd.c  |  195 +-
 .../realtek/rtl8192cu/hal/rtl8192c/rtl8192c_dm.c   | 1097 +++----
 .../rtl8192cu/hal/rtl8192c/rtl8192c_hal_init.c     |  633 ++--
 .../realtek/rtl8192cu/hal/rtl8192c/rtl8192c_mp.c   |    8 +-
 .../rtl8192cu/hal/rtl8192c/rtl8192c_phycfg.c       | 1051 +++----
 .../rtl8192cu/hal/rtl8192c/rtl8192c_rf6052.c       |  229 +-
 .../rtl8192cu/hal/rtl8192c/rtl8192c_rxdesc.c       |   52 +-
 .../rtl8192cu/hal/rtl8192c/rtl8192c_sreset.c       |   17 +-
 .../realtek/rtl8192cu/hal/rtl8192c/rtl8192c_xmit.c |    5 +-
 .../rtl8192cu/hal/rtl8192c/usb/Hal8192CUHWImg.c    |    3 +-
 .../hal/rtl8192c/usb/Hal8192CUHWImg_wowlan.c       |    9 +-
 .../rtl8192cu/hal/rtl8192c/usb/rtl8192cu_led.c     |  730 ++---
 .../rtl8192cu/hal/rtl8192c/usb/rtl8192cu_recv.c    |    6 +-
 .../rtl8192cu/hal/rtl8192c/usb/rtl8192cu_xmit.c    |  239 +-
 .../rtl8192cu/hal/rtl8192c/usb/usb_halinit.c       | 1173 ++++----
 .../rtl8192cu/hal/rtl8192c/usb/usb_ops_ce.c        |  328 +--
 .../rtl8192cu/hal/rtl8192c/usb/usb_ops_linux.c     |  489 ++--
 .../rtl8192cu/hal/rtl8192c/usb/usb_ops_xp.c        |  673 ++---
 .../realtek/rtl8192cu/include/Hal8192CEHWImg.h     |    2 +-
 .../realtek/rtl8192cu/include/Hal8192CPhyCfg.h     |  107 +-
 .../realtek/rtl8192cu/include/Hal8192CPhyReg.h     |  133 +-
 .../realtek/rtl8192cu/include/Hal8192CUHWImg.h     |    2 +-
 .../rtl8192cu/include/Hal8192CUHWImg_wowlan.h      |    3 +-
 .../realtek/rtl8192cu/include/Hal8192DEHWImg.h     |    2 +-
 .../realtek/rtl8192cu/include/Hal8192DPhyCfg.h     |  115 +-
 .../realtek/rtl8192cu/include/Hal8192DPhyReg.h     |  131 +-
 .../realtek/rtl8192cu/include/Hal8192DUHWImg.h     |    2 +-
 .../rtl8192cu/include/Hal8192DUHWImg_wowlan.h      |    3 +-
 .../realtek/rtl8192cu/include/HalPwrSeqCmd.h       |    0
 .../wireless/realtek/rtl8192cu/include/autoconf.h  |   39 +-
 .../realtek/rtl8192cu/include/basic_types.h        |   57 +-
 .../rtl8192cu/include/byteorder/big_endian.h       |    2 +-
 .../realtek/rtl8192cu/include/byteorder/generic.h  |    2 +-
 .../rtl8192cu/include/byteorder/little_endian.h    |    2 +-
 .../realtek/rtl8192cu/include/byteorder/swab.h     |   18 +-
 .../realtek/rtl8192cu/include/byteorder/swabb.h    |    2 +-
 .../wireless/realtek/rtl8192cu/include/circ_buf.h  |    2 +-
 .../wireless/realtek/rtl8192cu/include/cmd_osdep.h |    3 +-
 .../wireless/realtek/rtl8192cu/include/drv_conf.h  |    5 +-
 .../wireless/realtek/rtl8192cu/include/drv_types.h |   29 +-
 .../realtek/rtl8192cu/include/drv_types_ce.h       |    4 +-
 .../realtek/rtl8192cu/include/drv_types_linux.h    |    3 +-
 .../realtek/rtl8192cu/include/drv_types_sdio.h     |    5 +-
 .../realtek/rtl8192cu/include/drv_types_xp.h       |    5 +-
 .../wireless/realtek/rtl8192cu/include/ethernet.h  |    4 +-
 .../wireless/realtek/rtl8192cu/include/h2clbk.h    |    2 +-
 .../wireless/realtek/rtl8192cu/include/hal_com.h   |   13 +-
 .../wireless/realtek/rtl8192cu/include/hal_intf.h  |   13 +-
 .../wireless/realtek/rtl8192cu/include/ieee80211.h |   47 +-
 .../realtek/rtl8192cu/include/ieee80211_ext.h      |   27 +-
 .../wireless/realtek/rtl8192cu/include/if_ether.h  |   12 +-
 .../realtek/rtl8192cu/include/ioctl_cfg80211.h     |   24 +-
 .../net/wireless/realtek/rtl8192cu/include/ip.h    |    6 +-
 .../realtek/rtl8192cu/include/linux/wireless.h     |    6 +-
 .../realtek/rtl8192cu/include/mlme_osdep.h         |    3 +-
 .../realtek/rtl8192cu/include/mp_custom_oid.h      |   14 +-
 .../wireless/realtek/rtl8192cu/include/nic_spec.h  |    5 +-
 .../realtek/rtl8192cu/include/osdep_ce_service.h   |   11 +-
 .../realtek/rtl8192cu/include/osdep_intf.h         |    1 +
 .../realtek/rtl8192cu/include/osdep_service.h      |  150 +-
 .../wireless/realtek/rtl8192cu/include/pci_hal.h   |   29 +-
 .../wireless/realtek/rtl8192cu/include/pci_ops.h   |    2 +-
 .../realtek/rtl8192cu/include/pci_osintf.h         |    3 +-
 .../realtek/rtl8192cu/include/recv_osdep.h         |    7 +-
 .../realtek/rtl8192cu/include/rtl8192c_cmd.h       |    7 +-
 .../realtek/rtl8192cu/include/rtl8192c_dm.h        |   47 +-
 .../realtek/rtl8192cu/include/rtl8192c_event.h     |    4 +-
 .../realtek/rtl8192cu/include/rtl8192c_hal.h       |   75 +-
 .../realtek/rtl8192cu/include/rtl8192c_led.h       |    3 +-
 .../realtek/rtl8192cu/include/rtl8192c_recv.h      |    7 +-
 .../realtek/rtl8192cu/include/rtl8192c_rf.h        |   41 +-
 .../realtek/rtl8192cu/include/rtl8192c_spec.h      |   73 +-
 .../realtek/rtl8192cu/include/rtl8192c_sreset.h    |    2 +-
 .../realtek/rtl8192cu/include/rtl8192c_xmit.h      |    3 +-
 .../realtek/rtl8192cu/include/rtl8192d_cmd.h       |   10 +-
 .../realtek/rtl8192cu/include/rtl8192d_dm.h        |   34 +-
 .../realtek/rtl8192cu/include/rtl8192d_hal.h       |   91 +-
 .../realtek/rtl8192cu/include/rtl8192d_led.h       |    3 +-
 .../realtek/rtl8192cu/include/rtl8192d_recv.h      |    7 +-
 .../realtek/rtl8192cu/include/rtl8192d_rf.h        |   41 +-
 .../realtek/rtl8192cu/include/rtl8192d_spec.h      |   73 +-
 .../realtek/rtl8192cu/include/rtl8192d_xmit.h      |    3 +-
 .../realtek/rtl8192cu/include/rtw_android.h        |   33 +-
 .../wireless/realtek/rtl8192cu/include/rtw_ap.h    |    5 +-
 .../realtek/rtl8192cu/include/rtw_br_ext.h         |    3 +-
 .../realtek/rtl8192cu/include/rtw_byteorder.h      |    3 +-
 .../wireless/realtek/rtl8192cu/include/rtw_cmd.h   |  219 +-
 .../wireless/realtek/rtl8192cu/include/rtw_debug.h |   29 +-
 .../realtek/rtl8192cu/include/rtw_eeprom.h         |   32 +-
 .../wireless/realtek/rtl8192cu/include/rtw_efuse.h |    9 +-
 .../wireless/realtek/rtl8192cu/include/rtw_event.h |   17 +-
 .../wireless/realtek/rtl8192cu/include/rtw_ht.h    |    9 +-
 .../wireless/realtek/rtl8192cu/include/rtw_io.h    |   90 +-
 .../wireless/realtek/rtl8192cu/include/rtw_ioctl.h |   19 +-
 .../realtek/rtl8192cu/include/rtw_ioctl_query.h    |    3 +-
 .../realtek/rtl8192cu/include/rtw_ioctl_rtl.h      |   10 +-
 .../realtek/rtl8192cu/include/rtw_ioctl_set.h      |    8 +-
 .../wireless/realtek/rtl8192cu/include/rtw_iol.h   |    2 +-
 .../wireless/realtek/rtl8192cu/include/rtw_led.h   |   17 +-
 .../wireless/realtek/rtl8192cu/include/rtw_mlme.h  |   55 +-
 .../realtek/rtl8192cu/include/rtw_mlme_ext.h       |  111 +-
 .../wireless/realtek/rtl8192cu/include/rtw_mp.h    |   17 +-
 .../realtek/rtl8192cu/include/rtw_mp_ioctl.h       |    5 +-
 .../realtek/rtl8192cu/include/rtw_mp_phy_regdef.h  |  129 +-
 .../wireless/realtek/rtl8192cu/include/rtw_p2p.h   |    3 +-
 .../realtek/rtl8192cu/include/rtw_pwrctrl.h        |   30 +-
 .../wireless/realtek/rtl8192cu/include/rtw_qos.h   |    7 +-
 .../wireless/realtek/rtl8192cu/include/rtw_recv.h  |   15 +-
 .../wireless/realtek/rtl8192cu/include/rtw_rf.h    |   13 +-
 .../realtek/rtl8192cu/include/rtw_security.h       |   45 +-
 .../realtek/rtl8192cu/include/rtw_sreset.h         |    5 +-
 .../wireless/realtek/rtl8192cu/include/rtw_tdls.h  |    3 +-
 .../wireless/realtek/rtl8192cu/include/rtw_xmit.h  |    1 +
 .../wireless/realtek/rtl8192cu/include/sta_info.h  |   77 +-
 .../wireless/realtek/rtl8192cu/include/usb_hal.h   |    5 +-
 .../wireless/realtek/rtl8192cu/include/usb_ops.h   |   13 +-
 .../realtek/rtl8192cu/include/usb_ops_linux.h      |    3 +-
 .../realtek/rtl8192cu/include/usb_osintf.h         |    3 +-
 .../realtek/rtl8192cu/include/usb_vendor_req.h     |    2 +-
 .../net/wireless/realtek/rtl8192cu/include/wifi.h  |   39 +-
 .../realtek/rtl8192cu/include/wlan_bssdef.h        |   57 +-
 .../realtek/rtl8192cu/include/xmit_osdep.h         |    3 +-
 .../rtl8192cu/os_dep/linux/ioctl_cfg80211.c        | 1351 +++++----
 .../realtek/rtl8192cu/os_dep/linux/ioctl_linux.c   | 3042 ++++++++++----------
 .../realtek/rtl8192cu/os_dep/linux/mlme_linux.c    |  254 +-
 .../realtek/rtl8192cu/os_dep/linux/os_intfs.c      |   34 +-
 .../realtek/rtl8192cu/os_dep/linux/pci_intf.c      |    1 +
 .../realtek/rtl8192cu/os_dep/linux/pci_ops_linux.c |    3 +
 .../realtek/rtl8192cu/os_dep/linux/recv_linux.c    |   54 +-
 .../realtek/rtl8192cu/os_dep/linux/rtw_android.c   |   75 +-
 .../realtek/rtl8192cu/os_dep/linux/usb_intf.c      |   21 +-
 .../realtek/rtl8192cu/os_dep/linux/usb_ops_linux.c |  219 +-
 .../realtek/rtl8192cu/os_dep/linux/xmit_linux.c    |   67 +-
 .../realtek/rtl8192cu/os_dep/osdep_service.c       |  357 +--
 165 files changed, 12603 insertions(+), 12317 deletions(-)
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/core/efuse/rtw_efuse.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/core/rtw_ap.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/core/rtw_br_ext.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/core/rtw_cmd.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/core/rtw_debug.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/core/rtw_eeprom.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/core/rtw_ieee80211.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/core/rtw_io.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/core/rtw_ioctl_query.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/core/rtw_ioctl_rtl.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/core/rtw_ioctl_set.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/core/rtw_iol.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/core/rtw_mlme.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/core/rtw_mlme_ext.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/core/rtw_mp.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/core/rtw_mp_ioctl.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/core/rtw_p2p.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/core/rtw_pwrctrl.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/core/rtw_recv.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/core/rtw_rf.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/core/rtw_security.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/core/rtw_sreset.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/core/rtw_sta_mgt.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/core/rtw_tdls.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/core/rtw_wlan_util.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/core/rtw_xmit.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/hal/HalPwrSeqCmd.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/hal/dm.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/hal/dm.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/hal/hal_com.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/hal/hal_intf.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_cmd.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_dm.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_hal_init.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_mp.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_phycfg.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_rf6052.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_rxdesc.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_sreset.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_xmit.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/Hal8192CUHWImg.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/Hal8192CUHWImg_wowlan.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/rtl8192cu_led.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/rtl8192cu_recv.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/rtl8192cu_xmit.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/usb_halinit.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/usb_ops_ce.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/usb_ops_linux.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/usb_ops_xp.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/Hal8192CEHWImg.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/Hal8192CPhyCfg.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/Hal8192CPhyReg.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/Hal8192CUHWImg.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/Hal8192CUHWImg_wowlan.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/Hal8192DEHWImg.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/Hal8192DPhyCfg.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/Hal8192DPhyReg.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/Hal8192DUHWImg.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/Hal8192DUHWImg_wowlan.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/HalPwrSeqCmd.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/autoconf.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/basic_types.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/byteorder/big_endian.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/byteorder/generic.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/byteorder/little_endian.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/byteorder/swab.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/byteorder/swabb.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/circ_buf.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/cmd_osdep.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/drv_conf.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/drv_types.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/drv_types_ce.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/drv_types_linux.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/drv_types_sdio.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/drv_types_xp.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/ethernet.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/h2clbk.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/hal_com.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/hal_intf.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/ieee80211.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/ieee80211_ext.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/if_ether.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/ioctl_cfg80211.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/ip.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/linux/wireless.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/mlme_osdep.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/mp_custom_oid.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/nic_spec.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/osdep_ce_service.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/osdep_intf.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/osdep_service.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/pci_hal.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/pci_ops.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/pci_osintf.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/recv_osdep.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_cmd.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_dm.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_event.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_hal.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_led.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_recv.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_rf.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_spec.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_sreset.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_xmit.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_cmd.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_dm.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_hal.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_led.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_recv.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_rf.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_spec.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_xmit.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtw_android.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtw_ap.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtw_br_ext.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtw_byteorder.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtw_cmd.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtw_debug.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtw_eeprom.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtw_efuse.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtw_event.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtw_ht.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtw_io.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtw_ioctl.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtw_ioctl_query.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtw_ioctl_rtl.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtw_ioctl_set.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtw_iol.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtw_led.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtw_mlme.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtw_mlme_ext.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtw_mp.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtw_mp_ioctl.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtw_mp_phy_regdef.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtw_p2p.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtw_pwrctrl.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtw_qos.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtw_recv.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtw_rf.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtw_security.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtw_sreset.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtw_tdls.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/rtw_xmit.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/sta_info.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/usb_hal.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/usb_ops.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/usb_ops_linux.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/usb_osintf.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/usb_vendor_req.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/wifi.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/wlan_bssdef.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/include/xmit_osdep.h
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/ioctl_cfg80211.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/ioctl_linux.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/mlme_linux.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/os_intfs.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/pci_intf.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/pci_ops_linux.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/recv_linux.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/rtw_android.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/usb_intf.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/usb_ops_linux.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/xmit_linux.c
 mode change 100644 => 100755 drivers/net/wireless/realtek/rtl8192cu/os_dep/osdep_service.c

diff --git a/drivers/net/wireless/realtek/rtl8192cu/core/efuse/rtw_efuse.c b/drivers/net/wireless/realtek/rtl8192cu/core/efuse/rtw_efuse.c
old mode 100644
new mode 100755
index c7f2b67..3d341ac
--- a/drivers/net/wireless/realtek/rtl8192cu/core/efuse/rtw_efuse.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/core/efuse/rtw_efuse.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -100,7 +100,7 @@
 /*-----------------------------------------------------------------------------
  * Function:	Efuse_PowerSwitch
  *
- * Overview:	When we want to enable write operation, we should change to
+ * Overview:	When we want to enable write operation, we should change to 
  *				pwr on state. When we stop write, we should switch to 500k mode
  *				and disable LDO 2.5V.
  *
@@ -122,7 +122,7 @@
 	IN	u8		PwrState)
 {
 	pAdapter->HalFunc.EfusePowerSwitch(pAdapter, bWrite, PwrState);
-}
+}	
 
 /*-----------------------------------------------------------------------------
  * Function:	efuse_GetCurrentSize
@@ -179,9 +179,9 @@
 VOID
 ReadEFuseByte(
 		PADAPTER	Adapter,
-		u16 			_offset,
-		u8 			*pbuf,
-		IN BOOLEAN	bPseudoTest)
+		u16 			_offset, 
+		u8 			*pbuf, 
+		IN BOOLEAN	bPseudoTest) 
 {
 	u32	value32;
 	u8	readbyte;
@@ -195,14 +195,14 @@
 	}
 
 	//Write Address
-	rtw_write8(Adapter, EFUSE_CTRL+1, (_offset & 0xff));
+	rtw_write8(Adapter, EFUSE_CTRL+1, (_offset & 0xff));  		
 	readbyte = rtw_read8(Adapter, EFUSE_CTRL+2);
-	rtw_write8(Adapter, EFUSE_CTRL+2, ((_offset >> 8) & 0x03) | (readbyte & 0xfc));
+	rtw_write8(Adapter, EFUSE_CTRL+2, ((_offset >> 8) & 0x03) | (readbyte & 0xfc));  		
 
 	//Write bit 32 0
-	readbyte = rtw_read8(Adapter, EFUSE_CTRL+3);
-	rtw_write8(Adapter, EFUSE_CTRL+3, (readbyte & 0x7f));
-
+	readbyte = rtw_read8(Adapter, EFUSE_CTRL+3);		
+	rtw_write8(Adapter, EFUSE_CTRL+3, (readbyte & 0x7f));  	
+	
 	//Check bit 32 read-ready
 	retry = 0;
 	value32 = rtw_read32(Adapter, EFUSE_CTRL);
@@ -219,16 +219,16 @@
 	// result will always stay on last data we read.
 	rtw_udelay_os(50);
 	value32 = rtw_read32(Adapter, EFUSE_CTRL);
-
+	
 	*pbuf = (u8)(value32 & 0xff);
 	//DBG_871X("ReadEFuseByte _offset:%08u, in %d ms\n",_offset ,rtw_get_passing_time_ms(start));
-
+	
 }
 
 
 //
 //	Description:
-//		1. Execute E-Fuse read byte operation according as map offset and
+//		1. Execute E-Fuse read byte operation according as map offset and 
 //		    save to E-Fuse table.
 //		2. Refered from SD1 Richard.
 //
@@ -295,8 +295,8 @@
  *
  *---------------------------------------------------------------------------*/
 u8
-EFUSE_Read1Byte(
-	IN	PADAPTER	Adapter,
+EFUSE_Read1Byte(	
+	IN	PADAPTER	Adapter, 
 	IN	u16		Address)
 {
 	u8	data;
@@ -310,12 +310,12 @@
 	if (Address < contentLen)	//E-fuse 512Byte
 	{
 		//Write E-fuse Register address bit0~7
-		temp = Address & 0xFF;
-		rtw_write8(Adapter, EFUSE_CTRL+1, temp);
-		Bytetemp = rtw_read8(Adapter, EFUSE_CTRL+2);
+		temp = Address & 0xFF;	
+		rtw_write8(Adapter, EFUSE_CTRL+1, temp);	
+		Bytetemp = rtw_read8(Adapter, EFUSE_CTRL+2);	
 		//Write E-fuse Register address bit8~9
-		temp = ((Address >> 8) & 0x03) | (Bytetemp & 0xFC);
-		rtw_write8(Adapter, EFUSE_CTRL+2, temp);
+		temp = ((Address >> 8) & 0x03) | (Bytetemp & 0xFC);	
+		rtw_write8(Adapter, EFUSE_CTRL+2, temp);	
 
 		//Write 0x30[31]=0
 		Bytetemp = rtw_read8(Adapter, EFUSE_CTRL+3);
@@ -325,7 +325,7 @@
 		//Wait Write-ready (0x30[31]=1)
 		Bytetemp = rtw_read8(Adapter, EFUSE_CTRL+3);
 		while(!(Bytetemp & 0x80))
-		{
+		{				
 			Bytetemp = rtw_read8(Adapter, EFUSE_CTRL+3);
 			k++;
 			if(k==1000)
@@ -339,7 +339,7 @@
 	}
 	else
 		return 0xFF;
-
+	
 }/* EFUSE_Read1Byte */
 
 /*-----------------------------------------------------------------------------
@@ -359,14 +359,14 @@
  *
  *---------------------------------------------------------------------------*/
 
-void
-EFUSE_Write1Byte(
-	IN	PADAPTER	Adapter,
+void	
+EFUSE_Write1Byte(	
+	IN	PADAPTER	Adapter, 
 	IN	u16		Address,
 	IN	u8		Value);
-void
-EFUSE_Write1Byte(
-	IN	PADAPTER	Adapter,
+void	
+EFUSE_Write1Byte(	
+	IN	PADAPTER	Adapter, 
 	IN	u16		Address,
 	IN	u8		Value)
 {
@@ -383,13 +383,13 @@
 		rtw_write8(Adapter, EFUSE_CTRL, Value);
 
 		//Write E-fuse Register address bit0~7
-		temp = Address & 0xFF;
-		rtw_write8(Adapter, EFUSE_CTRL+1, temp);
-		Bytetemp = rtw_read8(Adapter, EFUSE_CTRL+2);
-
+		temp = Address & 0xFF;	
+		rtw_write8(Adapter, EFUSE_CTRL+1, temp);	
+		Bytetemp = rtw_read8(Adapter, EFUSE_CTRL+2);	
+		
 		//Write E-fuse Register address bit8~9
-		temp = ((Address >> 8) & 0x03) | (Bytetemp & 0xFC);
-		rtw_write8(Adapter, EFUSE_CTRL+2, temp);
+		temp = ((Address >> 8) & 0x03) | (Bytetemp & 0xFC);	
+		rtw_write8(Adapter, EFUSE_CTRL+2, temp);	
 
 		//Write 0x30[31]=1
 		Bytetemp = rtw_read8(Adapter, EFUSE_CTRL+3);
@@ -400,7 +400,7 @@
 		Bytetemp = rtw_read8(Adapter, EFUSE_CTRL+3);
 		while(Bytetemp & 0x80)
 		{
-			Bytetemp = rtw_read8(Adapter, EFUSE_CTRL+3);
+			Bytetemp = rtw_read8(Adapter, EFUSE_CTRL+3);			
 			k++;
 			if(k==100)
 			{
@@ -414,7 +414,7 @@
 /*  11/16/2008 MH Read one byte from real Efuse. */
 u8
 efuse_OneByteRead(
-	IN	PADAPTER	pAdapter,
+	IN	PADAPTER	pAdapter, 
 	IN	u16			addr,
 	IN	u8			*data,
 	IN	BOOLEAN		bPseudoTest)
@@ -428,35 +428,35 @@
 		return bResult;
 	}
 	// -----------------e-fuse reg ctrl ---------------------------------
-	//address
-	rtw_write8(pAdapter, EFUSE_CTRL+1, (u8)(addr&0xff));
-	rtw_write8(pAdapter, EFUSE_CTRL+2, ((u8)((addr>>8) &0x03) ) |
-	(rtw_read8(pAdapter, EFUSE_CTRL+2)&0xFC ));
+	//address			
+	rtw_write8(pAdapter, EFUSE_CTRL+1, (u8)(addr&0xff));		
+	rtw_write8(pAdapter, EFUSE_CTRL+2, ((u8)((addr>>8) &0x03) ) | 
+	(rtw_read8(pAdapter, EFUSE_CTRL+2)&0xFC ));	
 
-	rtw_write8(pAdapter, EFUSE_CTRL+3,  0x72);//read cmd
+	rtw_write8(pAdapter, EFUSE_CTRL+3,  0x72);//read cmd	
 
 	while(!(0x80 &rtw_read8(pAdapter, EFUSE_CTRL+3))&&(tmpidx<100))
 	{
 		tmpidx++;
 	}
 	if(tmpidx<100)
-	{
-		*data=rtw_read8(pAdapter, EFUSE_CTRL);
+	{			
+		*data=rtw_read8(pAdapter, EFUSE_CTRL);		
 		bResult = _TRUE;
 	}
 	else
 	{
-		*data = 0xff;
+		*data = 0xff;	
 		bResult = _FALSE;
 	}
 	return bResult;
 }
-
+		
 /*  11/16/2008 MH Write one byte to reald Efuse. */
 u8
 efuse_OneByteWrite(
-	IN	PADAPTER	pAdapter,
-	IN	u16			addr,
+	IN	PADAPTER	pAdapter,  
+	IN	u16			addr, 
 	IN	u8			data,
 	IN	BOOLEAN		bPseudoTest)
 {
@@ -472,29 +472,29 @@
 
 	//return	0;
 
-	// -----------------e-fuse reg ctrl ---------------------------------
-	//address
+	// -----------------e-fuse reg ctrl ---------------------------------	
+	//address			
 	rtw_write8(pAdapter, EFUSE_CTRL+1, (u8)(addr&0xff));
-	rtw_write8(pAdapter, EFUSE_CTRL+2,
-	(rtw_read8(pAdapter, EFUSE_CTRL+2)&0xFC )|(u8)((addr>>8)&0x03) );
-	rtw_write8(pAdapter, EFUSE_CTRL, data);//data
+	rtw_write8(pAdapter, EFUSE_CTRL+2, 
+	(rtw_read8(pAdapter, EFUSE_CTRL+2)&0xFC )|(u8)((addr>>8)&0x03) );	
+	rtw_write8(pAdapter, EFUSE_CTRL, data);//data		
 
 	rtw_write8(pAdapter, EFUSE_CTRL+3, 0xF2);//write cmd
-
+		
 	while((0x80 &  rtw_read8(pAdapter, EFUSE_CTRL+3)) && (tmpidx<100) ){
 		tmpidx++;
 	}
-
+	
 	if(tmpidx<100)
-	{
+	{					
 		bResult = _TRUE;
 	}
 	else
-	{
+	{			
 		bResult = _FALSE;
-	}
-
-	return bResult;
+	}		
+	
+	return bResult;	
 }
 
 int
@@ -510,8 +510,8 @@
 	return ret;
 }
 
-int
-Efuse_PgPacketWrite(IN	PADAPTER	pAdapter,
+int 
+Efuse_PgPacketWrite(IN	PADAPTER	pAdapter, 
 					IN	u8 			offset,
 					IN	u8			word_en,
 					IN	u8			*data,
@@ -545,7 +545,7 @@
 efuse_WordEnableDataRead(IN	u8	word_en,
 							IN	u8	*sourdata,
 							IN	u8	*targetdata)
-{
+{	
 	if (!(word_en&BIT(0)))
 	{
 		targetdata[0] = sourdata[0];
@@ -572,14 +572,14 @@
 u8
 Efuse_WordEnableDataWrite(	IN	PADAPTER	pAdapter,
 							IN	u16		efuse_addr,
-							IN	u8		word_en,
+							IN	u8		word_en, 
 							IN	u8		*data,
 							IN	BOOLEAN		bPseudoTest)
 {
 	u8	ret=0;
 
 	ret =  pAdapter->HalFunc.Efuse_WordEnableDataWrite(pAdapter, efuse_addr, word_en, data, bPseudoTest);
-
+	
 	return ret;
 }
 
@@ -781,15 +781,15 @@ u8 rtw_efuse_map_write(PADAPTER padapter, u16 addr, u16 cnts, u8 *data)
  * 11/11/2008 	MHC		Create Version 0.
  *
  *---------------------------------------------------------------------------*/
-VOID
+VOID 
 Efuse_ReadAllMap(
-	IN		PADAPTER	pAdapter,
+	IN		PADAPTER	pAdapter, 
 	IN		u8		efuseType,
 	IN OUT	u8		*Efuse,
 	IN		BOOLEAN		bPseudoTest);
-VOID
+VOID 
 Efuse_ReadAllMap(
-	IN		PADAPTER	pAdapter,
+	IN		PADAPTER	pAdapter, 
 	IN		u8		efuseType,
 	IN OUT	u8		*Efuse,
 	IN		BOOLEAN		bPseudoTest)
@@ -965,19 +965,19 @@ void EFUSE_ShadowMapUpdate(
 	}
 	else
 	{
-		#ifdef CONFIG_ADAPTOR_INFO_CACHING_FILE
+		#ifdef CONFIG_ADAPTOR_INFO_CACHING_FILE			
 		if(_SUCCESS != retriveAdaptorInfoFile(pAdapter->registrypriv.adaptor_info_caching_file_path, pEEPROM)) {
 		#endif
-
+		
 		Efuse_ReadAllMap(pAdapter, efuseType, pEEPROM->efuse_eeprom_data, bPseudoTest);
-
+		
 		#ifdef CONFIG_ADAPTOR_INFO_CACHING_FILE
 			storeAdaptorInfoFile(pAdapter->registrypriv.adaptor_info_caching_file_path, pEEPROM);
 		}
 		#endif
 	}
 
-	//PlatformMoveMemory((PVOID)&pHalData->EfuseMap[EFUSE_MODIFY_MAP][0],
+	//PlatformMoveMemory((PVOID)&pHalData->EfuseMap[EFUSE_MODIFY_MAP][0], 
 	//(PVOID)&pHalData->EfuseMap[EFUSE_INIT_MAP][0], mapLen);
 }// EFUSE_ShadowMapUpdate
 
@@ -1011,7 +1011,7 @@ void EFUSE_ShadowMapUpdate(
 		efuse_ShadowRead2Byte(pAdapter, Offset, (u16 *)Value);
 	else if (Type == 4)
 		efuse_ShadowRead4Byte(pAdapter, Offset, (u32 *)Value);
-
+	
 }	// EFUSE_ShadowRead
 
 /*-----------------------------------------------------------------------------
@@ -1066,7 +1066,7 @@ void EFUSE_ShadowMapUpdate(
 	)
 {
 	u8 i;
-
+	
 	_rtw_memset((PVOID)&fakeEfuseContent[0], 0xff, EFUSE_MAX_HW_SIZE);
 	_rtw_memset((PVOID)&fakeEfuseInitMap[0], 0xff, EFUSE_MAX_MAP_LEN);
 	_rtw_memset((PVOID)&fakeEfuseModifiedMap[0], 0xff, EFUSE_MAX_MAP_LEN);
@@ -1117,24 +1117,24 @@ int retriveAdaptorInfoFile(char *path, struct eeprom_priv * eeprom_priv)
 	int ret = _SUCCESS;
 	mm_segment_t oldfs;
 	struct file *fp;
-
+	
 	if(path && eeprom_priv) {
 
 		ret = rtw_retrive_from_file(path, eeprom_priv->efuse_eeprom_data, EEPROM_MAX_SIZE);
-
+		
 		if(ret == EEPROM_MAX_SIZE)
 			ret = _SUCCESS;
 		else
 			ret = _FAIL;
 
 		#if 0
-		if(isAdaptorInfoFileValid()) {
+		if(isAdaptorInfoFileValid()) {	
 			return 0;
 		} else {
 			return _FAIL;
 		}
 		#endif
-
+		
 	} else {
 		DBG_871X("%s NULL pointer\n",__FUNCTION__);
 		ret = _FAIL;
@@ -1143,3 +1143,5 @@ int retriveAdaptorInfoFile(char *path, struct eeprom_priv * eeprom_priv)
 }
 #endif //CONFIG_ADAPTOR_INFO_CACHING_FILE
 #endif //PLATFORM_LINUX
+
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_ap.c b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_ap.c
old mode 100644
new mode 100755
index e2403d2..405e7fe
--- a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_ap.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_ap.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -37,13 +37,13 @@ void init_mlme_ap_info(_adapter *padapter)
 {
 	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct sta_priv *pstapriv = &padapter->stapriv;	
 	struct wlan_acl_pool *pacl_list = &pstapriv->acl_list;
+	
 
+	_rtw_spinlock_init(&pmlmepriv->bcn_update_lock);	
 
-	_rtw_spinlock_init(&pmlmepriv->bcn_update_lock);
-
-	//for ACL
+	//for ACL 
 	_rtw_init_queue(&pacl_list->acl_node_q);
 
 	//pmlmeext->bstart_bss = _FALSE;
@@ -63,8 +63,8 @@ void free_mlme_ap_info(_adapter *padapter)
 	//stop_ap_mode(padapter);
 
 	pmlmepriv->update_bcn = _FALSE;
-	pmlmeext->bstart_bss = _FALSE;
-
+	pmlmeext->bstart_bss = _FALSE;	
+	
 	rtw_sta_flush(padapter);
 
 	pmlmeinfo->state = _HW_STATE_NOLINK_;
@@ -73,14 +73,14 @@ void free_mlme_ap_info(_adapter *padapter)
 	rtw_free_all_stainfo(padapter);
 
 	//free bc/mc sta_info
-	psta = rtw_get_bcmc_stainfo(padapter);
-	_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+	psta = rtw_get_bcmc_stainfo(padapter);	
+	_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);		
 	rtw_free_stainfo(padapter, psta);
 	_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
-
+	
 
 	_rtw_spinlock_free(&pmlmepriv->bcn_update_lock);
-
+	
 }
 
 static void update_BCNTIM(_adapter *padapter)
@@ -92,26 +92,26 @@ static void update_BCNTIM(_adapter *padapter)
 	unsigned char *pie = pnetwork_mlmeext->IEs;
 
 	//DBG_871X("%s\n", __FUNCTION__);
-
+	
 	//update TIM IE
 	//if(pstapriv->tim_bitmap)
 	if(_TRUE)
 	{
 		u8 *p, *dst_ie, *premainder_ie=NULL, *pbackup_remainder_ie=NULL;
 		u16 tim_bitmap_le;
-		uint offset, tmp_len, tim_ielen, tim_ie_offset, remainder_ielen;
-
+		uint offset, tmp_len, tim_ielen, tim_ie_offset, remainder_ielen;	
+	
 		tim_bitmap_le = cpu_to_le16(pstapriv->tim_bitmap);
 
 		p = rtw_get_ie(pie + _FIXED_IE_LENGTH_, _TIM_IE_, &tim_ielen, pnetwork_mlmeext->IELength - _FIXED_IE_LENGTH_);
 		if (p != NULL && tim_ielen>0)
 		{
 			tim_ielen += 2;
-
+			
 			premainder_ie = p+tim_ielen;
 
 			tim_ie_offset = (sint)(p -pie);
-
+			
 			remainder_ielen = pnetwork_mlmeext->IELength - tim_ie_offset - tim_ielen;
 
 			//append TIM IE from dst_ie offset
@@ -121,7 +121,7 @@ static void update_BCNTIM(_adapter *padapter)
 		{
 			tim_ielen = 0;
 
-			//calucate head_len
+			//calucate head_len		
 			offset = _FIXED_IE_LENGTH_;
 
 			/* get ssid_ie len */
@@ -130,73 +130,73 @@ static void update_BCNTIM(_adapter *padapter)
 				offset += tmp_len+2;
 
 			// get supported rates len
-			p = rtw_get_ie(pie + _BEACON_IE_OFFSET_, _SUPPORTEDRATES_IE_, &tmp_len, (pnetwork_mlmeext->IELength - _BEACON_IE_OFFSET_));
-			if (p !=  NULL)
-			{
+			p = rtw_get_ie(pie + _BEACON_IE_OFFSET_, _SUPPORTEDRATES_IE_, &tmp_len, (pnetwork_mlmeext->IELength - _BEACON_IE_OFFSET_));	
+			if (p !=  NULL) 
+			{			
 				offset += tmp_len+2;
 			}
 
-			//DS Parameter Set IE, len=3
+			//DS Parameter Set IE, len=3	
 			offset += 3;
 
 			premainder_ie = pie + offset;
 
-			remainder_ielen = pnetwork_mlmeext->IELength - offset - tim_ielen;
+			remainder_ielen = pnetwork_mlmeext->IELength - offset - tim_ielen;	
 
 			//append TIM IE from offset
 			dst_ie = pie + offset;
-
+			
 		}
 
-
+		
 		if(remainder_ielen>0)
 		{
 			pbackup_remainder_ie = rtw_malloc(remainder_ielen);
 			if(pbackup_remainder_ie && premainder_ie)
 				_rtw_memcpy(pbackup_remainder_ie, premainder_ie, remainder_ielen);
-		}
+		}		
 
 		*dst_ie++=_TIM_IE_;
 
-		if((pstapriv->tim_bitmap&0xff00) && (pstapriv->tim_bitmap&0x00fc))
+		if((pstapriv->tim_bitmap&0xff00) && (pstapriv->tim_bitmap&0x00fc))			
 			tim_ielen = 5;
 		else
 			tim_ielen = 4;
 
 		*dst_ie++= tim_ielen;
-
+		
 		*dst_ie++=0;//DTIM count
 		*dst_ie++=1;//DTIM peroid
-
+		
 		if(pstapriv->tim_bitmap&BIT(0))//for bc/mc frames
-			*dst_ie++ = BIT(0);//bitmap ctrl
+			*dst_ie++ = BIT(0);//bitmap ctrl 
 		else
 			*dst_ie++ = 0;
 
 		if(tim_ielen==4)
 		{
 			*dst_ie++ = *(u8*)&tim_bitmap_le;
-		}
+		}	
 		else if(tim_ielen==5)
 		{
 			_rtw_memcpy(dst_ie, &tim_bitmap_le, 2);
-			dst_ie+=2;
-		}
-
+			dst_ie+=2;				
+		}	
+		
 		//copy remainder IE
 		if(pbackup_remainder_ie)
 		{
 			_rtw_memcpy(dst_ie, pbackup_remainder_ie, remainder_ielen);
 
 			rtw_mfree(pbackup_remainder_ie, remainder_ielen);
-		}
+		}	
 
 		offset =  (uint)(dst_ie - pie);
 		pnetwork_mlmeext->IELength = offset + remainder_ielen;
-
+	
 	}
 
-#ifndef CONFIG_INTERRUPT_BASED_TXBCN
+#ifndef CONFIG_INTERRUPT_BASED_TXBCN 
 #if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
 	set_tx_beacon_cmd(padapter);
 #endif
@@ -210,7 +210,7 @@ void rtw_add_bcn_ie(_adapter *padapter, WLAN_BSSID_EX *pnetwork, u8 index, u8 *d
 	PNDIS_802_11_VARIABLE_IEs	pIE;
 	u8	bmatch = _FALSE;
 	u8	*pie = pnetwork->IEs;
-	u8	*p=NULL, *dst_ie=NULL, *premainder_ie=NULL, *pbackup_remainder_ie=NULL;
+	u8	*p, *dst_ie, *premainder_ie=NULL, *pbackup_remainder_ie=NULL;
 	u32	i, offset, ielen, ie_offset, remainder_ielen = 0;
 
 	for (i = sizeof(NDIS_802_11_FIXED_IEs); i < pnetwork->IELength;)
@@ -237,11 +237,11 @@ void rtw_add_bcn_ie(_adapter *padapter, WLAN_BSSID_EX *pnetwork, u8 index, u8 *d
 	if (p != NULL && ielen>0)
 	{
 		ielen += 2;
-
+		
 		premainder_ie = p+ielen;
 
 		ie_offset = (sint)(p -pie);
-
+		
 		remainder_ielen = pnetwork->IELength - ie_offset - ielen;
 
 		if(bmatch)
@@ -250,9 +250,6 @@ void rtw_add_bcn_ie(_adapter *padapter, WLAN_BSSID_EX *pnetwork, u8 index, u8 *d
 			dst_ie = (p+ielen);
 	}
 
-	if(dst_ie == NULL)
-		return;
-
 	if(remainder_ielen>0)
 	{
 		pbackup_remainder_ie = rtw_malloc(remainder_ielen);
@@ -288,11 +285,11 @@ void rtw_remove_bcn_ie(_adapter *padapter, WLAN_BSSID_EX *pnetwork, u8 index)
 	if (p != NULL && ielen>0)
 	{
 		ielen += 2;
-
+		
 		premainder_ie = p+ielen;
 
 		ie_offset = (sint)(p -pie);
-
+		
 		remainder_ielen = pnetwork->IELength - ie_offset - ielen;
 
 		dst_ie = p;
@@ -360,15 +357,15 @@ void	expire_timeout_chk(_adapter *padapter)
 {
 	_irqL irqL;
 	_list	*phead, *plist;
-	u8 updated = _FALSE;
-	struct sta_info *psta=NULL;
+	u8 updated;
+	struct sta_info *psta=NULL;	
 	struct sta_priv *pstapriv = &padapter->stapriv;
 	u8 chk_alive_num = 0;
 	char chk_alive_list[NUM_STA];
 	int i;
 
 	_enter_critical_bh(&pstapriv->auth_list_lock, &irqL);
-
+	
 	phead = &pstapriv->auth_list;
 	plist = get_next(phead);
 
@@ -379,41 +376,41 @@ void	expire_timeout_chk(_adapter *padapter)
 			, FUNC_NDEV_ARG(padapter->pnetdev), pstapriv->auth_list_cnt);
 	}
 	#endif
-	while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
+	while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)	
 	{
 		psta = LIST_CONTAINOR(plist, struct sta_info, auth_list);
 		plist = get_next(plist);
-
+	
 		if(psta->expire_to>0)
 		{
 			psta->expire_to--;
 			if (psta->expire_to == 0)
-			{
+			{				
 				rtw_list_delete(&psta->auth_list);
 				pstapriv->auth_list_cnt--;
-
+				
 				DBG_871X("auth expire %02X%02X%02X%02X%02X%02X\n",
 					psta->hwaddr[0],psta->hwaddr[1],psta->hwaddr[2],psta->hwaddr[3],psta->hwaddr[4],psta->hwaddr[5]);
-
+				
 				_exit_critical_bh(&pstapriv->auth_list_lock, &irqL);
-
-				_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+				
+				_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);	
 				rtw_free_stainfo(padapter, psta);
-				_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
-
+				_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);	
+				
 				_enter_critical_bh(&pstapriv->auth_list_lock, &irqL);
-			}
-		}
-
+			}	
+		}	
+		
 	}
 
 	_exit_critical_bh(&pstapriv->auth_list_lock, &irqL);
 
 	psta = NULL;
-
+	
 
 	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
-
+	
 	phead = &pstapriv->asoc_list;
 	plist = get_next(phead);
 
@@ -428,7 +425,7 @@ void	expire_timeout_chk(_adapter *padapter)
 	{
 		psta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);
 		plist = get_next(plist);
-
+	
 		if (chk_sta_is_alive(psta) || !psta->expire_to) {
 			psta->expire_to = pstapriv->expire_to;
 			psta->keep_alive_trycnt = 0;
@@ -442,10 +439,10 @@ void	expire_timeout_chk(_adapter *padapter)
 #ifndef CONFIG_ACTIVE_KEEP_ALIVE_CHECK
 #ifdef CONFIG_TX_MCAST2UNI
 		if ( (psta->flags & WLAN_STA_HT) && (psta->htpriv.agg_enable_bitmap || psta->under_exist_checking) ) {
-			// check sta by delba(addba) for 11n STA
+			// check sta by delba(addba) for 11n STA 
 			// ToDo: use CCX report to check for all STAs
 			//DBG_871X("asoc check by DELBA/ADDBA! (pstapriv->expire_to=%d s)(psta->expire_to=%d s), [%02x, %d]\n", pstapriv->expire_to*2, psta->expire_to*2, psta->htpriv.agg_enable_bitmap, psta->under_exist_checking);
-
+			
 			if ( psta->expire_to <= (pstapriv->expire_to - 50 ) ) {
 				DBG_871X("asoc expire by DELBA/ADDBA! (%d s)\n", (pstapriv->expire_to-psta->expire_to)*2);
 				psta->under_exist_checking = 0;
@@ -475,7 +472,7 @@ void	expire_timeout_chk(_adapter *padapter)
 
 			if (psta->state & WIFI_SLEEP_STATE) {
 				if (!(psta->state & WIFI_STA_ALIVE_CHK_STATE)) {
-					//to check if alive by another methods if staion is at ps mode.
+					//to check if alive by another methods if staion is at ps mode.					
 					psta->expire_to = pstapriv->expire_to;
 					psta->state |= WIFI_STA_ALIVE_CHK_STATE;
 
@@ -507,7 +504,7 @@ void	expire_timeout_chk(_adapter *padapter)
 
 			DBG_871X("asoc expire "MAC_FMT", state=0x%x\n", MAC_ARG(psta->hwaddr), psta->state);
 			updated = ap_free_sta(padapter, psta, _FALSE, WLAN_REASON_DEAUTH_LEAVING);
-		}
+		}	
 		else
 		{
 			/* TODO: Aging mechanism to digest frames in sleep_q to avoid running out of xmitframe */
@@ -537,12 +534,12 @@ void	expire_timeout_chk(_adapter *padapter)
 
 	/* issue null data to check sta alive*/
 	for (i = 0; i < chk_alive_num; i++) {
-
+		
 		int ret = _FAIL;
 
 		psta = rtw_get_stainfo_by_offset(pstapriv, chk_alive_list[i]);
 		if(!(psta->state &_FW_LINKED))
-			continue;
+			continue;		
 
 		if (psta->state & WIFI_SLEEP_STATE)
 			ret = issue_nulldata(padapter, psta->hwaddr, 0, 1, 50);
@@ -587,24 +584,24 @@ void	expire_timeout_chk(_adapter *padapter)
 
 
 static void add_RATid(_adapter *padapter, struct sta_info *psta)
-{
+{	
 	int i;
 	u8 rf_type;
 	u32 init_rate=0;
 	unsigned char sta_band = 0, raid, shortGIrate = _FALSE;
-	unsigned char limit;
+	unsigned char limit;	
 	unsigned int tx_ra_bitmap=0;
 	struct ht_priv	*psta_ht = NULL;
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-	WLAN_BSSID_EX *pcur_network = (WLAN_BSSID_EX *)&pmlmepriv->cur_network.network;
-
+	WLAN_BSSID_EX *pcur_network = (WLAN_BSSID_EX *)&pmlmepriv->cur_network.network;	
 
+	
 	if(psta)
 		psta_ht = &psta->htpriv;
 	else
 		return;
-
-	//b/g mode ra_bitmap
+	
+	//b/g mode ra_bitmap  
 	for (i=0; i<sizeof(psta->bssrateset); i++)
 	{
 		if (psta->bssrateset[i])
@@ -612,7 +609,7 @@ static void add_RATid(_adapter *padapter, struct sta_info *psta)
 	}
 
 	//n mode ra_bitmap
-	if(psta_ht->ht_option)
+	if(psta_ht->ht_option) 
 	{
 		rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
 		if(rf_type == RF_2T2R)
@@ -644,8 +641,8 @@ static void add_RATid(_adapter *padapter, struct sta_info *psta)
 				Switch_1SS_Antenna(priv, 3);
 			}
 		}
-		else// bg or 1R STA?
-		{
+		else// bg or 1R STA? 
+		{ 
 			if((priv->pmib->dot11BssType.net_work_type & WIRELESS_11N) && pstat->ht_cap_len && priv->pshare->has_2r_sta == 0)
 			{
 				if(rtw_read16(padapter, 0x102501f6) != 0x7777)
@@ -656,10 +653,10 @@ static void add_RATid(_adapter *padapter, struct sta_info *psta)
 				}
 			}
 		}
-
+		
 	}
 
-	if ((pstat->rssi_level < 1) || (pstat->rssi_level > 3))
+	if ((pstat->rssi_level < 1) || (pstat->rssi_level > 3)) 
 	{
 		if (pstat->rssi >= priv->pshare->rf_ft_var.raGoDownUpper)
 			pstat->rssi_level = 1;
@@ -693,7 +690,7 @@ static void add_RATid(_adapter *padapter, struct sta_info *psta)
 					break;
 			}
 		}
-		else
+		else 
 		{
 			switch (pstat->rssi_level) {
 				case 1:
@@ -734,7 +731,7 @@ static void add_RATid(_adapter *padapter, struct sta_info *psta)
 				break;
 		}
 	}
-	else
+	else 
 	{
 		pstat->tx_ra_bitmap &= 0x0000000d;
 	}
@@ -745,7 +742,7 @@ static void add_RATid(_adapter *padapter, struct sta_info *psta)
 	if ((!(pstat->tx_ra_bitmap & 0x8000000) && (priv->pshare->has_2r_sta > 0) && (get_rf_mimo_mode(padapter) == RTL8712_RF_2T2R)) ||
 		 (!(pstat->tx_ra_bitmap & 0x80000) && (get_rf_mimo_mode(padapter) != RTL8712_RF_2T2R)))
 	{
-		pstat->tx_ra_bitmap &= ~BIT(28);
+		pstat->tx_ra_bitmap &= ~BIT(28);	
 	}
 #endif
 
@@ -764,23 +761,23 @@ static void add_RATid(_adapter *padapter, struct sta_info *psta)
 			sta_band |= WIRELESS_11B;
 	}
 
-	raid = networktype_to_raid(sta_band);
+	raid = networktype_to_raid(sta_band);	
 	init_rate = get_highest_rate_idx(tx_ra_bitmap&0x0fffffff)&0x3f;
-
-	if (psta->aid < NUM_STA)
+	
+	if (psta->aid < NUM_STA) 
 	{
 		u8 arg = 0;
 
 		arg = psta->mac_id&0x1f;
-
+		
 		arg |= BIT(7);//support entry 2~31
-
+		
 		if (shortGIrate==_TRUE)
 			arg |= BIT(5);
 
 		tx_ra_bitmap |= ((raid<<28)&0xf0000000);
 
-		DBG_871X("%s=> mac_id:%d , raid:%d , bitmap=0x%x, arg=0x%x\n",
+		DBG_871X("%s=> mac_id:%d , raid:%d , bitmap=0x%x, arg=0x%x\n", 
 			__FUNCTION__ , psta->mac_id, raid ,tx_ra_bitmap, arg);
 
 		//bitmap[0:27] = tx_rate_bitmap
@@ -791,13 +788,13 @@ static void add_RATid(_adapter *padapter, struct sta_info *psta)
 
 		if (shortGIrate==_TRUE)
 			init_rate |= BIT(6);
-
+		
 		//set ra_id, init_rate
 		psta->raid = raid;
 		psta->init_rate = init_rate;
-
+		
 	}
-	else
+	else 
 	{
 		DBG_871X("station aid %d exceed the max number\n", psta->aid);
 	}
@@ -809,19 +806,19 @@ static void update_bmc_sta(_adapter *padapter)
 	_irqL	irqL;
 	u32 init_rate=0;
 	unsigned char	network_type, raid;
-	int i, supportRateNum = 0;
+	int i, supportRateNum = 0;	
 	unsigned int tx_ra_bitmap=0;
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-	WLAN_BSSID_EX *pcur_network = (WLAN_BSSID_EX *)&pmlmepriv->cur_network.network;
+	WLAN_BSSID_EX *pcur_network = (WLAN_BSSID_EX *)&pmlmepriv->cur_network.network;	
 	struct sta_info *psta = rtw_get_bcmc_stainfo(padapter);
 
 	if(psta)
 	{
 		psta->aid = 0;//default set to 0
-		//psta->mac_id = psta->aid+4;
+		//psta->mac_id = psta->aid+4;	
 		psta->mac_id = psta->aid + 1;
 
-		psta->qos_option = 0;
+		psta->qos_option = 0;		
 		psta->htpriv.ht_option = _FALSE;
 
 		psta->ieee8021x_blocked = 0;
@@ -832,16 +829,16 @@ static void update_bmc_sta(_adapter *padapter)
 
 
 
-		//prepare for add_RATid
+		//prepare for add_RATid		
 		supportRateNum = rtw_get_rateset_len((u8*)&pcur_network->SupportedRates);
 		network_type = rtw_check_network_type((u8*)&pcur_network->SupportedRates, supportRateNum, 1);
-
+		
 		_rtw_memcpy(psta->bssrateset, &pcur_network->SupportedRates, supportRateNum);
 		psta->bssratelen = supportRateNum;
 
-		//b/g mode ra_bitmap
+		//b/g mode ra_bitmap  
 		for (i=0; i<supportRateNum; i++)
-		{
+		{	
 			if (psta->bssrateset[i])
 				tx_ra_bitmap |= rtw_get_bit_value_from_ieee_value(psta->bssrateset[i]&0x7f);
 		}
@@ -851,16 +848,16 @@ static void update_bmc_sta(_adapter *padapter)
 			network_type = WIRELESS_11A;
 			tx_ra_bitmap = 0x150; // 6, 12, 24 Mbps
 		} else {
-			//force to b mode
+			//force to b mode 
 			network_type = WIRELESS_11B;
-			tx_ra_bitmap = 0xf;
+			tx_ra_bitmap = 0xf;		
 		}
 
 		//tx_ra_bitmap = update_basic_rate(pcur_network->SupportedRates, supportRateNum);
 
 		raid = networktype_to_raid(network_type);
 		init_rate = get_highest_rate_idx(tx_ra_bitmap&0x0fffffff)&0x3f;
-
+				
 		//DBG_871X("Add id %d val %08x to ratr for bmc sta\n", psta->aid, tx_ra_bitmap);
 
 		//if(pHalData->fw_ractrl == _TRUE)
@@ -868,13 +865,13 @@ static void update_bmc_sta(_adapter *padapter)
 			u8 arg = 0;
 
 			arg = psta->mac_id&0x1f;
-
+		
 			arg |= BIT(7);
-
+		
 			//if (shortGIrate==_TRUE)
 			//	arg |= BIT(5);
-
-			tx_ra_bitmap |= ((raid<<28)&0xf0000000);
+			
+			tx_ra_bitmap |= ((raid<<28)&0xf0000000);			
 
 			DBG_871X("update_bmc_sta, mask=0x%x, arg=0x%x\n", tx_ra_bitmap, arg);
 
@@ -882,14 +879,14 @@ static void update_bmc_sta(_adapter *padapter)
 			//bitmap[28:31]= Rate Adaptive id
 			//arg[0:4] = macid
 			//arg[5] = Short GI
-			rtw_hal_add_ra_tid(padapter, tx_ra_bitmap, arg);
-
+			rtw_hal_add_ra_tid(padapter, tx_ra_bitmap, arg);			
+		
 		}
 
 		//set ra_id, init_rate
 		psta->raid = raid;
 		psta->init_rate = init_rate;
-
+	 
 		_enter_critical_bh(&psta->lock, &irqL);
 		psta->state = _FW_LINKED;
 		_exit_critical_bh(&psta->lock, &irqL);
@@ -899,18 +896,18 @@ static void update_bmc_sta(_adapter *padapter)
 	{
 		DBG_871X("add_RATid_bmc_sta error!\n");
 	}
-
+		
 }
 
 //notes:
-//AID: 1~MAX for sta and 0 for bc/mc in ap/adhoc mode
-//MAC_ID = AID+1 for sta in ap/adhoc mode
+//AID: 1~MAX for sta and 0 for bc/mc in ap/adhoc mode 
+//MAC_ID = AID+1 for sta in ap/adhoc mode 
 //MAC_ID = 1 for bc/mc for sta/ap/adhoc
 //MAC_ID = 0 for bssid for sta/ap/adhoc
 //CAM_ID = //0~3 for default key, cmd_id=macid + 3, macid=aid+1;
 
 void update_sta_info_apmode(_adapter *padapter, struct sta_info *psta)
-{
+{	
 	_irqL	irqL;
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
@@ -922,19 +919,19 @@ void update_sta_info_apmode(_adapter *padapter, struct sta_info *psta)
 	//psta->intf_tag = 0;
 
 	//psta->mac_id = psta->aid+4;
-	psta->mac_id = psta->aid+1;
-
+	psta->mac_id = psta->aid+1; 
+	
 	if(psecuritypriv->dot11AuthAlgrthm==dot11AuthAlgrthm_8021X)
 		psta->ieee8021x_blocked = _TRUE;
 	else
 		psta->ieee8021x_blocked = _FALSE;
-
+	
 
 	//update sta's cap
-
+	
 	//ERP
 	VCS_update(padapter, psta);
-
+		
 	//HT related cap
 	if(phtpriv_sta->ht_option)
 	{
@@ -953,16 +950,16 @@ void update_sta_info_apmode(_adapter *padapter, struct sta_info *psta)
 			//phtpriv_sta->bwmode = HT_CHANNEL_WIDTH_40;
 			phtpriv_sta->bwmode = pmlmeext->cur_bwmode;
 			phtpriv_sta->ch_offset = pmlmeext->cur_ch_offset;
-
-		}
+			
+		}		
 
 		psta->qos_option = _TRUE;
-
+		
 	}
 	else
 	{
 		phtpriv_sta->ampdu_enable = _FALSE;
-
+		
 		phtpriv_sta->sgi = _FALSE;
 		phtpriv_sta->bwmode = HT_CHANNEL_WIDTH_20;
 		phtpriv_sta->ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
@@ -970,15 +967,15 @@ void update_sta_info_apmode(_adapter *padapter, struct sta_info *psta)
 
 	//Rx AMPDU
 	send_delba(padapter, 0, psta->hwaddr);// recipient
-
+	
 	//TX AMPDU
 	send_delba(padapter, 1, psta->hwaddr);// // originator
 	phtpriv_sta->agg_enable_bitmap = 0x0;//reset
 	phtpriv_sta->candidate_tid_bitmap = 0x0;//reset
-
+	
 
 	//todo: init other variables
-
+	
 	_rtw_memset((void*)&psta->sta_stats, 0, sizeof(struct stainfo_stats));
 
 
@@ -989,7 +986,7 @@ void update_sta_info_apmode(_adapter *padapter, struct sta_info *psta)
 	_enter_critical_bh(&psta->lock, &irqL);
 	psta->state |= _FW_LINKED;
 	_exit_critical_bh(&psta->lock, &irqL);
-
+	
 
 }
 
@@ -1000,18 +997,18 @@ static void update_hw_ht_param(_adapter *padapter)
 	struct registry_priv	 *pregpriv = &padapter->registrypriv;
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-
+	
 	DBG_871X("%s\n", __FUNCTION__);
-
+	
 
 	//handle A-MPDU parameter field
-	/*
+	/* 	
 		AMPDU_para [1:0]:Max AMPDU Len => 0:8k , 1:16k, 2:32k, 3:64k
-		AMPDU_para [4:2]:Min MPDU Start Spacing
+		AMPDU_para [4:2]:Min MPDU Start Spacing	
 	*/
-	max_AMPDU_len = pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x03;
-
-	min_MPDU_spacing = (pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x1c) >> 2;
+	max_AMPDU_len = pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x03;	
+	
+	min_MPDU_spacing = (pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x1c) >> 2;	
 
 	rtw_hal_set_hwreg(padapter, HW_VAR_AMPDU_MIN_SPACE, (u8 *)(&min_MPDU_spacing));
 
@@ -1044,11 +1041,11 @@ static void start_bss_network(_adapter *padapter, u8 *pbuf)
 	u8 *p;
 	u8 val8, cur_channel, cur_bwmode, cur_ch_offset;
 	u16 bcn_interval;
-	u32	acparm;
-	int	ie_len;
+	u32	acparm;	
+	int	ie_len;	
 	struct registry_priv	 *pregpriv = &padapter->registrypriv;
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-	struct security_priv* psecuritypriv=&(padapter->securitypriv);
+	struct security_priv* psecuritypriv=&(padapter->securitypriv);	
 	WLAN_BSSID_EX *pnetwork = (WLAN_BSSID_EX *)&pmlmepriv->cur_network.network;
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
@@ -1061,13 +1058,13 @@ static void start_bss_network(_adapter *padapter, u8 *pbuf)
 	u8 change_band = _FALSE;
 	//DBG_871X("%s\n", __FUNCTION__);
 
-	bcn_interval = (u16)pnetwork->Configuration.BeaconPeriod;
+	bcn_interval = (u16)pnetwork->Configuration.BeaconPeriod;	
 	cur_channel = pnetwork->Configuration.DSConfig;
 	cur_bwmode = HT_CHANNEL_WIDTH_20;;
 	cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+	
 
-
-	//check if there is wps ie,
+	//check if there is wps ie, 
 	//if there is wpsie in beacon, the hostapd will update beacon twice when stating hostapd,
 	//and at first time the security ie ( RSN/WPA IE) will not include in beacon.
 	if(NULL == rtw_get_wps_ie(pnetwork->IEs+_FIXED_IE_LENGTH_, pnetwork->IELength-_FIXED_IE_LENGTH_, NULL, NULL))
@@ -1090,18 +1087,18 @@ static void start_bss_network(_adapter *padapter, u8 *pbuf)
 
 		update_hw_ht_param(padapter);
 	}
-
+	
 
 	if(pmlmepriv->cur_network.join_res != _TRUE) //setting only at  first time
-	{
+	{		
 		//WEP Key will be set before this function, do not clear CAM.
 		if ((psecuritypriv->dot11PrivacyAlgrthm != _WEP40_) && (psecuritypriv->dot11PrivacyAlgrthm != _WEP104_))
 			flush_all_cam_entry(padapter);	//clear CAM
-	}
-
-	//set MSR to AP_Mode
-	Set_MSR(padapter, _HW_STATE_AP_);
+	}	
 
+	//set MSR to AP_Mode		
+	Set_MSR(padapter, _HW_STATE_AP_);	
+		
 	//Set BSSID REG
 	rtw_hal_set_hwreg(padapter, HW_VAR_BSSID, pnetwork->MacAddress);
 
@@ -1137,8 +1134,8 @@ static void start_bss_network(_adapter *padapter, u8 *pbuf)
 		//disable dynamic functions, such as high power, DIG
 		//Save_DM_Func_Flag(padapter);
 		//Switch_DM_Func(padapter, DYNAMIC_FUNC_DISABLE, _FALSE);
-
-#ifdef CONFIG_CONCURRENT_MODE
+		
+#ifdef CONFIG_CONCURRENT_MODE	
 		if(padapter->adapter_type > PRIMARY_ADAPTER)
 		{
 			if(rtw_buddy_adapter_up(padapter))
@@ -1147,22 +1144,22 @@ static void start_bss_network(_adapter *padapter, u8 *pbuf)
 
 				//turn on dynamic functions on PRIMARY_ADAPTER, dynamic functions only runs at PRIMARY_ADAPTER
 				Switch_DM_Func(pbuddy_adapter, DYNAMIC_FUNC_DIG|DYNAMIC_FUNC_HP|DYNAMIC_FUNC_SS, _TRUE);
-
+	
 				rtw_hal_set_hwreg(pbuddy_adapter, HW_VAR_INITIAL_GAIN, (u8 *)(&initialgain));
 			}
 		}
 		else
 #endif
 		{
-			//turn on dynamic functions
+			//turn on dynamic functions	
 			Switch_DM_Func(padapter, DYNAMIC_FUNC_DIG|DYNAMIC_FUNC_HP|DYNAMIC_FUNC_SS, _TRUE);
 
 			rtw_hal_set_hwreg(padapter, HW_VAR_INITIAL_GAIN, (u8 *)(&initialgain));
-		}
-
+		}	
+	
 	}
 
-	//set channel, bwmode
+	//set channel, bwmode	
 	p = rtw_get_ie((pnetwork->IEs + sizeof(NDIS_802_11_FIXED_IEs)), _HT_ADD_INFO_IE_, &ie_len, (pnetwork->IELength - sizeof(NDIS_802_11_FIXED_IEs)));
 	if( p && ie_len)
 	{
@@ -1176,7 +1173,7 @@ static void start_bss_network(_adapter *padapter, u8 *pbuf)
 		else
 			if( pregpriv->cbw40_enable & BIT(0) )
 				cbw40_enable = 1;
-
+			
 		if ((cbw40_enable) &&	 (pht_info->infos[0] & BIT(2)))
 		{
 			//switch to the 40M Hz mode
@@ -1188,20 +1185,20 @@ static void start_bss_network(_adapter *padapter, u8 *pbuf)
 					//pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;
 					cur_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;
 					break;
-
+			
 				case 3:
 					//pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER;
-					cur_ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER;
+					cur_ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER;					
 					break;
-
+				
 				default:
 					//pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
 					cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
 					break;
-			}
-
+			}		
+						
 		}
-
+					
 	}
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
@@ -1216,31 +1213,31 @@ static void start_bss_network(_adapter *padapter, u8 *pbuf)
 	}
 	else if(check_buddy_fwstate(padapter, _FW_LINKED)==_TRUE)//only second adapter can enter AP Mode
 	{
-		_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
+		_adapter *pbuddy_adapter = padapter->pbuddy_adapter;		
 		struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
-
+	
 		//To sync cur_channel/cur_bwmode/cur_ch_offset with primary adapter
 		DBG_871X("primary iface is at linked state, sync cur_channel/cur_bwmode/cur_ch_offset\n");
 		DBG_871X("primary adapter, CH=%d, BW=%d, offset=%d\n", pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_bwmode, pbuddy_mlmeext->cur_ch_offset);
 		DBG_871X("second adapter, CH=%d, BW=%d, offset=%d\n", cur_channel, cur_bwmode, cur_ch_offset);
-
+		
 		if((cur_channel <= 14 && pbuddy_mlmeext->cur_channel >= 36) ||
 		(cur_channel >= 36 && pbuddy_mlmeext->cur_channel <= 14))
 			change_band = _TRUE;
-
+		
 		cur_channel = pbuddy_mlmeext->cur_channel;
 		if(cur_bwmode == HT_CHANNEL_WIDTH_40)
 		{
 			if(pht_info)
 				pht_info->infos[0] &= ~(BIT(0)|BIT(1));
-
+			
 			if(pbuddy_mlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40)
 			{
 				cur_ch_offset = pbuddy_mlmeext->cur_ch_offset;
 
 				//to update cur_ch_offset value in beacon
 				if(pht_info)
-				{
+				{				
 					switch(cur_ch_offset)
 					{
 						case HAL_PRIME_CHNL_OFFSET_LOWER:
@@ -1249,22 +1246,22 @@ static void start_bss_network(_adapter *padapter, u8 *pbuf)
 						case HAL_PRIME_CHNL_OFFSET_UPPER:
 							pht_info->infos[0] |= 0x3;
 							break;
-						case HAL_PRIME_CHNL_OFFSET_DONT_CARE:
-						default:
-							break;
+						case HAL_PRIME_CHNL_OFFSET_DONT_CARE:							
+						default:							
+							break;					
 					}
-				}
-
+				}		
+				
 			}
 			else if(pbuddy_mlmeext->cur_bwmode == HT_CHANNEL_WIDTH_20)
 			{
 				cur_bwmode = HT_CHANNEL_WIDTH_20;
 				cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
-
+			
 				if(cur_channel>0 && cur_channel<5)
 				{
 					if(pht_info)
-						pht_info->infos[0] |= 0x1;
+						pht_info->infos[0] |= 0x1;		
 
 					cur_bwmode = HT_CHANNEL_WIDTH_40;
 					cur_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;
@@ -1274,30 +1271,30 @@ static void start_bss_network(_adapter *padapter, u8 *pbuf)
 				{
 					if(pht_info)
 						pht_info->infos[0] |= 0x3;
-
+						
 					cur_bwmode = HT_CHANNEL_WIDTH_40;
 					cur_ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER;
-				}
+				}					
 
 				set_channel_bwmode(padapter, cur_channel, cur_ch_offset, cur_bwmode);
 			}
-
+			
 		}
 
 		// to update channel value in beacon
-		pnetwork->Configuration.DSConfig = cur_channel;
+		pnetwork->Configuration.DSConfig = cur_channel;		
 		p = rtw_get_ie((pnetwork->IEs + sizeof(NDIS_802_11_FIXED_IEs)), _DSSET_IE_, &ie_len, (pnetwork->IELength - sizeof(NDIS_802_11_FIXED_IEs)));
 		if(p && ie_len>0)
 			*(p + 2) = cur_channel;
-
+		
 		if(pht_info)
 			pht_info->primary_channel = cur_channel;
-
+		
 		//set buddy adapter channel, bandwidth, offeset to current adapter
-		pmlmeext->cur_channel = cur_channel;
+		pmlmeext->cur_channel = cur_channel;	
 		pmlmeext->cur_bwmode = cur_bwmode;
 		pmlmeext->cur_ch_offset = cur_ch_offset;
-
+		
 		//buddy interface band is different from current interface, update ERP, support rate, ext support rate IE
 		if(change_band == _TRUE)
 			change_band_update_ie(padapter, pnetwork);
@@ -1309,7 +1306,7 @@ static void start_bss_network(_adapter *padapter, u8 *pbuf)
 	DBG_871X("CH=%d, BW=%d, offset=%d\n", cur_channel, cur_bwmode, cur_ch_offset);
 
 	//
-	pmlmeext->cur_channel = cur_channel;
+	pmlmeext->cur_channel = cur_channel;	
 	pmlmeext->cur_bwmode = cur_bwmode;
 	pmlmeext->cur_ch_offset = cur_ch_offset;
 #endif //CONFIG_DUALMAC_CONCURRENT
@@ -1324,12 +1321,12 @@ static void start_bss_network(_adapter *padapter, u8 *pbuf)
 
 	//udpate capability after cur_wireless_mode updated
 	update_capinfo(padapter, rtw_get_capability((WLAN_BSSID_EX *)pnetwork));
-
+	
 	//let pnetwork_mlmeext == pnetwork_mlme.
 	_rtw_memcpy(pnetwork_mlmeext, pnetwork, pnetwork->Length);
 
 #ifdef CONFIG_P2P
-	_rtw_memcpy(pwdinfo->p2p_group_ssid, pnetwork->Ssid.Ssid, pnetwork->Ssid.SsidLength);
+	_rtw_memcpy(pwdinfo->p2p_group_ssid, pnetwork->Ssid.Ssid, pnetwork->Ssid.SsidLength);	
 	pwdinfo->p2p_group_ssid_len = pnetwork->Ssid.SsidLength;
 #endif //CONFIG_P2P
 
@@ -1344,7 +1341,7 @@ static void start_bss_network(_adapter *padapter, u8 *pbuf)
 		{
 			DBG_871X("issue_beacon, fail!\n");
 		}
-#endif
+#endif 
 #endif //!CONFIG_INTERRUPT_BASED_TXBCN
 
 	}
@@ -1352,9 +1349,9 @@ static void start_bss_network(_adapter *padapter, u8 *pbuf)
 
 	//update bc/mc sta_info
 	update_bmc_sta(padapter);
-
+	
 	//pmlmeext->bstart_bss = _TRUE;
-
+	
 }
 
 int rtw_check_beacon_data(_adapter *padapter, u8 *pbuf,  int len)
@@ -1366,19 +1363,19 @@ int rtw_check_beacon_data(_adapter *padapter, u8 *pbuf,  int len)
 	struct sta_info *psta = NULL;
 	u16 cap, ht_cap=_FALSE;
 	uint ie_len = 0;
-	int group_cipher, pairwise_cipher;
+	int group_cipher, pairwise_cipher;	
 	u8	channel, network_type, supportRate[NDIS_802_11_LENGTH_RATES_EX];
 	int supportRateNum = 0;
 	u8 OUI1[] = {0x00, 0x50, 0xf2,0x01};
 	u8 wps_oui[4]={0x0,0x50,0xf2,0x04};
-	u8 WMM_PARA_IE[] = {0x00, 0x50, 0xf2, 0x02, 0x01, 0x01};
-	struct registry_priv *pregistrypriv = &padapter->registrypriv;
+	u8 WMM_PARA_IE[] = {0x00, 0x50, 0xf2, 0x02, 0x01, 0x01};	
+	struct registry_priv *pregistrypriv = &padapter->registrypriv;	
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-	WLAN_BSSID_EX *pbss_network = (WLAN_BSSID_EX *)&pmlmepriv->cur_network.network;
+	WLAN_BSSID_EX *pbss_network = (WLAN_BSSID_EX *)&pmlmepriv->cur_network.network;	
 	struct sta_priv *pstapriv = &padapter->stapriv;
 	u8 *ie = pbss_network->IEs;
-
+	
 
 	/* SSID */
 	/* Supported rates */
@@ -1399,11 +1396,11 @@ int rtw_check_beacon_data(_adapter *padapter, u8 *pbuf,  int len)
 
 	if(len>MAX_IE_SZ)
 		return _FAIL;
-
+	
 	pbss_network->IELength = len;
 
 	_rtw_memset(ie, 0, MAX_IE_SZ);
-
+	
 	_rtw_memcpy(ie, pbuf, pbss_network->IELength);
 
 
@@ -1413,12 +1410,12 @@ int rtw_check_beacon_data(_adapter *padapter, u8 *pbuf,  int len)
 	pbss_network->Rssi = 0;
 
 	_rtw_memcpy(pbss_network->MacAddress, myid(&(padapter->eeprompriv)), ETH_ALEN);
-
+	
 	//beacon interval
 	p = rtw_get_beacon_interval_from_ie(ie);//ie + 8;	// 8: TimeStamp, 2: Beacon Interval 2:Capability
 	//pbss_network->Configuration.BeaconPeriod = le16_to_cpu(*(unsigned short*)p);
 	pbss_network->Configuration.BeaconPeriod = RTW_GET_LE16(p);
-
+	
 	//capability
 	//cap = *(unsigned short *)rtw_get_capability_from_ie(ie);
 	//cap = le16_to_cpu(cap);
@@ -1431,7 +1428,7 @@ int rtw_check_beacon_data(_adapter *padapter, u8 *pbuf,  int len)
 		_rtw_memset(&pbss_network->Ssid, 0, sizeof(NDIS_802_11_SSID));
 		_rtw_memcpy(pbss_network->Ssid.Ssid, (p + 2), ie_len);
 		pbss_network->Ssid.SsidLength = ie_len;
-	}
+	}	
 
 	//chnnel
 	channel = 0;
@@ -1442,23 +1439,23 @@ int rtw_check_beacon_data(_adapter *padapter, u8 *pbuf,  int len)
 
 	pbss_network->Configuration.DSConfig = channel;
 
-
+	
 	_rtw_memset(supportRate, 0, NDIS_802_11_LENGTH_RATES_EX);
 	// get supported rates
-	p = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _SUPPORTEDRATES_IE_, &ie_len, (pbss_network->IELength - _BEACON_IE_OFFSET_));
-	if (p !=  NULL)
+	p = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _SUPPORTEDRATES_IE_, &ie_len, (pbss_network->IELength - _BEACON_IE_OFFSET_));	
+	if (p !=  NULL) 
 	{
-		_rtw_memcpy(supportRate, p+2, ie_len);
+		_rtw_memcpy(supportRate, p+2, ie_len);	
 		supportRateNum = ie_len;
 	}
-
+	
 	//get ext_supported rates
-	p = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _EXT_SUPPORTEDRATES_IE_, &ie_len, pbss_network->IELength - _BEACON_IE_OFFSET_);
+	p = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _EXT_SUPPORTEDRATES_IE_, &ie_len, pbss_network->IELength - _BEACON_IE_OFFSET_);	
 	if (p !=  NULL)
 	{
 		_rtw_memcpy(supportRate+supportRateNum, p+2, ie_len);
 		supportRateNum += ie_len;
-
+	
 	}
 
 	network_type = rtw_check_network_type(supportRate, supportRateNum, channel);
@@ -1484,14 +1481,14 @@ int rtw_check_beacon_data(_adapter *padapter, u8 *pbuf,  int len)
 	//wpa2
 	group_cipher = 0; pairwise_cipher = 0;
 	psecuritypriv->wpa2_group_cipher = _NO_PRIVACY_;
-	psecuritypriv->wpa2_pairwise_cipher = _NO_PRIVACY_;
-	p = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _RSN_IE_2_, &ie_len, (pbss_network->IELength - _BEACON_IE_OFFSET_));
+	psecuritypriv->wpa2_pairwise_cipher = _NO_PRIVACY_;	
+	p = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _RSN_IE_2_, &ie_len, (pbss_network->IELength - _BEACON_IE_OFFSET_));		
 	if(p && ie_len>0)
 	{
 		if(rtw_parse_wpa2_ie(p, ie_len+2, &group_cipher, &pairwise_cipher) == _SUCCESS)
 		{
 			psecuritypriv->dot11AuthAlgrthm= dot11AuthAlgrthm_8021X;
-
+			
 			psecuritypriv->dot8021xalg = 1;//psk,  todo:802.1x
 			psecuritypriv->wpa_psk |= BIT(1);
 
@@ -1500,60 +1497,60 @@ int rtw_check_beacon_data(_adapter *padapter, u8 *pbuf,  int len)
 #if 0
 			switch(group_cipher)
 			{
-				case WPA_CIPHER_NONE:
+				case WPA_CIPHER_NONE:				
 				psecuritypriv->wpa2_group_cipher = _NO_PRIVACY_;
 				break;
-				case WPA_CIPHER_WEP40:
+				case WPA_CIPHER_WEP40:				
 				psecuritypriv->wpa2_group_cipher = _WEP40_;
 				break;
-				case WPA_CIPHER_TKIP:
+				case WPA_CIPHER_TKIP:				
 				psecuritypriv->wpa2_group_cipher = _TKIP_;
 				break;
-				case WPA_CIPHER_CCMP:
-				psecuritypriv->wpa2_group_cipher = _AES_;
+				case WPA_CIPHER_CCMP:				
+				psecuritypriv->wpa2_group_cipher = _AES_;				
 				break;
-				case WPA_CIPHER_WEP104:
+				case WPA_CIPHER_WEP104:					
 				psecuritypriv->wpa2_group_cipher = _WEP104_;
 				break;
 			}
 
 			switch(pairwise_cipher)
 			{
-				case WPA_CIPHER_NONE:
+				case WPA_CIPHER_NONE:			
 				psecuritypriv->wpa2_pairwise_cipher = _NO_PRIVACY_;
 				break;
-				case WPA_CIPHER_WEP40:
+				case WPA_CIPHER_WEP40:			
 				psecuritypriv->wpa2_pairwise_cipher = _WEP40_;
 				break;
-				case WPA_CIPHER_TKIP:
+				case WPA_CIPHER_TKIP:				
 				psecuritypriv->wpa2_pairwise_cipher = _TKIP_;
 				break;
-				case WPA_CIPHER_CCMP:
+				case WPA_CIPHER_CCMP:			
 				psecuritypriv->wpa2_pairwise_cipher = _AES_;
 				break;
-				case WPA_CIPHER_WEP104:
+				case WPA_CIPHER_WEP104:					
 				psecuritypriv->wpa2_pairwise_cipher = _WEP104_;
 				break;
 			}
-#endif
+#endif			
 		}
-
+		
 	}
 
 	//wpa
 	ie_len = 0;
 	group_cipher = 0; pairwise_cipher = 0;
 	psecuritypriv->wpa_group_cipher = _NO_PRIVACY_;
-	psecuritypriv->wpa_pairwise_cipher = _NO_PRIVACY_;
+	psecuritypriv->wpa_pairwise_cipher = _NO_PRIVACY_;	
 	for (p = ie + _BEACON_IE_OFFSET_; ;p += (ie_len + 2))
 	{
-		p = rtw_get_ie(p, _SSN_IE_1_, &ie_len, (pbss_network->IELength - _BEACON_IE_OFFSET_ - (ie_len + 2)));
+		p = rtw_get_ie(p, _SSN_IE_1_, &ie_len, (pbss_network->IELength - _BEACON_IE_OFFSET_ - (ie_len + 2)));		
 		if ((p) && (_rtw_memcmp(p+2, OUI1, 4)))
 		{
 			if(rtw_parse_wpa_ie(p, ie_len+2, &group_cipher, &pairwise_cipher) == _SUCCESS)
 			{
 				psecuritypriv->dot11AuthAlgrthm= dot11AuthAlgrthm_8021X;
-
+				
 				psecuritypriv->dot8021xalg = 1;//psk,  todo:802.1x
 
 				psecuritypriv->wpa_psk |= BIT(0);
@@ -1564,53 +1561,53 @@ int rtw_check_beacon_data(_adapter *padapter, u8 *pbuf,  int len)
 #if 0
 				switch(group_cipher)
 				{
-					case WPA_CIPHER_NONE:
+					case WPA_CIPHER_NONE:					
 					psecuritypriv->wpa_group_cipher = _NO_PRIVACY_;
 					break;
-					case WPA_CIPHER_WEP40:
+					case WPA_CIPHER_WEP40:					
 					psecuritypriv->wpa_group_cipher = _WEP40_;
 					break;
-					case WPA_CIPHER_TKIP:
+					case WPA_CIPHER_TKIP:					
 					psecuritypriv->wpa_group_cipher = _TKIP_;
 					break;
-					case WPA_CIPHER_CCMP:
-					psecuritypriv->wpa_group_cipher = _AES_;
+					case WPA_CIPHER_CCMP:					
+					psecuritypriv->wpa_group_cipher = _AES_;				
 					break;
-					case WPA_CIPHER_WEP104:
+					case WPA_CIPHER_WEP104:					
 					psecuritypriv->wpa_group_cipher = _WEP104_;
 					break;
 				}
 
 				switch(pairwise_cipher)
 				{
-					case WPA_CIPHER_NONE:
+					case WPA_CIPHER_NONE:					
 					psecuritypriv->wpa_pairwise_cipher = _NO_PRIVACY_;
 					break;
-					case WPA_CIPHER_WEP40:
+					case WPA_CIPHER_WEP40:					
 					psecuritypriv->wpa_pairwise_cipher = _WEP40_;
 					break;
-					case WPA_CIPHER_TKIP:
+					case WPA_CIPHER_TKIP:					
 					psecuritypriv->wpa_pairwise_cipher = _TKIP_;
 					break;
-					case WPA_CIPHER_CCMP:
+					case WPA_CIPHER_CCMP:					
 					psecuritypriv->wpa_pairwise_cipher = _AES_;
 					break;
-					case WPA_CIPHER_WEP104:
+					case WPA_CIPHER_WEP104:					
 					psecuritypriv->wpa_pairwise_cipher = _WEP104_;
 					break;
 				}
-#endif
+#endif				
 			}
 
 			break;
-
+			
 		}
-
+			
 		if ((p == NULL) || (ie_len == 0))
 		{
 				break;
 		}
-
+		
 	}
 
 	//wmm
@@ -1619,28 +1616,28 @@ int rtw_check_beacon_data(_adapter *padapter, u8 *pbuf,  int len)
 	if(pregistrypriv->wmm_enable)
 	{
 		for (p = ie + _BEACON_IE_OFFSET_; ;p += (ie_len + 2))
-		{
-			p = rtw_get_ie(p, _VENDOR_SPECIFIC_IE_, &ie_len, (pbss_network->IELength - _BEACON_IE_OFFSET_ - (ie_len + 2)));
-			if((p) && _rtw_memcmp(p+2, WMM_PARA_IE, 6))
+		{			
+			p = rtw_get_ie(p, _VENDOR_SPECIFIC_IE_, &ie_len, (pbss_network->IELength - _BEACON_IE_OFFSET_ - (ie_len + 2)));	
+			if((p) && _rtw_memcmp(p+2, WMM_PARA_IE, 6)) 
 			{
-				pmlmepriv->qospriv.qos_option = 1;
+				pmlmepriv->qospriv.qos_option = 1;	
 
 				*(p+8) |= BIT(7);//QoS Info, support U-APSD
-
+				
 				/* disable all ACM bits since the WMM admission control is not supported */
 				*(p + 10) &= ~BIT(4); /* BE */
 				*(p + 14) &= ~BIT(4); /* BK */
 				*(p + 18) &= ~BIT(4); /* VI */
 				*(p + 22) &= ~BIT(4); /* VO */
-
-				break;
+				
+				break;				
 			}
-
+			
 			if ((p == NULL) || (ie_len == 0))
 			{
 				break;
-			}
-		}
+			}			
+		}		
 	}
 
 	//parsing HT_CAP_IE
@@ -1652,34 +1649,34 @@ int rtw_check_beacon_data(_adapter *padapter, u8 *pbuf,  int len)
 		struct rtw_ieee80211_ht_cap *pht_cap = (struct rtw_ieee80211_ht_cap *)(p+2);
 
 		pHT_caps_ie=p;
-
-
+		
+		
 		ht_cap = _TRUE;
 		network_type |= WIRELESS_11_24N;
 
-
+	
 		rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
 
 		if((psecuritypriv->wpa_pairwise_cipher & WPA_CIPHER_CCMP) ||
 			(psecuritypriv->wpa2_pairwise_cipher & WPA_CIPHER_CCMP))
 		{
 			pht_cap->ampdu_params_info |= (IEEE80211_HT_CAP_AMPDU_DENSITY&(0x07<<2));
-		}
+		}	
 		else
 		{
-			pht_cap->ampdu_params_info |= (IEEE80211_HT_CAP_AMPDU_DENSITY&0x00);
-		}
+			pht_cap->ampdu_params_info |= (IEEE80211_HT_CAP_AMPDU_DENSITY&0x00);	
+		}	
 
 		pht_cap->ampdu_params_info |= (IEEE80211_HT_CAP_AMPDU_FACTOR & 0x03); //set  Max Rx AMPDU size  to 64K
 
 		if(rf_type == RF_1T1R)
-		{
+		{			
 			pht_cap->supp_mcs_set[0] = 0xff;
-			pht_cap->supp_mcs_set[1] = 0x0;
+			pht_cap->supp_mcs_set[1] = 0x0;				
 		}
 
-		_rtw_memcpy(&pmlmepriv->htpriv.ht_cap, p+2, ie_len);
-
+		_rtw_memcpy(&pmlmepriv->htpriv.ht_cap, p+2, ie_len);		
+		
 	}
 
 	//parsing HT_INFO_IE
@@ -1693,7 +1690,7 @@ int rtw_check_beacon_data(_adapter *padapter, u8 *pbuf,  int len)
 	{
 		case WIRELESS_11B:
 			pbss_network->NetworkTypeInUse = Ndis802_11DS;
-			break;
+			break;	
 		case WIRELESS_11G:
 		case WIRELESS_11BG:
              case WIRELESS_11G_24N:
@@ -1707,7 +1704,7 @@ int rtw_check_beacon_data(_adapter *padapter, u8 *pbuf,  int len)
 			pbss_network->NetworkTypeInUse = Ndis802_11OFDM24;
 			break;
 	}
-
+	
 	pmlmepriv->cur_network.network_type = network_type;
 
 
@@ -1715,14 +1712,14 @@ int rtw_check_beacon_data(_adapter *padapter, u8 *pbuf,  int len)
 #ifdef CONFIG_80211N_HT
 	if( (psecuritypriv->wpa2_pairwise_cipher&WPA_CIPHER_TKIP) ||
 		      (psecuritypriv->wpa_pairwise_cipher&WPA_CIPHER_TKIP))
-	{
+	{	
 		//todo:
 		//ht_cap = _FALSE;
 	}
-
-	//ht_cap
+		      
+	//ht_cap	
 	if(pregistrypriv->ht_enable && ht_cap==_TRUE)
-	{
+	{		
 		pmlmepriv->htpriv.ht_option = _TRUE;
 		pmlmepriv->qospriv.qos_option = 1;
 
@@ -1732,7 +1729,7 @@ int rtw_check_beacon_data(_adapter *padapter, u8 *pbuf,  int len)
 		}
 
 		HT_caps_handler(padapter, (PNDIS_802_11_VARIABLE_IEs)pHT_caps_ie);
-
+		
 		HT_info_handler(padapter, (PNDIS_802_11_VARIABLE_IEs)pHT_info_ie);
 	}
 #endif
@@ -1742,23 +1739,23 @@ int rtw_check_beacon_data(_adapter *padapter, u8 *pbuf,  int len)
 
 	//issue beacon to start bss network
 	start_bss_network(padapter, (u8*)pbss_network);
-
+			
 
 	//alloc sta_info for ap itself
 	psta = rtw_get_stainfo(&padapter->stapriv, pbss_network->MacAddress);
 	if(!psta)
 	{
 		psta = rtw_alloc_stainfo(&padapter->stapriv, pbss_network->MacAddress);
-		if (psta == NULL)
-		{
+		if (psta == NULL) 
+		{ 
 			return _FAIL;
-		}
-	}
-	psta->state |= WIFI_AP_STATE;		//Aries, add,fix bug of flush_cam_entry at STOP AP mode , 0724
+		}	
+	}	
+	psta->state |= WIFI_AP_STATE;		//Aries, add,fix bug of flush_cam_entry at STOP AP mode , 0724 	
 	rtw_indicate_connect( padapter);
 
 	pmlmepriv->cur_network.join_res = _TRUE;//for check if already set beacon
-
+		
 	//update bc/mc sta_info
 	//update_bmc_sta(padapter);
 
@@ -1785,19 +1782,19 @@ int rtw_acl_add_sta(_adapter *padapter, u8 *addr)
 	struct rtw_wlan_acl_node *paclnode;
 	struct sta_priv *pstapriv = &padapter->stapriv;
 	struct wlan_acl_pool *pacl_list = &pstapriv->acl_list;
-	_queue	*pacl_node_q =&pacl_list->acl_node_q;
+	_queue	*pacl_node_q =&pacl_list->acl_node_q;	
 
-	DBG_871X("%s(acl_num=%d)=" MAC_FMT "\n", __func__, pacl_list->num, MAC_ARG(addr));
+	DBG_871X("%s(acl_num=%d)=" MAC_FMT "\n", __func__, pacl_list->num, MAC_ARG(addr));	
 
 	if((NUM_ACL-1) < pacl_list->num)
-		return (-1);
+		return (-1);	
 
 
 	_enter_critical_bh(&(pacl_node_q->lock), &irqL);
 
 	phead = get_list_head(pacl_node_q);
 	plist = get_next(phead);
-
+		
 	while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
 	{
 		paclnode = LIST_CONTAINOR(plist, struct rtw_wlan_acl_node, list);
@@ -1811,15 +1808,15 @@ int rtw_acl_add_sta(_adapter *padapter, u8 *addr)
 				DBG_871X("%s, sta has been added\n", __func__);
 				break;
 			}
-		}
+		}		
 	}
-
+	
 	_exit_critical_bh(&(pacl_node_q->lock), &irqL);
 
 
 	if(added == _TRUE)
 		return ret;
-
+	
 
 	_enter_critical_bh(&(pacl_node_q->lock), &irqL);
 
@@ -1830,13 +1827,13 @@ int rtw_acl_add_sta(_adapter *padapter, u8 *addr)
 		if(paclnode->valid == _FALSE)
 		{
 			_rtw_init_listhead(&paclnode->list);
-
+	
 			_rtw_memcpy(paclnode->addr, addr, ETH_ALEN);
-
+		
 			paclnode->valid = _TRUE;
 
 			rtw_list_insert_tail(&paclnode->list, get_list_head(pacl_node_q));
-
+	
 			pacl_list->num++;
 
 			break;
@@ -1844,7 +1841,7 @@ int rtw_acl_add_sta(_adapter *padapter, u8 *addr)
 	}
 
 	DBG_871X("%s, acl_num=%d\n", __func__, pacl_list->num);
-
+	
 	_exit_critical_bh(&(pacl_node_q->lock), &irqL);
 
 	return ret;
@@ -1858,15 +1855,15 @@ int rtw_acl_remove_sta(_adapter *padapter, u8 *addr)
 	struct rtw_wlan_acl_node *paclnode;
 	struct sta_priv *pstapriv = &padapter->stapriv;
 	struct wlan_acl_pool *pacl_list = &pstapriv->acl_list;
-	_queue	*pacl_node_q =&pacl_list->acl_node_q;
+	_queue	*pacl_node_q =&pacl_list->acl_node_q;	
 
-	DBG_871X("%s(acl_num=%d)=" MAC_FMT "\n", __func__, pacl_list->num, MAC_ARG(addr));
+	DBG_871X("%s(acl_num=%d)=" MAC_FMT "\n", __func__, pacl_list->num, MAC_ARG(addr));	
 
 	_enter_critical_bh(&(pacl_node_q->lock), &irqL);
 
 	phead = get_list_head(pacl_node_q);
 	plist = get_next(phead);
-
+		
 	while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
 	{
 		paclnode = LIST_CONTAINOR(plist, struct rtw_wlan_acl_node, list);
@@ -1879,16 +1876,16 @@ int rtw_acl_remove_sta(_adapter *padapter, u8 *addr)
 				paclnode->valid = _FALSE;
 
 				rtw_list_delete(&paclnode->list);
-
+				
 				pacl_list->num--;
 			}
-		}
+		}		
 	}
-
+	
 	_exit_critical_bh(&(pacl_node_q->lock), &irqL);
 
 	DBG_871X("%s, acl_num=%d\n", __func__, pacl_list->num);
-
+	
 	return ret;
 
 }
@@ -1930,10 +1927,10 @@ static void update_bcn_erpinfo_ie(_adapter *padapter)
 			pIE->data[0] |= RTW_ERP_INFO_BARKER_PREAMBLE_MODE;
 		else
 			pIE->data[0] &= ~(RTW_ERP_INFO_BARKER_PREAMBLE_MODE);
-
+	
 		ERP_IE_handler(padapter, pIE);
 	}
-
+	
 }
 
 static void update_bcn_htcap_ie(_adapter *padapter)
@@ -1943,7 +1940,7 @@ static void update_bcn_htcap_ie(_adapter *padapter)
 }
 
 static void update_bcn_htinfo_ie(_adapter *padapter)
-{
+{	
 	DBG_871X("%s\n", __FUNCTION__);
 
 }
@@ -1963,7 +1960,7 @@ static void update_bcn_wpa_ie(_adapter *padapter)
 static void update_bcn_wmm_ie(_adapter *padapter)
 {
 	DBG_871X("%s\n", __FUNCTION__);
-
+	
 }
 
 static void update_bcn_wps_ie(_adapter *padapter)
@@ -1981,7 +1978,7 @@ static void update_bcn_wps_ie(_adapter *padapter)
 	DBG_871X("%s\n", __FUNCTION__);
 
 	pwps_ie = rtw_get_wps_ie(ie+_FIXED_IE_LENGTH_, ielen-_FIXED_IE_LENGTH_, NULL, &wps_ielen);
-
+	
 	if(pwps_ie==NULL || wps_ielen==0)
 		return;
 
@@ -1998,7 +1995,7 @@ static void update_bcn_wps_ie(_adapter *padapter)
 			_rtw_memcpy(pbackup_remainder_ie, premainder_ie, remainder_ielen);
 	}
 
-
+	
 	pwps_ie_src = pmlmepriv->wps_beacon_ie;
 	if(pwps_ie_src == NULL)
 		return;
@@ -2050,9 +2047,9 @@ static void update_bcn_vendor_spec_ie(_adapter *padapter, u8*oui)
 	else
 	{
 		DBG_871X("unknown OUI type!\n");
-	}
-
-
+ 	}
+	
+	
 }
 
 void update_beacon(_adapter *padapter, u8 ie_id, u8 *oui, u8 tx)
@@ -2061,7 +2058,7 @@ void update_beacon(_adapter *padapter, u8 ie_id, u8 *oui, u8 tx)
 	struct mlme_priv *pmlmepriv;
 	struct mlme_ext_priv	*pmlmeext;
 	//struct mlme_ext_info	*pmlmeinfo;
-
+	
 	//DBG_871X("%s\n", __FUNCTION__);
 
 	if(!padapter)
@@ -2081,13 +2078,13 @@ void update_beacon(_adapter *padapter, u8 ie_id, u8 *oui, u8 tx)
 		case 0xFF:
 
 			update_bcn_fixed_ie(padapter);//8: TimeStamp, 2: Beacon Interval 2:Capability
-
+			
 			break;
 
 		case _TIM_IE_:
-
+			
 			update_BCNTIM(padapter);
-
+			
 			break;
 
 		case _ERPINFO_IE_:
@@ -2099,7 +2096,7 @@ void update_beacon(_adapter *padapter, u8 ie_id, u8 *oui, u8 tx)
 		case _HT_CAPABILITY_IE_:
 
 			update_bcn_htcap_ie(padapter);
-
+			
 			break;
 
 		case _RSN_IE_2_:
@@ -2107,28 +2104,28 @@ void update_beacon(_adapter *padapter, u8 ie_id, u8 *oui, u8 tx)
 			update_bcn_rsn_ie(padapter);
 
 			break;
-
+			
 		case _HT_ADD_INFO_IE_:
 
 			update_bcn_htinfo_ie(padapter);
-
+			
 			break;
-
+	
 		case _VENDOR_SPECIFIC_IE_:
 
 			update_bcn_vendor_spec_ie(padapter, oui);
-
+			
 			break;
-
+			
 		default:
 			break;
 	}
 
 	pmlmepriv->update_bcn = _TRUE;
-
-	_exit_critical_bh(&pmlmepriv->bcn_update_lock, &irqL);
-
-#ifndef CONFIG_INTERRUPT_BASED_TXBCN
+	
+	_exit_critical_bh(&pmlmepriv->bcn_update_lock, &irqL);		
+	
+#ifndef CONFIG_INTERRUPT_BASED_TXBCN 
 #if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI) || defined(CONFIG_GSPI_HCI)
 	if(tx)
 	{
@@ -2136,12 +2133,12 @@ void update_beacon(_adapter *padapter, u8 ie_id, u8 *oui, u8 tx)
 		set_tx_beacon_cmd(padapter);
 	}
 #else
-	{
-		//PCI will issue beacon when BCN interrupt occurs.
+	{	
+		//PCI will issue beacon when BCN interrupt occurs.		
 	}
 #endif
 #endif //!CONFIG_INTERRUPT_BASED_TXBCN
-
+	
 }
 
 #ifdef CONFIG_80211N_HT
@@ -2165,9 +2162,9 @@ static int rtw_ht_operation_update(_adapter *padapter)
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	struct ht_priv	*phtpriv_ap = &pmlmepriv->htpriv;
 
-	if(pmlmepriv->htpriv.ht_option == _TRUE)
+	if(pmlmepriv->htpriv.ht_option == _TRUE) 
 		return 0;
-
+	
 	//if (!iface->conf->ieee80211n || iface->conf->ht_op_mode_fixed)
 	//	return 0;
 
@@ -2226,7 +2223,7 @@ static int rtw_ht_operation_update(_adapter *padapter)
 		   __FUNCTION__, pmlmepriv->ht_op_mode, op_mode_changes);
 
 	return op_mode_changes;
-
+	
 }
 
 #endif /* CONFIG_80211N_HT */
@@ -2238,27 +2235,27 @@ void associated_clients_update(_adapter *padapter, u8 updated)
 	{
 		_irqL irqL;
 		_list	*phead, *plist;
-		struct sta_info *psta=NULL;
+		struct sta_info *psta=NULL;	
 		struct sta_priv *pstapriv = &padapter->stapriv;
-
+			
 		_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
-
+		
 		phead = &pstapriv->asoc_list;
 		plist = get_next(phead);
-
+		
 		//check asoc_queue
-		while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
+		while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)	
 		{
 			psta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);
-
+		
 			plist = get_next(plist);
 
-			VCS_update(padapter, psta);
+			VCS_update(padapter, psta);		
 		}
 
 		_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 
-	}
+	}		
 
 }
 
@@ -2269,34 +2266,34 @@ void bss_cap_update_on_sta_join(_adapter *padapter, struct sta_info *psta)
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	struct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);
 
-
+	
 #if 0
 	if (!(psta->capability & WLAN_CAPABILITY_SHORT_PREAMBLE) &&
 	    !psta->no_short_preamble_set) {
 		psta->no_short_preamble_set = 1;
 		pmlmepriv->num_sta_no_short_preamble++;
-		if ((pmlmeext->cur_wireless_mode > WIRELESS_11B) &&
+		if ((pmlmeext->cur_wireless_mode > WIRELESS_11B) && 
 		     (pmlmepriv->num_sta_no_short_preamble == 1))
 			ieee802_11_set_beacons(hapd->iface);
 	}
 #endif
 
 
-	if(!(psta->flags & WLAN_STA_SHORT_PREAMBLE))
+	if(!(psta->flags & WLAN_STA_SHORT_PREAMBLE))	
 	{
 		if(!psta->no_short_preamble_set)
 		{
 			psta->no_short_preamble_set = 1;
-
+			
 			pmlmepriv->num_sta_no_short_preamble++;
-
-			if ((pmlmeext->cur_wireless_mode > WIRELESS_11B) &&
-				(pmlmepriv->num_sta_no_short_preamble == 1))
+			
+			if ((pmlmeext->cur_wireless_mode > WIRELESS_11B) && 
+		     		(pmlmepriv->num_sta_no_short_preamble == 1))
 			{
 				beacon_updated = _TRUE;
 				update_beacon(padapter, 0xFF, NULL, _TRUE);
-			}
-
+			}	
+			
 		}
 	}
 	else
@@ -2304,16 +2301,16 @@ void bss_cap_update_on_sta_join(_adapter *padapter, struct sta_info *psta)
 		if(psta->no_short_preamble_set)
 		{
 			psta->no_short_preamble_set = 0;
-
+			
 			pmlmepriv->num_sta_no_short_preamble--;
-
-			if ((pmlmeext->cur_wireless_mode > WIRELESS_11B) &&
-				(pmlmepriv->num_sta_no_short_preamble == 0))
+			
+			if ((pmlmeext->cur_wireless_mode > WIRELESS_11B) && 
+		     		(pmlmepriv->num_sta_no_short_preamble == 0))
 			{
 				beacon_updated = _TRUE;
 				update_beacon(padapter, 0xFF, NULL, _TRUE);
-			}
-
+			}	
+			
 		}
 	}
 
@@ -2331,32 +2328,32 @@ void bss_cap_update_on_sta_join(_adapter *padapter, struct sta_info *psta)
 		if(!psta->nonerp_set)
 		{
 			psta->nonerp_set = 1;
-
+			
 			pmlmepriv->num_sta_non_erp++;
-
+			
 			if (pmlmepriv->num_sta_non_erp == 1)
 			{
 				beacon_updated = _TRUE;
 				update_beacon(padapter, _ERPINFO_IE_, NULL, _TRUE);
-			}
+			}	
 		}
-
+		
 	}
 	else
 	{
 		if(psta->nonerp_set)
 		{
 			psta->nonerp_set = 0;
-
+			
 			pmlmepriv->num_sta_non_erp--;
-
+			
 			if (pmlmepriv->num_sta_non_erp == 0)
 			{
 				beacon_updated = _TRUE;
 				update_beacon(padapter, _ERPINFO_IE_, NULL, _TRUE);
-			}
+			}	
 		}
-
+		
 	}
 
 
@@ -2376,16 +2373,16 @@ void bss_cap_update_on_sta_join(_adapter *padapter, struct sta_info *psta)
 		if(!psta->no_short_slot_time_set)
 		{
 			psta->no_short_slot_time_set = 1;
-
+			
 			pmlmepriv->num_sta_no_short_slot_time++;
-
+			
 			if ((pmlmeext->cur_wireless_mode > WIRELESS_11B) &&
-				 (pmlmepriv->num_sta_no_short_slot_time == 1))
+		   		 (pmlmepriv->num_sta_no_short_slot_time == 1))
 			{
 				beacon_updated = _TRUE;
 				update_beacon(padapter, 0xFF, NULL, _TRUE);
-			}
-
+			}			
+			
 		}
 	}
 	else
@@ -2393,24 +2390,24 @@ void bss_cap_update_on_sta_join(_adapter *padapter, struct sta_info *psta)
 		if(psta->no_short_slot_time_set)
 		{
 			psta->no_short_slot_time_set = 0;
-
+			
 			pmlmepriv->num_sta_no_short_slot_time--;
-
+			
 			if ((pmlmeext->cur_wireless_mode > WIRELESS_11B) &&
-				 (pmlmepriv->num_sta_no_short_slot_time == 0))
+		   		 (pmlmepriv->num_sta_no_short_slot_time == 0))
 			{
 				beacon_updated = _TRUE;
 				update_beacon(padapter, 0xFF, NULL, _TRUE);
-			}
+			}			
 		}
 	}
-
+	
 #ifdef CONFIG_80211N_HT
 
-	if (psta->flags & WLAN_STA_HT)
+	if (psta->flags & WLAN_STA_HT) 
 	{
 		u16 ht_capab = le16_to_cpu(psta->htpriv.ht_cap.cap_info);
-
+			
 		DBG_871X("HT: STA " MAC_FMT " HT Capabilities "
 			   "Info: 0x%04x\n", MAC_ARG(psta->hwaddr), ht_capab);
 
@@ -2418,7 +2415,7 @@ void bss_cap_update_on_sta_join(_adapter *padapter, struct sta_info *psta)
 			psta->no_ht_set = 0;
 			pmlmepriv->num_sta_no_ht--;
 		}
-
+		
 		if ((ht_capab & IEEE80211_HT_CAP_GRN_FLD) == 0) {
 			if (!psta->no_ht_gf_set) {
 				psta->no_ht_gf_set = 1;
@@ -2429,7 +2426,7 @@ void bss_cap_update_on_sta_join(_adapter *padapter, struct sta_info *psta)
 				   __FUNCTION__, MAC_ARG(psta->hwaddr),
 				   pmlmepriv->num_sta_ht_no_gf);
 		}
-
+		
 		if ((ht_capab & IEEE80211_HT_CAP_SUP_WIDTH) == 0) {
 			if (!psta->ht_20mhz_set) {
 				psta->ht_20mhz_set = 1;
@@ -2440,15 +2437,15 @@ void bss_cap_update_on_sta_join(_adapter *padapter, struct sta_info *psta)
 				   __FUNCTION__, MAC_ARG(psta->hwaddr),
 				   pmlmepriv->num_sta_ht_20mhz);
 		}
-
-	}
-	else
+		
+	} 
+	else 
 	{
 		if (!psta->no_ht_set) {
 			psta->no_ht_set = 1;
 			pmlmepriv->num_sta_no_ht++;
 		}
-		if(pmlmepriv->htpriv.ht_option == _TRUE) {
+		if(pmlmepriv->htpriv.ht_option == _TRUE) {		
 			DBG_871X("%s STA " MAC_FMT
 				   " - no HT, num of non-HT stations %d\n",
 				   __FUNCTION__, MAC_ARG(psta->hwaddr),
@@ -2460,8 +2457,8 @@ void bss_cap_update_on_sta_join(_adapter *padapter, struct sta_info *psta)
 	{
 		update_beacon(padapter, _HT_CAPABILITY_IE_, NULL, _FALSE);
 		update_beacon(padapter, _HT_ADD_INFO_IE_, NULL, _TRUE);
-	}
-
+	}	
+	
 #endif /* CONFIG_80211N_HT */
 
 	//update associcated stations cap.
@@ -2488,17 +2485,17 @@ u8 bss_cap_update_on_sta_leave(_adapter *padapter, struct sta_info *psta)
 		{
 			beacon_updated = _TRUE;
 			update_beacon(padapter, 0xFF, NULL, _TRUE);
-		}
-	}
+		}	
+	}	
 
 	if (psta->nonerp_set) {
-		psta->nonerp_set = 0;
+		psta->nonerp_set = 0;		
 		pmlmepriv->num_sta_non_erp--;
 		if (pmlmepriv->num_sta_non_erp == 0)
 		{
 			beacon_updated = _TRUE;
 			update_beacon(padapter, _ERPINFO_IE_, NULL, _TRUE);
-		}
+		}	
 	}
 
 	if (psta->no_short_slot_time_set) {
@@ -2509,9 +2506,9 @@ u8 bss_cap_update_on_sta_leave(_adapter *padapter, struct sta_info *psta)
 		{
 			beacon_updated = _TRUE;
 			update_beacon(padapter, 0xFF, NULL, _TRUE);
-		}
+		}	
 	}
-
+	
 #ifdef CONFIG_80211N_HT
 
 	if (psta->no_ht_gf_set) {
@@ -2534,7 +2531,7 @@ u8 bss_cap_update_on_sta_leave(_adapter *padapter, struct sta_info *psta)
 		update_beacon(padapter, _HT_CAPABILITY_IE_, NULL, _FALSE);
 		update_beacon(padapter, _HT_ADD_INFO_IE_, NULL, _TRUE);
 	}
-
+	
 #endif /* CONFIG_80211N_HT */
 
 	//update associcated stations cap.
@@ -2562,10 +2559,10 @@ u8 ap_free_sta(_adapter *padapter, struct sta_info *psta, bool active, u16 reaso
 #ifdef CONFIG_80211N_HT
 		//tear down Rx AMPDU
 		send_delba(padapter, 0, psta->hwaddr);// recipient
-
+	
 		//tear down TX AMPDU
 		send_delba(padapter, 1, psta->hwaddr);// // originator
-
+		
 #endif //CONFIG_80211N_HT
 
 		issue_deauth(padapter, psta->hwaddr, reason);
@@ -2605,10 +2602,10 @@ u8 ap_free_sta(_adapter *padapter, struct sta_info *psta, bool active, u16 reaso
 
 	beacon_updated = bss_cap_update_on_sta_leave(padapter, psta);
 
-	_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+	_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);					
 	rtw_free_stainfo(padapter, psta);
 	_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
-
+	
 
 	return beacon_updated;
 
@@ -2618,8 +2615,8 @@ int rtw_ap_inform_ch_switch(_adapter *padapter, u8 new_ch, u8 ch_offset)
 {
 	_irqL irqL;
 	_list	*phead, *plist;
-	int ret=0;
-	struct sta_info *psta = NULL;
+	int ret=0;	
+	struct sta_info *psta = NULL;	
 	struct sta_priv *pstapriv = &padapter->stapriv;
 	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
@@ -2634,10 +2631,10 @@ int rtw_ap_inform_ch_switch(_adapter *padapter, u8 new_ch, u8 ch_offset)
 	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	phead = &pstapriv->asoc_list;
 	plist = get_next(phead);
-
+	
 	/* for each sta in asoc_queue */
-	while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
-	{
+	while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)	
+	{		
 		psta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);
 		plist = get_next(plist);
 
@@ -2655,8 +2652,8 @@ int rtw_sta_flush(_adapter *padapter)
 {
 	_irqL irqL;
 	_list	*phead, *plist;
-	int ret=0;
-	struct sta_info *psta = NULL;
+	int ret=0;	
+	struct sta_info *psta = NULL;	
 	struct sta_priv *pstapriv = &padapter->stapriv;
 	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
@@ -2676,7 +2673,7 @@ int rtw_sta_flush(_adapter *padapter)
 
 	while ((rtw_end_of_queue_search(phead, plist)) == _FALSE) {
 		int stainfo_offset;
-
+		
 		psta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);
 		plist = get_next(plist);
 
@@ -2709,40 +2706,40 @@ int rtw_sta_flush(_adapter *padapter)
 
 /* called > TSR LEVEL for USB or SDIO Interface*/
 void sta_info_update(_adapter *padapter, struct sta_info *psta)
-{
+{	
 	int flags = psta->flags;
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-
-
+	
+				
 	//update wmm cap.
 	if(WLAN_STA_WME&flags)
 		psta->qos_option = 1;
 	else
 		psta->qos_option = 0;
 
-	if(pmlmepriv->qospriv.qos_option == 0)
+	if(pmlmepriv->qospriv.qos_option == 0)	
 		psta->qos_option = 0;
 
-
-#ifdef CONFIG_80211N_HT
+		
+#ifdef CONFIG_80211N_HT		
 	//update 802.11n ht cap.
 	if(WLAN_STA_HT&flags)
 	{
 		psta->htpriv.ht_option = _TRUE;
-		psta->qos_option = 1;
+		psta->qos_option = 1;	
 	}
-	else
+	else		
 	{
 		psta->htpriv.ht_option = _FALSE;
 	}
-
-	if(pmlmepriv->htpriv.ht_option == _FALSE)
+		
+	if(pmlmepriv->htpriv.ht_option == _FALSE)	
 		psta->htpriv.ht_option = _FALSE;
-#endif
+#endif		
 
 
 	update_sta_info_apmode(padapter, psta);
-
+		
 
 }
 
@@ -2750,10 +2747,10 @@ void sta_info_update(_adapter *padapter, struct sta_info *psta)
 void ap_sta_info_defer_update(_adapter *padapter, struct sta_info *psta)
 {
 	if(psta->state & _FW_LINKED)
-	{
+	{	
 		//add ratid
 		add_RATid(padapter, psta);
-	}
+	}	
 }
 
 /* restore hw setting from sw data structures */
@@ -2791,7 +2788,7 @@ void rtw_ap_restore_network(_adapter *padapter)
 	}
 
 	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
-
+	
 	phead = &pstapriv->asoc_list;
 	plist = get_next(phead);
 
@@ -2830,9 +2827,9 @@ void start_ap_mode(_adapter *padapter)
 	struct sta_priv *pstapriv = &padapter->stapriv;
 	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
 	struct wlan_acl_pool *pacl_list = &pstapriv->acl_list;
-
+	
 	pmlmepriv->update_bcn = _FALSE;
-
+	
 	//init_mlme_ap_info(padapter);
 	pmlmeext->bstart_bss = _FALSE;
 
@@ -2845,13 +2842,13 @@ void start_ap_mode(_adapter *padapter)
 	pmlmepriv->num_sta_ht_no_gf = 0;
 
 	pmlmepriv->num_sta_no_ht = 0;
-
+	
 	pmlmepriv->num_sta_ht_20mhz = 0;
 
 	pmlmepriv->olbc = _FALSE;
 
 	pmlmepriv->olbc_ht = _FALSE;
-
+	
 #ifdef CONFIG_80211N_HT
 	pmlmepriv->ht_op_mode = 0;
 #endif
@@ -2859,20 +2856,20 @@ void start_ap_mode(_adapter *padapter)
 	for(i=0; i<NUM_STA; i++)
 		pstapriv->sta_aid[i] = NULL;
 
-	pmlmepriv->wps_beacon_ie = NULL;
+	pmlmepriv->wps_beacon_ie = NULL;	
 	pmlmepriv->wps_probe_resp_ie = NULL;
 	pmlmepriv->wps_assoc_resp_ie = NULL;
-
+	
 	pmlmepriv->p2p_beacon_ie = NULL;
 	pmlmepriv->p2p_probe_resp_ie = NULL;
 
-
-	//for ACL
+	
+	//for ACL 
 	_rtw_init_listhead(&(pacl_list->acl_node_q.queue));
 	pacl_list->num = 0;
 	pacl_list->mode = 0;
 	for(i = 0; i < NUM_ACL; i++)
-	{
+	{		
 		_rtw_init_listhead(&pacl_list->aclnode[i].list);
 		pacl_list->aclnode[i].valid = _FALSE;
 	}
@@ -2887,14 +2884,14 @@ void stop_ap_mode(_adapter *padapter)
 	struct sta_info *psta=NULL;
 	struct sta_priv *pstapriv = &padapter->stapriv;
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;	
 	struct wlan_acl_pool *pacl_list = &pstapriv->acl_list;
-	_queue	*pacl_node_q =&pacl_list->acl_node_q;
+	_queue	*pacl_node_q =&pacl_list->acl_node_q;	
 
 	pmlmepriv->update_bcn = _FALSE;
 	pmlmeext->bstart_bss = _FALSE;
 	//_rtw_spinlock_free(&pmlmepriv->bcn_update_lock);
-
+	
 	//reset and init security priv , this can refine with rtw_reset_securitypriv
 	_rtw_memset((unsigned char *)&padapter->securitypriv, 0, sizeof (struct security_priv));
 	padapter->securitypriv.ndisauthtype = Ndis802_11AuthModeOpen;
@@ -2903,7 +2900,7 @@ void stop_ap_mode(_adapter *padapter)
 	//for ACL
 	_enter_critical_bh(&(pacl_node_q->lock), &irqL);
 	phead = get_list_head(pacl_node_q);
-	plist = get_next(phead);
+	plist = get_next(phead);		
 	while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
 	{
 		paclnode = LIST_CONTAINOR(plist, struct rtw_wlan_acl_node, list);
@@ -2914,25 +2911,25 @@ void stop_ap_mode(_adapter *padapter)
 			paclnode->valid = _FALSE;
 
 			rtw_list_delete(&paclnode->list);
-
-			pacl_list->num--;
-		}
-	}
+				
+			pacl_list->num--;		
+		}		
+	}	
 	_exit_critical_bh(&(pacl_node_q->lock), &irqL);
-
+	
 	DBG_871X("%s, free acl_node_queue, num=%d\n", __func__, pacl_list->num);
-
+	
 	rtw_sta_flush(padapter);
 
-	//free_assoc_sta_resources
+	//free_assoc_sta_resources	
 	rtw_free_all_stainfo(padapter);
-
+	
 	psta = rtw_get_bcmc_stainfo(padapter);
-	_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+	_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);		
 	rtw_free_stainfo(padapter, psta);
 	_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
-
-	rtw_init_bcmc_stainfo(padapter);
+	
+	rtw_init_bcmc_stainfo(padapter);	
 
 	rtw_free_mlme_priv_ie_data(pmlmepriv);
 
@@ -2940,3 +2937,4 @@ void stop_ap_mode(_adapter *padapter)
 
 #endif //CONFIG_NATIVEAP_MLME
 #endif //CONFIG_AP_MODE
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_br_ext.c b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_br_ext.c
old mode 100644
new mode 100755
index 39289c9..2f84a38
--- a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_br_ext.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_br_ext.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -232,10 +232,10 @@ static unsigned char *scan_tlv(unsigned char *data, int len, unsigned char tag,
 {
 	while (len > 0) {
 		if (*data == tag && *(data+1) == len8b && len >= len8b*8)
-			return data+2;
-
-		len -= (*(data+1))*8;
-		data += (*(data+1))*8;
+			return data+2;	
+		
+		len -= (*(data+1))*8;		
+		data += (*(data+1))*8;		
 	}
 	return NULL;
 }
@@ -245,16 +245,16 @@ static int update_nd_link_layer_addr(unsigned char *data, int len, unsigned char
 {
 	struct icmp6hdr *icmphdr = (struct icmp6hdr *)data;
 	unsigned char *mac;
-
-	if (icmphdr->icmp6_type == NDISC_ROUTER_SOLICITATION) {
+	
+	if (icmphdr->icmp6_type == NDISC_ROUTER_SOLICITATION) { 
 		if (len >= 8) {
 			mac = scan_tlv(&data[8], len-8, 1, 1);
 			if (mac) {
 				_DEBUG_INFO("Router Solicitation, replace MAC From: %02x:%02x:%02x:%02x:%02x:%02x, To: %02x:%02x:%02x:%02x:%02x:%02x\n",
-					mac[0],mac[1],mac[2],mac[3],mac[4],mac[5],
+					mac[0],mac[1],mac[2],mac[3],mac[4],mac[5],					
 					replace_mac[0],replace_mac[1],replace_mac[2],replace_mac[3],replace_mac[4],replace_mac[5]);
-				memcpy(mac, replace_mac, 6);
-				return 1;
+				memcpy(mac, replace_mac, 6);	
+				return 1;				
 			}
 		}
 	}
@@ -263,55 +263,55 @@ static int update_nd_link_layer_addr(unsigned char *data, int len, unsigned char
 			mac = scan_tlv(&data[16], len-16, 1, 1);
 			if (mac) {
 				_DEBUG_INFO("Router Advertisement, replace MAC From: %02x:%02x:%02x:%02x:%02x:%02x, To: %02x:%02x:%02x:%02x:%02x:%02x\n",
-					mac[0],mac[1],mac[2],mac[3],mac[4],mac[5],
+					mac[0],mac[1],mac[2],mac[3],mac[4],mac[5],					
 					replace_mac[0],replace_mac[1],replace_mac[2],replace_mac[3],replace_mac[4],replace_mac[5]);
-				memcpy(mac, replace_mac, 6);
-				return 1;
+				memcpy(mac, replace_mac, 6);			
+				return 1;				
 			}
-		}
+		}		
 	}
 	else if (icmphdr->icmp6_type == NDISC_NEIGHBOUR_SOLICITATION) {
 		if (len >= 24) {
 			mac = scan_tlv(&data[24], len-24, 1, 1);
-			if (mac) {
+			if (mac) {		
 				_DEBUG_INFO("Neighbor Solicitation, replace MAC From: %02x:%02x:%02x:%02x:%02x:%02x, To: %02x:%02x:%02x:%02x:%02x:%02x\n",
-					mac[0],mac[1],mac[2],mac[3],mac[4],mac[5],
+					mac[0],mac[1],mac[2],mac[3],mac[4],mac[5],					
 					replace_mac[0],replace_mac[1],replace_mac[2],replace_mac[3],replace_mac[4],replace_mac[5]);
-				memcpy(mac, replace_mac, 6);
-				return 1;
+				memcpy(mac, replace_mac, 6);	
+				return 1;								
 			}
-		}
+		}		
 	}
 	else if (icmphdr->icmp6_type == NDISC_NEIGHBOUR_ADVERTISEMENT) {
 		if (len >= 24) {
 			mac = scan_tlv(&data[24], len-24, 2, 1);
 			if (mac) {
 				_DEBUG_INFO("Neighbor Advertisement, replace MAC From: %02x:%02x:%02x:%02x:%02x:%02x, To: %02x:%02x:%02x:%02x:%02x:%02x\n",
-					mac[0],mac[1],mac[2],mac[3],mac[4],mac[5],
+					mac[0],mac[1],mac[2],mac[3],mac[4],mac[5],					
 					replace_mac[0],replace_mac[1],replace_mac[2],replace_mac[3],replace_mac[4],replace_mac[5]);
-				memcpy(mac, replace_mac, 6);
-				return 1;
+				memcpy(mac, replace_mac, 6);		
+				return 1;				
 			}
-		}
+		}		
 	}
 	else if (icmphdr->icmp6_type == NDISC_REDIRECT) {
 		if (len >= 40) {
 			mac = scan_tlv(&data[40], len-40, 2, 1);
-			if (mac) {
+			if (mac) {				
 				_DEBUG_INFO("Redirect,  replace MAC From: %02x:%02x:%02x:%02x:%02x:%02x, To: %02x:%02x:%02x:%02x:%02x:%02x\n",
-					mac[0],mac[1],mac[2],mac[3],mac[4],mac[5],
+					mac[0],mac[1],mac[2],mac[3],mac[4],mac[5],					
 					replace_mac[0],replace_mac[1],replace_mac[2],replace_mac[3],replace_mac[4],replace_mac[5]);
-				memcpy(mac, replace_mac, 6);
-				return 1;
+				memcpy(mac, replace_mac, 6);	
+				return 1;				
 			}
-		}
-	}
+		}		
+	}	
 	return 0;
 }
 
 
 static void convert_ipv6_mac_to_mc(struct sk_buff *skb)
-{
+{	
 	struct ipv6hdr *iph = (struct ipv6hdr *)(skb->data + ETH_HLEN);
 	unsigned char *dst_mac = skb->data;
 
@@ -321,7 +321,7 @@ static void convert_ipv6_mac_to_mc(struct sk_buff *skb)
 	dst_mac[0] = 0x33;
 	dst_mac[1] = 0x33;
 	memcpy(&dst_mac[2], &iph->daddr.s6_addr32[3], 4);
-	#if defined(__LINUX_2_6__)
+	#if defined(__LINUX_2_6__) 
 	/*modified by qinjunjie,warning:should not remove next line*/
 	skb->pkt_type = PACKET_MULTICAST;
 	#endif
@@ -373,10 +373,10 @@ static __inline__ int __nat25_network_hash(unsigned char *networkAddr)
 			networkAddr[6] ^ networkAddr[7] ^ networkAddr[8] ^ networkAddr[9] ^ networkAddr[10] ^
 			networkAddr[11] ^ networkAddr[12] ^ networkAddr[13] ^ networkAddr[14] ^ networkAddr[15] ^
 			networkAddr[16];
-
+	
 		return x & (NAT25_HASH_SIZE - 1);
 	}
-#endif
+#endif	
 	else
 	{
 		unsigned long x = 0;
@@ -442,8 +442,8 @@ static int __nat25_db_network_lookup_and_replace(_adapter *priv,
 				atomic_inc(&db->use_count);
 
 #ifdef CL_IPV6_PASS
-				DEBUG_INFO("NAT25: Lookup M:%02x%02x%02x%02x%02x%02x N:%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"
-							"%02x%02x%02x%02x%02x%02x\n",
+				DEBUG_INFO("NAT25: Lookup M:%02x%02x%02x%02x%02x%02x N:%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"	
+							"%02x%02x%02x%02x%02x%02x\n",				
 					db->macAddr[0],
 					db->macAddr[1],
 					db->macAddr[2],
@@ -467,7 +467,7 @@ static int __nat25_db_network_lookup_and_replace(_adapter *priv,
 					db->networkAddr[14],
 					db->networkAddr[15],
 					db->networkAddr[16]);
-#else
+#else				
 				DEBUG_INFO("NAT25: Lookup M:%02x%02x%02x%02x%02x%02x N:%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\n",
 					db->macAddr[0],
 					db->macAddr[1],
@@ -634,7 +634,7 @@ void nat25_db_cleanup(_adapter *priv)
 	int i;
 	_irqL irqL;
 	_enter_critical_bh(&priv->br_ext_lock, &irqL);
-
+	
 	for(i=0; i<NAT25_HASH_SIZE; i++)
 	{
 		struct nat25_network_db_entry *f;
@@ -665,7 +665,7 @@ void nat25_db_expire(_adapter *priv)
 	int i;
 	_irqL irqL;
 	_enter_critical_bh(&priv->br_ext_lock, &irqL);
-
+	
 	//if(!priv->ethBrExtInfo.nat25_disable)
 	{
 		for (i=0; i<NAT25_HASH_SIZE; i++)
@@ -1424,13 +1424,13 @@ int nat25_db_handle(_adapter *priv, struct sk_buff *skb, int method)
 		{
 			case NAT25_CHECK:
 				if (skb->data[0] & 1)
-					return 0;
+					return 0;				
 				return -1;
 
 			case NAT25_INSERT:
 				{
 					DEBUG_INFO("NAT25: Insert IP, SA=%4x:%4x:%4x:%4x:%4x:%4x:%4x:%4x,"
-									" DA=%4x:%4x:%4x:%4x:%4x:%4x:%4x:%4x\n",
+									" DA=%4x:%4x:%4x:%4x:%4x:%4x:%4x:%4x\n", 
 						iph->saddr.s6_addr16[0],iph->saddr.s6_addr16[1],iph->saddr.s6_addr16[2],iph->saddr.s6_addr16[3],
 						iph->saddr.s6_addr16[4],iph->saddr.s6_addr16[5],iph->saddr.s6_addr16[6],iph->saddr.s6_addr16[7],
 						iph->daddr.s6_addr16[0],iph->daddr.s6_addr16[1],iph->daddr.s6_addr16[2],iph->daddr.s6_addr16[3],
@@ -1441,10 +1441,10 @@ int nat25_db_handle(_adapter *priv, struct sk_buff *skb, int method)
 						__nat25_db_network_insert(priv, skb->data+ETH_ALEN, networkAddr);
 						__nat25_db_print(priv);
 
-						if (iph->nexthdr == IPPROTO_ICMPV6 &&
+						if (iph->nexthdr == IPPROTO_ICMPV6 && 
 								skb->len > (ETH_HLEN +  sizeof(*iph) + 4)) {
-							if (update_nd_link_layer_addr(skb->data + ETH_HLEN + sizeof(*iph),
-                                                                skb->len - ETH_HLEN - sizeof(*iph), GET_MY_HWADDR(priv))) {
+							if (update_nd_link_layer_addr(skb->data + ETH_HLEN + sizeof(*iph), 
+                                                                skb->len - ETH_HLEN - sizeof(*iph), GET_MY_HWADDR(priv))) {                                                   
 								struct icmp6hdr  *hdr = (struct icmp6hdr *)(skb->data + ETH_HLEN + sizeof(*iph));
 								hdr->icmp6_cksum = 0;
 								hdr->icmp6_cksum = csum_ipv6_magic(&iph->saddr, &iph->daddr,
@@ -1452,26 +1452,26 @@ int nat25_db_handle(_adapter *priv, struct sk_buff *skb, int method)
 												IPPROTO_ICMPV6,
 												csum_partial((__u8 *)hdr, iph->payload_len, 0));
 							}
-						}
+						}						
 					}
 				}
 				return 0;
 
 			case NAT25_LOOKUP:
 				DEBUG_INFO("NAT25: Lookup IP, SA=%4x:%4x:%4x:%4x:%4x:%4x:%4x:%4x,"
-								" DA=%4x:%4x:%4x:%4x:%4x:%4x:%4x:%4x\n",
+								" DA=%4x:%4x:%4x:%4x:%4x:%4x:%4x:%4x\n", 
 						iph->saddr.s6_addr16[0],iph->saddr.s6_addr16[1],iph->saddr.s6_addr16[2],iph->saddr.s6_addr16[3],
 						iph->saddr.s6_addr16[4],iph->saddr.s6_addr16[5],iph->saddr.s6_addr16[6],iph->saddr.s6_addr16[7],
 						iph->daddr.s6_addr16[0],iph->daddr.s6_addr16[1],iph->daddr.s6_addr16[2],iph->daddr.s6_addr16[3],
 						iph->daddr.s6_addr16[4],iph->daddr.s6_addr16[5],iph->daddr.s6_addr16[6],iph->daddr.s6_addr16[7]);
-
+			
 
 				__nat25_generate_ipv6_network_addr(networkAddr, (unsigned int *)&iph->daddr);
 				if (!__nat25_db_network_lookup_and_replace(priv, skb, networkAddr)) {
-#ifdef SUPPORT_RX_UNI2MCAST
+#ifdef SUPPORT_RX_UNI2MCAST							
 					if (iph->daddr.s6_addr[0] == 0xff)
-						convert_ipv6_mac_to_mc(skb);
-#endif
+						convert_ipv6_mac_to_mc(skb);	
+#endif											
 				}
 				return 0;
 
@@ -1532,12 +1532,12 @@ int nat25_handle_frame(_adapter *priv, struct sk_buff *skb)
 				(*((unsigned short *)(skb->data+ETH_ALEN*2)) == __constant_htons(ETH_P_IP)) &&
 				!memcmp(priv->scdb_ip, skb->data+ETH_HLEN+16, 4)) {
 				memcpy(skb->data, priv->scdb_mac, ETH_ALEN);
-
+				
 				_exit_critical_bh(&priv->br_ext_lock, &irqL);
 			}
 			else {
 				_exit_critical_bh(&priv->br_ext_lock, &irqL);
-
+				
 				retval = nat25_db_handle(priv, skb, NAT25_LOOKUP);
 			}
 		}
diff --git a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_cmd.c b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_cmd.c
old mode 100644
new mode 100755
index 2455304..f906eb3
--- a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_cmd.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_cmd.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -37,47 +37,47 @@
 sint	_rtw_init_cmd_priv (struct	cmd_priv *pcmdpriv)
 {
 	sint res=_SUCCESS;
-
-_func_enter_;
+	
+_func_enter_;	
 
 	_rtw_init_sema(&(pcmdpriv->cmd_queue_sema), 0);
 	//_rtw_init_sema(&(pcmdpriv->cmd_done_sema), 0);
 	_rtw_init_sema(&(pcmdpriv->terminate_cmdthread_sema), 0);
-
-
+	
+	
 	_rtw_init_queue(&(pcmdpriv->cmd_queue));
-
+	
 	//allocate DMA-able/Non-Page memory for cmd_buf and rsp_buf
-
+	
 	pcmdpriv->cmd_seq = 1;
-
+	
 	pcmdpriv->cmd_allocated_buf = rtw_zmalloc(MAX_CMDSZ + CMDBUFF_ALIGN_SZ);
-
+	
 	if (pcmdpriv->cmd_allocated_buf == NULL){
 		res= _FAIL;
 		goto exit;
 	}
-
+	
 	pcmdpriv->cmd_buf = pcmdpriv->cmd_allocated_buf  +  CMDBUFF_ALIGN_SZ - ( (SIZE_PTR)(pcmdpriv->cmd_allocated_buf) & (CMDBUFF_ALIGN_SZ-1));
-
+		
 	pcmdpriv->rsp_allocated_buf = rtw_zmalloc(MAX_RSPSZ + 4);
-
+	
 	if (pcmdpriv->rsp_allocated_buf == NULL){
 		res= _FAIL;
 		goto exit;
 	}
-
+	
 	pcmdpriv->rsp_buf = pcmdpriv->rsp_allocated_buf  +  4 - ( (SIZE_PTR)(pcmdpriv->rsp_allocated_buf) & 3);
 
 	pcmdpriv->cmd_issued_cnt = pcmdpriv->cmd_done_cnt = pcmdpriv->rsp_cnt = 0;
 
 exit:
-
-_func_exit_;
+	
+_func_exit_;	  
 
 	return res;
-
-}
+	
+}	
 
 #ifdef CONFIG_C2H_WK
 static void c2h_wk_callback(_workitem *work);
@@ -86,15 +86,15 @@ sint _rtw_init_evt_priv(struct evt_priv *pevtpriv)
 {
 	sint res=_SUCCESS;
 
-_func_enter_;
+_func_enter_;	
 
 #ifdef CONFIG_H2CLBK
 	_rtw_init_sema(&(pevtpriv->lbkevt_done), 0);
 	pevtpriv->lbkevt_limit = 0;
 	pevtpriv->lbkevt_num = 0;
-	pevtpriv->cmdevt_parm = NULL;
-#endif
-
+	pevtpriv->cmdevt_parm = NULL;		
+#endif		
+	
 	//allocate DMA-able/Non-Page memory for cmd_buf and rsp_buf
 	ATOMIC_SET(&pevtpriv->event_seq, 0);
 	pevtpriv->evt_done_cnt = 0;
@@ -104,17 +104,17 @@ sint _rtw_init_evt_priv(struct evt_priv *pevtpriv)
 	_rtw_init_sema(&(pevtpriv->evt_notify), 0);
 	_rtw_init_sema(&(pevtpriv->terminate_evtthread_sema), 0);
 
-	pevtpriv->evt_allocated_buf = rtw_zmalloc(MAX_EVTSZ + 4);
+	pevtpriv->evt_allocated_buf = rtw_zmalloc(MAX_EVTSZ + 4);	
 	if (pevtpriv->evt_allocated_buf == NULL){
 		res= _FAIL;
 		goto exit;
 		}
 	pevtpriv->evt_buf = pevtpriv->evt_allocated_buf  +  4 - ((unsigned int)(pevtpriv->evt_allocated_buf) & 3);
-
-
+	
+		
 #ifdef CONFIG_SDIO_HCI
-	pevtpriv->allocated_c2h_mem = rtw_zmalloc(C2H_MEM_SZ +4);
-
+	pevtpriv->allocated_c2h_mem = rtw_zmalloc(C2H_MEM_SZ +4); 
+	
 	if (pevtpriv->allocated_c2h_mem == NULL){
 		res= _FAIL;
 		goto exit;
@@ -124,7 +124,7 @@ sint _rtw_init_evt_priv(struct evt_priv *pevtpriv)
 	- ( (u32)(pevtpriv->allocated_c2h_mem) & 3);
 #ifdef PLATFORM_OS_XP
 	pevtpriv->pc2h_mdl= IoAllocateMdl((u8 *)pevtpriv->c2h_mem, C2H_MEM_SZ , FALSE, FALSE, NULL);
-
+	
 	if(pevtpriv->pc2h_mdl == NULL){
 		res= _FAIL;
 		goto exit;
@@ -135,7 +135,7 @@ sint _rtw_init_evt_priv(struct evt_priv *pevtpriv)
 
 	_rtw_init_queue(&(pevtpriv->evt_queue));
 
-exit:
+exit:	
 
 #endif //end of CONFIG_EVENT_THREAD_MODE
 
@@ -145,7 +145,7 @@ sint _rtw_init_evt_priv(struct evt_priv *pevtpriv)
 	pevtpriv->c2h_queue = rtw_cbuf_alloc(C2H_QUEUE_MAX_LEN+1);
 #endif
 
-_func_exit_;
+_func_exit_;		 
 
 	return res;
 }
@@ -182,7 +182,7 @@ void _rtw_free_evt_priv (struct	evt_priv *pevtpriv)
 
 	RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("-_rtw_free_evt_priv \n"));
 
-_func_exit_;
+_func_exit_;	  	
 
 }
 
@@ -198,17 +198,17 @@ void _rtw_free_cmd_priv (struct	cmd_priv *pcmdpriv)
 
 		if (pcmdpriv->cmd_allocated_buf)
 			rtw_mfree(pcmdpriv->cmd_allocated_buf, MAX_CMDSZ + CMDBUFF_ALIGN_SZ);
-
+		
 		if (pcmdpriv->rsp_allocated_buf)
 			rtw_mfree(pcmdpriv->rsp_allocated_buf, MAX_RSPSZ + 4);
 	}
-_func_exit_;
+_func_exit_;		
 }
 
 /*
 Calling Context:
 
-rtw_enqueue_cmd can only be called between kernel thread,
+rtw_enqueue_cmd can only be called between kernel thread, 
 since only spin_lock is used.
 
 ISR/Call-Back functions can't call this sub-function.
@@ -225,14 +225,14 @@ sint	_rtw_enqueue_cmd(_queue *queue, struct cmd_obj *obj)
 		goto exit;
 
 	//_enter_critical_bh(&queue->lock, &irqL);
-	_enter_critical(&queue->lock, &irqL);
+	_enter_critical(&queue->lock, &irqL);	
 
 	rtw_list_insert_tail(&obj->list, &queue->queue);
 
-	//_exit_critical_bh(&queue->lock, &irqL);
+	//_exit_critical_bh(&queue->lock, &irqL);	
 	_exit_critical(&queue->lock, &irqL);
 
-exit:
+exit:	
 
 _func_exit_;
 
@@ -259,7 +259,7 @@ struct	cmd_obj	*_rtw_dequeue_cmd(_queue *queue)
 	//_exit_critical_bh(&(queue->lock), &irqL);
 	_exit_critical(&queue->lock, &irqL);
 
-_func_exit_;
+_func_exit_;	
 
 	return obj;
 }
@@ -267,18 +267,18 @@ struct	cmd_obj	*_rtw_dequeue_cmd(_queue *queue)
 u32	rtw_init_cmd_priv(struct cmd_priv *pcmdpriv)
 {
 	u32	res;
-_func_enter_;
+_func_enter_;	
 	res = _rtw_init_cmd_priv (pcmdpriv);
-_func_exit_;
-	return res;
+_func_exit_;	
+	return res;	
 }
 
 u32	rtw_init_evt_priv (struct	evt_priv *pevtpriv)
 {
 	int	res;
-_func_enter_;
+_func_enter_;		
 	res = _rtw_init_evt_priv(pevtpriv);
-_func_exit_;
+_func_exit_;		
 	return res;
 }
 
@@ -287,35 +287,35 @@ void rtw_free_evt_priv (struct	evt_priv *pevtpriv)
 _func_enter_;
 	RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("rtw_free_evt_priv\n"));
 	_rtw_free_evt_priv(pevtpriv);
-_func_exit_;
-}
+_func_exit_;		
+}	
 
 void rtw_free_cmd_priv (struct	cmd_priv *pcmdpriv)
 {
 _func_enter_;
 	RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("rtw_free_cmd_priv\n"));
 	_rtw_free_cmd_priv(pcmdpriv);
-_func_exit_;
-}
+_func_exit_;	
+}	
 
 int rtw_cmd_filter(struct cmd_priv *pcmdpriv, struct cmd_obj *cmd_obj);
 int rtw_cmd_filter(struct cmd_priv *pcmdpriv, struct cmd_obj *cmd_obj)
 {
 	u8 bAllow = _FALSE; //set to _TRUE to allow enqueuing cmd when hw_init_completed is _FALSE
-
+	
 	#ifdef SUPPORT_HW_RFOFF_DETECTED
 	//To decide allow or not
 	if(	(pcmdpriv->padapter->pwrctrlpriv.bHWPwrPindetect)
 		&&(!pcmdpriv->padapter->registrypriv.usbss_enable)
-	)
+	)		
 	{
-		if(cmd_obj->cmdcode == GEN_CMD_CODE(_Set_Drv_Extra) )
+		if(cmd_obj->cmdcode == GEN_CMD_CODE(_Set_Drv_Extra) ) 
 		{
-			struct drvextra_cmd_parm	*pdrvextra_cmd_parm = (struct drvextra_cmd_parm	*)cmd_obj->parmbuf;
+			struct drvextra_cmd_parm	*pdrvextra_cmd_parm = (struct drvextra_cmd_parm	*)cmd_obj->parmbuf;	
 			if(pdrvextra_cmd_parm->ec_id == POWER_SAVING_CTRL_WK_CID)
-			{
+			{	
 				//DBG_871X("==>enqueue POWER_SAVING_CTRL_WK_CID\n");
-				bAllow = _TRUE;
+				bAllow = _TRUE;	
 			}
 		}
 	}
@@ -335,7 +335,7 @@ int rtw_cmd_filter(struct cmd_priv *pcmdpriv, struct cmd_obj *cmd_obj)
 		//);
 
 		return _FAIL;
-	}
+	}	
 	return _SUCCESS;
 }
 
@@ -345,9 +345,9 @@ u32 rtw_enqueue_cmd(struct cmd_priv *pcmdpriv, struct cmd_obj *cmd_obj)
 {
 	int res = _FAIL;
 	PADAPTER padapter = pcmdpriv->padapter;
-
-_func_enter_;
-
+	
+_func_enter_;	
+	
 	if (cmd_obj == NULL) {
 		goto exit;
 	}
@@ -358,7 +358,7 @@ u32 rtw_enqueue_cmd(struct cmd_priv *pcmdpriv, struct cmd_obj *cmd_obj)
 	//change pcmdpriv to primary's pcmdpriv
 	if (padapter->adapter_type != PRIMARY_ADAPTER && padapter->pbuddy_adapter)
 		pcmdpriv = &(padapter->pbuddy_adapter->cmdpriv);
-#endif
+#endif	
 
 	if( _FAIL == (res=rtw_cmd_filter(pcmdpriv, cmd_obj)) ) {
 		rtw_free_cmd_obj(cmd_obj);
@@ -369,9 +369,9 @@ u32 rtw_enqueue_cmd(struct cmd_priv *pcmdpriv, struct cmd_obj *cmd_obj)
 
 	if(res == _SUCCESS)
 		_rtw_up_sema(&pcmdpriv->cmd_queue_sema);
-
-exit:
-
+	
+exit:	
+	
 _func_exit_;
 
 	return res;
@@ -380,12 +380,12 @@ u32 rtw_enqueue_cmd(struct cmd_priv *pcmdpriv, struct cmd_obj *cmd_obj)
 struct	cmd_obj	*rtw_dequeue_cmd(struct cmd_priv *pcmdpriv)
 {
 	struct cmd_obj *cmd_obj;
-
-_func_enter_;
+	
+_func_enter_;		
 
 	cmd_obj = _rtw_dequeue_cmd(&pcmdpriv->cmd_queue);
-
-_func_exit_;
+		
+_func_exit_;			
 	return cmd_obj;
 }
 
@@ -394,7 +394,7 @@ void rtw_cmd_clr_isr(struct	cmd_priv *pcmdpriv)
 _func_enter_;
 	pcmdpriv->cmd_done_cnt++;
 	//_rtw_up_sema(&(pcmdpriv->cmd_done_sema));
-_func_exit_;
+_func_exit_;		
 }
 
 void rtw_free_cmd_obj(struct cmd_obj *pcmd)
@@ -405,21 +405,21 @@ void rtw_free_cmd_obj(struct cmd_obj *pcmd)
 	{
 		//free parmbuf in cmd_obj
 		rtw_mfree((unsigned char*)pcmd->parmbuf, pcmd->cmdsz);
-	}
-
+	}	
+	
 	if(pcmd->rsp!=NULL)
 	{
 		if(pcmd->rspsz!= 0)
 		{
 			//free rsp in cmd_obj
 			rtw_mfree((unsigned char*)pcmd->rsp, pcmd->rspsz);
-		}
-	}
+		}	
+	}	
 
 	//free cmd_obj
 	rtw_mfree((unsigned char*)pcmd, sizeof(struct cmd_obj));
-
-_func_exit_;
+	
+_func_exit_;		
 }
 
 void rtw_stop_cmd_thread(_adapter *adapter)
@@ -442,7 +442,7 @@ thread_return rtw_cmd_thread(thread_context context)
 	void (*pcmd_callback)(_adapter *dev, struct cmd_obj *pcmd);
        _adapter *padapter = (_adapter *)context;
 	struct cmd_priv *pcmdpriv = &(padapter->cmdpriv);
-
+	
 _func_enter_;
 
 	thread_enter("RTW_CMD_THREAD");
@@ -453,7 +453,7 @@ thread_return rtw_cmd_thread(thread_context context)
 	pcmdpriv->stop_req = 0;
 	pcmdpriv->cmdthd_running=_TRUE;
 	_rtw_up_sema(&pcmdpriv->terminate_cmdthread_sema);
-
+	
 	RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("start r871x rtw_cmd_thread !!!!\n"));
 
 	while(1)
@@ -493,7 +493,7 @@ thread_return rtw_cmd_thread(thread_context context)
 		if( _FAIL == rtw_cmd_filter(pcmdpriv, pcmd) )
 		{
 			pcmd->res = H2C_DROPPED;
-			goto post_process;
+			goto post_process;					
 		}
 
 		if( _FAIL == rtw_cmd_filter(pcmdpriv, pcmd) ) {
@@ -560,7 +560,7 @@ thread_return rtw_cmd_thread(thread_context context)
 
 		//DBG_871X("%s: leaving... drop cmdcode:%u\n", __FUNCTION__, pcmd->cmdcode);
 
-		rtw_free_cmd_obj(pcmd);
+		rtw_free_cmd_obj(pcmd);	
 	}while(1);
 
 	_rtw_up_sema(&pcmdpriv->terminate_cmdthread_sema);
@@ -578,37 +578,37 @@ u32 rtw_enqueue_evt(struct evt_priv *pevtpriv, struct evt_obj *obj)
 	_irqL irqL;
 	int	res;
 	_queue *queue = &pevtpriv->evt_queue;
+	
+_func_enter_;	
 
-_func_enter_;
-
-	res = _SUCCESS;
+	res = _SUCCESS; 		
 
 	if (obj == NULL) {
 		res = _FAIL;
 		goto exit;
-	}
+	}	
 
 	_enter_critical_bh(&queue->lock, &irqL);
 
 	rtw_list_insert_tail(&obj->list, &queue->queue);
-
+	
 	_exit_critical_bh(&queue->lock, &irqL);
 
 	//rtw_evt_notify_isr(pevtpriv);
 
 exit:
+	
+_func_exit_;		
 
-_func_exit_;
-
-	return res;
+	return res;	
 }
 
 struct evt_obj *rtw_dequeue_evt(_queue *queue)
 {
 	_irqL irqL;
 	struct	evt_obj	*pevtobj;
-
-_func_enter_;
+	
+_func_enter_;		
 
 	_enter_critical_bh(&queue->lock, &irqL);
 
@@ -621,10 +621,10 @@ struct evt_obj *rtw_dequeue_evt(_queue *queue)
 	}
 
 	_exit_critical_bh(&queue->lock, &irqL);
+	
+_func_exit_;			
 
-_func_exit_;
-
-	return pevtobj;
+	return pevtobj;	
 }
 
 void rtw_free_evt_obj(struct evt_obj *pevtobj)
@@ -633,10 +633,10 @@ void rtw_free_evt_obj(struct evt_obj *pevtobj)
 
 	if(pevtobj->parmbuf)
 		rtw_mfree((unsigned char*)pevtobj->parmbuf, pevtobj->evtsz);
-
+	
 	rtw_mfree((unsigned char*)pevtobj, sizeof(struct evt_obj));
-
-_func_exit_;
+	
+_func_exit_;		
 }
 
 void rtw_evt_notify_isr(struct evt_priv *pevtpriv)
@@ -644,13 +644,13 @@ void rtw_evt_notify_isr(struct evt_priv *pevtpriv)
 _func_enter_;
 	pevtpriv->evt_done_cnt++;
 	_rtw_up_sema(&(pevtpriv->evt_notify));
-_func_exit_;
+_func_exit_;	
 }
 #endif
 
 
 /*
-u8 rtw_setstandby_cmd(unsigned char  *adapter)
+u8 rtw_setstandby_cmd(unsigned char  *adapter) 
 */
 u8 rtw_setstandby_cmd(_adapter *padapter, uint action)
 {
@@ -659,16 +659,16 @@ u8 rtw_setstandby_cmd(_adapter *padapter, uint action)
 	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;
 
 	u8 ret = _SUCCESS;
-
-_func_enter_;
+	
+_func_enter_;	
 
 	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
 	if (ph2c == NULL) {
 		ret = _FAIL;
 		goto exit;
 	}
-
-	psetusbsuspend = (struct usb_suspend_parm*)rtw_zmalloc(sizeof(struct usb_suspend_parm));
+	
+	psetusbsuspend = (struct usb_suspend_parm*)rtw_zmalloc(sizeof(struct usb_suspend_parm)); 
 	if (psetusbsuspend == NULL) {
 		rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
 		ret = _FAIL;
@@ -679,11 +679,11 @@ u8 rtw_setstandby_cmd(_adapter *padapter, uint action)
 
 	init_h2fwcmd_w_parm_no_rsp(ph2c, psetusbsuspend, GEN_CMD_CODE(_SetUsbSuspend));
 
-	ret = rtw_enqueue_cmd(pcmdpriv, ph2c);
-
-exit:
-
-_func_exit_;
+	ret = rtw_enqueue_cmd(pcmdpriv, ph2c);	
+	
+exit:	
+	
+_func_exit_;		
 
 	return ret;
 }
@@ -720,7 +720,7 @@ u8 rtw_sitesurvey_cmd(_adapter  *padapter, NDIS_802_11_SSID *ssid, int ssid_num,
 	if (ph2c == NULL)
 		return _FAIL;
 
-	psurveyPara = (struct sitesurvey_parm*)rtw_zmalloc(sizeof(struct sitesurvey_parm));
+	psurveyPara = (struct sitesurvey_parm*)rtw_zmalloc(sizeof(struct sitesurvey_parm)); 
 	if (psurveyPara == NULL) {
 		rtw_mfree((unsigned char*) ph2c, sizeof(struct cmd_obj));
 		return _FAIL;
@@ -775,7 +775,7 @@ u8 rtw_sitesurvey_cmd(_adapter  *padapter, NDIS_802_11_SSID *ssid, int ssid_num,
 		if (padapter->pbuddy_adapter == NULL )
 			goto full_scan_timeout;
 		if((padapter->pbuddy_adapter->mlmeextpriv.mlmext_info.state&0x03) == WIFI_FW_AP_STATE)
-			_set_timer(&pmlmepriv->scan_to_timer,
+			_set_timer(&pmlmepriv->scan_to_timer, 
 				SURVEY_TO * ( padapter->mlmeextpriv.max_chan_nums + ( padapter->mlmeextpriv.max_chan_nums  / RTW_SCAN_NUM_OF_CH ) * RTW_STAY_AP_CH_MILLISECOND ) + 1000 );
 		else
 #endif //CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
@@ -789,7 +789,7 @@ u8 rtw_sitesurvey_cmd(_adapter  *padapter, NDIS_802_11_SSID *ssid, int ssid_num,
 		_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY);
 	}
 
-_func_exit_;
+_func_exit_;		
 
 	return res;
 }
@@ -801,7 +801,7 @@ u8 rtw_setdatarate_cmd(_adapter *padapter, u8 *rateset)
 	struct cmd_priv*		pcmdpriv = &padapter->cmdpriv;
 	u8	res = _SUCCESS;
 
-_func_enter_;
+_func_enter_;	
 
 	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
 	if (ph2c == NULL) {
@@ -809,7 +809,7 @@ u8 rtw_setdatarate_cmd(_adapter *padapter, u8 *rateset)
 		goto exit;
 	}
 
-	pbsetdataratepara = (struct setdatarate_parm*)rtw_zmalloc(sizeof(struct setdatarate_parm));
+	pbsetdataratepara = (struct setdatarate_parm*)rtw_zmalloc(sizeof(struct setdatarate_parm)); 
 	if (pbsetdataratepara == NULL) {
 		rtw_mfree((u8 *) ph2c, sizeof(struct cmd_obj));
 		res = _FAIL;
@@ -846,7 +846,7 @@ u8 rtw_setbasicrate_cmd(_adapter *padapter, u8 *rateset)
 		res= _FAIL;
 		goto exit;
 	}
-	pssetbasicratepara = (struct setbasicrate_parm*)rtw_zmalloc(sizeof(struct setbasicrate_parm));
+	pssetbasicratepara = (struct setbasicrate_parm*)rtw_zmalloc(sizeof(struct setbasicrate_parm)); 
 
 	if (pssetbasicratepara == NULL) {
 		rtw_mfree((u8*) ph2c, sizeof(struct cmd_obj));
@@ -856,19 +856,19 @@ u8 rtw_setbasicrate_cmd(_adapter *padapter, u8 *rateset)
 
 	init_h2fwcmd_w_parm_no_rsp(ph2c, pssetbasicratepara, _SetBasicRate_CMD_);
 
-	_rtw_memcpy(pssetbasicratepara->basicrates, rateset, NumRates);
+	_rtw_memcpy(pssetbasicratepara->basicrates, rateset, NumRates);	   
 
-	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
-exit:
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);	
+exit:	
 
-_func_exit_;
+_func_exit_;		
 
 	return res;
 }
 
 
 /*
-unsigned char rtw_setphy_cmd(unsigned char  *adapter)
+unsigned char rtw_setphy_cmd(unsigned char  *adapter) 
 
 1.  be called only after rtw_update_registrypriv_dev_network( ~) or mp testing program
 2.  for AdHoc/Ap mode or mp mode?
@@ -883,14 +883,14 @@ u8 rtw_setphy_cmd(_adapter *padapter, u8 modem, u8 ch)
 //	struct registry_priv*		pregistry_priv = &padapter->registrypriv;
 	u8	res=_SUCCESS;
 
-_func_enter_;
+_func_enter_;	
 
 	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
 	if(ph2c==NULL){
 		res= _FAIL;
 		goto exit;
 		}
-	psetphypara = (struct setphy_parm*)rtw_zmalloc(sizeof(struct setphy_parm));
+	psetphypara = (struct setphy_parm*)rtw_zmalloc(sizeof(struct setphy_parm)); 
 
 	if(psetphypara==NULL){
 		rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
@@ -905,17 +905,17 @@ u8 rtw_setphy_cmd(_adapter *padapter, u8 modem, u8 ch)
 	psetphypara->modem = modem;
 	psetphypara->rfchannel = ch;
 
-	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
-exit:
-_func_exit_;
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);	
+exit:	
+_func_exit_;		
 	return res;
 }
 
 u8 rtw_setbbreg_cmd(_adapter*padapter, u8 offset, u8 val)
-{
+{	
 	struct cmd_obj*			ph2c;
 	struct writeBB_parm*		pwritebbparm;
-	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;
+	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;	
 	u8	res=_SUCCESS;
 _func_enter_;
 	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
@@ -923,7 +923,7 @@ u8 rtw_setbbreg_cmd(_adapter*padapter, u8 offset, u8 val)
 		res= _FAIL;
 		goto exit;
 		}
-	pwritebbparm = (struct writeBB_parm*)rtw_zmalloc(sizeof(struct writeBB_parm));
+	pwritebbparm = (struct writeBB_parm*)rtw_zmalloc(sizeof(struct writeBB_parm)); 
 
 	if(pwritebbparm==NULL){
 		rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
@@ -931,31 +931,31 @@ u8 rtw_setbbreg_cmd(_adapter*padapter, u8 offset, u8 val)
 		goto exit;
 	}
 
-	init_h2fwcmd_w_parm_no_rsp(ph2c, pwritebbparm, GEN_CMD_CODE(_SetBBReg));
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pwritebbparm, GEN_CMD_CODE(_SetBBReg));	
 
 	pwritebbparm->offset = offset;
 	pwritebbparm->value = val;
 
-	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
-exit:
-_func_exit_;
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);	
+exit:	
+_func_exit_;	
 	return res;
 }
 
 u8 rtw_getbbreg_cmd(_adapter  *padapter, u8 offset, u8 *pval)
-{
+{	
 	struct cmd_obj*			ph2c;
 	struct readBB_parm*		prdbbparm;
 	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;
 	u8	res=_SUCCESS;
-
+	
 _func_enter_;
 	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
 	if(ph2c==NULL){
 		res=_FAIL;
 		goto exit;
 		}
-	prdbbparm = (struct readBB_parm*)rtw_zmalloc(sizeof(struct readBB_parm));
+	prdbbparm = (struct readBB_parm*)rtw_zmalloc(sizeof(struct readBB_parm)); 
 
 	if(prdbbparm ==NULL){
 		rtw_mfree((unsigned char *) ph2c, sizeof(struct	cmd_obj));
@@ -968,28 +968,28 @@ u8 rtw_getbbreg_cmd(_adapter  *padapter, u8 offset, u8 *pval)
 	ph2c->cmdsz =  sizeof(struct readBB_parm);
 	ph2c->rsp = pval;
 	ph2c->rspsz = sizeof(struct readBB_rsp);
-
+	
 	prdbbparm ->offset = offset;
-
-	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+	
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);	
 exit:
-_func_exit_;
+_func_exit_;	
 	return res;
 }
 
 u8 rtw_setrfreg_cmd(_adapter  *padapter, u8 offset, u32 val)
-{
+{	
 	struct cmd_obj*			ph2c;
 	struct writeRF_parm*		pwriterfparm;
-	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;
+	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;	
 	u8	res=_SUCCESS;
 _func_enter_;
 	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
 	if(ph2c==NULL){
-		res= _FAIL;
+		res= _FAIL;	
 		goto exit;
 	}
-	pwriterfparm = (struct writeRF_parm*)rtw_zmalloc(sizeof(struct writeRF_parm));
+	pwriterfparm = (struct writeRF_parm*)rtw_zmalloc(sizeof(struct writeRF_parm)); 
 
 	if(pwriterfparm==NULL){
 		rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
@@ -997,22 +997,22 @@ u8 rtw_setrfreg_cmd(_adapter  *padapter, u8 offset, u32 val)
 		goto exit;
 	}
 
-	init_h2fwcmd_w_parm_no_rsp(ph2c, pwriterfparm, GEN_CMD_CODE(_SetRFReg));
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pwriterfparm, GEN_CMD_CODE(_SetRFReg));	
 
 	pwriterfparm->offset = offset;
 	pwriterfparm->value = val;
 
-	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);	
 exit:
-_func_exit_;
+_func_exit_;	
 	return res;
 }
 
 u8 rtw_getrfreg_cmd(_adapter  *padapter, u8 offset, u8 *pval)
-{
+{	
 	struct cmd_obj*			ph2c;
 	struct readRF_parm*		prdrfparm;
-	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;
+	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;	
 	u8	res=_SUCCESS;
 
 _func_enter_;
@@ -1023,7 +1023,7 @@ u8 rtw_getrfreg_cmd(_adapter  *padapter, u8 offset, u8 *pval)
 		goto exit;
 	}
 
-	prdrfparm = (struct readRF_parm*)rtw_zmalloc(sizeof(struct readRF_parm));
+	prdrfparm = (struct readRF_parm*)rtw_zmalloc(sizeof(struct readRF_parm)); 
 	if(prdrfparm ==NULL){
 		rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
 		res= _FAIL;
@@ -1036,40 +1036,40 @@ u8 rtw_getrfreg_cmd(_adapter  *padapter, u8 offset, u8 *pval)
 	ph2c->cmdsz =  sizeof(struct readRF_parm);
 	ph2c->rsp = pval;
 	ph2c->rspsz = sizeof(struct readRF_rsp);
-
+	
 	prdrfparm ->offset = offset;
-
-	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+	
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);	
 
 exit:
 
-_func_exit_;
+_func_exit_;	
 
 	return res;
 }
 
 void rtw_getbbrfreg_cmdrsp_callback(_adapter*	padapter,  struct cmd_obj *pcmd)
-{
- _func_enter_;
-
+{       
+ _func_enter_;  
+		
 	//rtw_free_cmd_obj(pcmd);
 	rtw_mfree((unsigned char*) pcmd->parmbuf, pcmd->cmdsz);
 	rtw_mfree((unsigned char*) pcmd, sizeof(struct cmd_obj));
-
-#ifdef CONFIG_MP_INCLUDED
+	
+#ifdef CONFIG_MP_INCLUDED	
 	padapter->mppriv.workparam.bcompleted= _TRUE;
-#endif
-_func_exit_;
+#endif	
+_func_exit_;		
 }
 
 void rtw_readtssi_cmdrsp_callback(_adapter*	padapter,  struct cmd_obj *pcmd)
 {
- _func_enter_;
+ _func_enter_;  
 
 	rtw_mfree((unsigned char*) pcmd->parmbuf, pcmd->cmdsz);
 	rtw_mfree((unsigned char*) pcmd, sizeof(struct cmd_obj));
-
-#ifdef CONFIG_MP_INCLUDED
+	
+#ifdef CONFIG_MP_INCLUDED	
 	padapter->mppriv.workparam.bcompleted= _TRUE;
 #endif
 
@@ -1089,11 +1089,11 @@ u8 rtw_createbss_cmd(_adapter  *padapter)
 	rtw_led_control(padapter, LED_CTL_START_TO_LINK);
 
 	if (pmlmepriv->assoc_ssid.SsidLength == 0){
-		RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,(" createbss for Any SSid:%s\n",pmlmepriv->assoc_ssid.Ssid));
+		RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,(" createbss for Any SSid:%s\n",pmlmepriv->assoc_ssid.Ssid));		
 	} else {
 		RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,(" createbss for SSid:%s\n", pmlmepriv->assoc_ssid.Ssid));
 	}
-
+		
 	pcmd = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
 	if(pcmd==NULL){
 		res= _FAIL;
@@ -1105,9 +1105,9 @@ u8 rtw_createbss_cmd(_adapter  *padapter)
 	pcmd->parmbuf = (unsigned char *)pdev_network;
 	pcmd->cmdsz = get_WLAN_BSSID_EX_sz((WLAN_BSSID_EX*)pdev_network);
 	pcmd->rsp = NULL;
-	pcmd->rspsz = 0;
-
-	pdev_network->Length = pcmd->cmdsz;
+	pcmd->rspsz = 0;	
+	
+	pdev_network->Length = pcmd->cmdsz;	
 
 #ifdef CONFIG_RTL8712
 	//notes: translate IELength & Length after assign the Length to cmdsz;
@@ -1116,11 +1116,11 @@ u8 rtw_createbss_cmd(_adapter  *padapter)
 	pdev_network->Ssid.SsidLength = cpu_to_le32(pdev_network->Ssid.SsidLength);
 #endif
 
-	res = rtw_enqueue_cmd(pcmdpriv, pcmd);
+	res = rtw_enqueue_cmd(pcmdpriv, pcmd);	
 
 exit:
 
-_func_exit_;
+_func_exit_;	
 
 	return res;
 }
@@ -1130,9 +1130,9 @@ u8 rtw_createbss_cmd_ex(_adapter  *padapter, unsigned char *pbss, unsigned int s
 	struct cmd_obj*	pcmd;
 	struct cmd_priv 	*pcmdpriv=&padapter->cmdpriv;
 	u8	res=_SUCCESS;
-
+	
 _func_enter_;
-
+			
 	pcmd = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
 	if(pcmd==NULL){
 		res= _FAIL;
@@ -1149,10 +1149,10 @@ u8 rtw_createbss_cmd_ex(_adapter  *padapter, unsigned char *pbss, unsigned int s
 	res = rtw_enqueue_cmd(pcmdpriv, pcmd);
 
 exit:
+	
+_func_exit_;	
 
-_func_exit_;
-
-	return res;
+	return res;	
 }
 
 u8 rtw_joinbss_cmd(_adapter  *padapter, struct wlan_network* pnetwork)
@@ -1187,12 +1187,12 @@ u8 rtw_joinbss_cmd(_adapter  *padapter, struct wlan_network* pnetwork)
 		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("rtw_joinbss_cmd: memory allocate for cmd_obj fail!!!\n"));
 		goto exit;
 	}
-	/* // for IEs is pointer
-	t_len = sizeof (ULONG) + sizeof (NDIS_802_11_MAC_ADDRESS) + 2 +
-			sizeof (NDIS_802_11_SSID) + sizeof (ULONG) +
-			sizeof (NDIS_802_11_RSSI) + sizeof (NDIS_802_11_NETWORK_TYPE) +
-			sizeof (NDIS_802_11_CONFIGURATION) +
-			sizeof (NDIS_802_11_NETWORK_INFRASTRUCTURE) +
+	/* // for IEs is pointer 
+	t_len = sizeof (ULONG) + sizeof (NDIS_802_11_MAC_ADDRESS) + 2 + 
+			sizeof (NDIS_802_11_SSID) + sizeof (ULONG) + 
+			sizeof (NDIS_802_11_RSSI) + sizeof (NDIS_802_11_NETWORK_TYPE) + 
+			sizeof (NDIS_802_11_CONFIGURATION) +	
+			sizeof (NDIS_802_11_NETWORK_INFRASTRUCTURE) +   
 			sizeof (NDIS_802_11_RATES_EX)+ sizeof(WLAN_PHY_INFO)+ sizeof (ULONG) + MAX_IE_SZ;
 	*/
 	//for IEs is fix buf size
@@ -1225,18 +1225,18 @@ u8 rtw_joinbss_cmd(_adapter  *padapter, struct wlan_network* pnetwork)
 	{
 		if(pcmd !=NULL)
 			rtw_mfree((unsigned char *)pcmd, sizeof(struct	cmd_obj));
-
+		
 		res=_FAIL;
-
+		
 		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("rtw_joinbss_cmd :psecnetwork==NULL!!!\n"));
-
+		
 		goto exit;
 	}
 
 	_rtw_memset(psecnetwork, 0, t_len);
 
 	_rtw_memcpy(psecnetwork, &pnetwork->network, get_WLAN_BSSID_EX_sz(&pnetwork->network));
-
+	
 	auth=&psecuritypriv->authenticator_ie[0];
 	psecuritypriv->authenticator_ie[0]=(unsigned char)psecnetwork->IELength;
 
@@ -1245,13 +1245,13 @@ u8 rtw_joinbss_cmd(_adapter  *padapter, struct wlan_network* pnetwork)
 	} else {
 		_rtw_memcpy(&psecuritypriv->authenticator_ie[1], &psecnetwork->IEs[12], (256-1));
 	}
-
+	  
 	psecnetwork->IELength = 0;
 	// Added by Albert 2009/02/18
 	// If the the driver wants to use the bssid to create the connection.
 	// If not,  we have to copy the connecting AP's MAC address to it so that
 	// the driver just has the bssid information for PMKIDList searching.
-
+        
 	if ( pmlmepriv->assoc_by_bssid == _FALSE )
 	{
 		_rtw_memcpy( &pmlmepriv->assoc_bssid[ 0 ], &pnetwork->network.MacAddress[ 0 ], ETH_ALEN );
@@ -1261,23 +1261,23 @@ u8 rtw_joinbss_cmd(_adapter  *padapter, struct wlan_network* pnetwork)
 
 
 	pqospriv->qos_option = 0;
-
-	if(pregistrypriv->wmm_enable)
-	{
+	
+	if(pregistrypriv->wmm_enable)	
+	{	
 		u32 tmp_len;
+		
+		tmp_len = rtw_restruct_wmm_ie(padapter, &pnetwork->network.IEs[0], &psecnetwork->IEs[0], pnetwork->network.IELength, psecnetwork->IELength);	
 
-		tmp_len = rtw_restruct_wmm_ie(padapter, &pnetwork->network.IEs[0], &psecnetwork->IEs[0], pnetwork->network.IELength, psecnetwork->IELength);
-
-		if (psecnetwork->IELength != tmp_len)
+		if (psecnetwork->IELength != tmp_len)		
 		{
 			psecnetwork->IELength = tmp_len;
 			pqospriv->qos_option = 1; //There is WMM IE in this corresp. beacon
 		}
-		else
+		else 
 		{
 			pqospriv->qos_option = 0;//There is no WMM IE in this corresp. beacon
-		}
-	}
+		}		
+	}	
 
 #ifdef CONFIG_80211N_HT
 	phtpriv->ht_option = _FALSE;
@@ -1291,7 +1291,7 @@ u8 rtw_joinbss_cmd(_adapter  *padapter, struct wlan_network* pnetwork)
 			( padapter->securitypriv.dot11PrivacyAlgrthm != _TKIP_ ))
 		{
 			//rtw_restructure_ht_ie
-			rtw_restructure_ht_ie(padapter, &pnetwork->network.IEs[0], &psecnetwork->IEs[0],
+			rtw_restructure_ht_ie(padapter, &pnetwork->network.IEs[0], &psecnetwork->IEs[0], 
 									pnetwork->network.IELength, &psecnetwork->IELength, (u8)psecnetwork->Configuration.DSConfig );
 		}
 	}
@@ -1312,11 +1312,11 @@ u8 rtw_joinbss_cmd(_adapter  *padapter, struct wlan_network* pnetwork)
 		_rtw_memcpy(&psecuritypriv->supplicant_ie[1], &psecnetwork->IEs[0], (256-1));
 	}
 	#endif
-
+	
 	pcmd->cmdsz = get_WLAN_BSSID_EX_sz(psecnetwork);//get cmdsz before endian conversion
 
 #ifdef CONFIG_RTL8712
-	//wlan_network endian conversion
+	//wlan_network endian conversion	
 	psecnetwork->Length = cpu_to_le32(psecnetwork->Length);
 	psecnetwork->Ssid.SsidLength= cpu_to_le32(psecnetwork->Ssid.SsidLength);
 	psecnetwork->Privacy = cpu_to_le32(psecnetwork->Privacy);
@@ -1328,10 +1328,10 @@ u8 rtw_joinbss_cmd(_adapter  *padapter, struct wlan_network* pnetwork)
 	psecnetwork->Configuration.FHConfig.DwellTime=cpu_to_le32(psecnetwork->Configuration.FHConfig.DwellTime);
 	psecnetwork->Configuration.FHConfig.HopPattern=cpu_to_le32(psecnetwork->Configuration.FHConfig.HopPattern);
 	psecnetwork->Configuration.FHConfig.HopSet=cpu_to_le32(psecnetwork->Configuration.FHConfig.HopSet);
-	psecnetwork->Configuration.FHConfig.Length=cpu_to_le32(psecnetwork->Configuration.FHConfig.Length);
+	psecnetwork->Configuration.FHConfig.Length=cpu_to_le32(psecnetwork->Configuration.FHConfig.Length);	
 	psecnetwork->Configuration.Length = cpu_to_le32(psecnetwork->Configuration.Length);
 	psecnetwork->InfrastructureMode = cpu_to_le32(psecnetwork->InfrastructureMode);
-	psecnetwork->IELength = cpu_to_le32(psecnetwork->IELength);
+	psecnetwork->IELength = cpu_to_le32(psecnetwork->IELength);      
 #endif
 
 	_rtw_init_listhead(&pcmd->list);
@@ -1343,7 +1343,7 @@ u8 rtw_joinbss_cmd(_adapter  *padapter, struct wlan_network* pnetwork)
 	res = rtw_enqueue_cmd(pcmdpriv, pcmd);
 
 exit:
-
+	
 _func_exit_;
 
 	return res;
@@ -1387,7 +1387,7 @@ u8 rtw_disassoc_cmd(_adapter*padapter, u32 deauth_timeout_ms, bool enqueue) /* f
 
 exit:
 
-_func_exit_;
+_func_exit_;	
 
 	return res;
 }
@@ -1402,12 +1402,12 @@ u8 rtw_setopmode_cmd(_adapter  *padapter, NDIS_802_11_NETWORK_INFRASTRUCTURE net
 
 _func_enter_;
 
-	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
+	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));			
 	if(ph2c==NULL){
 		res= _FALSE;
 		goto exit;
 	}
-	psetop = (struct setopmode_parm*)rtw_zmalloc(sizeof(struct setopmode_parm));
+	psetop = (struct setopmode_parm*)rtw_zmalloc(sizeof(struct setopmode_parm)); 
 
 	if(psetop==NULL){
 		rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
@@ -1422,7 +1422,7 @@ u8 rtw_setopmode_cmd(_adapter  *padapter, NDIS_802_11_NETWORK_INFRASTRUCTURE net
 
 exit:
 
-_func_exit_;
+_func_exit_;	
 
 	return res;
 }
@@ -1433,7 +1433,7 @@ u8 rtw_setstakey_cmd(_adapter *padapter, u8 *psta, u8 unicast_key)
 	struct set_stakey_parm	*psetstakey_para;
 	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;
 	struct set_stakey_rsp		*psetstakey_rsp = NULL;
-
+	
 	struct mlme_priv			*pmlmepriv = &padapter->mlmepriv;
 	struct security_priv 		*psecuritypriv = &padapter->securitypriv;
 	struct sta_info* 			sta = (struct sta_info* )psta;
@@ -1454,7 +1454,7 @@ u8 rtw_setstakey_cmd(_adapter *padapter, u8 *psta, u8 unicast_key)
 		goto exit;
 	}
 
-	psetstakey_rsp = (struct set_stakey_rsp*)rtw_zmalloc(sizeof(struct set_stakey_rsp));
+	psetstakey_rsp = (struct set_stakey_rsp*)rtw_zmalloc(sizeof(struct set_stakey_rsp)); 
 	if(psetstakey_rsp == NULL){
 		rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
 		rtw_mfree((u8 *) psetstakey_para, sizeof(struct set_stakey_parm));
@@ -1467,9 +1467,9 @@ u8 rtw_setstakey_cmd(_adapter *padapter, u8 *psta, u8 unicast_key)
 	ph2c->rspsz = sizeof(struct set_stakey_rsp);
 
 	_rtw_memcpy(psetstakey_para->addr, sta->hwaddr,ETH_ALEN);
-
+	
 	if(check_fwstate(pmlmepriv, WIFI_STATION_STATE)){
-#ifdef CONFIG_TDLS
+#ifdef CONFIG_TDLS		
 		if(sta->tdls_sta_state&TDLS_LINKED_STATE)
 			psetstakey_para->algorithm=(u8)sta->dot118021XPrivacy;
 		else
@@ -1493,11 +1493,11 @@ u8 rtw_setstakey_cmd(_adapter *padapter, u8 *psta, u8 unicast_key)
 	//jeff: set this becasue at least sw key is ready
 	padapter->securitypriv.busetkipkey=_TRUE;
 
-	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);	
 
 exit:
 
-_func_exit_;
+_func_exit_;	
 
 	return res;
 }
@@ -1507,7 +1507,7 @@ u8 rtw_clearstakey_cmd(_adapter *padapter, u8 *psta, u8 entry, u8 enqueue)
 	struct cmd_obj*			ph2c;
 	struct set_stakey_parm	*psetstakey_para;
 	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;
-	struct set_stakey_rsp		*psetstakey_rsp = NULL;
+	struct set_stakey_rsp		*psetstakey_rsp = NULL;	
 	struct mlme_priv			*pmlmepriv = &padapter->mlmepriv;
 	struct security_priv 		*psecuritypriv = &padapter->securitypriv;
 	struct sta_info* 			sta = (struct sta_info* )psta;
@@ -1534,7 +1534,7 @@ u8 rtw_clearstakey_cmd(_adapter *padapter, u8 *psta, u8 entry, u8 enqueue)
 			goto exit;
 		}
 
-		psetstakey_rsp = (struct set_stakey_rsp*)rtw_zmalloc(sizeof(struct set_stakey_rsp));
+		psetstakey_rsp = (struct set_stakey_rsp*)rtw_zmalloc(sizeof(struct set_stakey_rsp)); 
 		if(psetstakey_rsp == NULL){
 			rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
 			rtw_mfree((u8 *) psetstakey_para, sizeof(struct set_stakey_parm));
@@ -1551,14 +1551,14 @@ u8 rtw_clearstakey_cmd(_adapter *padapter, u8 *psta, u8 entry, u8 enqueue)
 		psetstakey_para->algorithm = _NO_PRIVACY_;
 
 		psetstakey_para->id = entry;
-
-		res = rtw_enqueue_cmd(pcmdpriv, ph2c);
-
+	
+		res = rtw_enqueue_cmd(pcmdpriv, ph2c);	
+		
 	}
-
+	
 exit:
 
-_func_exit_;
+_func_exit_;	
 
 	return res;
 }
@@ -1566,17 +1566,17 @@ u8 rtw_clearstakey_cmd(_adapter *padapter, u8 *psta, u8 entry, u8 enqueue)
 u8 rtw_setrttbl_cmd(_adapter  *padapter, struct setratable_parm *prate_table)
 {
 	struct cmd_obj*			ph2c;
-	struct setratable_parm *	psetrttblparm;
+	struct setratable_parm *	psetrttblparm;	
 	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;
 	u8	res=_SUCCESS;
-_func_enter_;
+_func_enter_;	
 
 	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
 	if(ph2c==NULL){
 		res= _FAIL;
 		goto exit;
 		}
-	psetrttblparm = (struct setratable_parm*)rtw_zmalloc(sizeof(struct setratable_parm));
+	psetrttblparm = (struct setratable_parm*)rtw_zmalloc(sizeof(struct setratable_parm)); 
 
 	if(psetrttblparm==NULL){
 		rtw_mfree((unsigned char *) ph2c, sizeof(struct	cmd_obj));
@@ -1588,9 +1588,9 @@ u8 rtw_setrttbl_cmd(_adapter  *padapter, struct setratable_parm *prate_table)
 
 	_rtw_memcpy(psetrttblparm,prate_table,sizeof(struct setratable_parm));
 
-	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);	
 exit:
-_func_exit_;
+_func_exit_;	
 	return res;
 
 }
@@ -1598,17 +1598,17 @@ u8 rtw_setrttbl_cmd(_adapter  *padapter, struct setratable_parm *prate_table)
 u8 rtw_getrttbl_cmd(_adapter  *padapter, struct getratable_rsp *pval)
 {
 	struct cmd_obj*			ph2c;
-	struct getratable_parm *	pgetrttblparm;
+	struct getratable_parm *	pgetrttblparm;	
 	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;
 	u8	res=_SUCCESS;
-_func_enter_;
+_func_enter_;	
 
 	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
 	if(ph2c==NULL){
 		res= _FAIL;
 		goto exit;
 	}
-	pgetrttblparm = (struct getratable_parm*)rtw_zmalloc(sizeof(struct getratable_parm));
+	pgetrttblparm = (struct getratable_parm*)rtw_zmalloc(sizeof(struct getratable_parm)); 
 
 	if(pgetrttblparm==NULL){
 		rtw_mfree((unsigned char *) ph2c, sizeof(struct	cmd_obj));
@@ -1624,12 +1624,12 @@ u8 rtw_getrttbl_cmd(_adapter  *padapter, struct getratable_rsp *pval)
 	ph2c->cmdsz =  sizeof(struct getratable_parm);
 	ph2c->rsp = (u8*)pval;
 	ph2c->rspsz = sizeof(struct getratable_rsp);
-
+	
 	pgetrttblparm ->rsvd = 0x0;
-
-	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+	
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);	
 exit:
-_func_exit_;
+_func_exit_;	
 	return res;
 
 }
@@ -1638,12 +1638,12 @@ u8 rtw_setassocsta_cmd(_adapter  *padapter, u8 *mac_addr)
 {
 	struct cmd_priv 		*pcmdpriv = &padapter->cmdpriv;
 	struct cmd_obj*			ph2c;
-	struct set_assocsta_parm	*psetassocsta_para;
+	struct set_assocsta_parm	*psetassocsta_para;	
 	struct set_stakey_rsp		*psetassocsta_rsp = NULL;
 
 	u8	res=_SUCCESS;
 
-_func_enter_;
+_func_enter_;	
 
 	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
 	if(ph2c==NULL){
@@ -1658,7 +1658,7 @@ u8 rtw_setassocsta_cmd(_adapter  *padapter, u8 *mac_addr)
 		goto exit;
 	}
 
-	psetassocsta_rsp = (struct set_stakey_rsp*)rtw_zmalloc(sizeof(struct set_assocsta_rsp));
+	psetassocsta_rsp = (struct set_stakey_rsp*)rtw_zmalloc(sizeof(struct set_assocsta_rsp)); 
 	if(psetassocsta_rsp==NULL){
 		rtw_mfree((u8 *) ph2c, sizeof(struct	cmd_obj));
 		rtw_mfree((u8 *) psetassocsta_para, sizeof(struct set_assocsta_parm));
@@ -1670,12 +1670,12 @@ u8 rtw_setassocsta_cmd(_adapter  *padapter, u8 *mac_addr)
 	ph2c->rspsz = sizeof(struct set_assocsta_rsp);
 
 	_rtw_memcpy(psetassocsta_para->addr, mac_addr,ETH_ALEN);
-
-	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+	
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);	
 
 exit:
 
-_func_exit_;
+_func_exit_;	
 
 	return res;
  }
@@ -1687,16 +1687,16 @@ u8 rtw_addbareq_cmd(_adapter*padapter, u8 tid, u8 *addr)
 	struct addBaReq_parm	*paddbareq_parm;
 
 	u8	res=_SUCCESS;
+	
+_func_enter_;	
 
-_func_enter_;
-
-	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
+	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));	
 	if(ph2c==NULL){
 		res= _FAIL;
 		goto exit;
 	}
-
-	paddbareq_parm = (struct addBaReq_parm*)rtw_zmalloc(sizeof(struct addBaReq_parm));
+	
+	paddbareq_parm = (struct addBaReq_parm*)rtw_zmalloc(sizeof(struct addBaReq_parm)); 
 	if(paddbareq_parm==NULL){
 		rtw_mfree((unsigned char *)ph2c, sizeof(struct	cmd_obj));
 		res= _FAIL;
@@ -1710,11 +1710,11 @@ u8 rtw_addbareq_cmd(_adapter*padapter, u8 tid, u8 *addr)
 
 	//DBG_871X("rtw_addbareq_cmd, tid=%d\n", tid);
 
-	//rtw_enqueue_cmd(pcmdpriv, ph2c);
+	//rtw_enqueue_cmd(pcmdpriv, ph2c);	
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
-
+	
 exit:
-
+	
 _func_exit_;
 
 	return res;
@@ -1723,19 +1723,19 @@ u8 rtw_addbareq_cmd(_adapter*padapter, u8 tid, u8 *addr)
 u8 rtw_reset_securitypriv_cmd(_adapter*padapter)
 {
 	struct cmd_obj*		ph2c;
-	struct drvextra_cmd_parm  *pdrvextra_cmd_parm;
+	struct drvextra_cmd_parm  *pdrvextra_cmd_parm;	
 	struct cmd_priv	*pcmdpriv=&padapter->cmdpriv;
 	u8	res=_SUCCESS;
+	
+_func_enter_;	
 
-_func_enter_;
-
-	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
+	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));	
 	if(ph2c==NULL){
 		res= _FAIL;
 		goto exit;
 	}
-
-	pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm));
+	
+	pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm)); 
 	if(pdrvextra_cmd_parm==NULL){
 		rtw_mfree((unsigned char *)ph2c, sizeof(struct cmd_obj));
 		res= _FAIL;
@@ -1748,12 +1748,12 @@ u8 rtw_reset_securitypriv_cmd(_adapter*padapter)
 
 	init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));
 
-
-	//rtw_enqueue_cmd(pcmdpriv, ph2c);
+	
+	//rtw_enqueue_cmd(pcmdpriv, ph2c);	
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
-
+	
 exit:
-
+	
 _func_exit_;
 
 	return res;
@@ -1763,19 +1763,19 @@ u8 rtw_reset_securitypriv_cmd(_adapter*padapter)
 u8 rtw_free_assoc_resources_cmd(_adapter*padapter)
 {
 	struct cmd_obj*		ph2c;
-	struct drvextra_cmd_parm  *pdrvextra_cmd_parm;
+	struct drvextra_cmd_parm  *pdrvextra_cmd_parm;	
 	struct cmd_priv	*pcmdpriv=&padapter->cmdpriv;
 	u8	res=_SUCCESS;
+	
+_func_enter_;	
 
-_func_enter_;
-
-	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
+	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));	
 	if(ph2c==NULL){
 		res= _FAIL;
 		goto exit;
 	}
-
-	pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm));
+	
+	pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm)); 
 	if(pdrvextra_cmd_parm==NULL){
 		rtw_mfree((unsigned char *)ph2c, sizeof(struct cmd_obj));
 		res= _FAIL;
@@ -1788,12 +1788,12 @@ u8 rtw_free_assoc_resources_cmd(_adapter*padapter)
 
 	init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));
 
-
-	//rtw_enqueue_cmd(pcmdpriv, ph2c);
+	
+	//rtw_enqueue_cmd(pcmdpriv, ph2c);	
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
-
+	
 exit:
-
+	
 _func_exit_;
 
 	return res;
@@ -1804,11 +1804,11 @@ u8 rtw_free_assoc_resources_cmd(_adapter*padapter)
 u8 rtw_dynamic_chk_wk_cmd(_adapter*padapter)
 {
 	struct cmd_obj*		ph2c;
-	struct drvextra_cmd_parm  *pdrvextra_cmd_parm;
+	struct drvextra_cmd_parm  *pdrvextra_cmd_parm;	
 	struct cmd_priv	*pcmdpriv=&padapter->cmdpriv;
 	u8	res=_SUCCESS;
-
-_func_enter_;
+	
+_func_enter_;	
 
 	if ((padapter->bDriverStopped == _TRUE)||(padapter->bSurpriseRemoved== _TRUE))
 		goto exit;
@@ -1819,13 +1819,13 @@ u8 rtw_dynamic_chk_wk_cmd(_adapter*padapter)
 		pcmdpriv = &(padapter->pbuddy_adapter->cmdpriv);
 #endif
 
-	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
+	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));	
 	if(ph2c==NULL){
 		res= _FAIL;
 		goto exit;
 	}
-
-	pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm));
+	
+	pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm)); 
 	if(pdrvextra_cmd_parm==NULL){
 		rtw_mfree((unsigned char *)ph2c, sizeof(struct cmd_obj));
 		res= _FAIL;
@@ -1838,12 +1838,12 @@ u8 rtw_dynamic_chk_wk_cmd(_adapter*padapter)
 
 	init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));
 
-
-	//rtw_enqueue_cmd(pcmdpriv, ph2c);
+	
+	//rtw_enqueue_cmd(pcmdpriv, ph2c);	
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
-
+	
 exit:
-
+	
 _func_exit_;
 
 	return res;
@@ -1890,7 +1890,7 @@ u8 rtw_set_ch_cmd(_adapter*padapter, u8 ch, u8 bw, u8 ch_offset, u8 enqueue)
 		/* no need to enqueue, do the cmd hdl directly and free cmd parameter */
 		if( H2C_SUCCESS !=set_ch_hdl(padapter, (u8 *)set_ch_parm) )
 			res = _FAIL;
-
+		
 		rtw_mfree((u8 *)set_ch_parm, sizeof(*set_ch_parm));
 	}
 
@@ -1900,7 +1900,7 @@ u8 rtw_set_ch_cmd(_adapter*padapter, u8 ch, u8 bw, u8 ch_offset, u8 enqueue)
 
 	DBG_871X(FUNC_NDEV_FMT" res:%u\n", FUNC_NDEV_ARG(padapter->pnetdev), res);
 
-_func_exit_;
+_func_exit_;	
 
 	return res;
 }
@@ -1949,17 +1949,17 @@ u8 rtw_set_chplan_cmd(_adapter*padapter, u8 chplan, u8 enqueue)
 		//no need to enqueue, do the cmd hdl directly and free cmd parameter
 		if( H2C_SUCCESS !=set_chplan_hdl(padapter, (unsigned char *)setChannelPlan_param) )
 			res = _FAIL;
-
+		
 		rtw_mfree((u8 *)setChannelPlan_param, sizeof(struct SetChannelPlan_param));
 	}
 
 	//do something based on res...
 	if(res == _SUCCESS)
 		padapter->mlmepriv.ChannelPlan = chplan;
-
+	
 exit:
 
-_func_exit_;
+_func_exit_;	
 
 	return res;
 }
@@ -1975,7 +1975,7 @@ u8 rtw_led_blink_cmd(_adapter*padapter, PLED_871x pLed)
 _func_enter_;
 
 	RT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_, ("+rtw_led_blink_cmd\n"));
-
+	
 	pcmdobj = (struct	cmd_obj*)rtw_zmalloc(sizeof(struct	cmd_obj));
 	if(pcmdobj == NULL){
 		res=_FAIL;
@@ -1990,13 +1990,13 @@ u8 rtw_led_blink_cmd(_adapter*padapter, PLED_871x pLed)
 	}
 
 	ledBlink_param->pLed=pLed;
-
+	
 	init_h2fwcmd_w_parm_no_rsp(pcmdobj, ledBlink_param, GEN_CMD_CODE(_LedBlink));
 	res = rtw_enqueue_cmd(pcmdpriv, pcmdobj);
-
+	
 exit:
 
-_func_exit_;
+_func_exit_;	
 
 	return res;
 }
@@ -2013,7 +2013,7 @@ u8 rtw_set_csa_cmd(_adapter*padapter, u8 new_ch_no)
 _func_enter_;
 
 	RT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_, ("+rtw_set_csa_cmd\n"));
-
+	
 	pcmdobj = (struct	cmd_obj*)rtw_zmalloc(sizeof(struct	cmd_obj));
 	if(pcmdobj == NULL){
 		res=_FAIL;
@@ -2028,13 +2028,13 @@ u8 rtw_set_csa_cmd(_adapter*padapter, u8 new_ch_no)
 	}
 
 	setChannelSwitch_param->new_ch_no=new_ch_no;
-
+	
 	init_h2fwcmd_w_parm_no_rsp(pcmdobj, setChannelSwitch_param, GEN_CMD_CODE(_SetChannelSwitch));
 	res = rtw_enqueue_cmd(pcmdpriv, pcmdobj);
-
+	
 exit:
 
-_func_exit_;
+_func_exit_;	
 
 	return res;
 }
@@ -2068,18 +2068,18 @@ u8 rtw_tdls_cmd(_adapter *padapter, u8 *addr, u8 option)
 	}
 
 	_rtw_spinlock(&(padapter->tdlsinfo.cmd_lock));
-	_rtw_memcpy(TDLSoption->addr, addr, 6);
+	_rtw_memcpy(TDLSoption->addr, addr, 6);	
 	TDLSoption->option = option;
 	_rtw_spinunlock(&(padapter->tdlsinfo.cmd_lock));
 	init_h2fwcmd_w_parm_no_rsp(pcmdobj, TDLSoption, GEN_CMD_CODE(_TDLS));
 	res = rtw_enqueue_cmd(pcmdpriv, pcmdobj);
 
 #endif	//CONFIG_TDLS
-
+	
 exit:
 
 
-_func_exit_;
+_func_exit_;	
 
 	return res;
 }
@@ -2102,7 +2102,7 @@ static void traffic_status_watchdog(_adapter *padapter)
 	//
 	// Determine if our traffic is busy now
 	//
-	if((check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE)
+	if((check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE) 
 		/*&& !MgntInitAdapterInProgress(pMgntInfo)*/)
 	{
 
@@ -2202,19 +2202,19 @@ static void traffic_status_watchdog(_adapter *padapter)
 	pmlmepriv->LinkDetectInfo.bHigherBusyTraffic = bHigherBusyTraffic;
 	pmlmepriv->LinkDetectInfo.bHigherBusyRxTraffic = bHigherBusyRxTraffic;
 	pmlmepriv->LinkDetectInfo.bHigherBusyTxTraffic = bHigherBusyTxTraffic;
-
+	
 }
 
 void dynamic_chk_wk_hdl(_adapter *padapter, u8 *pbuf, int sz);
 void dynamic_chk_wk_hdl(_adapter *padapter, u8 *pbuf, int sz)
 {
 	struct mlme_priv *pmlmepriv;
-
+	
 	if ((padapter->bDriverStopped == _TRUE)||(padapter->bSurpriseRemoved== _TRUE))
 		return;
 
 	if((void*)padapter != (void*)pbuf && padapter->pbuddy_adapter == NULL)
-		return;
+		return;		
 
 	padapter = (_adapter *)pbuf;
 
@@ -2226,25 +2226,25 @@ void dynamic_chk_wk_hdl(_adapter *padapter, u8 *pbuf, int sz)
 #ifdef CONFIG_ACTIVE_KEEP_ALIVE_CHECK
 #ifdef CONFIG_AP_MODE
 	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
-	{
+	{			
 		expire_timeout_chk(padapter);
 	}
 #endif
 #endif //CONFIG_ACTIVE_KEEP_ALIVE_CHECK
 
-	#ifdef DBG_CONFIG_ERROR_DETECT
+	#ifdef DBG_CONFIG_ERROR_DETECT	
 	rtw_hal_sreset_xmit_status_check(padapter);
-	#endif
+	#endif	
 
 	//if(check_fwstate(pmlmepriv, _FW_UNDER_LINKING|_FW_UNDER_SURVEY)==_FALSE)
 	{
-		linked_status_chk(padapter);
+		linked_status_chk(padapter);	
 		traffic_status_watchdog(padapter);
 	}
 
 	rtw_hal_dm_watchdog(padapter);
 
-	//check_hw_pbc(padapter, pdrvextra_cmd->pbuf, pdrvextra_cmd->type_size);
+	//check_hw_pbc(padapter, pdrvextra_cmd->pbuf, pdrvextra_cmd->type_size);	
 
 }
 
@@ -2256,7 +2256,7 @@ void lps_ctrl_wk_hdl(_adapter *padapter, u8 lps_ctrl_type)
 	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	u8	mstatus;
-
+	
 _func_enter_;
 
 	if((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE)
@@ -2304,11 +2304,11 @@ void lps_ctrl_wk_hdl(_adapter *padapter, u8 lps_ctrl_type)
 u8 rtw_lps_ctrl_wk_cmd(_adapter*padapter, u8 lps_ctrl_type, u8 enqueue)
 {
 	struct cmd_obj	*ph2c;
-	struct drvextra_cmd_parm	*pdrvextra_cmd_parm;
+	struct drvextra_cmd_parm	*pdrvextra_cmd_parm;	
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
 	//struct pwrctrl_priv *pwrctrlpriv = &padapter->pwrctrlpriv;
 	u8	res = _SUCCESS;
-
+	
 _func_enter_;
 
 	//if(!pwrctrlpriv->bLeisurePs)
@@ -2321,13 +2321,13 @@ u8 rtw_lps_ctrl_wk_cmd(_adapter*padapter, u8 lps_ctrl_type, u8 enqueue)
 
 	if(enqueue)
 	{
-		ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
+		ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));	
 		if(ph2c==NULL){
 			res= _FAIL;
 			goto exit;
 		}
-
-		pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm));
+		
+		pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm)); 
 		if(pdrvextra_cmd_parm==NULL){
 			rtw_mfree((unsigned char *)ph2c, sizeof(struct cmd_obj));
 			res= _FAIL;
@@ -2346,9 +2346,9 @@ u8 rtw_lps_ctrl_wk_cmd(_adapter*padapter, u8 lps_ctrl_type, u8 enqueue)
 	{
 		lps_ctrl_wk_hdl(padapter, lps_ctrl_type);
 	}
-
+	
 exit:
-
+	
 _func_exit_;
 
 	return res;
@@ -2366,7 +2366,7 @@ void antenna_select_wk_hdl(_adapter *padapter, u8 antenna)
 u8 rtw_antenna_select_cmd(_adapter*padapter, u8 antenna,u8 enqueue)
 {
 	struct cmd_obj		*ph2c;
-	struct drvextra_cmd_parm	*pdrvextra_cmd_parm;
+	struct drvextra_cmd_parm	*pdrvextra_cmd_parm;	
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
 	u8 	bSupportAntDiv = _FALSE;
 	u8	res = _SUCCESS;
@@ -2377,7 +2377,7 @@ u8 rtw_antenna_select_cmd(_adapter*padapter, u8 antenna,u8 enqueue)
 
 	if(_TRUE == enqueue)
 	{
-		ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
+		ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));	
 		if(ph2c==NULL){
 			res= _FAIL;
 			goto exit;
@@ -2434,7 +2434,7 @@ u8 p2p_protocol_wk_cmd(_adapter*padapter, int intCmdType )
 	struct wifidirect_info	*pwdinfo= &(padapter->wdinfo);
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
 	u8	res = _SUCCESS;
-
+	
 _func_enter_;
 
 	if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
@@ -2442,13 +2442,13 @@ u8 p2p_protocol_wk_cmd(_adapter*padapter, int intCmdType )
 		return res;
 	}
 
-	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
+	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));	
 	if(ph2c==NULL){
 		res= _FAIL;
 		goto exit;
 	}
-
-	pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm));
+			
+	pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm)); 
 	if(pdrvextra_cmd_parm==NULL){
 		rtw_mfree((unsigned char *)ph2c, sizeof(struct cmd_obj));
 		res= _FAIL;
@@ -2462,9 +2462,9 @@ u8 p2p_protocol_wk_cmd(_adapter*padapter, int intCmdType )
 	init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));
 
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
-
+	
 exit:
-
+	
 _func_exit_;
 
 	return res;
@@ -2475,9 +2475,9 @@ u8 p2p_protocol_wk_cmd(_adapter*padapter, int intCmdType )
 u8 rtw_ps_cmd(_adapter*padapter)
 {
 	struct cmd_obj		*ppscmd;
-	struct drvextra_cmd_parm	*pdrvextra_cmd_parm;
+	struct drvextra_cmd_parm	*pdrvextra_cmd_parm;	
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
-
+	
 	u8	res = _SUCCESS;
 _func_enter_;
 
@@ -2485,28 +2485,28 @@ u8 rtw_ps_cmd(_adapter*padapter)
 	if (padapter->adapter_type != PRIMARY_ADAPTER)
 		goto exit;
 #endif
-
-	ppscmd = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
+	
+	ppscmd = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));	
 	if(ppscmd==NULL){
 		res= _FAIL;
 		goto exit;
 	}
-
-	pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm));
+		
+	pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm)); 
 	if(pdrvextra_cmd_parm==NULL){
 		rtw_mfree((unsigned char *)ppscmd, sizeof(struct cmd_obj));
 		res= _FAIL;
 		goto exit;
 	}
 
-	pdrvextra_cmd_parm->ec_id = POWER_SAVING_CTRL_WK_CID;
+	pdrvextra_cmd_parm->ec_id = POWER_SAVING_CTRL_WK_CID;	
 	pdrvextra_cmd_parm->pbuf = NULL;
 	init_h2fwcmd_w_parm_no_rsp(ppscmd, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));
 
 	res = rtw_enqueue_cmd(pcmdpriv, ppscmd);
-
+	
 exit:
-
+	
 _func_exit_;
 
 	return res;
@@ -2533,36 +2533,36 @@ static void rtw_chk_hi_queue_hdl(_adapter *padapter)
 			rtw_msleep_os(100);
 
 			cnt++;
-
+			
 			if(cnt>10)
-				break;
+				break;	
 		}
 
 		if(cnt<=10)
 		{
 			pstapriv->tim_bitmap &= ~BIT(0);
 			pstapriv->sta_dz_bitmap &= ~BIT(0);
-
+			
 			update_beacon(padapter, _TIM_IE_, NULL, _FALSE);
-		}
-	}
-
+		}	
+	}	
+	
 }
 
 u8 rtw_chk_hi_queue_cmd(_adapter*padapter)
 {
 	struct cmd_obj	*ph2c;
-	struct drvextra_cmd_parm	*pdrvextra_cmd_parm;
+	struct drvextra_cmd_parm	*pdrvextra_cmd_parm;	
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
 	u8	res = _SUCCESS;
-
-	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
+	
+	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));	
 	if(ph2c==NULL){
 		res= _FAIL;
 		goto exit;
 	}
-
-	pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm));
+			
+	pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm)); 
 	if(pdrvextra_cmd_parm==NULL){
 		rtw_mfree((unsigned char *)ph2c, sizeof(struct cmd_obj));
 		res= _FAIL;
@@ -2576,9 +2576,9 @@ u8 rtw_chk_hi_queue_cmd(_adapter*padapter)
 	init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));
 
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
-
+	
 exit:
-
+	
 	return res;
 
 }
@@ -2611,9 +2611,9 @@ u8 rtw_c2h_wk_cmd(PADAPTER padapter, u8 *c2h_evt)
 	init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));
 
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
-
+	
 exit:
-
+	
 	return res;
 }
 
@@ -2626,7 +2626,7 @@ s32 c2h_evt_hdl(_adapter *adapter, struct c2h_evt_hdr *c2h_evt, c2h_id_filter fi
 		/* No c2h event in cmd_obj, read c2h event before handling*/
 		if (c2h_evt_read(adapter, buf) == _SUCCESS) {
 			c2h_evt = (struct c2h_evt_hdr *)buf;
-
+			
 			if (filter && filter(c2h_evt->id) == _FALSE)
 				goto exit;
 
@@ -2671,7 +2671,7 @@ static void c2h_wk_callback(_workitem *work)
 			rtw_mfree((u8*)c2h_evt, 16);
 			continue;
 		}
-
+		
 		if (ccx_id_filter(c2h_evt->id) == _TRUE) {
 			/* Handle CCX report here */
 			rtw_hal_c2h_handler(adapter, c2h_evt);
@@ -2694,14 +2694,14 @@ u8 rtw_drvextra_cmd_hdl(_adapter *padapter, unsigned char *pbuf)
 		return H2C_PARAMETERS_ERROR;
 
 	pdrvextra_cmd = (struct drvextra_cmd_parm*)pbuf;
-
+	
 	switch(pdrvextra_cmd->ec_id)
 	{
 		case DYNAMIC_CHK_WK_CID:
 			dynamic_chk_wk_hdl(padapter, pdrvextra_cmd->pbuf, pdrvextra_cmd->type_size);
 			break;
 		case POWER_SAVING_CTRL_WK_CID:
-			power_saving_wk_hdl(padapter, pdrvextra_cmd->pbuf, pdrvextra_cmd->type_size);
+			power_saving_wk_hdl(padapter, pdrvextra_cmd->pbuf, pdrvextra_cmd->type_size);	
 			break;
 #ifdef CONFIG_LPS
 		case LPS_CTRL_WK_CID:
@@ -2774,26 +2774,26 @@ void rtw_survey_cmd_callback(_adapter*	padapter ,  struct cmd_obj *pcmd)
 	else if (pcmd->res != H2C_SUCCESS) {
 		_set_timer(&pmlmepriv->scan_to_timer, 1);
 		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\n ********Error: MgntActrtw_set_802_11_bssid_LIST_SCAN Fail ************\n\n."));
-	}
+	} 
 
 	// free cmd
 	rtw_free_cmd_obj(pcmd);
 
-_func_exit_;
+_func_exit_;	
 }
 void rtw_disassoc_cmd_callback(_adapter*	padapter,  struct cmd_obj *pcmd)
 {
 	_irqL	irqL;
 	struct 	mlme_priv *pmlmepriv = &padapter->mlmepriv;
-
-_func_enter_;
+	
+_func_enter_;	
 
 	if (pcmd->res != H2C_SUCCESS)
 	{
 		_enter_critical_bh(&pmlmepriv->lock, &irqL);
 		set_fwstate(pmlmepriv, _FW_LINKED);
 		_exit_critical_bh(&pmlmepriv->lock, &irqL);
-
+				
 		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\n ***Error: disconnect_cmd_callback Fail ***\n."));
 
 		goto exit;
@@ -2805,10 +2805,10 @@ void rtw_disassoc_cmd_callback(_adapter*	padapter,  struct cmd_obj *pcmd)
 
 	// free cmd
 	rtw_free_cmd_obj(pcmd);
-
+	
 exit:
-
-_func_exit_;
+	
+_func_exit_;	
 }
 
 
@@ -2816,7 +2816,7 @@ void rtw_joinbss_cmd_callback(_adapter*	padapter,  struct cmd_obj *pcmd)
 {
 	struct 	mlme_priv *pmlmepriv = &padapter->mlmepriv;
 
-_func_enter_;
+_func_enter_;	
 
 	if(pcmd->res == H2C_DROPPED)
 	{
@@ -2825,75 +2825,75 @@ void rtw_joinbss_cmd_callback(_adapter*	padapter,  struct cmd_obj *pcmd)
 		_set_timer(&pmlmepriv->assoc_timer, 1);
 	}
 	else if(pcmd->res != H2C_SUCCESS)
-	{
+	{				
 		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("********Error:rtw_select_and_join_from_scanned_queue Wait Sema  Fail ************\n"));
-		_set_timer(&pmlmepriv->assoc_timer, 1);
+		_set_timer(&pmlmepriv->assoc_timer, 1);	
 	}
-
+	
 	rtw_free_cmd_obj(pcmd);
-
-_func_exit_;
+	
+_func_exit_;	
 }
 
 void rtw_createbss_cmd_callback(_adapter *padapter, struct cmd_obj *pcmd)
-{
+{	
 	_irqL irqL;
 	u8 timer_cancelled;
 	struct sta_info *psta = NULL;
-	struct wlan_network *pwlan = NULL;
-	struct 	mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct wlan_network *pwlan = NULL;		
+	struct 	mlme_priv *pmlmepriv = &padapter->mlmepriv;	
 	WLAN_BSSID_EX *pnetwork = (WLAN_BSSID_EX *)pcmd->parmbuf;
 	struct wlan_network *tgt_network = &(pmlmepriv->cur_network);
 
-_func_enter_;
+_func_enter_;	
 
 	if((pcmd->res != H2C_SUCCESS))
-	{
+	{	
 		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\n ********Error: rtw_createbss_cmd_callback  Fail ************\n\n."));
-		_set_timer(&pmlmepriv->assoc_timer, 1 );
+		_set_timer(&pmlmepriv->assoc_timer, 1 );		
 	}
-
+	
 	_cancel_timer(&pmlmepriv->assoc_timer, &timer_cancelled);
 
 #ifdef CONFIG_FW_MLMLE
        //endian_convert
 	pnetwork->Length = le32_to_cpu(pnetwork->Length);
-	pnetwork->Ssid.SsidLength = le32_to_cpu(pnetwork->Ssid.SsidLength);
+  	pnetwork->Ssid.SsidLength = le32_to_cpu(pnetwork->Ssid.SsidLength);
 	pnetwork->Privacy =le32_to_cpu(pnetwork->Privacy);
 	pnetwork->Rssi = le32_to_cpu(pnetwork->Rssi);
-	pnetwork->NetworkTypeInUse =le32_to_cpu(pnetwork->NetworkTypeInUse);
+	pnetwork->NetworkTypeInUse =le32_to_cpu(pnetwork->NetworkTypeInUse);	
 	pnetwork->Configuration.ATIMWindow = le32_to_cpu(pnetwork->Configuration.ATIMWindow);
 	//pnetwork->Configuration.BeaconPeriod = le32_to_cpu(pnetwork->Configuration.BeaconPeriod);
 	pnetwork->Configuration.DSConfig =le32_to_cpu(pnetwork->Configuration.DSConfig);
 	pnetwork->Configuration.FHConfig.DwellTime=le32_to_cpu(pnetwork->Configuration.FHConfig.DwellTime);
 	pnetwork->Configuration.FHConfig.HopPattern=le32_to_cpu(pnetwork->Configuration.FHConfig.HopPattern);
 	pnetwork->Configuration.FHConfig.HopSet=le32_to_cpu(pnetwork->Configuration.FHConfig.HopSet);
-	pnetwork->Configuration.FHConfig.Length=le32_to_cpu(pnetwork->Configuration.FHConfig.Length);
+	pnetwork->Configuration.FHConfig.Length=le32_to_cpu(pnetwork->Configuration.FHConfig.Length);	
 	pnetwork->Configuration.Length = le32_to_cpu(pnetwork->Configuration.Length);
 	pnetwork->InfrastructureMode = le32_to_cpu(pnetwork->InfrastructureMode);
 	pnetwork->IELength = le32_to_cpu(pnetwork->IELength);
 #endif
-
+	
 	_enter_critical_bh(&pmlmepriv->lock, &irqL);
-
-
+	
+	
 	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) )
 	{
 		psta = rtw_get_stainfo(&padapter->stapriv, pnetwork->MacAddress);
 		if(!psta)
 		{
 		psta = rtw_alloc_stainfo(&padapter->stapriv, pnetwork->MacAddress);
-		if (psta == NULL)
-		{
+		if (psta == NULL) 
+		{ 
 			RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\nCan't alloc sta_info when createbss_cmd_callback\n"));
 			goto createbss_cmd_fail ;
 		}
-		}
-
+		}	
+			
 		rtw_indicate_connect( padapter);
 	}
 	else
-	{
+	{	
 		_irqL	irqL;
 
 		pwlan = _rtw_alloc_network(pmlmepriv);
@@ -2907,13 +2907,13 @@ void rtw_createbss_cmd_callback(_adapter *padapter, struct cmd_obj *pcmd)
 				_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
 				goto createbss_cmd_fail;
 			}
-			pwlan->last_scanned = rtw_get_current_time();
-		}
+			pwlan->last_scanned = rtw_get_current_time();			
+		}	
 		else
 		{
 			rtw_list_insert_tail(&(pwlan->list), &pmlmepriv->scanned_queue.queue);
 		}
-
+				
 		pnetwork->Length = get_WLAN_BSSID_EX_sz(pnetwork);
 		_rtw_memcpy(&(pwlan->network), pnetwork, pnetwork->Length);
 		//pwlan->fixed = _TRUE;
@@ -2928,7 +2928,7 @@ void rtw_createbss_cmd_callback(_adapter *padapter, struct cmd_obj *pcmd)
 
 		_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
 
-#if 0
+#if 0		
 		if((pmlmepriv->fw_state) & WIFI_AP_STATE)
 		{
 			psta = rtw_alloc_stainfo(&padapter->stapriv, pnetwork->MacAddress);
@@ -2937,26 +2937,26 @@ void rtw_createbss_cmd_callback(_adapter *padapter, struct cmd_obj *pcmd)
 				RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\nCan't alloc sta_info when createbss_cmd_callback\n"));
 				goto createbss_cmd_fail ;
 			}
-
+			
 			rtw_indicate_connect( padapter);
 		}
 		else {
 
 			//rtw_indicate_disconnect(dev);
-		}
+		}		
 #endif
 		_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
 		// we will set _FW_LINKED when there is one more sat to join us (rtw_stassoc_event_callback)
-
+			
 	}
 
 createbss_cmd_fail:
-
+	
 	_exit_critical_bh(&pmlmepriv->lock, &irqL);
 
 	rtw_free_cmd_obj(pcmd);
-
-_func_exit_;
+	
+_func_exit_;	
 
 }
 
@@ -2964,71 +2964,72 @@ void rtw_createbss_cmd_callback(_adapter *padapter, struct cmd_obj *pcmd)
 
 void rtw_setstaKey_cmdrsp_callback(_adapter*	padapter ,  struct cmd_obj *pcmd)
 {
-
+	
 	struct sta_priv * pstapriv = &padapter->stapriv;
 	struct set_stakey_rsp* psetstakey_rsp = (struct set_stakey_rsp*) (pcmd->rsp);
 	struct sta_info*	psta = rtw_get_stainfo(pstapriv, psetstakey_rsp->addr);
 
-_func_enter_;
+_func_enter_;	
 
 	if(psta==NULL)
 	{
 		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\nERROR: rtw_setstaKey_cmdrsp_callback => can't get sta_info \n\n"));
 		goto exit;
 	}
-
+	
 	//psta->aid = psta->mac_id = psetstakey_rsp->keyid; //CAM_ID(CAM_ENTRY)
-
-exit:
+	
+exit:	
 
 	rtw_free_cmd_obj(pcmd);
-
-_func_exit_;
+	
+_func_exit_;	
 
 }
 void rtw_setassocsta_cmdrsp_callback(_adapter*	padapter,  struct cmd_obj *pcmd)
 {
 	_irqL	irqL;
 	struct sta_priv * pstapriv = &padapter->stapriv;
-	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;	
 	struct set_assocsta_parm* passocsta_parm = (struct set_assocsta_parm*)(pcmd->parmbuf);
-	struct set_assocsta_rsp* passocsta_rsp = (struct set_assocsta_rsp*) (pcmd->rsp);
+	struct set_assocsta_rsp* passocsta_rsp = (struct set_assocsta_rsp*) (pcmd->rsp);		
 	struct sta_info*	psta = rtw_get_stainfo(pstapriv, passocsta_parm->addr);
 
-_func_enter_;
-
+_func_enter_;	
+	
 	if(psta==NULL)
 	{
 		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\nERROR: setassocsta_cmdrsp_callbac => can't get sta_info \n\n"));
 		goto exit;
 	}
-
+	
 	psta->aid = psta->mac_id = passocsta_rsp->cam_id;
 
 	_enter_critical_bh(&pmlmepriv->lock, &irqL);
 
-	if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE) && (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == _TRUE))
+	if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE) && (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == _TRUE))           	
 		_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
 
-       set_fwstate(pmlmepriv, _FW_LINKED);
+       set_fwstate(pmlmepriv, _FW_LINKED);       	   
 	_exit_critical_bh(&pmlmepriv->lock, &irqL);
 
-exit:
+exit:	  
 	rtw_free_cmd_obj(pcmd);
 
-_func_exit_;
+_func_exit_;	  
 }
 
 void rtw_getrttbl_cmd_cmdrsp_callback(_adapter*	padapter,  struct cmd_obj *pcmd);
 void rtw_getrttbl_cmd_cmdrsp_callback(_adapter*	padapter,  struct cmd_obj *pcmd)
 {
-_func_enter_;
-
+_func_enter_;	
+	  
 	rtw_free_cmd_obj(pcmd);
 #ifdef CONFIG_MP_INCLUDED
 	padapter->mppriv.workparam.bcompleted=_TRUE;
 #endif
 
-_func_exit_;
+_func_exit_;	  
 
 }
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_debug.c b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_debug.c
old mode 100644
new mode 100755
index 2268c1a..f70fcb7
--- a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_debug.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_debug.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -68,11 +68,11 @@ int proc_get_drv_version(char *page, char **start,
 			  int *eof, void *data)
 {
 	struct net_device *dev = data;
-
+	
 	int len = 0;
 
 	len += snprintf(page + len, count - len, "%s\n", DRIVERVERSION);
-
+				
 	*eof = 1;
 	return len;
 }
@@ -84,7 +84,7 @@ int proc_get_log_level(char *page, char **start,
 	struct net_device *dev = data;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-
+	
 	int len = 0;
 
 	len += snprintf(page + len, count - len,
@@ -107,7 +107,7 @@ int proc_set_log_level(struct file *file, const char *buffer,
 	if (count < 1)
 		return -EFAULT;
 
-	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {		
 
 		int num = sscanf(tmp, "%d ", &is_signal_dbg);
 
@@ -117,16 +117,16 @@ int proc_set_log_level(struct file *file, const char *buffer,
 			printk("%d\n", GlobalDebugLevel);
 		}
 	}
-
+	
 	return count;
-
+	
 }
 
 #ifdef DBG_MEM_ALLOC
 int proc_get_mstat(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
-{
+{	
 	int len = 0;
 
 	len += _rtw_mstat_dump(page+len, count-len);
@@ -156,9 +156,9 @@ int proc_set_write_reg(struct file *file, const char *buffer,
 	{
 		DBG_871X("argument size is less than 3\n");
 		return -EFAULT;
-	}
+	}	
 
-	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {		
 
 		int num = sscanf(tmp, "%x %x %x", &addr, &val, &len);
 
@@ -170,23 +170,23 @@ int proc_set_write_reg(struct file *file, const char *buffer,
 		switch(len)
 		{
 			case 1:
-				rtw_write8(padapter, addr, (u8)val);
+				rtw_write8(padapter, addr, (u8)val);				
 				break;
 			case 2:
-				rtw_write16(padapter, addr, (u16)val);
+				rtw_write16(padapter, addr, (u16)val);				
 				break;
 			case 4:
-				rtw_write32(padapter, addr, val);
+				rtw_write32(padapter, addr, val);				
 				break;
 			default:
 				DBG_871X("error write length=%d", len);
 				break;
-		}
-
+		}			
+		
 	}
-
+	
 	return count;
-
+	
 }
 
 static u32 proc_get_read_addr=0xeeeeeeee;
@@ -195,21 +195,21 @@ int proc_set_write_reg(struct file *file, const char *buffer,
 int proc_get_read_reg(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
-{
+{	
 	struct net_device *dev = data;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
-
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
+	
 	int len = 0;
 
 	if(proc_get_read_addr==0xeeeeeeee)
 	{
 		*eof = 1;
 		return len;
-	}
+	}	
 
 	switch(proc_get_read_len)
 	{
-		case 1:
+		case 1:			
 			len += snprintf(page + len, count - len, "rtw_read8(0x%x)=0x%x\n", proc_get_read_addr, rtw_read8(padapter, proc_get_read_addr));
 			break;
 		case 2:
@@ -238,9 +238,9 @@ int proc_set_read_reg(struct file *file, const char *buffer,
 	{
 		DBG_871X("argument size is less than 2\n");
 		return -EFAULT;
-	}
+	}	
 
-	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {		
 
 		int num = sscanf(tmp, "%x %x", &addr, &len);
 
@@ -250,10 +250,10 @@ int proc_set_read_reg(struct file *file, const char *buffer,
 		}
 
 		proc_get_read_addr = addr;
-
+		
 		proc_get_read_len = len;
 	}
-
+	
 	return count;
 
 }
@@ -265,11 +265,11 @@ int proc_get_fwstate(char *page, char **start,
 	struct net_device *dev = data;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-
+	
 	int len = 0;
 
 	len += snprintf(page + len, count - len, "fwstate=0x%x\n", get_fwstate(pmlmepriv));
-
+				
 	*eof = 1;
 	return len;
 }
@@ -279,15 +279,15 @@ int proc_get_sec_info(char *page, char **start,
 			  int *eof, void *data)
 {
 	struct net_device *dev = data;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
-
+	
 	int len = 0;
 
-	len += snprintf(page + len, count - len, "auth_alg=0x%x, enc_alg=0x%x, auth_type=0x%x, enc_type=0x%x\n",
+	len += snprintf(page + len, count - len, "auth_alg=0x%x, enc_alg=0x%x, auth_type=0x%x, enc_type=0x%x\n", 
 						psecuritypriv->dot11AuthAlgrthm, psecuritypriv->dot11PrivacyAlgrthm,
 						psecuritypriv->ndisauthtype, psecuritypriv->ndisencryptstatus);
-
+				
 	*eof = 1;
 	return len;
 }
@@ -297,14 +297,14 @@ int proc_get_mlmext_state(char *page, char **start,
 			  int *eof, void *data)
 {
 	struct net_device *dev = data;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-
+	
 	int len = 0;
 
 	len += snprintf(page + len, count - len, "pmlmeinfo->state=0x%x\n", pmlmeinfo->state);
-
+				
 	*eof = 1;
 	return len;
 }
@@ -316,11 +316,11 @@ int proc_get_qos_option(char *page, char **start,
 	struct net_device *dev = data;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-
+	
 	int len = 0;
 
 	len += snprintf(page + len, count - len, "qos_option=%d\n", pmlmepriv->qospriv.qos_option);
-
+				
 	*eof = 1;
 	return len;
 
@@ -333,11 +333,11 @@ int proc_get_ht_option(char *page, char **start,
 	struct net_device *dev = data;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-
+	
 	int len = 0;
 
 	len += snprintf(page + len, count - len, "ht_option=%d\n", pmlmepriv->htpriv.ht_option);
-
+				
 	*eof = 1;
 	return len;
 }
@@ -378,29 +378,29 @@ int proc_get_ap_info(char *page, char **start,
 	{
 		int i;
 		struct recv_reorder_ctrl *preorder_ctrl;
-
-		len += snprintf(page + len, count - len, "SSID=%s\n", cur_network->network.Ssid.Ssid);
+					
+		len += snprintf(page + len, count - len, "SSID=%s\n", cur_network->network.Ssid.Ssid);		
 		len += snprintf(page + len, count - len, "sta's macaddr:" MAC_FMT "\n", MAC_ARG(psta->hwaddr));
-		len += snprintf(page + len, count - len, "cur_channel=%d, cur_bwmode=%d, cur_ch_offset=%d\n", pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
+		len += snprintf(page + len, count - len, "cur_channel=%d, cur_bwmode=%d, cur_ch_offset=%d\n", pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);		
 		len += snprintf(page + len, count - len, "rtsen=%d, cts2slef=%d\n", psta->rtsen, psta->cts2self);
-		len += snprintf(page + len, count - len, "qos_en=%d, ht_en=%d, init_rate=%d\n", psta->qos_option, psta->htpriv.ht_option, psta->init_rate);
-		len += snprintf(page + len, count - len, "state=0x%x, aid=%d, macid=%d, raid=%d\n", psta->state, psta->aid, psta->mac_id, psta->raid);
-		len += snprintf(page + len, count - len, "bwmode=%d, ch_offset=%d, sgi=%d\n", psta->htpriv.bwmode, psta->htpriv.ch_offset, psta->htpriv.sgi);
-		len += snprintf(page + len, count - len, "ampdu_enable = %d\n", psta->htpriv.ampdu_enable);
+		len += snprintf(page + len, count - len, "qos_en=%d, ht_en=%d, init_rate=%d\n", psta->qos_option, psta->htpriv.ht_option, psta->init_rate);	
+		len += snprintf(page + len, count - len, "state=0x%x, aid=%d, macid=%d, raid=%d\n", psta->state, psta->aid, psta->mac_id, psta->raid);	
+		len += snprintf(page + len, count - len, "bwmode=%d, ch_offset=%d, sgi=%d\n", psta->htpriv.bwmode, psta->htpriv.ch_offset, psta->htpriv.sgi);						
+		len += snprintf(page + len, count - len, "ampdu_enable = %d\n", psta->htpriv.ampdu_enable);	
 		len += snprintf(page + len, count - len, "agg_enable_bitmap=%x, candidate_tid_bitmap=%x\n", psta->htpriv.agg_enable_bitmap, psta->htpriv.candidate_tid_bitmap);
-
+					
 		for(i=0;i<16;i++)
-		{
+		{							
 			preorder_ctrl = &psta->recvreorder_ctrl[i];
 			if(preorder_ctrl->enable)
 			{
 				len += snprintf(page + len, count - len, "tid=%d, indicate_seq=%d\n", i, preorder_ctrl->indicate_seq);
 			}
-		}
-
+		}	
+							
 	}
 	else
-	{
+	{							
 		len += snprintf(page + len, count - len, "can't get sta's macaddr, cur_network's macaddr:" MAC_FMT "\n", MAC_ARG(cur_network->network.MacAddress));
 	}
 
@@ -416,15 +416,15 @@ int proc_get_adapter_state(char *page, char **start,
 	struct net_device *dev = data;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	int len = 0;
-
-	len += snprintf(page + len, count - len, "bSurpriseRemoved=%d, bDriverStopped=%d\n",
+	
+	len += snprintf(page + len, count - len, "bSurpriseRemoved=%d, bDriverStopped=%d\n", 
 						padapter->bSurpriseRemoved, padapter->bDriverStopped);
 
 	*eof = 1;
 	return len;
 
 }
-
+	
 int proc_get_trx_info(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -437,7 +437,7 @@ int proc_get_trx_info(char *page, char **start,
 	struct dvobj_priv	*pdvobj = adapter_to_dvobj(padapter);
         struct hw_xmit *phwxmit;
 	int len = 0;
-
+	
 	len += snprintf(page + len, count - len, "free_xmitbuf_cnt=%d, free_xmitframe_cnt=%d"
 				", free_ext_xmitbuf_cnt=%d, free_xframe_ext_cnt=%d"
 				", free_recvframe_cnt=%d\n",
@@ -457,7 +457,7 @@ int proc_get_trx_info(char *page, char **start,
 	len += snprintf(page + len, count - len, "continual_urb_error=%d\n", atomic_read(&pdvobj->continual_urb_error));
 #endif
 
-        for(i = 0; i < 4; i++)
+        for(i = 0; i < 4; i++) 
 	{
 		phwxmit = pxmitpriv->hwxmits + i;
 		len += snprintf(page + len, count - len, "%d, hwq.accnt=%d\n", i, phwxmit->accnt);
@@ -467,8 +467,8 @@ int proc_get_trx_info(char *page, char **start,
 	return len;
 
 }
-
-
+	
+		
 
 int proc_get_mac_reg_dump1(char *page, char **start,
 			  off_t offset, int count,
@@ -482,10 +482,10 @@ int proc_get_mac_reg_dump1(char *page, char **start,
 	len += snprintf(page + len, count - len, "\n======= MAC REG =======\n");
 
 	for(i=0x0;i<0x300;i+=4)
-	{
+	{	
 		if(j%4==1)	len += snprintf(page + len, count - len,"0x%02x",i);
-		len += snprintf(page + len, count - len," 0x%08x ",rtw_read32(padapter,i));
-		if((j++)%4 == 0)	len += snprintf(page + len, count - len,"\n");
+		len += snprintf(page + len, count - len," 0x%08x ",rtw_read32(padapter,i));		
+		if((j++)%4 == 0)	len += snprintf(page + len, count - len,"\n");	
 	}
 
 	*eof = 1;
@@ -505,12 +505,12 @@ int proc_get_mac_reg_dump2(char *page, char **start,
 	len += snprintf(page + len, count - len, "\n======= MAC REG =======\n");
 	memset(page, 0, count);
 	for(i=0x300;i<0x600;i+=4)
-	{
+	{	
 		if(j%4==1)	len += snprintf(page + len, count - len,"0x%02x",i);
-		len += snprintf(page + len, count - len," 0x%08x ",rtw_read32(padapter,i));
-		if((j++)%4 == 0)	len += snprintf(page + len, count - len,"\n");
+		len += snprintf(page + len, count - len," 0x%08x ",rtw_read32(padapter,i));		
+		if((j++)%4 == 0)	len += snprintf(page + len, count - len,"\n");	
 	}
-
+	
 	*eof = 1;
 	return len;
 
@@ -528,10 +528,10 @@ int proc_get_mac_reg_dump3(char *page, char **start,
 	len += snprintf(page + len, count - len, "\n======= MAC REG =======\n");
 
 	for(i=0x600;i<0x800;i+=4)
-	{
+	{	
 		if(j%4==1)	len += snprintf(page + len, count - len,"0x%02x",i);
-		len += snprintf(page + len, count - len," 0x%08x ",rtw_read32(padapter,i));
-		if((j++)%4 == 0)	len += snprintf(page + len, count - len,"\n");
+		len += snprintf(page + len, count - len," 0x%08x ",rtw_read32(padapter,i));		
+		if((j++)%4 == 0)	len += snprintf(page + len, count - len,"\n");	
 	}
 
 	*eof = 1;
@@ -544,19 +544,19 @@ int proc_get_bb_reg_dump1(char *page, char **start,
 			  int *eof, void *data)
 {
 	struct net_device *dev = data;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
 	int len = 0;
-	int i,j=1;
+	int i,j=1;		
 
-	len += snprintf(page + len, count - len, "\n======= BB REG =======\n");
+	len += snprintf(page + len, count - len, "\n======= BB REG =======\n");	
 	for(i=0x800;i<0xB00;i+=4)
 	{
-		if(j%4==1) 	len += snprintf(page + len, count - len,"0x%02x",i);
-		len += snprintf(page + len, count - len," 0x%08x ",rtw_read32(padapter,i));
-		if((j++)%4 == 0)	len += snprintf(page + len, count - len,"\n");
+		if(j%4==1) 	len += snprintf(page + len, count - len,"0x%02x",i);		
+		len += snprintf(page + len, count - len," 0x%08x ",rtw_read32(padapter,i));		
+		if((j++)%4 == 0)	len += snprintf(page + len, count - len,"\n");	
 	}
 	*eof = 1;
-	return len;
+	return len;	
 }
 
 int proc_get_bb_reg_dump2(char *page, char **start,
@@ -564,19 +564,19 @@ int proc_get_bb_reg_dump2(char *page, char **start,
 			  int *eof, void *data)
 {
 	struct net_device *dev = data;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
 	int len = 0;
-	int i,j=1;
+	int i,j=1;		
 
-	len += snprintf(page + len, count - len, "\n======= BB REG =======\n");
+	len += snprintf(page + len, count - len, "\n======= BB REG =======\n");	
 	for(i=0xB00;i<0xE00;i+=4)
 	{
-		if(j%4==1) 	len += snprintf(page + len, count - len,"0x%02x",i);
-		len += snprintf(page + len, count - len," 0x%08x ",rtw_read32(padapter,i));
-		if((j++)%4 == 0)	len += snprintf(page + len, count - len,"\n");
+		if(j%4==1) 	len += snprintf(page + len, count - len,"0x%02x",i);		
+		len += snprintf(page + len, count - len," 0x%08x ",rtw_read32(padapter,i));		
+		if((j++)%4 == 0)	len += snprintf(page + len, count - len,"\n");	
 	}
 	*eof = 1;
-	return len;
+	return len;	
 }
 
 int proc_get_bb_reg_dump3(char *page, char **start,
@@ -584,19 +584,19 @@ int proc_get_bb_reg_dump3(char *page, char **start,
 			  int *eof, void *data)
 {
 	struct net_device *dev = data;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
 	int len = 0;
-	int i,j=1;
+	int i,j=1;		
 
-	len += snprintf(page + len, count - len, "\n======= BB REG =======\n");
+	len += snprintf(page + len, count - len, "\n======= BB REG =======\n");	
 	for(i=0xE00;i<0x1000;i+=4)
 	{
-		if(j%4==1) 	len += snprintf(page + len, count - len,"0x%02x",i);
-		len += snprintf(page + len, count - len," 0x%08x ",rtw_read32(padapter,i));
-		if((j++)%4 == 0)	len += snprintf(page + len, count - len,"\n");
+		if(j%4==1) 	len += snprintf(page + len, count - len,"0x%02x",i);		
+		len += snprintf(page + len, count - len," 0x%08x ",rtw_read32(padapter,i));		
+		if((j++)%4 == 0)	len += snprintf(page + len, count - len,"\n");	
 	}
 	*eof = 1;
-	return len;
+	return len;	
 }
 
 int proc_get_rf_reg_dump1(char *page, char **start,
@@ -608,21 +608,21 @@ int proc_get_rf_reg_dump1(char *page, char **start,
 	int len = 0;
 	int i,j=1,path;
 	u32 value;
-
+	
 	len += snprintf(page + len, count - len, "\n======= RF REG =======\n");
 	path = 1;
 	len += snprintf(page + len, count - len, "\nRF_Path(%x)\n",path);
 	for(i=0;i<0xC0;i++)
-	{
+	{								
 		//value = PHY_QueryRFReg(padapter, (RF90_RADIO_PATH_E)path,i, bMaskDWord);
 		value =rtw_hal_read_rfreg(padapter, path, i, 0xffffffff);
 		if(j%4==1)	len += snprintf(page + len, count - len, "0x%02x ",i);
 		len += snprintf(page + len, count - len, " 0x%08x ",value);
-		if((j++)%4==0)	len += snprintf(page + len, count - len, "\n");
+		if((j++)%4==0)	len += snprintf(page + len, count - len, "\n");	
 	}
 
 	*eof = 1;
-	return len;
+	return len;	
 }
 
 
@@ -634,21 +634,21 @@ int proc_get_rf_reg_dump2(char *page, char **start,
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	int len = 0;
 	int i,j=1,path;
-	u32 value;
+	u32 value;	
 
-	len += snprintf(page + len, count - len, "\n======= RF REG =======\n");
+	len += snprintf(page + len, count - len, "\n======= RF REG =======\n");	
 	path = 1;
 	len += snprintf(page + len, count - len, "\nRF_Path(%x)\n",path);
 	for(i=0xC0;i<0x100;i++)
-	{
+	{								
 		//value = PHY_QueryRFReg(padapter, (RF90_RADIO_PATH_E)path,i, bMaskDWord);
 		value =rtw_hal_read_rfreg(padapter, path, i, 0xffffffff);
 		if(j%4==1)	len += snprintf(page + len, count - len, "0x%02x ",i);
 		len += snprintf(page + len, count - len, " 0x%08x ",value);
-		if((j++)%4==0)	len += snprintf(page + len, count - len, "\n");
+		if((j++)%4==0)	len += snprintf(page + len, count - len, "\n");	
 	}
 	*eof = 1;
-	return len;
+	return len;	
 }
 
 
@@ -660,22 +660,22 @@ int proc_get_rf_reg_dump3(char *page, char **start,
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	int len = 0;
 	int i,j=1,path;
-	u32 value;
+	u32 value;	
 
 	len += snprintf(page + len, count - len, "\n======= RF REG =======\n");
 	path = 2;
 	len += snprintf(page + len, count - len, "\nRF_Path(%x)\n",path);
 	for(i=0;i<0xC0;i++)
-	{
+	{								
 		//value = PHY_QueryRFReg(padapter, (RF90_RADIO_PATH_E)path,i, bMaskDWord);
 		value =rtw_hal_read_rfreg(padapter, path, i, 0xffffffff);
 		if(j%4==1)	len += snprintf(page + len, count - len, "0x%02x ",i);
 		len += snprintf(page + len, count - len, " 0x%08x ",value);
-		if((j++)%4==0)	len += snprintf(page + len, count - len, "\n");
+		if((j++)%4==0)	len += snprintf(page + len, count - len, "\n");	
 	}
 
 	*eof = 1;
-	return len;
+	return len;	
 }
 
 
@@ -693,7 +693,7 @@ int proc_get_rf_reg_dump4(char *page, char **start,
 	path = 2;
 	len += snprintf(page + len, count - len, "\nRF_Path(%x)\n",path);
 	for(i=0xC0;i<0x100;i++)
-	{
+	{								
 		//value = PHY_QueryRFReg(padapter, (RF90_RADIO_PATH_E)path,i, bMaskDWord);
 		value =rtw_hal_read_rfreg(padapter, path, i, 0xffffffff);
 		if(j%4==1)	len += snprintf(page + len, count - len, "0x%02x ",i);
@@ -701,11 +701,11 @@ int proc_get_rf_reg_dump4(char *page, char **start,
 		if((j++)%4==0)	len += snprintf(page + len, count - len, "\n");
 	}
 	*eof = 1;
-	return len;
+	return len;	
 }
 
 
-
+		
 int proc_get_rx_signal(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -713,7 +713,7 @@ int proc_get_rx_signal(char *page, char **start,
 	struct net_device *dev = data;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-
+	
 	int len = 0;
 
 	len += snprintf(page + len, count - len,
@@ -721,14 +721,14 @@ int proc_get_rx_signal(char *page, char **start,
 		"rxpwdb:%d\n"
 		"signal_strength:%u\n"
 		"signal_qual:%u\n"
-		"noise:%u\n",
+		"noise:%u\n", 
 		padapter->recvpriv.rssi,
 		padapter->recvpriv.rxpwdb,
 		padapter->recvpriv.signal_strength,
 		padapter->recvpriv.signal_qual,
 		padapter->recvpriv.noise
 		);
-
+				
 	*eof = 1;
 	return len;
 }
@@ -744,15 +744,15 @@ int proc_set_rx_signal(struct file *file, const char *buffer,
 	if (count < 1)
 		return -EFAULT;
 
-	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {		
 
 		int num = sscanf(tmp, "%u %u", &is_signal_dbg, &signal_strength);
 
 		is_signal_dbg = is_signal_dbg==0?0:1;
-
+		
 		if(is_signal_dbg && num!=2)
 			return count;
-
+			
 		signal_strength = signal_strength>100?100:signal_strength;
 		signal_strength = signal_strength<0?0:signal_strength;
 
@@ -763,11 +763,11 @@ int proc_set_rx_signal(struct file *file, const char *buffer,
 			DBG_871X("set %s %u\n", "DBG_SIGNAL_STRENGTH", signal_strength);
 		else
 			DBG_871X("set %s\n", "HW_SIGNAL_STRENGTH");
-
+		
 	}
-
+	
 	return count;
-
+	
 }
 
 int proc_get_ht_enable(char *page, char **start,
@@ -777,9 +777,9 @@ int proc_get_ht_enable(char *page, char **start,
 	struct net_device *dev = data;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct registry_priv	*pregpriv = &padapter->registrypriv;
-
+	
 	int len = 0;
-
+	
 	if(pregpriv)
 		len += snprintf(page + len, count - len,
 			"%d\n",
@@ -802,7 +802,7 @@ int proc_set_ht_enable(struct file *file, const char *buffer,
 	if (count < 1)
 		return -EFAULT;
 
-	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {		
 
 		int num = sscanf(tmp, "%d ", &mode);
 
@@ -812,9 +812,9 @@ int proc_set_ht_enable(struct file *file, const char *buffer,
 			printk("ht_enable=%d\n", pregpriv->ht_enable);
 		}
 	}
-
+	
 	return count;
-
+	
 }
 
 
@@ -825,9 +825,9 @@ int proc_get_cbw40_enable(char *page, char **start,
 	struct net_device *dev = data;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct registry_priv	*pregpriv = &padapter->registrypriv;
-
+	
 	int len = 0;
-
+	
 	if(pregpriv)
 		len += snprintf(page + len, count - len,
 			"%d\n",
@@ -850,7 +850,7 @@ int proc_set_cbw40_enable(struct file *file, const char *buffer,
 	if (count < 1)
 		return -EFAULT;
 
-	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {		
 
 		int num = sscanf(tmp, "%d ", &mode);
 
@@ -860,9 +860,9 @@ int proc_set_cbw40_enable(struct file *file, const char *buffer,
 			printk("cbw40_enable=%d\n", mode);
 		}
 	}
-
+	
 	return count;
-
+	
 }
 
 int proc_get_ampdu_enable(char *page, char **start,
@@ -872,9 +872,9 @@ int proc_get_ampdu_enable(char *page, char **start,
 	struct net_device *dev = data;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct registry_priv	*pregpriv = &padapter->registrypriv;
-
+	
 	int len = 0;
-
+	
 	if(pregpriv)
 		len += snprintf(page + len, count - len,
 			"%d\n",
@@ -897,7 +897,7 @@ int proc_set_ampdu_enable(struct file *file, const char *buffer,
 	if (count < 1)
 		return -EFAULT;
 
-	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {		
 
 		int num = sscanf(tmp, "%d ", &mode);
 
@@ -907,9 +907,9 @@ int proc_set_ampdu_enable(struct file *file, const char *buffer,
 			printk("ampdu_enable=%d\n", mode);
 		}
 	}
-
+	
 	return count;
-
+	
 }
 
 
@@ -919,9 +919,9 @@ int proc_get_two_path_rssi(char *page, char **start,
 {
 	struct net_device *dev = data;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
-
+	
 	int len = 0;
-
+	
 	if(padapter)
 		len += snprintf(page + len, count - len,
 			"%d %d\n",
@@ -940,9 +940,9 @@ int proc_get_rx_stbc(char *page, char **start,
 	struct net_device *dev = data;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct registry_priv	*pregpriv = &padapter->registrypriv;
-
+	
 	int len = 0;
-
+	
 	if(pregpriv)
 		len += snprintf(page + len, count - len,
 			"%d\n",
@@ -965,7 +965,7 @@ int proc_set_rx_stbc(struct file *file, const char *buffer,
 	if (count < 1)
 		return -EFAULT;
 
-	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {		
 
 		int num = sscanf(tmp, "%d ", &mode);
 
@@ -975,9 +975,9 @@ int proc_set_rx_stbc(struct file *file, const char *buffer,
 			printk("rx_stbc=%d\n", mode);
 		}
 	}
-
+	
 	return count;
-
+	
 }
 
 int proc_get_vid(char *page, char **start,
@@ -989,14 +989,14 @@ int proc_get_vid(char *page, char **start,
 	u16 VID=0;
 	int len = 0;
 
-	rtw_hal_get_hwreg(padapter, HW_VAR_VID, (u8 *)&VID);
+	rtw_hal_get_hwreg(padapter, HW_VAR_VID, (u8 *)&VID);	
 	len += snprintf(page + len, count - len,
 		"%04x\n",
 		VID
 		);
 
 	*eof = 1;
-	return len;
+	return len;	
 }
 
 int proc_get_pid(char *page, char **start,
@@ -1005,17 +1005,17 @@ int proc_get_pid(char *page, char **start,
 {
 	struct net_device *dev = data;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
-	u16 PID=0;
+	u16 PID=0;	
 	int len = 0;
 
-	rtw_hal_get_hwreg(padapter, HW_VAR_PID, (u8 *)&PID);
+	rtw_hal_get_hwreg(padapter, HW_VAR_PID, (u8 *)&PID);		
 	len += snprintf(page + len, count - len,
 		"%04x\n",
 		PID
 		);
 
 	*eof = 1;
-	return len;
+	return len;	
 }
 
 int proc_get_rssi_disp(char *page, char **start,
@@ -1038,9 +1038,9 @@ int proc_set_rssi_disp(struct file *file, const char *buffer,
 	{
 		DBG_8192C("argument size is less than 1\n");
 		return -EFAULT;
-	}
+	}	
 
-	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {		
 
 		int num = sscanf(tmp, "%x", &enable);
 
@@ -1048,25 +1048,25 @@ int proc_set_rssi_disp(struct file *file, const char *buffer,
 			DBG_8192C("invalid set_rssi_disp parameter!\n");
 			return count;
 		}
-
+		
 		if(enable)
-		{
+		{			
 			DBG_8192C("Turn On Rx RSSI Display Function\n");
-			padapter->bRxRSSIDisplay = enable ;
+			padapter->bRxRSSIDisplay = enable ;			
 		}
 		else
 		{
 			DBG_8192C("Turn Off Rx RSSI Display Function\n");
 			padapter->bRxRSSIDisplay = 0 ;
 		}
-
+	
 	}
-
+	
 	return count;
+	
+}	
 
-}
-
-
+		
 #ifdef CONFIG_AP_MODE
 
 int proc_get_all_sta_info(char *page, char **start,
@@ -1081,18 +1081,18 @@ int proc_get_all_sta_info(char *page, char **start,
 	int i, j;
 	_list	*plist, *phead;
 	struct recv_reorder_ctrl *preorder_ctrl;
-	int len = 0;
-
+	int len = 0;	
+						
 
 	len += snprintf(page + len, count - len, "sta_dz_bitmap=0x%x, tim_bitmap=0x%x\n", pstapriv->sta_dz_bitmap, pstapriv->tim_bitmap);
-
+					
 	_enter_critical_bh(&pstapriv->sta_hash_lock, &irqL);
 
 	for(i=0; i< NUM_STA; i++)
 	{
 		phead = &(pstapriv->sta_hash[i]);
 		plist = get_next(phead);
-
+		
 		while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
 		{
 			psta = LIST_CONTAINOR(plist, struct sta_info, hash_list);
@@ -1103,10 +1103,10 @@ int proc_get_all_sta_info(char *page, char **start,
 			{
 				len += snprintf(page + len, count - len, "sta's macaddr:" MAC_FMT "\n", MAC_ARG(psta->hwaddr));
 				len += snprintf(page + len, count - len, "rtsen=%d, cts2slef=%d\n", psta->rtsen, psta->cts2self);
-				len += snprintf(page + len, count - len, "qos_en=%d, ht_en=%d, init_rate=%d\n", psta->qos_option, psta->htpriv.ht_option, psta->init_rate);
-				len += snprintf(page + len, count - len, "state=0x%x, aid=%d, macid=%d, raid=%d\n", psta->state, psta->aid, psta->mac_id, psta->raid);
-				len += snprintf(page + len, count - len, "bwmode=%d, ch_offset=%d, sgi=%d\n", psta->htpriv.bwmode, psta->htpriv.ch_offset, psta->htpriv.sgi);
-				len += snprintf(page + len, count - len, "ampdu_enable = %d\n", psta->htpriv.ampdu_enable);
+				len += snprintf(page + len, count - len, "qos_en=%d, ht_en=%d, init_rate=%d\n", psta->qos_option, psta->htpriv.ht_option, psta->init_rate);	
+				len += snprintf(page + len, count - len, "state=0x%x, aid=%d, macid=%d, raid=%d\n", psta->state, psta->aid, psta->mac_id, psta->raid);	
+				len += snprintf(page + len, count - len, "bwmode=%d, ch_offset=%d, sgi=%d\n", psta->htpriv.bwmode, psta->htpriv.ch_offset, psta->htpriv.sgi);						
+				len += snprintf(page + len, count - len, "ampdu_enable = %d\n", psta->htpriv.ampdu_enable);									
 				len += snprintf(page + len, count - len, "agg_enable_bitmap=%x, candidate_tid_bitmap=%x\n", psta->htpriv.agg_enable_bitmap, psta->htpriv.candidate_tid_bitmap);
 				len += snprintf(page + len, count - len, "sleepq_len=%d\n", psta->sleepq_len);
 				len += snprintf(page + len, count - len, "capability=0x%x\n", psta->capability);
@@ -1116,30 +1116,30 @@ int proc_get_all_sta_info(char *page, char **start,
 				len += snprintf(page + len, count - len, "wpa2_pairwise_cipher=0x%x\n", psta->wpa2_pairwise_cipher);
 				len += snprintf(page + len, count - len, "qos_info=0x%x\n", psta->qos_info);
 				len += snprintf(page + len, count - len, "dot118021XPrivacy=0x%x\n", psta->dot118021XPrivacy);
-
+								
 				for(j=0;j<16;j++)
-				{
+				{							
 					preorder_ctrl = &psta->recvreorder_ctrl[j];
 					if(preorder_ctrl->enable)
 					{
 						len += snprintf(page + len, count - len, "tid=%d, indicate_seq=%d\n", j, preorder_ctrl->indicate_seq);
 					}
-				}
-
-			}
-
+				}		
+									
+			}							
+			
 		}
-
+		
 	}
-
+	
 	_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);
 
 	*eof = 1;
 	return len;
 
 }
-
-#endif
+	
+#endif		
 
 #ifdef DBG_MEMORY_LEAK
 #include <asm/atomic.h>
@@ -1150,12 +1150,12 @@ int proc_get_malloc_cnt(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
 {
-
+	
 	int len = 0;
 
 	len += snprintf(page + len, count - len, "_malloc_cnt=%d\n", atomic_read(&_malloc_cnt));
 	len += snprintf(page + len, count - len, "_malloc_size=%d\n", atomic_read(&_malloc_size));
-
+				
 	*eof = 1;
 	return len;
 }
@@ -1177,8 +1177,8 @@ int proc_get_best_channel(char *page, char **start,
 			index_24G = i;
 		if ( pmlmeext->channel_set[i].ChannelNum == 36)
 			index_5G = i;
-	}
-
+	}	
+	
 	for (i=0; pmlmeext->channel_set[i].ChannelNum !=0; i++) {
 		// 2.4G
 		if ( pmlmeext->channel_set[i].ChannelNum == 6 ) {
@@ -1209,11 +1209,11 @@ int proc_get_best_channel(char *page, char **start,
 			}
 		}
 #if 1 // debug
-		len += snprintf(page + len, count - len, "The rx cnt of channel %3d = %d\n",
+		len += snprintf(page + len, count - len, "The rx cnt of channel %3d = %d\n", 
 					pmlmeext->channel_set[i].ChannelNum, pmlmeext->channel_set[i].rx_count);
 #endif
 	}
-
+	
 	len += snprintf(page + len, count - len, "best_channel_5G = %d\n", best_channel_5G);
 	len += snprintf(page + len, count - len, "best_channel_24G = %d\n", best_channel_24G);
 
@@ -1255,9 +1255,9 @@ int proc_get_sreset(char *page, char **start, off_t offset, int count, int *eof,
 	struct net_device *dev = data;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-
+	
 	int len = 0;
-
+	
 	*eof = 1;
 	return len;
 }
@@ -1272,7 +1272,7 @@ int proc_set_sreset(struct file *file, const char *buffer, unsigned long count,
 	if (count < 1)
 		return -EFAULT;
 
-	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {		
 
 		int num = sscanf(tmp, "%d", &trigger_point);
 
@@ -1281,9 +1281,9 @@ int proc_set_sreset(struct file *file, const char *buffer, unsigned long count,
 		else
 			sreset_set_trigger_point(padapter, trigger_point);
 	}
-
+	
 	return count;
-
+	
 }
 #endif /* DBG_CONFIG_ERROR_DETECT */
 
@@ -1328,9 +1328,10 @@ int proc_set_dm_adaptivity(struct file *file, const char *buffer,
 
 		dm_adaptivity_set_parm(padapter, (s8)TH_L2H_ini, TH_EDCCA_HL_diff, (s8)IGI_Base, (bool)ForceEDCCA, AdapEn_RSSI, IGI_LowerBound);
 	}
-
+	
 	return count;
 }
 #endif /* CONFIG_DM_ADAPTIVITY */
 
 #endif
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_eeprom.c b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_eeprom.c
old mode 100644
new mode 100755
index c0a6b54..fd07d64
--- a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_eeprom.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_eeprom.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -31,7 +31,7 @@ void up_clk(_adapter*	padapter,	 u16 *x)
 	rtw_udelay_os(CLOCK_RATE);
 
 _func_exit_;
-
+	
 }
 
 void down_clk(_adapter *	padapter, u16 *x	)
@@ -40,7 +40,7 @@ void down_clk(_adapter *	padapter, u16 *x	)
 	*x = *x & ~_EESK;
 	rtw_write8(padapter, EE_9346CR, (u8)*x);
 	rtw_udelay_os(CLOCK_RATE);
-_func_exit_;
+_func_exit_;	
 }
 
 void shift_out_bits(_adapter * padapter, u16 data, u16 count)
@@ -78,14 +78,14 @@ void shift_out_bits(_adapter * padapter, u16 data, u16 count)
 	}
 	x &= ~_EEDI;
 	rtw_write8(padapter, EE_9346CR, (u8)x);
-out:
-_func_exit_;
+out:	
+_func_exit_;		
 }
 
 u16 shift_in_bits (_adapter * padapter)
 {
 	u16 x,d=0,i;
-_func_enter_;
+_func_enter_;	
 	if(padapter->bSurpriseRemoved==_TRUE){
 		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
 		goto out;
@@ -111,8 +111,8 @@ u16 shift_in_bits (_adapter * padapter)
 
 		down_clk(padapter, &x);
 	}
-out:
-_func_exit_;
+out:	
+_func_exit_;		
 
 	return d;
 }
@@ -120,7 +120,7 @@ u16 shift_in_bits (_adapter * padapter)
 void standby(_adapter *	padapter	)
 {
 	u8   x;
-_func_enter_;
+_func_enter_;	
 	x = rtw_read8(padapter, EE_9346CR);
 
 	x &= ~(_EECS | _EESK);
@@ -130,16 +130,16 @@ void standby(_adapter *	padapter	)
 	x |= _EECS;
 	rtw_write8(padapter, EE_9346CR, x);
 	rtw_udelay_os(CLOCK_RATE);
-_func_exit_;
+_func_exit_;		
 }
 
 u16 wait_eeprom_cmd_done(_adapter* padapter)
 {
 	u8 	x;
 	u16	i,res=_FALSE;
-_func_enter_;
+_func_enter_;	
 	standby(padapter );
-	for (i=0; i<200; i++)
+	for (i=0; i<200; i++) 
 	{
 		x = rtw_read8(padapter, EE_9346CR);
 		if (x & _EEDO){
@@ -148,15 +148,15 @@ u16 wait_eeprom_cmd_done(_adapter* padapter)
 			}
 		rtw_udelay_os(CLOCK_RATE);
 	}
-exit:
-_func_exit_;
+exit:	
+_func_exit_;			
 	return res;
 }
 
 void eeprom_clean(_adapter * padapter)
 {
 	u16 x;
-_func_enter_;
+_func_enter_;		
 	if(padapter->bSurpriseRemoved==_TRUE){
 		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
 		goto out;
@@ -178,8 +178,8 @@ void eeprom_clean(_adapter * padapter)
 		goto out;
 	}
 	down_clk(padapter, &x);
-out:
-_func_exit_;
+out:	
+_func_exit_;			
 }
 
 void eeprom_write16(_adapter * padapter, u16 reg, u16 data)
@@ -189,7 +189,7 @@ void eeprom_write16(_adapter * padapter, u16 reg, u16 data)
 	u8	tmp8_ori,tmp8_new,tmp8_clk_ori,tmp8_clk_new;
 	tmp8_ori=rtw_read8(padapter, 0x102502f1);
 	tmp8_new=tmp8_ori & 0xf7;
-	if(tmp8_ori != tmp8_new){
+	if(tmp8_ori != tmp8_new){	
 		rtw_write8(padapter, 0x102502f1, tmp8_new);
 		RT_TRACE(_module_rtl871x_mp_ioctl_c_,_drv_err_,("====write 0x102502f1=====\n"));
 	}
@@ -198,10 +198,10 @@ void eeprom_write16(_adapter * padapter, u16 reg, u16 data)
 	if(tmp8_clk_new!=tmp8_clk_ori){
 		RT_TRACE(_module_rtl871x_mp_ioctl_c_,_drv_err_,("====write 0x10250003=====\n"));
 		rtw_write8(padapter, 0x10250003, tmp8_clk_new);
-	}
+	}	
 #endif
-_func_enter_;
-
+_func_enter_;		
+	
 	x = rtw_read8(padapter, EE_9346CR);
 
 	x &= ~(_EEDI | _EEDO | _EESK | _EEM0);
@@ -209,12 +209,12 @@ void eeprom_write16(_adapter * padapter, u16 reg, u16 data)
 	rtw_write8(padapter, EE_9346CR, x);
 
 	shift_out_bits(padapter, EEPROM_EWEN_OPCODE, 5);
-
+	
 	if(padapter->EepromAddressSize==8)	//CF+ and SDIO
 		shift_out_bits(padapter, 0, 6);
 	else									//USB
 		shift_out_bits(padapter, 0, 4);
-
+	
 	standby( padapter);
 
 // Commented out by rcnjko, 2004.0
@@ -223,7 +223,7 @@ void eeprom_write16(_adapter * padapter, u16 reg, u16 data)
 //	shift_out_bits(Adapter, EEPROM_ERASE_OPCODE, 3);
 //	shift_out_bits(Adapter, reg, Adapter->EepromAddressSize);
 //
-//	if (wait_eeprom_cmd_done(Adapter ) == FALSE)
+//	if (wait_eeprom_cmd_done(Adapter ) == FALSE) 
 //	{
 //		return;
 //	}
@@ -242,7 +242,7 @@ void eeprom_write16(_adapter * padapter, u16 reg, u16 data)
 	// write the data to the selected EEPROM word.
 	shift_out_bits(padapter, data, 16);
 
-	if (wait_eeprom_cmd_done(padapter ) == _FALSE)
+	if (wait_eeprom_cmd_done(padapter ) == _FALSE) 
 	{
 
 		goto exit;
@@ -254,7 +254,7 @@ void eeprom_write16(_adapter * padapter, u16 reg, u16 data)
 	shift_out_bits(padapter, reg, 4);
 
 	eeprom_clean(padapter );
-exit:
+exit:	
 #ifdef CONFIG_RTL8712
 	if(tmp8_clk_new!=tmp8_clk_ori)
 		rtw_write8(padapter, 0x10250003, tmp8_clk_ori);
@@ -262,7 +262,7 @@ void eeprom_write16(_adapter * padapter, u16 reg, u16 data)
 		rtw_write8(padapter, 0x102502f1, tmp8_ori);
 
 #endif
-_func_exit_;
+_func_exit_;	
 	return;
 }
 
@@ -275,7 +275,7 @@ u16 eeprom_read16(_adapter * padapter, u16 reg) //ReadEEprom
 	u8	tmp8_ori,tmp8_new,tmp8_clk_ori,tmp8_clk_new;
 	tmp8_ori= rtw_read8(padapter, 0x102502f1);
 	tmp8_new = tmp8_ori & 0xf7;
-	if(tmp8_ori != tmp8_new){
+	if(tmp8_ori != tmp8_new){	
 		rtw_write8(padapter, 0x102502f1, tmp8_new);
 		RT_TRACE(_module_rtl871x_mp_ioctl_c_,_drv_err_,("====write 0x102502f1=====\n"));
 	}
@@ -284,9 +284,9 @@ u16 eeprom_read16(_adapter * padapter, u16 reg) //ReadEEprom
 	if(tmp8_clk_new!=tmp8_clk_ori){
 		RT_TRACE(_module_rtl871x_mp_ioctl_c_,_drv_err_,("====write 0x10250003=====\n"));
 		rtw_write8(padapter, 0x10250003, tmp8_clk_new);
-	}
+	}	
 #endif
-_func_enter_;
+_func_enter_;		
 
 	if(padapter->bSurpriseRemoved==_TRUE){
 		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
@@ -313,7 +313,7 @@ u16 eeprom_read16(_adapter * padapter, u16 reg) //ReadEEprom
 	data = shift_in_bits(padapter);
 
 	eeprom_clean(padapter);
-out:
+out:	
 #ifdef CONFIG_RTL8712
 	if(tmp8_clk_new!=tmp8_clk_ori)
 		rtw_write8(padapter, 0x10250003, tmp8_clk_ori);
@@ -321,7 +321,7 @@ u16 eeprom_read16(_adapter * padapter, u16 reg) //ReadEEprom
 		rtw_write8(padapter, 0x102502f1, tmp8_ori);
 
 #endif
-_func_exit_;
+_func_exit_;		
 	return data;
 
 
@@ -331,12 +331,12 @@ u16 eeprom_read16(_adapter * padapter, u16 reg) //ReadEEprom
 
 
 //From even offset
-void eeprom_read_sz(_adapter * padapter, u16 reg, u8* data, u32 sz)
+void eeprom_read_sz(_adapter * padapter, u16 reg, u8* data, u32 sz) 
 {
 
 	u16 x, data16;
 	u32 i;
-_func_enter_;
+_func_enter_;		
 	if(padapter->bSurpriseRemoved==_TRUE){
 		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("padapter->bSurpriseRemoved==_TRUE"));
 		goto out;
@@ -363,12 +363,12 @@ void eeprom_read_sz(_adapter * padapter, u16 reg, u8* data, u32 sz)
 	{
 		data16 = shift_in_bits(padapter);
 		data[i] = data16 & 0xff;
-		data[i+1] = data16 >>8;
+		data[i+1] = data16 >>8;		
 	}
 
 	eeprom_clean(padapter);
-out:
-_func_exit_;
+out:	
+_func_exit_;		
 
 
 
@@ -380,7 +380,7 @@ u8 eeprom_read(_adapter * padapter, u32 addr_off, u8 sz, u8* rbuf)
 {
 	u8 quotient, remainder, addr_2align_odd;
 	u16 reg, stmp , i=0, idx = 0;
-_func_enter_;
+_func_enter_;		
 	reg = (u16)(addr_off >> 1);
 	addr_2align_odd = (u8)(addr_off & 0x1);
 
@@ -390,7 +390,7 @@ u8 eeprom_read(_adapter * padapter, u32 addr_off, u8 sz, u8* rbuf)
 		rbuf[idx++] = (u8) ((stmp>>8)&0xff); //return hogh-part of the short
 		reg++; sz--;
 	}
-
+	
 	quotient = sz >> 1;
 	remainder = sz & 0x1;
 
@@ -400,13 +400,13 @@ u8 eeprom_read(_adapter * padapter, u32 addr_off, u8 sz, u8* rbuf)
 		rbuf[idx++] = (u8) (stmp&0xff);
 		rbuf[idx++] = (u8) ((stmp>>8)&0xff);
 	}
-
+	
 	reg = reg+i;
 	if(remainder){ //end of read at lower part of short : 0,2,4,6,...
 		stmp = eeprom_read16(padapter, reg);
-		rbuf[idx] = (u8)(stmp & 0xff);
+		rbuf[idx] = (u8)(stmp & 0xff); 
 	}
-_func_exit_;
+_func_exit_;		
 	return _TRUE;
 }
 
@@ -415,8 +415,9 @@ u8 eeprom_read(_adapter * padapter, u32 addr_off, u8 sz, u8* rbuf)
 VOID read_eeprom_content(_adapter *	padapter)
 {
 
-_func_enter_;
+_func_enter_;		
 
 
-_func_exit_;
+_func_exit_;		
 }
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_ieee80211.c b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_ieee80211.c
old mode 100644
new mode 100755
index 9470d72..6305ba3
--- a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_ieee80211.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_ieee80211.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -47,16 +47,16 @@
 u8 RSN_CIPHER_SUITE_CCMP[] = { 0x00, 0x0f, 0xac, 4 };
 u8 RSN_CIPHER_SUITE_WEP104[] = { 0x00, 0x0f, 0xac, 5 };
 //-----------------------------------------------------------
-// for adhoc-master to generate ie and provide supported-rate to fw
+// for adhoc-master to generate ie and provide supported-rate to fw 
 //-----------------------------------------------------------
 
-static u8 	WIFI_CCKRATES[] =
+static u8 	WIFI_CCKRATES[] = 
 {(IEEE80211_CCK_RATE_1MB | IEEE80211_BASIC_RATE_MASK),
  (IEEE80211_CCK_RATE_2MB | IEEE80211_BASIC_RATE_MASK),
  (IEEE80211_CCK_RATE_5MB | IEEE80211_BASIC_RATE_MASK),
  (IEEE80211_CCK_RATE_11MB | IEEE80211_BASIC_RATE_MASK)};
 
-static u8 	WIFI_OFDMRATES[] =
+static u8 	WIFI_OFDMRATES[] = 
 {(IEEE80211_OFDM_RATE_6MB),
  (IEEE80211_OFDM_RATE_9MB),
  (IEEE80211_OFDM_RATE_12MB),
@@ -81,17 +81,17 @@ int rtw_get_bit_value_from_ieee_value(u8 val)
 }
 
 uint	rtw_is_cckrates_included(u8 *rate)
-{
-		u32	i = 0;
+{	
+		u32	i = 0;			
 
 		while(rate[i]!=0)
-		{
-			if  (  (((rate[i]) & 0x7f) == 2)	|| (((rate[i]) & 0x7f) == 4) ||
-			(((rate[i]) & 0x7f) == 11)  || (((rate[i]) & 0x7f) == 22) )
-			return _TRUE;
+		{		
+			if  (  (((rate[i]) & 0x7f) == 2)	|| (((rate[i]) & 0x7f) == 4) ||		
+			(((rate[i]) & 0x7f) == 11)  || (((rate[i]) & 0x7f) == 22) )		
+			return _TRUE;	
 			i++;
 		}
-
+		
 		return _FALSE;
 }
 
@@ -105,11 +105,11 @@ uint	rtw_is_cckratesonly_included(u8 *rate)
 			if  (  (((rate[i]) & 0x7f) != 2) && (((rate[i]) & 0x7f) != 4) &&
 				(((rate[i]) & 0x7f) != 11)  && (((rate[i]) & 0x7f) != 22) )
 
-			return _FALSE;
+			return _FALSE;		
 
 			i++;
 	}
-
+	
 	return _TRUE;
 
 }
@@ -122,17 +122,17 @@ int rtw_check_network_type(unsigned char *rate, int ratelen, int channel)
 			return WIRELESS_INVALID;
 		else
 			return WIRELESS_11A;
-	}
+	}	
 	else  // could be pure B, pure G, or B/G
 	{
-		if ((rtw_is_cckratesonly_included(rate)) == _TRUE)
+		if ((rtw_is_cckratesonly_included(rate)) == _TRUE)	
 			return WIRELESS_11B;
 		else if((rtw_is_cckrates_included(rate)) == _TRUE)
 			return 	WIRELESS_11BG;
 		else
 			return WIRELESS_11G;
 	}
-
+	
 }
 
 u8 *rtw_set_fixed_ie(unsigned char *pbuf, unsigned int len, unsigned char *source,
@@ -146,10 +146,10 @@ u8 *rtw_set_fixed_ie(unsigned char *pbuf, unsigned int len, unsigned char *sourc
 // rtw_set_ie will update frame length
 u8 *rtw_set_ie
 (
-	u8 *pbuf,
-	sint index,
+	u8 *pbuf, 
+	sint index, 
 	uint len,
-	u8 *source,
+	u8 *source, 
 	uint *frlen //frame length
 )
 {
@@ -160,11 +160,11 @@ u8 *rtw_set_fixed_ie(unsigned char *pbuf, unsigned int len, unsigned char *sourc
 
 	if (len > 0)
 		_rtw_memcpy((void *)(pbuf + 2), (void *)source, len);
-
+	
 	*frlen = *frlen + (len + 2);
-
+	
 	return (pbuf + len + 2);
-_func_exit_;
+_func_exit_;	
 }
 
 inline u8 *rtw_set_ie_ch_switch(u8 *buf, u32 *buf_len, u8 ch_switch_mode,
@@ -229,7 +229,7 @@ u8 *rtw_get_ie(u8 *pbuf, sint index, sint *len, sint limit)
 	u8 *p;
 _func_enter_;
 	if (limit < 1){
-		_func_exit_;
+		_func_exit_;	
 		return NULL;
 	}
 
@@ -252,7 +252,7 @@ u8 *rtw_get_ie(u8 *pbuf, sint index, sint *len, sint limit)
 		if (i >= limit)
 			break;
 	}
-_func_exit_;
+_func_exit_;		
 	return NULL;
 }
 
@@ -291,7 +291,7 @@ u8 *rtw_get_ie_ex(u8 *in_ie, uint in_len, u8 eid, u8 *oui, u8 oui_len, u8 *ie, u
 
 			if(ie)
 				_rtw_memcpy(ie, &in_ie[cnt], in_ie[cnt+1]+2);
-
+			
 			if(ielen)
 				*ielen = in_ie[cnt+1]+2;
 
@@ -299,10 +299,10 @@ u8 *rtw_get_ie_ex(u8 *in_ie, uint in_len, u8 eid, u8 *oui, u8 oui_len, u8 *ie, u
 		}
 		else
 		{
-			cnt+=in_ie[cnt+1]+2; //goto next
-		}
+			cnt+=in_ie[cnt+1]+2; //goto next	
+		}		
 
-	}
+	}	
 
 	return target_ie;
 }
@@ -325,7 +325,7 @@ int rtw_ies_remove_ie(u8 *ies, uint *ies_len, uint offset, u8 eid, u8 *oui, u8 o
 	u32 target_ielen;
 	u8 *start;
 	uint search_len;
-
+	
 	if(!ies || !ies_len || *ies_len <= offset)
 		goto exit;
 
@@ -338,7 +338,7 @@ int rtw_ies_remove_ie(u8 *ies, uint *ies_len, uint offset, u8 eid, u8 *oui, u8 o
 			u8 buf[MAX_IE_SZ] = {0};
 			u8 *remain_ies = target_ie + target_ielen;
 			uint remain_len = search_len - (remain_ies - start);
-
+			
 			_rtw_memcpy(buf, remain_ies, remain_len);
 			_rtw_memcpy(target_ie, buf, remain_len);
 			*ies_len = *ies_len - target_ielen;
@@ -354,25 +354,25 @@ int rtw_ies_remove_ie(u8 *ies, uint *ies_len, uint offset, u8 eid, u8 *oui, u8 o
 	return ret;
 }
 
-void rtw_set_supported_rate(u8* SupportedRates, uint mode)
+void rtw_set_supported_rate(u8* SupportedRates, uint mode) 
 {
 _func_enter_;
 
 	_rtw_memset(SupportedRates, 0, NDIS_802_11_LENGTH_RATES_EX);
-
+	
 	switch (mode)
 	{
 		case WIRELESS_11B:
 			_rtw_memcpy(SupportedRates, WIFI_CCKRATES, IEEE80211_CCK_RATE_LEN);
 			break;
-
+		
 		case WIRELESS_11G:
 		case WIRELESS_11A:
 		case WIRELESS_11_5N:
 		case WIRELESS_11A_5N://Todo: no basic rate for ofdm ?
 			_rtw_memcpy(SupportedRates, WIFI_OFDMRATES, IEEE80211_NUM_OFDM_RATESLEN);
 			break;
-
+		
 		case WIRELESS_11BG:
 		case WIRELESS_11G_24N:
 		case WIRELESS_11_24N:
@@ -380,26 +380,26 @@ void rtw_set_supported_rate(u8* SupportedRates, uint mode)
 			_rtw_memcpy(SupportedRates, WIFI_CCKRATES, IEEE80211_CCK_RATE_LEN);
 			_rtw_memcpy(SupportedRates + IEEE80211_CCK_RATE_LEN, WIFI_OFDMRATES, IEEE80211_NUM_OFDM_RATESLEN);
 			break;
-
+	
 	}
-_func_exit_;
+_func_exit_;	
 }
 
 uint	rtw_get_rateset_len(u8	*rateset)
 {
 	uint i = 0;
-_func_enter_;
+_func_enter_;	
 	while(1)
 	{
 		if ((rateset[i]) == 0)
 			break;
-
+			
 		if (i > 12)
 			break;
-
-		i++;
+			
+		i++;			
 	}
-_func_exit_;
+_func_exit_;		
 	return i;
 }
 
@@ -409,35 +409,35 @@ int rtw_generate_ie(struct registry_priv *pregistrypriv)
 	int 	sz = 0, rateLen;
 	WLAN_BSSID_EX*	pdev_network = &pregistrypriv->dev_network;
 	u8*	ie = pdev_network->IEs;
-
-_func_enter_;
+	
+_func_enter_;		
 
 	//timestamp will be inserted by hardware
-	sz += 8;
+	sz += 8;	
 	ie += sz;
-
+	
 	//beacon interval : 2bytes
 	*(u16*)ie = cpu_to_le16((u16)pdev_network->Configuration.BeaconPeriod);//BCN_INTERVAL;
-	sz += 2;
+	sz += 2; 
 	ie += 2;
-
+	
 	//capability info
 	*(u16*)ie = 0;
-
+	
 	*(u16*)ie |= cpu_to_le16(cap_IBSS);
 
 	if(pregistrypriv->preamble == PREAMBLE_SHORT)
 		*(u16*)ie |= cpu_to_le16(cap_ShortPremble);
-
+	
 	if (pdev_network->Privacy)
 		*(u16*)ie |= cpu_to_le16(cap_Privacy);
-
+	
 	sz += 2;
 	ie += 2;
-
+	
 	//SSID
 	ie = rtw_set_ie(ie, _SSID_IE_, pdev_network->Ssid.SsidLength, pdev_network->Ssid.Ssid, &sz);
-
+	
 	//supported rates
 	if(pregistrypriv->wireless_mode == WIRELESS_11ABGN)
 	{
@@ -450,9 +450,9 @@ int rtw_generate_ie(struct registry_priv *pregistrypriv)
 	{
 		wireless_mode = pregistrypriv->wireless_mode;
 	}
-
+	
 	rtw_set_supported_rate(pdev_network->SupportedRates, wireless_mode) ;
-
+	
 	rateLen = rtw_get_rateset_len(pdev_network->SupportedRates);
 
 	if (rateLen > 8)
@@ -470,17 +470,17 @@ int rtw_generate_ie(struct registry_priv *pregistrypriv)
 
 
 	//IBSS Parameter Set
-
+	
 	ie = rtw_set_ie(ie, _IBSS_PARA_IE_, 2, (u8 *)&(pdev_network->Configuration.ATIMWindow), &sz);
 
 	if (rateLen > 8)
-	{
+	{		
 		ie = rtw_set_ie(ie, _EXT_SUPPORTEDRATES_IE_, (rateLen - 8), (pdev_network->SupportedRates + 8), &sz);
 	}
-
-
+	
+		
 	//HT Cap.
-	if(((pregistrypriv->wireless_mode&WIRELESS_11_5N)||(pregistrypriv->wireless_mode&WIRELESS_11_24N))
+	if(((pregistrypriv->wireless_mode&WIRELESS_11_5N)||(pregistrypriv->wireless_mode&WIRELESS_11_24N)) 
 		&& (pregistrypriv->ht_enable==_TRUE))
 	{
 		//todo:
@@ -503,7 +503,7 @@ unsigned char *rtw_get_wpa_ie(unsigned char *pie, int *wpa_ie_len, int limit)
 	unsigned char wpa_oui_type[] = {0x00, 0x50, 0xf2, 0x01};
 	u8 *pbuf = pie;
 
-	while(1)
+	while(1) 
 	{
 		pbuf = rtw_get_ie(pbuf, _WPA_IE_ID_, &len, limit);
 
@@ -548,7 +548,7 @@ unsigned char *rtw_get_wpa_ie(unsigned char *pie, int *wpa_ie_len, int limit)
 }
 
 unsigned char *rtw_get_wpa2_ie(unsigned char *pie, int *rsn_ie_len, int limit)
-{
+{	
 
 	return rtw_get_ie(pie, _WPA2_IE_ID_,rsn_ie_len, limit);
 
@@ -598,68 +598,68 @@ int rtw_parse_wpa_ie(u8* wpa_ie, int wpa_ie_len, int *group_cipher, int *pairwis
 		return _FAIL;
 	}
 
-
+	
 	if ((*wpa_ie != _WPA_IE_ID_) || (*(wpa_ie+1) != (u8)(wpa_ie_len - 2)) ||
 	   (_rtw_memcmp(wpa_ie+2, RTW_WPA_OUI_TYPE, WPA_SELECTOR_LEN) != _TRUE) )
-	{
+	{		
 		return _FAIL;
 	}
 
 	pos = wpa_ie;
 
 	pos += 8;
-	left = wpa_ie_len - 8;
+	left = wpa_ie_len - 8;	
 
 
 	//group_cipher
 	if (left >= WPA_SELECTOR_LEN) {
 
 		*group_cipher = rtw_get_wpa_cipher_suite(pos);
-
+		
 		pos += WPA_SELECTOR_LEN;
 		left -= WPA_SELECTOR_LEN;
-
-	}
+		
+	} 
 	else if (left > 0)
 	{
 		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("%s: ie length mismatch, %u too much", __FUNCTION__, left));
-
+		
 		return _FAIL;
 	}
 
 
 	//pairwise_cipher
 	if (left >= 2)
-	{
-                //count = le16_to_cpu(*(u16*)pos);
+	{		
+                //count = le16_to_cpu(*(u16*)pos);	
 		count = RTW_GET_LE16(pos);
 		pos += 2;
 		left -= 2;
-
+		
 		if (count == 0 || left < count * WPA_SELECTOR_LEN) {
 			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("%s: ie count botch (pairwise), "
-						"count %u left %u", __FUNCTION__, count, left));
+				   		"count %u left %u", __FUNCTION__, count, left));
 			return _FAIL;
 		}
-
+		
 		for (i = 0; i < count; i++)
 		{
 			*pairwise_cipher |= rtw_get_wpa_cipher_suite(pos);
-
+			
 			pos += WPA_SELECTOR_LEN;
 			left -= WPA_SELECTOR_LEN;
 		}
-
-	}
+		
+	} 
 	else if (left == 1)
 	{
 		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("%s: ie too short (for key mgmt)",   __FUNCTION__));
 		return _FAIL;
 	}
 
-
+	
 	return ret;
-
+	
 }
 
 int rtw_parse_wpa2_ie(u8* rsn_ie, int rsn_ie_len, int *group_cipher, int *pairwise_cipher)
@@ -675,22 +675,22 @@ int rtw_parse_wpa2_ie(u8* rsn_ie, int rsn_ie_len, int *group_cipher, int *pairwi
 
 
 	if ((*rsn_ie!= _WPA2_IE_ID_) || (*(rsn_ie+1) != (u8)(rsn_ie_len - 2)))
-	{
+	{		
 		return _FAIL;
 	}
-
+	
 	pos = rsn_ie;
 	pos += 4;
-	left = rsn_ie_len - 4;
+	left = rsn_ie_len - 4;	
 
 	//group_cipher
 	if (left >= RSN_SELECTOR_LEN) {
 
 		*group_cipher = rtw_get_wpa2_cipher_suite(pos);
-
+		
 		pos += RSN_SELECTOR_LEN;
 		left -= RSN_SELECTOR_LEN;
-
+		
 	} else if (left > 0) {
 		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("%s: ie length mismatch, %u too much", __FUNCTION__, left));
 		return _FAIL;
@@ -698,7 +698,7 @@ int rtw_parse_wpa2_ie(u8* rsn_ie, int rsn_ie_len, int *group_cipher, int *pairwi
 
 	//pairwise_cipher
 	if (left >= 2)
-	{
+	{		
 	        //count = le16_to_cpu(*(u16*)pos);
 		count = RTW_GET_LE16(pos);
 		pos += 2;
@@ -706,29 +706,29 @@ int rtw_parse_wpa2_ie(u8* rsn_ie, int rsn_ie_len, int *group_cipher, int *pairwi
 
 		if (count == 0 || left < count * RSN_SELECTOR_LEN) {
 			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("%s: ie count botch (pairwise), "
-						 "count %u left %u", __FUNCTION__, count, left));
+				  		 "count %u left %u", __FUNCTION__, count, left));
 			return _FAIL;
 		}
-
+		
 		for (i = 0; i < count; i++)
-		{
+		{			
 			*pairwise_cipher |= rtw_get_wpa2_cipher_suite(pos);
-
+			
 			pos += RSN_SELECTOR_LEN;
 			left -= RSN_SELECTOR_LEN;
 		}
 
-	}
+	} 
 	else if (left == 1)
 	{
 		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("%s: ie too short (for key mgmt)",  __FUNCTION__));
-
+		
 		return _FAIL;
 	}
 
 
 	return ret;
-
+	
 }
 
 int rtw_get_sec_ie(u8 *in_ie,uint in_len,u8 *rsn_ie,u16 *rsn_len,u8 *wpa_ie,u16 *wpa_len)
@@ -736,22 +736,22 @@ int rtw_get_sec_ie(u8 *in_ie,uint in_len,u8 *rsn_ie,u16 *rsn_len,u8 *wpa_ie,u16
 	u8 authmode, sec_idx, i;
 	u8 wpa_oui[4]={0x0,0x50,0xf2,0x01};
 	uint 	cnt;
-
+	
 _func_enter_;
 
 	//Search required WPA or WPA2 IE and copy to sec_ie[ ]
-
+	
 	cnt = (_TIMESTAMP_ + _BEACON_ITERVAL_ + _CAPABILITY_);
-
+	
 	sec_idx=0;
-
+		
 	while(cnt<in_len)
 	{
 		authmode=in_ie[cnt];
-
+		
 		if((authmode==_WPA_IE_ID_)&&(_rtw_memcmp(&in_ie[cnt+2], &wpa_oui[0],4)==_TRUE))
-		{
-				RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("\n rtw_get_wpa_ie: sec_idx=%d in_ie[cnt+1]+2=%d\n",sec_idx,in_ie[cnt+1]+2));
+		{	
+				RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("\n rtw_get_wpa_ie: sec_idx=%d in_ie[cnt+1]+2=%d\n",sec_idx,in_ie[cnt+1]+2));		
 
 				_rtw_memcpy(wpa_ie, &in_ie[cnt],in_ie[cnt+1]+2);
 
@@ -766,7 +766,7 @@ int rtw_get_sec_ie(u8 *in_ie,uint in_len,u8 *rsn_ie,u16 *rsn_len,u8 *wpa_ie,u16
 		{
 			if(authmode==_WPA2_IE_ID_)
 			{
-				RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("\n get_rsn_ie: sec_idx=%d in_ie[cnt+1]+2=%d\n",sec_idx,in_ie[cnt+1]+2));
+				RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("\n get_rsn_ie: sec_idx=%d in_ie[cnt+1]+2=%d\n",sec_idx,in_ie[cnt+1]+2));		
 
 				_rtw_memcpy(rsn_ie, &in_ie[cnt],in_ie[cnt+1]+2);
 
@@ -780,32 +780,32 @@ int rtw_get_sec_ie(u8 *in_ie,uint in_len,u8 *rsn_ie,u16 *rsn_len,u8 *wpa_ie,u16
 			else
 			{
 				cnt+=in_ie[cnt+1]+2;   //get next
-			}
+			}	
 		}
-
+		
 	}
-
+	
 _func_exit_;
 
 	return (*rsn_len+*wpa_len);
-
+	
 }
 
 u8 rtw_is_wps_ie(u8 *ie_ptr, uint *wps_ielen)
-{
+{	
 	u8 match = _FALSE;
 	u8 eid, wps_oui[4]={0x0,0x50,0xf2,0x04};
-
+	
 	if(ie_ptr == NULL) return match;
-
+	
 	eid = ie_ptr[0];
-
+	
 	if((eid==_WPA_IE_ID_)&&(_rtw_memcmp(&ie_ptr[2], wps_oui, 4)==_TRUE))
-	{
-		//printk("==> found WPS_IE.....\n");
-		*wps_ielen = ie_ptr[1]+2;
+	{			
+		//printk("==> found WPS_IE.....\n");		
+		*wps_ielen = ie_ptr[1]+2;			
 		match=_TRUE;
-	}
+	}	
 	return match;
 }
 
@@ -842,20 +842,20 @@ u8 *rtw_get_wps_ie(u8 *in_ie, uint in_len, u8 *wps_ie, uint *wps_ielen)
 
 			if(wps_ie)
 				_rtw_memcpy(wps_ie, &in_ie[cnt], in_ie[cnt+1]+2);
-
+			
 			if(wps_ielen)
 				*wps_ielen = in_ie[cnt+1]+2;
-
+			
 			cnt+=in_ie[cnt+1]+2;
 
 			break;
 		}
 		else
 		{
-			cnt+=in_ie[cnt+1]+2; //goto next
-		}
+			cnt+=in_ie[cnt+1]+2; //goto next	
+		}		
 
-	}
+	}	
 
 	return wpsie_ptr;
 }
@@ -887,33 +887,33 @@ u8 *rtw_get_wps_attr(u8 *wps_ie, uint wps_ielen, u16 target_attr_id ,u8 *buf_att
 
 	// 6 = 1(Element ID) + 1(Length) + 4(WPS OUI)
 	attr_ptr = wps_ie + 6; //goto first attr
-
+	
 	while(attr_ptr - wps_ie < wps_ielen)
 	{
 		// 4 = 2(Attribute ID) + 2(Length)
 		u16 attr_id = RTW_GET_BE16(attr_ptr);
 		u16 attr_data_len = RTW_GET_BE16(attr_ptr + 2);
 		u16 attr_len = attr_data_len + 4;
-
+		
 		//DBG_871X("%s attr_ptr:%p, id:%u, length:%u\n", __FUNCTION__, attr_ptr, attr_id, attr_data_len);
 		if( attr_id == target_attr_id )
 		{
 			target_attr_ptr = attr_ptr;
-
+		
 			if(buf_attr)
 				_rtw_memcpy(buf_attr, attr_ptr, attr_len);
-
+			
 			if(len_attr)
 				*len_attr = attr_len;
-
+			
 			break;
 		}
 		else
 		{
 			attr_ptr += attr_len; //goto next
-		}
-
-	}
+		}		
+		
+	}	
 
 	return target_attr_ptr;
 }
@@ -935,7 +935,7 @@ u8 *rtw_get_wps_attr_content(u8 *wps_ie, uint wps_ielen, u16 target_attr_id ,u8
 
 	if(len_content)
 		*len_content = 0;
-
+	
 	attr_ptr = rtw_get_wps_attr(wps_ie, wps_ielen, target_attr_id, NULL, &attr_len);
 
 	if(attr_ptr && attr_len)
@@ -1046,7 +1046,7 @@ static int rtw_ieee802_11_parse_vendor_specific(u8 *pos, uint elen,
 	}
 
 	return 0;
-
+	
 }
 
 /**
@@ -1079,7 +1079,7 @@ ParseRes rtw_ieee802_11_parse_elems(u8 *start, uint len,
 				DBG_871X("IEEE 802.11 element "
 					   "parse failed (id=%d elen=%d "
 					   "left=%lu)\n",
-					   id, elen, (unsigned long) left);
+					   id, elen, (unsigned long) left);				
 			}
 			return ParseFailed;
 		}
@@ -1181,7 +1181,7 @@ ParseRes rtw_ieee802_11_parse_elems(u8 *start, uint len,
 		return ParseFailed;
 
 	return unknown ? ParseUnknown : ParseOK;
-
+	
 }
 
 static u8 key_char2num(u8 ch);
@@ -1219,7 +1219,7 @@ void rtw_macaddr_cfg(u8 *mac_addr)
 {
 	u8 mac[ETH_ALEN];
 	if(mac_addr == NULL)	return;
-
+	
 	if ( rtw_initmac )
 	{	//	Users specify the mac address
 		int jj,kk;
@@ -1234,7 +1234,7 @@ void rtw_macaddr_cfg(u8 *mac_addr)
 	{	//	Use the mac address stored in the Efuse
 		_rtw_memcpy(mac, mac_addr, ETH_ALEN);
 	}
-
+	
 	if (((mac[0]==0xff) &&(mac[1]==0xff) && (mac[2]==0xff) &&
 	     (mac[3]==0xff) && (mac[4]==0xff) &&(mac[5]==0xff)) ||
 	    ((mac[0]==0x0) && (mac[1]==0x0) && (mac[2]==0x0) &&
@@ -1249,7 +1249,7 @@ void rtw_macaddr_cfg(u8 *mac_addr)
 		// use default mac addresss
 		_rtw_memcpy(mac_addr, mac, ETH_ALEN);
 		DBG_871X("MAC Address from efuse error, assign default one !!!\n");
-	}
+	}	
 
 	DBG_871X("rtw_macaddr_cfg MAC Address  = "MAC_FMT"\n", MAC_ARG(mac_addr));
 }
@@ -1257,7 +1257,7 @@ void rtw_macaddr_cfg(u8 *mac_addr)
 void dump_ies(u8 *buf, u32 buf_len) {
 	u8* pos = (u8*)buf;
 	u8 id, len;
-
+	
 	while(pos-buf<=buf_len){
 		id = *pos;
 		len = *(pos+1);
@@ -1269,7 +1269,7 @@ void dump_ies(u8 *buf, u32 buf_len) {
 		dump_wps_ie(pos, len);
 
 		pos+=(2+len);
-	}
+	}	
 }
 
 void dump_wps_ie(u8 *ie, u32 ie_len) {
@@ -1279,7 +1279,7 @@ void dump_wps_ie(u8 *ie, u32 ie_len) {
 
 	u8 *wps_ie;
 	uint wps_ielen;
-
+	
 	wps_ie = rtw_get_wps_ie(ie, ie_len, NULL, &wps_ielen);
 	if(wps_ie != ie || wps_ielen == 0)
 		return;
@@ -1292,7 +1292,7 @@ void dump_wps_ie(u8 *ie, u32 ie_len) {
 		DBG_871X("%s ID:0x%04x, LEN:%u\n", __FUNCTION__, id, len);
 
 		pos+=(4+len);
-	}
+	}	
 }
 
 #ifdef CONFIG_P2P
@@ -1374,7 +1374,7 @@ void dump_p2p_ie(u8 *ie, u32 ie_len) {
 
 	u8 *p2p_ie;
 	uint p2p_ielen;
-
+	
 	p2p_ie = rtw_get_p2p_ie(ie, ie_len, NULL, &p2p_ielen);
 	if(p2p_ie != ie || p2p_ielen == 0)
 		return;
@@ -1387,7 +1387,7 @@ void dump_p2p_ie(u8 *ie, u32 ie_len) {
 		DBG_871X("%s ID:%u, LEN:%u\n", __FUNCTION__, id, len);
 
 		pos+=(3+len);
-	}
+	}	
 }
 
 /**
@@ -1420,7 +1420,7 @@ u8 *rtw_get_p2p_ie(u8 *in_ie, int in_len, u8 *p2p_ie, uint *p2p_ielen)
 		if( ( eid == _VENDOR_SPECIFIC_IE_ ) && ( _rtw_memcmp( &in_ie[cnt+2], p2p_oui, 4) == _TRUE ) )
 		{
 			p2p_ie_ptr = in_ie + cnt;
-
+		
 			if ( p2p_ie != NULL )
 			{
 				_rtw_memcpy( p2p_ie, &in_ie[ cnt ], in_ie[ cnt + 1 ] + 2 );
@@ -1430,17 +1430,17 @@ u8 *rtw_get_p2p_ie(u8 *in_ie, int in_len, u8 *p2p_ie, uint *p2p_ielen)
 			{
 				*p2p_ielen = in_ie[ cnt + 1 ] + 2;
 			}
-
+			
 			return p2p_ie_ptr;
 
 			break;
 		}
 		else
 		{
-			cnt += in_ie[ cnt + 1 ] +2; //goto next
-		}
-
-	}
+			cnt += in_ie[ cnt + 1 ] +2; //goto next	
+		}		
+		
+	}	
 
 	return NULL;
 
@@ -1473,33 +1473,33 @@ u8 *rtw_get_p2p_attr(u8 *p2p_ie, uint p2p_ielen, u8 target_attr_id ,u8 *buf_attr
 
 	// 6 = 1(Element ID) + 1(Length) + 3 (OUI) + 1(OUI Type)
 	attr_ptr = p2p_ie + 6; //goto first attr
-
+	
 	while(attr_ptr - p2p_ie < p2p_ielen)
 	{
 		// 3 = 1(Attribute ID) + 2(Length)
 		u8 attr_id = *attr_ptr;
 		u16 attr_data_len = RTW_GET_LE16(attr_ptr + 1);
 		u16 attr_len = attr_data_len + 3;
-
+		
 		//DBG_871X("%s attr_ptr:%p, id:%u, length:%u\n", __FUNCTION__, attr_ptr, attr_id, attr_data_len);
 		if( attr_id == target_attr_id )
 		{
 			target_attr_ptr = attr_ptr;
-
+		
 			if(buf_attr)
 				_rtw_memcpy(buf_attr, attr_ptr, attr_len);
-
+			
 			if(len_attr)
 				*len_attr = attr_len;
-
+			
 			break;
 		}
 		else
 		{
 			attr_ptr += attr_len; //goto next
-		}
-
-	}
+		}		
+		
+	}	
 
 	return target_attr_ptr;
 }
@@ -1521,7 +1521,7 @@ u8 *rtw_get_p2p_attr_content(u8 *p2p_ie, uint p2p_ielen, u8 target_attr_id ,u8 *
 
 	if(len_content)
 		*len_content = 0;
-
+	
 	attr_ptr = rtw_get_p2p_attr(p2p_ie, p2p_ielen, target_attr_id, NULL, &attr_len);
 
 	if(attr_ptr && attr_len)
@@ -1539,19 +1539,19 @@ u8 *rtw_get_p2p_attr_content(u8 *p2p_ie, uint p2p_ielen, u8 target_attr_id ,u8 *
 }
 
 u32 rtw_set_p2p_attr_content(u8 *pbuf, u8 attr_id, u16 attr_len, u8 *pdata_attr)
-{
+{	
 	u32 a_len;
 
 	*pbuf = attr_id;
-
+		
 	//*(u16*)(pbuf + 1) = cpu_to_le16(attr_len);
 	RTW_PUT_LE16(pbuf + 1, attr_len);
 
 	if(pdata_attr)
-		_rtw_memcpy(pbuf + 3, pdata_attr, attr_len);
-
+		_rtw_memcpy(pbuf + 3, pdata_attr, attr_len);		
+		
 	a_len = attr_len + 3;
-
+		
 	return a_len;
 }
 
@@ -1602,8 +1602,8 @@ void rtw_WLAN_BSSID_EX_remove_p2p_attr(WLAN_BSSID_EX *bss_ex, u8 attr_id)
 	u8 *p2p_ie;
 	uint p2p_ielen, p2p_ielen_ori;
 	int cnt;
-
-	if( (p2p_ie=rtw_get_p2p_ie(bss_ex->IEs+_FIXED_IE_LENGTH_, bss_ex->IELength-_FIXED_IE_LENGTH_, NULL, &p2p_ielen_ori)) )
+	
+	if( (p2p_ie=rtw_get_p2p_ie(bss_ex->IEs+_FIXED_IE_LENGTH_, bss_ex->IELength-_FIXED_IE_LENGTH_, NULL, &p2p_ielen_ori)) ) 
 	{
 		#if 0
 		if(rtw_get_p2p_attr(p2p_ie, p2p_ielen_ori, attr_id, NULL, NULL)) {
@@ -1614,7 +1614,7 @@ void rtw_WLAN_BSSID_EX_remove_p2p_attr(WLAN_BSSID_EX *bss_ex, u8 attr_id)
 
 		p2p_ielen=rtw_p2p_attr_remove(p2p_ie, p2p_ielen_ori, attr_id);
 		if(p2p_ielen != p2p_ielen_ori) {
-
+			
 			u8 *next_ie_ori = p2p_ie+p2p_ielen_ori;
 			u8 *next_ie = p2p_ie+p2p_ielen;
 			uint remain_len = bss_ex->IELength-(next_ie_ori-bss_ex->IEs);
@@ -1637,7 +1637,7 @@ void rtw_WLAN_BSSID_EX_remove_p2p_attr(WLAN_BSSID_EX *bss_ex, u8 attr_id)
 int rtw_get_wfd_ie(u8 *in_ie, int in_len, u8 *wfd_ie, uint *wfd_ielen)
 {
 	int match;
-	uint cnt = 0;
+	uint cnt = 0;	
 	u8 eid, wfd_oui[4]={0x50,0x6F,0x9A,0x0A};
 
 
@@ -1647,17 +1647,17 @@ int rtw_get_wfd_ie(u8 *in_ie, int in_len, u8 *wfd_ie, uint *wfd_ielen)
 	{
 		return match;
 	}
-
+	
 	while(cnt<in_len)
 	{
 		eid = in_ie[cnt];
-
+		
 		if( ( eid == _VENDOR_SPECIFIC_IE_ ) && ( _rtw_memcmp( &in_ie[cnt+2], wfd_oui, 4) == _TRUE ) )
 		{
 			if ( wfd_ie != NULL )
 			{
 				_rtw_memcpy( wfd_ie, &in_ie[ cnt ], in_ie[ cnt + 1 ] + 2 );
-
+			
 			}
 			else
 			{
@@ -1666,12 +1666,12 @@ int rtw_get_wfd_ie(u8 *in_ie, int in_len, u8 *wfd_ie, uint *wfd_ielen)
 					*wfd_ielen = 0;
 				}
 			}
-
+			
 			if ( wfd_ielen != NULL )
 			{
 				*wfd_ielen = in_ie[ cnt + 1 ] + 2;
 			}
-
+			
 			cnt += in_ie[ cnt + 1 ] + 2;
 
 			match = _TRUE;
@@ -1679,16 +1679,16 @@ int rtw_get_wfd_ie(u8 *in_ie, int in_len, u8 *wfd_ie, uint *wfd_ielen)
 		}
 		else
 		{
-			cnt += in_ie[ cnt + 1 ] +2; //goto next
-		}
-
-	}
+			cnt += in_ie[ cnt + 1 ] +2; //goto next	
+		}		
+		
+	}	
 
 	if ( match == _TRUE )
 	{
 		match = cnt;
 	}
-
+	
 	return match;
 
 }
@@ -1698,7 +1698,7 @@ int rtw_get_wfd_ie(u8 *in_ie, int in_len, u8 *wfd_ie, uint *wfd_ielen)
 int rtw_get_wfd_attr_content(u8 *wfd_ie, uint wfd_ielen, u8 target_attr_id ,u8 *attr_content, uint *attr_contentlen)
 {
 	int match;
-	uint cnt = 0;
+	uint cnt = 0;	
 	u8 attr_id, wfd_oui[4]={0x50,0x6F,0x9A,0x0A};
 
 
@@ -1714,18 +1714,18 @@ int rtw_get_wfd_attr_content(u8 *wfd_ie, uint wfd_ielen, u8 target_attr_id ,u8 *
 	cnt = 6;
 	while( cnt < wfd_ielen )
 	{
-		u16 attrlen = RTW_GET_BE16(wfd_ie + cnt + 1);
-
+		u16 attrlen = RTW_GET_BE16(wfd_ie + cnt + 1);		
+		
 		attr_id = wfd_ie[cnt];
 		if( attr_id == target_attr_id )
 		{
 			//	3 -> 1 byte for attribute ID field, 2 bytes for length field
 			if(attr_content)
 				_rtw_memcpy( attr_content, &wfd_ie[ cnt + 3 ], attrlen );
-
+			
 			if(attr_contentlen)
 				*attr_contentlen = attrlen;
-
+			
 			cnt += attrlen + 3;
 
 			match = _TRUE;
@@ -1733,10 +1733,10 @@ int rtw_get_wfd_attr_content(u8 *wfd_ie, uint wfd_ielen, u8 target_attr_id ,u8 *
 		}
 		else
 		{
-			cnt += attrlen + 3; //goto next
-		}
-
-	}
+			cnt += attrlen + 3; //goto next	
+		}		
+		
+	}	
 
 	return match;
 
@@ -1791,7 +1791,7 @@ int ieee80211_get_hdrlen(u16 fc)
 u16 rtw_mcs_rate(u8 rf_type, u8 bw_40MHz, u8 short_GI_20, u8 short_GI_40, unsigned char * MCS_rate)
 {
 	u16 max_rate = 0;
-
+	
 	if(rf_type == RF_1T1R)
 	{
 		if(MCS_rate[0] & BIT(7))
@@ -1859,8 +1859,7 @@ int rtw_action_frame_parse(const u8 *frame, u32 frame_len, u8* category, u8 *act
 {
 	const u8 *frame_body = frame + sizeof(struct rtw_ieee80211_hdr_3addr);
 	u16 fc;
-	u8 c;
-	u8 a = ACT_PUBLIC_MAX;
+	u8 c, a;
 
 	fc = le16_to_cpu(((struct rtw_ieee80211_hdr_3addr *)frame)->frame_ctl);
 
@@ -1913,3 +1912,4 @@ const char *action_public_str(u8 action)
 	action = (action >= ACT_PUBLIC_MAX) ? ACT_PUBLIC_MAX : action;
 	return _action_public_str[action];
 }
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_io.c b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_io.c
old mode 100644
new mode 100755
index 3e8ee42..4ffaa50
--- a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_io.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_io.c
@@ -129,7 +129,7 @@ int _rtw_write8(_adapter *adapter, u32 addr, u8 val)
 
 	ret = _write8(pintfhdl, addr, val);
 	_func_exit_;
-
+	
 	return RTW_STATUS_CODE(ret);
 }
 int _rtw_write16(_adapter *adapter, u32 addr, u16 val)
@@ -234,7 +234,7 @@ void _rtw_read_mem(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem)
 
 	if( (adapter->bDriverStopped ==_TRUE) || (adapter->bSurpriseRemoved == _TRUE))
 	{
-	     RT_TRACE(_module_rtl871x_io_c_, _drv_info_, ("rtw_read_mem:bDriverStopped(%d) OR bSurpriseRemoved(%d)", adapter->bDriverStopped, adapter->bSurpriseRemoved));
+	     RT_TRACE(_module_rtl871x_io_c_, _drv_info_, ("rtw_read_mem:bDriverStopped(%d) OR bSurpriseRemoved(%d)", adapter->bDriverStopped, adapter->bSurpriseRemoved));	    
 	     return;
 	}
 
@@ -274,7 +274,7 @@ void _rtw_read_port(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem)
 
 	if( (adapter->bDriverStopped ==_TRUE) || (adapter->bSurpriseRemoved == _TRUE))
 	{
-	     RT_TRACE(_module_rtl871x_io_c_, _drv_info_, ("rtw_read_port:bDriverStopped(%d) OR bSurpriseRemoved(%d)", adapter->bDriverStopped, adapter->bSurpriseRemoved));
+	     RT_TRACE(_module_rtl871x_io_c_, _drv_info_, ("rtw_read_port:bDriverStopped(%d) OR bSurpriseRemoved(%d)", adapter->bDriverStopped, adapter->bSurpriseRemoved));	    
 	     return;
 	}
 
@@ -310,7 +310,7 @@ u32 _rtw_write_port(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem)
 	_func_enter_;
 
 	_write_port = pintfhdl->io_ops._write_port;
-
+	
 	ret = _write_port(pintfhdl, addr, cnt, pmem);
 
 	 _func_exit_;
@@ -369,12 +369,12 @@ int rtw_init_io_priv(_adapter *padapter, void (*set_intf_ops)(struct _io_ops *po
 
 u16 read_sniff_ranges[][2] = {
 	//{0x550, 0x551},
-};
+}; 
 
 u16 write_sniff_ranges[][2] = {
 	//{0x550, 0x551},
 	//{0x4c, 0x4c},
-};
+}; 
 
 int read_sniff_num = sizeof(read_sniff_ranges)/sizeof(u16)/2;
 int write_sniff_num = sizeof(write_sniff_ranges)/sizeof(u16)/2;
@@ -386,7 +386,7 @@ bool match_read_sniff_ranges(u16 addr, u16 len)
 		if (addr + len > read_sniff_ranges[i][0] && addr <= read_sniff_ranges[i][1])
 			return _TRUE;
 	}
-
+	
 	return _FALSE;
 }
 
@@ -397,7 +397,7 @@ bool match_write_sniff_ranges(u16 addr, u16 len)
 		if (addr + len > write_sniff_ranges[i][0] && addr <= write_sniff_ranges[i][1])
 			return _TRUE;
 	}
-
+	
 	return _FALSE;
 }
 
@@ -414,7 +414,7 @@ u8 dbg_rtw_read8(_adapter *adapter, u32 addr, const char *caller, const int line
 u16 dbg_rtw_read16(_adapter *adapter, u32 addr, const char *caller, const int line)
 {
 	u16 val = _rtw_read16(adapter, addr);
-
+	
 	if (match_read_sniff_ranges(addr, 2))
 		DBG_871X("DBG_IO %s:%d rtw_read16(0x%04x) return 0x%04x\n", caller, line, addr, val);
 
@@ -424,7 +424,7 @@ u16 dbg_rtw_read16(_adapter *adapter, u32 addr, const char *caller, const int li
 u32 dbg_rtw_read32(_adapter *adapter, u32 addr, const char *caller, const int line)
 {
 	u32 val = _rtw_read32(adapter, addr);
-
+	
 	if (match_read_sniff_ranges(addr, 4))
 		DBG_871X("DBG_IO %s:%d rtw_read32(0x%04x) return 0x%08x\n", caller, line, addr, val);
 
@@ -435,21 +435,21 @@ int dbg_rtw_write8(_adapter *adapter, u32 addr, u8 val, const char *caller, cons
 {
 	if (match_write_sniff_ranges(addr, 1))
 		DBG_871X("DBG_IO %s:%d rtw_write8(0x%04x, 0x%02x)\n", caller, line, addr, val);
-
+	
 	return _rtw_write8(adapter, addr, val);
 }
 int dbg_rtw_write16(_adapter *adapter, u32 addr, u16 val, const char *caller, const int line)
 {
 	if (match_write_sniff_ranges(addr, 2))
 		DBG_871X("DBG_IO %s:%d rtw_write16(0x%04x, 0x%04x)\n", caller, line, addr, val);
-
+	
 	return _rtw_write16(adapter, addr, val);
 }
 int dbg_rtw_write32(_adapter *adapter, u32 addr, u32 val, const char *caller, const int line)
 {
 	if (match_write_sniff_ranges(addr, 4))
 		DBG_871X("DBG_IO %s:%d rtw_write32(0x%04x, 0x%08x)\n", caller, line, addr, val);
-
+	
 	return _rtw_write32(adapter, addr, val);
 }
 int dbg_rtw_writeN(_adapter *adapter, u32 addr ,u32 length , u8 *data, const char *caller, const int line)
@@ -460,3 +460,5 @@ int dbg_rtw_writeN(_adapter *adapter, u32 addr ,u32 length , u8 *data, const cha
 	return _rtw_writeN(adapter, addr, length, data);
 }
 #endif
+
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_ioctl_query.c b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_ioctl_query.c
old mode 100644
new mode 100755
index a67b08d..0601886
--- a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_ioctl_query.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_ioctl_query.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -37,23 +37,23 @@
 	u32 *		pulOutLen
 )
 {
-	static NDIS_802_11_AUTHENTICATION_ENCRYPTION szAuthEnc[] =
+	static NDIS_802_11_AUTHENTICATION_ENCRYPTION szAuthEnc[] = 
 	{
-		{Ndis802_11AuthModeOpen, Ndis802_11EncryptionDisabled},
+		{Ndis802_11AuthModeOpen, Ndis802_11EncryptionDisabled}, 
 		{Ndis802_11AuthModeOpen, Ndis802_11Encryption1Enabled},
-		{Ndis802_11AuthModeShared, Ndis802_11EncryptionDisabled},
+		{Ndis802_11AuthModeShared, Ndis802_11EncryptionDisabled}, 
 		{Ndis802_11AuthModeShared, Ndis802_11Encryption1Enabled},
-		{Ndis802_11AuthModeWPA, Ndis802_11Encryption2Enabled},
+		{Ndis802_11AuthModeWPA, Ndis802_11Encryption2Enabled}, 
 		{Ndis802_11AuthModeWPA, Ndis802_11Encryption3Enabled},
-		{Ndis802_11AuthModeWPAPSK, Ndis802_11Encryption2Enabled},
+		{Ndis802_11AuthModeWPAPSK, Ndis802_11Encryption2Enabled}, 
 		{Ndis802_11AuthModeWPAPSK, Ndis802_11Encryption3Enabled},
-		{Ndis802_11AuthModeWPANone, Ndis802_11Encryption2Enabled},
+		{Ndis802_11AuthModeWPANone, Ndis802_11Encryption2Enabled}, 
 		{Ndis802_11AuthModeWPANone, Ndis802_11Encryption3Enabled},
-		{Ndis802_11AuthModeWPA2, Ndis802_11Encryption2Enabled},
+		{Ndis802_11AuthModeWPA2, Ndis802_11Encryption2Enabled}, 
 		{Ndis802_11AuthModeWPA2, Ndis802_11Encryption3Enabled},
-		{Ndis802_11AuthModeWPA2PSK, Ndis802_11Encryption2Enabled},
+		{Ndis802_11AuthModeWPA2PSK, Ndis802_11Encryption2Enabled}, 
 		{Ndis802_11AuthModeWPA2PSK, Ndis802_11Encryption3Enabled}
-	};
+	};	
 	static ULONG	ulNumOfPairSupported = sizeof(szAuthEnc)/sizeof(NDIS_802_11_AUTHENTICATION_ENCRYPTION);
 	NDIS_802_11_CAPABILITY * pCap = (NDIS_802_11_CAPABILITY *)pucBuf;
 	u8*	pucAuthEncryptionSupported = (u8*) pCap->AuthenticationEncryptionSupported;
@@ -62,9 +62,9 @@
 	pCap->Length = sizeof(NDIS_802_11_CAPABILITY);
 	if(ulNumOfPairSupported > 1 )
 		pCap->Length += 	(ulNumOfPairSupported-1) * sizeof(NDIS_802_11_AUTHENTICATION_ENCRYPTION);
-
-	pCap->Version = 2;
-	pCap->NoOfPMKIDs = NUM_PMKID_CACHE;
+	
+	pCap->Version = 2;	
+	pCap->NoOfPMKIDs = NUM_PMKID_CACHE;	
 	pCap->NoOfAuthEncryptPairsSupported = ulNumOfPairSupported;
 
 	if( sizeof (szAuthEnc) <= 240 )		// 240 = 256 - 4*4	// SecurityInfo.szCapability: only 256 bytes in size.
@@ -86,7 +86,7 @@ u8 query_802_11_association_information(	_adapter *padapter,PNDIS_802_11_ASSOCIA
 	struct wlan_network *tgt_network;
 	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
 	struct	security_priv  *psecuritypriv=&(padapter->securitypriv);
-	WLAN_BSSID_EX	*psecnetwork=(WLAN_BSSID_EX*)&(psecuritypriv->sec_bss);
+	WLAN_BSSID_EX	*psecnetwork=(WLAN_BSSID_EX*)&(psecuritypriv->sec_bss);					
 	u8 *	pDest = (u8 *)pAssocInfo + sizeof(NDIS_802_11_ASSOCIATION_INFORMATION);
 	unsigned char i,*auth_ie,*supp_ie;
 
@@ -99,7 +99,7 @@ u8 query_802_11_association_information(	_adapter *padapter,PNDIS_802_11_ASSOCIA
 	//------------------------------------------------------
 	// Req_1. AvailableRequestFixedIEs
 	if(psecnetwork!=NULL){
-
+		
 	pAssocInfo->AvailableRequestFixedIEs |= NDIS_802_11_AI_REQFI_CAPABILITIES|NDIS_802_11_AI_REQFI_CURRENTAPADDRESS;
 	pAssocInfo->RequestFixedIEs.Capabilities = (unsigned short)* & psecnetwork->IEs[10];
 	_rtw_memcpy(pAssocInfo->RequestFixedIEs.CurrentAPAddress,
@@ -109,12 +109,12 @@ u8 query_802_11_association_information(	_adapter *padapter,PNDIS_802_11_ASSOCIA
 
 	if(check_fwstate( pmlmepriv, _FW_UNDER_LINKING|_FW_LINKED)==_TRUE)
 	{
-
+		
 		if(psecuritypriv->ndisauthtype>=Ndis802_11AuthModeWPA2)
 			pDest[0] =48;		//RSN Information Element
-		else
+		else 
 			pDest[0] =221;	//WPA(SSN) Information Element
-
+		
 		RT_TRACE(_module_rtl871x_ioctl_query_c_,_drv_info_,("\n Adapter->ndisauthtype==Ndis802_11AuthModeWPA)?0xdd:0x30 [%d]",pDest[0]));
 		supp_ie=&psecuritypriv->supplicant_ie[0];
 		for(i=0;i<supp_ie[0];i++)
@@ -122,34 +122,34 @@ u8 query_802_11_association_information(	_adapter *padapter,PNDIS_802_11_ASSOCIA
 			RT_TRACE(_module_rtl871x_ioctl_query_c_,_drv_info_,("IEs [%d] = 0x%x \n\n", i,supp_ie[i]));
 		}
 
-		i=13;	//0~11 is fixed information element
+		i=13;	//0~11 is fixed information element		
 		RT_TRACE(_module_rtl871x_ioctl_query_c_,_drv_info_,("i= %d tgt_network->network.IELength=%d\n\n", i,(int)psecnetwork->IELength));
 		while((i<supp_ie[0]) && (i<256)){
 			if((unsigned char)supp_ie[i]==pDest[0]){
 						_rtw_memcpy((u8 *)(pDest),
-							&supp_ie[i],
+							&supp_ie[i], 
 							supp_ie[1+i]+2);
-
+			
 				break;
 			}
-
+			
 			i=i+supp_ie[i+1]+2;
 			if(supp_ie[1+i]==0)
 				i=i+1;
 			RT_TRACE(_module_rtl871x_ioctl_query_c_,_drv_info_,("iteration i=%d IEs [%d] = 0x%x \n\n", i,i,supp_ie[i+1]));
-
+			
 		}
-
+		
 
 		pAssocInfo->RequestIELength += (2 + supp_ie[1+i]);// (2 + psecnetwork->IEs[1+i]+4);
 
 	}
-
+	
 
 		RT_TRACE(_module_rtl871x_ioctl_query_c_,_drv_info_,("\n psecnetwork != NULL,fwstate==_FW_UNDER_LINKING \n"));
 
 	}
-
+	
 
 	//------------------------------------------------------
 	// Association Response related information
@@ -177,19 +177,20 @@ u8 query_802_11_association_information(	_adapter *padapter,PNDIS_802_11_ASSOCIA
 		i=auth_ie[0]-12;
 		if(i>0){
 			_rtw_memcpy((u8 *)&pDest[0],&auth_ie[1],i);
-			pAssocInfo->ResponseIELength =i;
+			pAssocInfo->ResponseIELength =i; 
 		}
 
 
-		pAssocInfo->OffsetResponseIEs = sizeof(NDIS_802_11_ASSOCIATION_INFORMATION) + pAssocInfo->RequestIELength;
+		pAssocInfo->OffsetResponseIEs = sizeof(NDIS_802_11_ASSOCIATION_INFORMATION) + pAssocInfo->RequestIELength;  
 
 
 		RT_TRACE(_module_rtl871x_ioctl_query_c_,_drv_info_,("\n tgt_network != NULL,fwstate==_FW_LINKED \n"));
 		}
-	}
+	}												  	
 	RT_TRACE(_module_rtl871x_ioctl_query_c_,_drv_info_,("\n exit query_802_11_association_information \n"));
 _func_exit_;
 
 	return _TRUE;
 }
 #endif
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_ioctl_rtl.c b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_ioctl_rtl.c
old mode 100644
new mode 100755
index 4e663d7..31b4704
--- a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_ioctl_rtl.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_ioctl_rtl.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -61,7 +61,7 @@ struct oid_obj_priv oid_rtl_seg_01_01[] =
 	{1, &oid_rt_get_preamble_mode_hdl},							//0x96
 	{1, &oid_null_function},										//0x97
 	{1, &oid_rt_get_ap_ip_hdl},									//0x98
-	{1, &oid_rt_get_channelplan_hdl},							//0x99
+	{1, &oid_rt_get_channelplan_hdl},							//0x99	
 	{1, &oid_rt_set_preamble_mode_hdl},	 						//0x9A
 	{1, &oid_rt_set_bcn_intvl_hdl},								//0x9B
 	{1, &oid_null_function},										//0x9C
@@ -77,7 +77,7 @@ struct oid_obj_priv oid_rtl_seg_01_01[] =
 	{1, &oid_null_function},										//0xA6
 	{1, &oid_rt_get_total_tx_bytes_hdl},							//0xA7
 	{1, &oid_rt_get_total_rx_bytes_hdl},							//0xA8
-	{1, &oid_rt_current_tx_power_level_hdl},						//0xA9
+	{1, &oid_rt_current_tx_power_level_hdl},						//0xA9	
 	{1, &oid_rt_get_enc_key_mismatch_count_hdl},	 			//0xAA
 	{1, &oid_rt_get_enc_key_match_count_hdl},					//0xAB
 	{1, &oid_rt_get_channel_hdl},								//0xAC
@@ -93,7 +93,7 @@ struct oid_obj_priv oid_rtl_seg_01_01[] =
 	{1, &oid_null_function},										//0xB6
 	{1, &oid_null_function},										//0xB7
 	{1, &oid_null_function},										//0xB8
-	{1, &oid_null_function},										//0xB9
+	{1, &oid_null_function},										//0xB9	
 	{1, &oid_null_function},	 									//0xBA
 	{1, &oid_rt_supported_wireless_mode_hdl},					//0xBB
 	{1, &oid_rt_get_channel_list_hdl},							//0xBC
@@ -109,14 +109,14 @@ struct oid_obj_priv oid_rtl_seg_01_01[] =
 	{1, &oid_null_function},										//0xC6
 	{1, &oid_null_function},										//0xC7
 	{1, &oid_null_function},										//0xC8
-	{1, &oid_null_function},										//0xC9
+	{1, &oid_null_function},										//0xC9	
 	{1, &oid_null_function},	 									//0xCA
 	{1, &oid_null_function},										//0xCB
 	{1, &oid_null_function},										//0xCC
 	{1, &oid_null_function},										//0xCD
 	{1, &oid_null_function},										//0xCE
 	{1, &oid_null_function},										//0xCF
-
+	
 };
 
 struct oid_obj_priv oid_rtl_seg_01_03[] =
@@ -132,7 +132,7 @@ struct oid_obj_priv oid_rtl_seg_01_03[] =
 
 struct oid_obj_priv oid_rtl_seg_01_11[] =
 {
-	{1, &oid_null_function},					//0xC0	OID_RT_PRO_RX_FILTER
+	{1, &oid_null_function},					//0xC0	OID_RT_PRO_RX_FILTER	
 	{1, &oid_null_function},					//0xC1	OID_CE_USB_WRITE_REGISTRY
 	{1, &oid_null_function},					//0xC2	OID_CE_USB_READ_REGISTRY
 	{1, &oid_null_function},					//0xC3	OID_RT_PRO_SET_INITIAL_GAIN
@@ -140,10 +140,10 @@ struct oid_obj_priv oid_rtl_seg_01_11[] =
 	{1, &oid_null_function},					//0xC5	OID_RT_PRO_SET_BB_RF_SHUTDOWN_MODE
 	{1, &oid_null_function},					//0xC6	OID_RT_PRO_SET_TX_CHARGE_PUMP
 	{1, &oid_null_function},					//0xC7	OID_RT_PRO_SET_RX_CHARGE_PUMP
-	{1, &oid_rt_pro_rf_write_registry_hdl},	//0xC8
-	{1, &oid_rt_pro_rf_read_registry_hdl},	//0xC9
+	{1, &oid_rt_pro_rf_write_registry_hdl},	//0xC8	
+	{1, &oid_rt_pro_rf_read_registry_hdl},	//0xC9	
 	{1, &oid_null_function}					//0xCA	OID_RT_PRO_QUERY_RF_TYPE
-
+	
 };
 
 struct oid_obj_priv oid_rtl_seg_03_00[] =
@@ -154,11 +154,11 @@ struct oid_obj_priv oid_rtl_seg_03_00[] =
 	{1, &oid_null_function},										//0x03
 	{1, &oid_rt_set_default_key_id_hdl},							//0x04
 
-
+	
 };
 
 
-//**************  oid_rtl_seg_01_01 section start **************
+//**************  oid_rtl_seg_01_01 section start ************** 
 
 NDIS_STATUS oid_rt_pro_set_fw_dig_state_hdl(struct oid_par_priv* poid_par_priv)
 {
@@ -166,28 +166,28 @@ NDIS_STATUS oid_rt_pro_set_fw_dig_state_hdl(struct oid_par_priv* poid_par_priv)
 #if 0
 	PADAPTER		Adapter = (PADAPTER)(poid_par_priv->adapter_context);
 	_irqL			oldirql;
-
+	
 	_func_enter_;
-
-	if(poid_par_priv->type_of_oid != SET_OID)
+	
+	if(poid_par_priv->type_of_oid != SET_OID) 
 	{
 		status = NDIS_STATUS_NOT_ACCEPTED;
 		return status;
 	}
-
+			
 	_irqlevel_changed_(&oldirql,LOWER);
 	if(poid_par_priv->information_buf_len >= sizeof(struct setdig_parm))
 	{
-		//DEBUG_ERR(("===> oid_rt_pro_set_fw_dig_state_hdl. type:0x%02x.\n",*((unsigned char*)poid_par_priv->information_buf )));
-		if(!rtw_setfwdig_cmd(Adapter,*((unsigned char*)poid_par_priv->information_buf )))
+		//DEBUG_ERR(("===> oid_rt_pro_set_fw_dig_state_hdl. type:0x%02x.\n",*((unsigned char*)poid_par_priv->information_buf )));	
+		if(!rtw_setfwdig_cmd(Adapter,*((unsigned char*)poid_par_priv->information_buf )))			
 		{
 			status = NDIS_STATUS_NOT_ACCEPTED;
 		}
-
+		                   
 	}
 	else{
 		status = NDIS_STATUS_NOT_ACCEPTED;
-	}
+	}  
 	_irqlevel_changed_(&oldirql,RAISE);
 	_func_exit_;
 #endif
@@ -201,29 +201,29 @@ NDIS_STATUS oid_rt_pro_set_fw_ra_state_hdl(struct oid_par_priv* poid_par_priv)
 #if 0
 	PADAPTER		Adapter = (PADAPTER)(poid_par_priv->adapter_context);
 	_irqL			oldirql;
-
-	_func_enter_;
-	if(poid_par_priv->type_of_oid != SET_OID)
+	
+	_func_enter_;	
+	if(poid_par_priv->type_of_oid != SET_OID) 
 	{
 		status = NDIS_STATUS_NOT_ACCEPTED;
 		return status;
 	}
 
-
+					
 	_irqlevel_changed_(&oldirql,LOWER);
-
+	
 	if(poid_par_priv->information_buf_len >= sizeof(struct setra_parm))
 	{
-		//DEBUG_ERR(("===> oid_rt_pro_set_fw_ra_state_hdl. type:0x%02x.\n",*((unsigned char*)poid_par_priv->information_buf )));
-		if(!rtw_setfwra_cmd(Adapter,*((unsigned char*)poid_par_priv->information_buf )))
+		//DEBUG_ERR(("===> oid_rt_pro_set_fw_ra_state_hdl. type:0x%02x.\n",*((unsigned char*)poid_par_priv->information_buf )));	
+		if(!rtw_setfwra_cmd(Adapter,*((unsigned char*)poid_par_priv->information_buf )))			
 		{
 			status = NDIS_STATUS_NOT_ACCEPTED;
 		}
-
+		                   
 	}
 	else{
 		status = NDIS_STATUS_NOT_ACCEPTED;
-	}
+	}  
 	_irqlevel_changed_(&oldirql,RAISE);
 	_func_exit_;
 #endif
@@ -240,7 +240,7 @@ NDIS_STATUS oid_rt_get_signal_quality_hdl(struct oid_par_priv* poid_par_priv)
 	{
 		status = NDIS_STATUS_NOT_ACCEPTED;
 		return status;
-	}
+	}		
 
 #if 0
 		if(pMgntInfo->mAssoc || pMgntInfo->mIbss)
@@ -269,12 +269,12 @@ NDIS_STATUS oid_rt_get_small_packet_crc_hdl(struct oid_par_priv* poid_par_priv)
 	{
 		status = NDIS_STATUS_NOT_ACCEPTED;
 		return status;
-	}
-
+	}		
+		
 	if(poid_par_priv->information_buf_len >=  sizeof(ULONG) )
-	{
+	{		
 		*(ULONG *)poid_par_priv->information_buf = padapter->recvpriv.rx_smallpacket_crcerr;
-		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;		
 	}
 	else
 	{
@@ -293,12 +293,12 @@ NDIS_STATUS oid_rt_get_middle_packet_crc_hdl(struct oid_par_priv* poid_par_priv)
 	{
 		status = NDIS_STATUS_NOT_ACCEPTED;
 		return status;
-	}
+	}		
 
 	if(poid_par_priv->information_buf_len >=  sizeof(ULONG) )
-	{
+	{		
 		*(ULONG *)poid_par_priv->information_buf = padapter->recvpriv.rx_middlepacket_crcerr;
-		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;		
 	}
 	else
 	{
@@ -318,12 +318,12 @@ NDIS_STATUS oid_rt_get_large_packet_crc_hdl(struct oid_par_priv* poid_par_priv)
 	{
 		status = NDIS_STATUS_NOT_ACCEPTED;
 		return status;
-	}
+	}	
 
 	if(poid_par_priv->information_buf_len >=  sizeof(ULONG) )
-	{
+	{		
 		*(ULONG *)poid_par_priv->information_buf = padapter->recvpriv.rx_largepacket_crcerr;
-		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;		
 	}
 	else
 	{
@@ -344,7 +344,7 @@ NDIS_STATUS oid_rt_get_tx_retry_hdl(struct oid_par_priv* poid_par_priv)
 	{
 		status = NDIS_STATUS_NOT_ACCEPTED;
 		return status;
-	}
+	}		
 
 	return status;
 }
@@ -357,7 +357,7 @@ NDIS_STATUS oid_rt_get_rx_retry_hdl(struct oid_par_priv* poid_par_priv)
 	{
 		status = NDIS_STATUS_NOT_ACCEPTED;
 		return status;
-	}
+	}		
 	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
 	return status;
 }
@@ -371,11 +371,11 @@ NDIS_STATUS oid_rt_get_rx_total_packet_hdl(struct oid_par_priv* poid_par_priv)
 	{
 		status = NDIS_STATUS_NOT_ACCEPTED;
 		return status;
-	}
+	}	
 	if(poid_par_priv->information_buf_len >=  sizeof(ULONG) )
-	{
+	{		
 		*(u64 *)poid_par_priv->information_buf = padapter->recvpriv.rx_pkts + padapter->recvpriv.rx_drop;
-		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
+		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;		
 	}
 	else
 	{
@@ -395,7 +395,7 @@ NDIS_STATUS oid_rt_get_tx_beacon_ok_hdl(struct oid_par_priv* poid_par_priv)
 	{
 		status = NDIS_STATUS_NOT_ACCEPTED;
 		return status;
-	}
+	}		
 
 	return status;
 }
@@ -408,7 +408,7 @@ NDIS_STATUS oid_rt_get_tx_beacon_err_hdl(struct oid_par_priv* poid_par_priv)
 	{
 		status = NDIS_STATUS_NOT_ACCEPTED;
 		return status;
-	}
+	}		
 
 	return status;
 }
@@ -433,7 +433,7 @@ NDIS_STATUS oid_rt_get_rx_icv_err_hdl(struct oid_par_priv* poid_par_priv)
 	{
 		status = NDIS_STATUS_INVALID_LENGTH ;
 	}
-
+	
 
 	return status;
 }
@@ -447,7 +447,7 @@ NDIS_STATUS oid_rt_set_encryption_algorithm_hdl(struct oid_par_priv* poid_par_pr
 	{
 		status = NDIS_STATUS_NOT_ACCEPTED;
 		return status;
-	}
+	}	
 
 	return status;
 }
@@ -456,23 +456,23 @@ NDIS_STATUS oid_rt_get_preamble_mode_hdl(struct oid_par_priv* poid_par_priv)
 {
 	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
 	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
-	ULONG			preamblemode = 0 ;
-
+	ULONG			preamblemode = 0 ;			
+		
 	if(poid_par_priv->type_of_oid != QUERY_OID)
 	{
 		status = NDIS_STATUS_NOT_ACCEPTED;
 		return status;
-	}
+	}		
 	if(poid_par_priv->information_buf_len>= sizeof(ULONG))
-	{
+	{		
 		if(padapter->registrypriv.preamble == PREAMBLE_LONG)
 			preamblemode = 0;
 		else if (padapter->registrypriv.preamble == PREAMBLE_AUTO)
 			preamblemode = 1;
 		else if (padapter->registrypriv.preamble == PREAMBLE_SHORT)
 			preamblemode = 2;
-
-
+		
+			
 		*(ULONG *)poid_par_priv->information_buf = preamblemode ;
 		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
 	}
@@ -492,7 +492,7 @@ NDIS_STATUS oid_rt_get_ap_ip_hdl(struct oid_par_priv* poid_par_priv)
 	{
 		status = NDIS_STATUS_NOT_ACCEPTED;
 		return status;
-	}
+	}		
 
 	return status;
 }
@@ -501,13 +501,13 @@ NDIS_STATUS oid_rt_get_channelplan_hdl(struct oid_par_priv* poid_par_priv)
 {
 	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
 	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
-	struct eeprom_priv*	peeprompriv = &padapter->eeprompriv;
+	struct eeprom_priv*	peeprompriv = &padapter->eeprompriv;	
 
 	if(poid_par_priv->type_of_oid != QUERY_OID)
 	{
 		status = NDIS_STATUS_NOT_ACCEPTED;
 		return status;
-	}
+	}		
 	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
 	*(u16 *)poid_par_priv->information_buf = peeprompriv->channel_plan ;
 
@@ -517,14 +517,14 @@ NDIS_STATUS oid_rt_set_channelplan_hdl(struct oid_par_priv* poid_par_priv)
 {
 	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
 	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
-	struct eeprom_priv*	peeprompriv = &padapter->eeprompriv;
-
+	struct eeprom_priv*	peeprompriv = &padapter->eeprompriv;	
+	
 	if(poid_par_priv->type_of_oid != SET_OID)
 	{
 		status = NDIS_STATUS_NOT_ACCEPTED;
 		return status;
-	}
-
+	}		
+	
 	peeprompriv->channel_plan = *(u16 *)poid_par_priv->information_buf ;
 
 	return status;
@@ -540,24 +540,24 @@ NDIS_STATUS oid_rt_set_preamble_mode_hdl(struct oid_par_priv* poid_par_priv)
 		status = NDIS_STATUS_NOT_ACCEPTED;
 		return status;
 	}
-
+	 
 	if(poid_par_priv->information_buf_len>= sizeof(ULONG))
-	{
+	{		
 		preamblemode = *(ULONG *)poid_par_priv->information_buf ;
 		if( preamblemode == 0)
 			padapter->registrypriv.preamble = PREAMBLE_LONG;
 		else if (preamblemode==1 )
 			padapter->registrypriv.preamble = PREAMBLE_AUTO;
 		else if ( preamblemode==2 )
-			padapter->registrypriv.preamble = PREAMBLE_SHORT;
-
+			padapter->registrypriv.preamble = PREAMBLE_SHORT;		
+			
 		*(ULONG *)poid_par_priv->information_buf = preamblemode ;
 		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
 	}
 	else
 	{
 		status = NDIS_STATUS_INVALID_LENGTH ;
-	}
+	}	
 
 	return status;
 }
@@ -592,9 +592,9 @@ NDIS_STATUS oid_rt_get_total_tx_bytes_hdl(struct oid_par_priv* poid_par_priv)
 	{
 		status = NDIS_STATUS_NOT_ACCEPTED;
 		return status;
-	}
+	}	
 	if(poid_par_priv->information_buf_len>= sizeof(ULONG))
-	{
+	{		
 		*(u64 *)poid_par_priv->information_buf = padapter->xmitpriv.tx_bytes;
 		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
 	}
@@ -602,7 +602,7 @@ NDIS_STATUS oid_rt_get_total_tx_bytes_hdl(struct oid_par_priv* poid_par_priv)
 	{
 		status = NDIS_STATUS_INVALID_LENGTH ;
 	}
-
+	
 
 	return status;
 }
@@ -646,7 +646,7 @@ NDIS_STATUS oid_rt_get_enc_key_mismatch_count_hdl(struct oid_par_priv* poid_par_
 	{
 		status = NDIS_STATUS_NOT_ACCEPTED;
 		return status;
-	}
+	}		
 
 	return status;
 }
@@ -659,7 +659,7 @@ NDIS_STATUS oid_rt_get_enc_key_match_count_hdl(struct oid_par_priv* poid_par_pri
 	{
 		status = NDIS_STATUS_NOT_ACCEPTED;
 		return status;
-	}
+	}		
 
 	return status;
 }
@@ -677,7 +677,7 @@ NDIS_STATUS oid_rt_get_channel_hdl(struct oid_par_priv* poid_par_priv)
 	{
 		status = NDIS_STATUS_NOT_ACCEPTED;
 		return status;
-	}
+	}		
 
 	if ( (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) ||
 		(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE))
@@ -687,7 +687,7 @@ NDIS_STATUS oid_rt_get_channel_hdl(struct oid_par_priv* poid_par_priv)
 
 	channelnum = pnic_Config->DSConfig;
 	*(ULONG *)poid_par_priv->information_buf = channelnum;
-
+	
 	*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
 
 	_func_exit_;
@@ -705,7 +705,7 @@ NDIS_STATUS oid_rt_get_hardware_radio_off_hdl(struct oid_par_priv* poid_par_priv
 	{
 		status = NDIS_STATUS_NOT_ACCEPTED;
 		return status;
-	}
+	}		
 
 	return status;
 }
@@ -718,7 +718,7 @@ NDIS_STATUS oid_rt_get_key_mismatch_hdl(struct oid_par_priv* poid_par_priv)
 	{
 		status = NDIS_STATUS_NOT_ACCEPTED;
 		return status;
-	}
+	}		
 
 	return status;
 }
@@ -727,24 +727,24 @@ NDIS_STATUS oid_rt_supported_wireless_mode_hdl(struct oid_par_priv* poid_par_pri
 	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
 	PADAPTER		padapter = (PADAPTER)(poid_par_priv->adapter_context);
 	ULONG 			ulInfo = 0 ;
-	//DEBUG_ERR(("<**********************oid_rt_supported_wireless_mode_hdl \n"));
+	//DEBUG_ERR(("<**********************oid_rt_supported_wireless_mode_hdl \n"));	
 	if(poid_par_priv->type_of_oid != QUERY_OID)
 	{
 		status = NDIS_STATUS_NOT_ACCEPTED;
 		return status;
-	}
+	}		
 	if(poid_par_priv->information_buf_len >= sizeof(ULONG)){
 		ulInfo |= 0x0100; //WIRELESS_MODE_B
 		ulInfo |= 0x0200; //WIRELESS_MODE_G
 		ulInfo |= 0x0400; //WIRELESS_MODE_A
 
-		*(ULONG *) poid_par_priv->information_buf = ulInfo;
-		//DEBUG_ERR(("<===oid_rt_supported_wireless_mode %x\n",ulInfo));
+		*(ULONG *) poid_par_priv->information_buf = ulInfo;		
+		//DEBUG_ERR(("<===oid_rt_supported_wireless_mode %x\n",ulInfo));	
 		*poid_par_priv->bytes_rw = poid_par_priv->information_buf_len;
 	}
 	else{
 		status = NDIS_STATUS_INVALID_LENGTH;
-	}
+	}		
 
 	return status;
 }
@@ -757,7 +757,7 @@ NDIS_STATUS oid_rt_get_channel_list_hdl(struct oid_par_priv* poid_par_priv)
 	{
 		status = NDIS_STATUS_NOT_ACCEPTED;
 		return status;
-	}
+	}		
 
 	return status;
 }
@@ -770,7 +770,7 @@ NDIS_STATUS oid_rt_get_scan_in_progress_hdl(struct oid_par_priv* poid_par_priv)
 	{
 		status = NDIS_STATUS_NOT_ACCEPTED;
 		return status;
-	}
+	}		
 
 	return status;
 }
@@ -799,7 +799,7 @@ NDIS_STATUS oid_rt_get_bss_wireless_mode_hdl(struct oid_par_priv* poid_par_priv)
 	{
 		status = NDIS_STATUS_NOT_ACCEPTED;
 		return status;
-	}
+	}		
 
 	return status;
 }
@@ -811,9 +811,9 @@ NDIS_STATUS oid_rt_scan_with_magic_packet_hdl(struct oid_par_priv* poid_par_priv
 
 	return status;
 }
-//**************  oid_rtl_seg_01_01 section end **************
+//**************  oid_rtl_seg_01_01 section end ************** 
 
-//**************  oid_rtl_seg_01_03 section start **************
+//**************  oid_rtl_seg_01_03 section start ************** 
 NDIS_STATUS oid_rt_ap_get_associated_station_list_hdl(struct oid_par_priv* poid_par_priv)
 {
 	NDIS_STATUS	 	status = NDIS_STATUS_SUCCESS;
@@ -823,7 +823,7 @@ NDIS_STATUS oid_rt_ap_get_associated_station_list_hdl(struct oid_par_priv* poid_
 	{
 		status = NDIS_STATUS_NOT_ACCEPTED;
 		return status;
-	}
+	}		
 
 	return status;
 }
@@ -850,12 +850,12 @@ NDIS_STATUS oid_rt_ap_set_passphrase_hdl(struct oid_par_priv* poid_par_priv)
 	{
 		status = NDIS_STATUS_NOT_ACCEPTED;
 		return status;
-	}
+	}		
 
 	return status;
 }
 
-//**************  oid_rtl_seg_01_03 section end **************
+//**************  oid_rtl_seg_01_03 section end ************** 
 
 //****************  oid_rtl_seg_01_11   section start ****************
 NDIS_STATUS oid_rt_pro_rf_write_registry_hdl(struct oid_par_priv* poid_par_priv)
@@ -870,27 +870,27 @@ NDIS_STATUS oid_rt_pro_rf_write_registry_hdl(struct oid_par_priv* poid_par_priv)
 		status = NDIS_STATUS_NOT_ACCEPTED;
 		return status;
 	}
-
+	
 	_irqlevel_changed_(&oldirql,LOWER);
 	if(poid_par_priv->information_buf_len== (sizeof(unsigned long)*3))
-	{
+	{      
 		//RegOffsetValue	- The offset of RF register to write.
 		//RegDataWidth	- The data width of RF register to write.
-		//RegDataValue	- The value to write.
+		//RegDataValue	- The value to write. 
 		//RegOffsetValue = *((unsigned long*)InformationBuffer);
-		//RegDataWidth = *((unsigned long*)InformationBuffer+1);
-		//RegDataValue =  *((unsigned long*)InformationBuffer+2);
-		if(!rtw_setrfreg_cmd(Adapter,
-						*(unsigned char*)poid_par_priv->information_buf,
+		//RegDataWidth = *((unsigned long*)InformationBuffer+1);	   
+		//RegDataValue =  *((unsigned long*)InformationBuffer+2);	
+		if(!rtw_setrfreg_cmd(Adapter, 
+						*(unsigned char*)poid_par_priv->information_buf, 
 						(unsigned long)(*((unsigned long*)poid_par_priv->information_buf+2))))
 		{
 			status = NDIS_STATUS_NOT_ACCEPTED;
 		}
-
+	                   
 	}
 	else{
 		status = NDIS_STATUS_INVALID_LENGTH;
-	}
+	}   
 	_irqlevel_changed_(&oldirql,RAISE);
 	_func_exit_;
 
@@ -911,8 +911,8 @@ NDIS_STATUS oid_rt_pro_rf_read_registry_hdl(struct oid_par_priv* poid_par_priv)
 	{
 		status = NDIS_STATUS_NOT_ACCEPTED;
 		return status;
-	}
-
+	}	
+	
 	_irqlevel_changed_(&oldirql,LOWER);
 	if(poid_par_priv->information_buf_len== (sizeof(unsigned long)*3))
 	{
@@ -926,24 +926,24 @@ NDIS_STATUS oid_rt_pro_rf_read_registry_hdl(struct oid_par_priv* poid_par_priv)
 			Adapter->mppriv.act_in_progress = _TRUE;
 			Adapter->mppriv.workparam.bcompleted= _FALSE;
 			Adapter->mppriv.workparam.act_type = MPT_READ_RF;
-			Adapter->mppriv.workparam.io_offset = *(unsigned long*)poid_par_priv->information_buf;
+			Adapter->mppriv.workparam.io_offset = *(unsigned long*)poid_par_priv->information_buf;		
 			Adapter->mppriv.workparam.io_value = 0xcccccccc;
-
+				       
 			//RegOffsetValue	- The offset of RF register to read.
 			//RegDataWidth	- The data width of RF register to read.
-			//RegDataValue	- The value to read.
+			//RegDataValue	- The value to read. 
 			//RegOffsetValue = *((unsigned long*)InformationBuffer);
-			//RegDataWidth = *((unsigned long*)InformationBuffer+1);
-			//RegDataValue =  *((unsigned long*)InformationBuffer+2);
-			if(!rtw_getrfreg_cmd(Adapter,
-							*(unsigned char*)poid_par_priv->information_buf,
+			//RegDataWidth = *((unsigned long*)InformationBuffer+1);	   
+			//RegDataValue =  *((unsigned long*)InformationBuffer+2);	   	 	                   
+			if(!rtw_getrfreg_cmd(Adapter, 
+							*(unsigned char*)poid_par_priv->information_buf, 
 							(unsigned char*)&Adapter->mppriv.workparam.io_value))
 			{
 				status = NDIS_STATUS_NOT_ACCEPTED;
 			}
 		}
-
-
+				      		   
+		                   
 	}
 	else	{
 		status = NDIS_STATUS_INVALID_LENGTH;
@@ -954,10 +954,10 @@ NDIS_STATUS oid_rt_pro_rf_read_registry_hdl(struct oid_par_priv* poid_par_priv)
 	return status;
 }
 
-//****************  oid_rtl_seg_01_11   section end****************
+//****************  oid_rtl_seg_01_11   section end****************	
 
 
-//**************  oid_rtl_seg_03_00 section start **************
+//**************  oid_rtl_seg_03_00 section start **************  
 enum _CONNECT_STATE_{
 	CHECKINGSTATUS,
 	ASSOCIATED,
@@ -973,21 +973,21 @@ NDIS_STATUS oid_rt_get_connect_state_hdl(struct oid_par_priv* poid_par_priv)
 	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
 
 	ULONG ulInfo;
-
+		
 	if(poid_par_priv->type_of_oid != QUERY_OID)
 	{
 		status = NDIS_STATUS_NOT_ACCEPTED;
 		return status;
-	}
+	}		
 
 	// nStatus==0	CheckingStatus
 	// nStatus==1	Associated
 	// nStatus==2	AdHocMode
 	// nStatus==3	NotAssociated
-
+	
 	if(check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == _TRUE)
 		ulInfo = CHECKINGSTATUS;
-	else if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
+	else if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)	
 		ulInfo = ASSOCIATED;
 	else if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)== _TRUE)
 		ulInfo = ADHOCMODE;
@@ -1025,7 +1025,7 @@ NDIS_STATUS oid_rt_set_default_key_id_hdl(struct oid_par_priv* poid_par_priv)
 		status = NDIS_STATUS_NOT_ACCEPTED;
 		return status;
 	}
-
+	
 	return status;
 }
-//**************  oid_rtl_seg_03_00 section end **************
+//**************  oid_rtl_seg_03_00 section end **************  
diff --git a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_ioctl_set.c b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_ioctl_set.c
old mode 100644
new mode 100755
index a86fa5f..e67f219
--- a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_ioctl_set.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_ioctl_set.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -43,14 +43,14 @@
 		(addr[4] == 0xff) && (addr[5] == 0xff) )  ? _TRUE : _FALSE \
 )
 
-u8 rtw_validate_bssid(const u8 *bssid)
+u8 rtw_validate_bssid(u8 *bssid)
 {
 	u8 ret = _TRUE;
 
 	if (is_zero_mac_addr(bssid)
 		|| is_broadcast_mac_addr(bssid)
 		|| is_multicast_mac_addr(bssid)
-	) {
+	) { 
 		ret = _FALSE;
 	}
 
@@ -62,7 +62,7 @@ u8 rtw_validate_ssid(NDIS_802_11_SSID *ssid)
 	u8	 i;
 	u8	ret=_TRUE;
 
-_func_enter_;
+_func_enter_;	
 
 	if (ssid->SsidLength > 32) {
 		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("ssid length >32\n"));
@@ -82,7 +82,7 @@ u8 rtw_validate_ssid(NDIS_802_11_SSID *ssid)
 	}
 #endif /* CONFIG_VALIDATE_SSID */
 
-exit:
+exit:	
 
 _func_exit_;
 
@@ -108,7 +108,7 @@ u8 rtw_do_join(_adapter * padapter)
 	RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("\n rtw_do_join: phead = %p; plist = %p \n\n\n", phead, plist));
 
 	pmlmepriv->cur_network.join_res = -2;
-
+		
 	set_fwstate(pmlmepriv, _FW_UNDER_LINKING);
 
 	pmlmepriv->pscanned = plist;
@@ -116,13 +116,13 @@ u8 rtw_do_join(_adapter * padapter)
 	pmlmepriv->to_join = _TRUE;
 
 	if(_rtw_queue_empty(queue)== _TRUE)
-	{
+	{	
 		_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
 		_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
-
+            		
 		//when set_ssid/set_bssid for rtw_do_join(), but scanning queue is empty
-		//we try to issue sitesurvey firstly
-
+		//we try to issue sitesurvey firstly	
+            		
 		if (pmlmepriv->LinkDetectInfo.bBusyTraffic ==_FALSE
 			|| rtw_to_roaming(padapter) > 0
 		)
@@ -133,10 +133,10 @@ u8 rtw_do_join(_adapter * padapter)
 				RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("rtw_do_join(): site survey return error\n."));
 			}
 		}
-
+		
 		goto exit;
-	}
-	else
+	}	
+	else 	
 	{
 		int select_ret;
 		_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
@@ -151,60 +151,60 @@ u8 rtw_do_join(_adapter * padapter)
 			_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
 			rtw_indicate_connect(padapter);
 		}
-		else
+		else	
 		{
 			if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)==_TRUE)
 			{
 				// submit createbss_cmd to change to a ADHOC_MASTER
 
-				//pmlmepriv->lock has been acquired by caller...
+ 				//pmlmepriv->lock has been acquired by caller...
 				WLAN_BSSID_EX    *pdev_network = &(padapter->registrypriv.dev_network);
 
 				pmlmepriv->fw_state = WIFI_ADHOC_MASTER_STATE;
-
+				
 				pibss = padapter->registrypriv.dev_network.MacAddress;
 
 				_rtw_memset(&pdev_network->Ssid, 0, sizeof(NDIS_802_11_SSID));
 				_rtw_memcpy(&pdev_network->Ssid, &pmlmepriv->assoc_ssid, sizeof(NDIS_802_11_SSID));
-
+	
 				rtw_update_registrypriv_dev_network(padapter);
 
 				rtw_generate_random_ibss(pibss);
-
+					
 				if(rtw_createbss_cmd(padapter)!=_SUCCESS)
 				{
-					RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("***Error=>do_goin: rtw_createbss_cmd status FAIL*** \n "));
+					RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("***Error=>do_goin: rtw_createbss_cmd status FAIL*** \n "));						
 					ret =  _FALSE;
 					goto exit;
 				}
 
-				pmlmepriv->to_join = _FALSE;
+			     	pmlmepriv->to_join = _FALSE;
 
-				RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("***Error=> rtw_select_and_join_from_scanned_queue FAIL under STA_Mode*** \n "));
+				RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("***Error=> rtw_select_and_join_from_scanned_queue FAIL under STA_Mode*** \n "));						
 
-			}
+			}			
 			else
-			{
-				// can't associate ; reset under-linking
+			{ 
+				// can't associate ; reset under-linking			
 				_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
 
-#if 0
+#if 0	
 				if((check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE))
 				{
 					if(_rtw_memcmp(pmlmepriv->cur_network.network.Ssid.Ssid, pmlmepriv->assoc_ssid.Ssid, pmlmepriv->assoc_ssid.SsidLength))
-					{
+					{ 
 						// for funk to do roaming
 						// funk will reconnect, but funk will not sitesurvey before reconnect
 						RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("for funk to do roaming"));
 						if(pmlmepriv->sitesurveyctrl.traffic_busy==_FALSE)
 							rtw_sitesurvey_cmd(padapter, &pmlmepriv->assoc_ssid, 1, NULL, 0);
 					}
-
-				}
+				
+				}				
 #endif
 
 				//when set_ssid/set_bssid for rtw_do_join(), but there are no desired bss in scanning queue
-				//we try to issue sitesurvey firstly
+				//we try to issue sitesurvey firstly			
 				if(pmlmepriv->LinkDetectInfo.bBusyTraffic==_FALSE
 					|| rtw_to_roaming(padapter) > 0
 				)
@@ -213,7 +213,7 @@ u8 rtw_do_join(_adapter * padapter)
 					if( _SUCCESS!=(ret=rtw_sitesurvey_cmd(padapter, &pmlmepriv->assoc_ssid, 1, NULL, 0)) ){
 						RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("do_join(): site survey return error\n."));
 					}
-				}
+				}				
 
 
 			}
@@ -221,12 +221,12 @@ u8 rtw_do_join(_adapter * padapter)
 		}
 
 	}
-
+	
 exit:
+	
+_func_exit_;	
 
-_func_exit_;
-
-	return ret;
+	return ret;	
 }
 
 #ifdef PLATFORM_WINDOWS
@@ -237,20 +237,20 @@ u8 rtw_pnp_set_power_wakeup(_adapter* padapter)
 _func_enter_;
 
 	RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("==>rtw_pnp_set_power_wakeup!!!\n"));
-
+	
 	res = rtw_setstandby_cmd(padapter, 0);
 
 	RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("<==rtw_pnp_set_power_wakeup!!!\n"));
 
 _func_exit_;
-
+	
 	return res;
 }
 
 u8 rtw_pnp_set_power_sleep(_adapter* padapter)
 {
-	u8 res=_SUCCESS;
-
+	u8 res=_SUCCESS;	
+	
 _func_enter_;
 
 	RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("==>rtw_pnp_set_power_sleep!!!\n"));
@@ -280,18 +280,18 @@ u8 rtw_set_802_11_reload_defaults(_adapter * padapter, NDIS_802_11_RELOAD_DEFAUL
 	// 8711 CAM was not for En/Decrypt only
 	// so, we can't clear all keys.
 	// should we disable WPAcfg (ox0088) bit 1-2, instead of clear all CAM
-
+	
 	//TO DO...
 
 _func_exit_;
-
+	
 	return _TRUE;
 }
 
 u8 set_802_11_test(_adapter* padapter, NDIS_802_11_TEST *test)
 {
 	u8 ret=_TRUE;
-
+	
 _func_enter_;
 
 	switch(test->Type)
@@ -313,7 +313,7 @@ u8 set_802_11_test(_adapter* padapter, NDIS_802_11_TEST *test)
 
 _func_exit_;
 
-	return ret;
+	return ret;	
 }
 
 u8	rtw_set_802_11_pmkid(_adapter*	padapter, NDIS_802_11_PMKID *pmkid)
@@ -326,15 +326,15 @@ u8	rtw_set_802_11_pmkid(_adapter*	padapter, NDIS_802_11_PMKID *pmkid)
 #endif
 
 u8 rtw_set_802_11_bssid(_adapter* padapter, u8 *bssid)
-{
-	_irqL irqL;
+{	
+	_irqL irqL;	
 	u8 status=_SUCCESS;
 	u32 cur_time = 0;
 
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-
+	
 _func_enter_;
-
+	
 	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_notice_,
 		 ("+rtw_set_802_11_bssid: bssid="MAC_FMT"\n", MAC_ARG(bssid) ));
 
@@ -344,7 +344,7 @@ u8 rtw_set_802_11_bssid(_adapter* padapter, u8 *bssid)
 		status = _FAIL;
 		goto exit;
 	}
-
+		
 	_enter_critical_bh(&pmlmepriv->lock, &irqL);
 
 
@@ -360,7 +360,7 @@ u8 rtw_set_802_11_bssid(_adapter* padapter, u8 *bssid)
 		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("set_bssid: _FW_LINKED||WIFI_ADHOC_MASTER_STATE\n"));
 
 		if (_rtw_memcmp(&pmlmepriv->cur_network.network.MacAddress, bssid, ETH_ALEN) == _TRUE)
-		{
+		{		
 			if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _FALSE)
 				goto release_mlme_lock;//it means driver is in WIFI_ADHOC_MASTER_STATE, we needn't create bss again.
 		} else {
@@ -378,7 +378,7 @@ u8 rtw_set_802_11_bssid(_adapter* padapter, u8 *bssid)
 			if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE)) {
 				_clr_fwstate_(pmlmepriv, WIFI_ADHOC_MASTER_STATE);
 				set_fwstate(pmlmepriv, WIFI_ADHOC_STATE);
-			}
+			}		
 		}
 	}
 
@@ -392,7 +392,7 @@ u8 rtw_set_802_11_bssid(_adapter* padapter, u8 *bssid)
 	pmlmepriv->assoc_by_bssid=_TRUE;
 
 	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == _TRUE) {
-		pmlmepriv->to_join = _TRUE;
+		pmlmepriv->to_join = _TRUE;	
 	}
 	else {
 		status = rtw_do_join(padapter);
@@ -400,27 +400,27 @@ u8 rtw_set_802_11_bssid(_adapter* padapter, u8 *bssid)
 
 release_mlme_lock:
 	_exit_critical_bh(&pmlmepriv->lock, &irqL);
-
+		
 exit:
 	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
 		("rtw_set_802_11_bssid: status=%d\n", status));
-
+	
 _func_exit_;
 
 	return status;
 }
 
 u8 rtw_set_802_11_ssid(_adapter* padapter, NDIS_802_11_SSID *ssid)
-{
+{	
 	_irqL irqL;
 	u8 status = _SUCCESS;
 	u32 cur_time = 0;
 
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct wlan_network *pnetwork = &pmlmepriv->cur_network;
-
+	
 _func_enter_;
-
+	
 	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_notice_,
 		 ("+rtw_set_802_11_ssid: ssid=[%s] fw_state=0x%08x\n",
 		  ssid->Ssid, get_fwstate(pmlmepriv)));
@@ -431,11 +431,11 @@ u8 rtw_set_802_11_ssid(_adapter* padapter, NDIS_802_11_SSID *ssid)
 		status = _FAIL;
 		goto exit;
 	}
-
+		
 	_enter_critical_bh(&pmlmepriv->lock, &irqL);
 
 	DBG_871X("Set SSID under fw_state=0x%08x\n", get_fwstate(pmlmepriv));
-	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == _TRUE) {
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == _TRUE) {	
 		goto handle_tkip_countermeasure;
 	} else if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == _TRUE) {
 		goto release_mlme_lock;
@@ -448,7 +448,7 @@ u8 rtw_set_802_11_ssid(_adapter* padapter, NDIS_802_11_SSID *ssid)
 
 		if ((pmlmepriv->assoc_ssid.SsidLength == ssid->SsidLength) &&
 		    (_rtw_memcmp(&pmlmepriv->assoc_ssid.Ssid, ssid->Ssid, ssid->SsidLength) == _TRUE))
-		{
+		{			
 			if((check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _FALSE))
 			{
 				RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
@@ -456,13 +456,13 @@ u8 rtw_set_802_11_ssid(_adapter* padapter, NDIS_802_11_SSID *ssid)
 					  get_fwstate(pmlmepriv)));
 
 				if(rtw_is_same_ibss(padapter, pnetwork) == _FALSE)
-				{
+				{				
 					//if in WIFI_ADHOC_MASTER_STATE | WIFI_ADHOC_STATE, create bss or rejoin again
 					rtw_disassoc_cmd(padapter, 0, _TRUE);
 
 					if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
 						rtw_indicate_disconnect(padapter);
-
+						
 					rtw_free_assoc_resources(padapter, 1);
 
 					if (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE) {
@@ -491,14 +491,14 @@ u8 rtw_set_802_11_ssid(_adapter* padapter, NDIS_802_11_SSID *ssid)
 
 			if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
 				rtw_indicate_disconnect(padapter);
-
+			
 			rtw_free_assoc_resources(padapter, 1);
 
 			if (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE) {
 				_clr_fwstate_(pmlmepriv, WIFI_ADHOC_MASTER_STATE);
 				set_fwstate(pmlmepriv, WIFI_ADHOC_STATE);
 			}
-		}
+		}		
 	}
 
 handle_tkip_countermeasure:
@@ -516,7 +516,7 @@ u8 rtw_set_802_11_ssid(_adapter* padapter, NDIS_802_11_SSID *ssid)
 	pmlmepriv->assoc_by_bssid=_FALSE;
 
 	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == _TRUE) {
-		pmlmepriv->to_join = _TRUE;
+		pmlmepriv->to_join = _TRUE;	
 	}
 	else {
 		status = rtw_do_join(padapter);
@@ -528,15 +528,14 @@ u8 rtw_set_802_11_ssid(_adapter* padapter, NDIS_802_11_SSID *ssid)
 exit:
 	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
 		("-rtw_set_802_11_ssid: status=%d\n", status));
-
+	
 _func_exit_;
 
 	return status;
-
+	
 }
 
-u8 rtw_set_802_11_connect(_adapter *padapter, const u8 *bssid
-	, NDIS_802_11_SSID *ssid)
+u8 rtw_set_802_11_connect(_adapter* padapter, u8 *bssid, NDIS_802_11_SSID *ssid)
 {
 	_irqL irqL;
 	u8 status = _SUCCESS;
@@ -593,7 +592,7 @@ u8 rtw_set_802_11_connect(_adapter *padapter, const u8 *bssid
 	}
 
 	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == _TRUE) {
-		pmlmepriv->to_join = _TRUE;
+		pmlmepriv->to_join = _TRUE;	
 	}
 	else {
 		status = rtw_do_join(padapter);
@@ -603,7 +602,7 @@ u8 rtw_set_802_11_connect(_adapter *padapter, const u8 *bssid
 	_exit_critical_bh(&pmlmepriv->lock, &irqL);
 
 exit:
-
+	
 _func_exit_;
 
 	return status;
@@ -614,35 +613,35 @@ u8 rtw_set_802_11_connect(_adapter *padapter, const u8 *bssid
 	### NOTE:#### (!!!!)
 	MUST TAKE CARE THAT BEFORE CALLING THIS FUNC, YOU SHOULD HAVE LOCKED pmlmepriv->lock and scanned_queue->lock in sequence
 */
-u8 rtw_set_802_11_infrastructure_mode(_adapter* padapter,
+u8 rtw_set_802_11_infrastructure_mode(_adapter* padapter, 
 	NDIS_802_11_NETWORK_INFRASTRUCTURE networktype)
 {
 	_irqL irqL;
 	struct	mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 	struct	wlan_network	*cur_network = &pmlmepriv->cur_network;
 	NDIS_802_11_NETWORK_INFRASTRUCTURE* pold_state = &(cur_network->network.InfrastructureMode);
-
+	
 _func_enter_;
 
 	RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_notice_,
 		 ("+rtw_set_802_11_infrastructure_mode: old=%d new=%d fw_state=0x%08x\n",
 		  *pold_state, networktype, get_fwstate(pmlmepriv)));
-
+	
 	if(*pold_state != networktype)
 	{
-
+		
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,(" change mode!"));
 		//DBG_871X("change mode, old_mode=%d, new_mode=%d, fw_state=0x%x\n", *pold_state, networktype, get_fwstate(pmlmepriv));
 
 		if(*pold_state==Ndis802_11APMode)
-		{
-			//change to other mode from Ndis802_11APMode
+		{		
+			//change to other mode from Ndis802_11APMode			
 			cur_network->join_res = -1;
-
+			
 #ifdef CONFIG_NATIVEAP_MLME
 			stop_ap_mode(padapter);
 #endif
-		}
+		}	
 
 		if((check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE) ||(*pold_state==Ndis802_11IBSS))
 			rtw_disassoc_cmd(padapter, 0, _TRUE);
@@ -654,7 +653,7 @@ u8 rtw_set_802_11_infrastructure_mode(_adapter* padapter,
 		if((*pold_state == Ndis802_11Infrastructure) ||(*pold_state == Ndis802_11IBSS))
 	       {
 			if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
-			{
+			{		
 				rtw_indicate_disconnect(padapter); //will clr Linked_state; before this function, we must have chked whether  issue dis-assoc_cmd or not
 			}
 	       }
@@ -662,33 +661,33 @@ u8 rtw_set_802_11_infrastructure_mode(_adapter* padapter,
 		*pold_state = networktype;
 
 		_clr_fwstate_(pmlmepriv, ~WIFI_NULL_STATE);
-
+				
 		switch(networktype)
 		{
 			case Ndis802_11IBSS:
 				set_fwstate(pmlmepriv, WIFI_ADHOC_STATE);
 				break;
-
+				
 			case Ndis802_11Infrastructure:
 				set_fwstate(pmlmepriv, WIFI_STATION_STATE);
 				break;
-
+				
 			case Ndis802_11APMode:
 				set_fwstate(pmlmepriv, WIFI_AP_STATE);
 #ifdef CONFIG_NATIVEAP_MLME
 				start_ap_mode(padapter);
 				//rtw_indicate_connect(padapter);
-#endif
-
+#endif				
+				
 				break;
 
 			case Ndis802_11AutoUnknown:
 			case Ndis802_11InfrastructureMax:
-				break;
+				break;                        				
 		}
 
 		//SecClearAllKeys(adapter);
-
+		
 		//RT_TRACE(COMP_OID_SET, DBG_LOUD, ("set_infrastructure: fw_state:%x after changing mode\n",
 		//									get_fwstate(pmlmepriv) ));
 
@@ -720,18 +719,18 @@ u8 rtw_set_802_11_disassociate(_adapter *padapter)
 	}
 
 	_exit_critical_bh(&pmlmepriv->lock, &irqL);
-
+	
 _func_exit_;
 
-	return _TRUE;
+	return _TRUE;	
 }
 
 u8 rtw_set_802_11_bssid_list_scan(_adapter* padapter, NDIS_802_11_SSID *pssid, int ssid_max_num)
-{
+{	
 	_irqL	irqL;
 	struct	mlme_priv		*pmlmepriv= &padapter->mlmepriv;
 	u8	res=_TRUE;
-
+	
 _func_enter_;
 
 	RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("+rtw_set_802_11_bssid_list_scan(), fw_state=%x\n", get_fwstate(pmlmepriv)));
@@ -745,7 +744,7 @@ u8 rtw_set_802_11_bssid_list_scan(_adapter* padapter, NDIS_802_11_SSID *pssid, i
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n===rtw_set_802_11_bssid_list_scan:hw_init_completed==_FALSE===\n"));
 		goto exit;
 	}
-
+	
 	if ((check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE) ||
 		(pmlmepriv->LinkDetectInfo.bBusyTraffic == _TRUE))
 	{
@@ -758,50 +757,50 @@ u8 rtw_set_802_11_bssid_list_scan(_adapter* padapter, NDIS_802_11_SSID *pssid, i
 		} else {
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n###pmlmepriv->sitesurveyctrl.traffic_busy==_TRUE\n\n"));
 		}
-	} else {
+	} else {		
 		if (rtw_is_scan_deny(padapter)) {
 			DBG_871X(FUNC_ADPT_FMT": scan deny\n", FUNC_ADPT_ARG(padapter));
 			indicate_wx_scan_complete_event(padapter);
 			return _SUCCESS;
 		}
-
-		_enter_critical_bh(&pmlmepriv->lock, &irqL);
-
+		
+		_enter_critical_bh(&pmlmepriv->lock, &irqL);		
+		
 		res = rtw_sitesurvey_cmd(padapter, pssid, ssid_max_num, NULL, 0);
-
+		
 		_exit_critical_bh(&pmlmepriv->lock, &irqL);
 	}
 exit:
-
+	
 _func_exit_;
 
-	return res;
+	return res;	
 }
 
-u8 rtw_set_802_11_authentication_mode(_adapter* padapter, NDIS_802_11_AUTHENTICATION_MODE authmode)
+u8 rtw_set_802_11_authentication_mode(_adapter* padapter, NDIS_802_11_AUTHENTICATION_MODE authmode) 
 {
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
 	int res;
 	u8 ret;
-
+	
 _func_enter_;
 
 	RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("set_802_11_auth.mode(): mode=%x\n", authmode));
 
 	psecuritypriv->ndisauthtype=authmode;
-
+	
 	RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("rtw_set_802_11_authentication_mode:psecuritypriv->ndisauthtype=%d", psecuritypriv->ndisauthtype));
-
+	
 	if(psecuritypriv->ndisauthtype>3)
 		psecuritypriv->dot11AuthAlgrthm=dot11AuthAlgrthm_8021X;
-
+	
 	res=rtw_set_auth(padapter,psecuritypriv);
-
+	
 	if(res==_SUCCESS)
 		ret=_TRUE;
 	else
 		ret=_FALSE;
-
+	
 _func_exit_;
 
 	return ret;
@@ -827,7 +826,7 @@ u8 rtw_set_802_11_add_wep(_adapter* padapter, NDIS_802_11_WEP *wep){
 		ret=_FALSE;
 		goto exit;
 	}
-
+	
 	switch(wep->KeyLength)
 	{
 		case 5:
@@ -843,7 +842,7 @@ u8 rtw_set_802_11_add_wep(_adapter* padapter, NDIS_802_11_WEP *wep){
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("MgntActrtw_set_802_11_add_wep:wep->KeyLength!=5 or 13\n"));
 			break;
 	}
-
+	
 	RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("rtw_set_802_11_add_wep:befor memcpy, wep->KeyLength=0x%x wep->KeyIndex=0x%x  keyid =%x\n",wep->KeyLength,wep->KeyIndex,keyid));
 
 	_rtw_memcpy(&(psecuritypriv->dot11DefKey[keyid].skey[0]),&(wep->KeyMaterial),wep->KeyLength);
@@ -860,58 +859,58 @@ u8 rtw_set_802_11_add_wep(_adapter* padapter, NDIS_802_11_WEP *wep){
 		psecuritypriv->dot11DefKey[keyid].skey[12]));
 
 	res=rtw_set_key(padapter,psecuritypriv, keyid, 1);
-
+	
 	if(res==_FAIL)
 		ret= _FALSE;
 exit:
-
+	
 _func_exit_;
 
 	return ret;
-
+	
 }
 
 u8 rtw_set_802_11_remove_wep(_adapter* padapter, u32 keyindex){
-
+	
 	u8 ret=_SUCCESS;
-
+	
 _func_enter_;
 
 	if (keyindex >= 0x80000000 || padapter == NULL){
-
+		
 		ret=_FALSE;
 		goto exit;
 
 	}
-	else
+	else 
 	{
 		int res;
 		struct security_priv* psecuritypriv=&(padapter->securitypriv);
 		if( keyindex < 4 ){
-
+			
 			_rtw_memset(&psecuritypriv->dot11DefKey[keyindex], 0, 16);
-
+			
 			res=rtw_set_key(padapter,psecuritypriv,keyindex, 0);
-
+			
 			psecuritypriv->dot11DefKeylen[keyindex]=0;
-
+			
 			if(res==_FAIL)
 				ret=_FAIL;
-
+			
 		}
 		else
-		{
+		{			
 			ret=_FAIL;
 		}
-
+		
 	}
-
-exit:
-
+	
+exit:	
+	
 _func_exit_;
 
 	return ret;
-
+	
 }
 
 u8 rtw_set_802_11_add_key(_adapter* padapter, NDIS_802_11_KEY *key){
@@ -922,12 +921,12 @@ u8 rtw_set_802_11_add_key(_adapter* padapter, NDIS_802_11_KEY *key){
 	u8	bgroup = _FALSE;
 	u8	bgrouptkey = _FALSE;//can be remove later
 	u8	ret=_SUCCESS;
-
+	
 _func_enter_;
 
 	if (((key->KeyIndex & 0x80000000) == 0) && ((key->KeyIndex & 0x40000000) > 0)){
 
-		// It is invalid to clear bit 31 and set bit 30. If the miniport driver encounters this combination,
+		// It is invalid to clear bit 31 and set bit 30. If the miniport driver encounters this combination, 
 		// it must fail the request and return NDIS_STATUS_INVALID_DATA.
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("rtw_set_802_11_add_key: ((key->KeyIndex & 0x80000000) == 0)[=%d] ",(int)(key->KeyIndex & 0x80000000) == 0));
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("rtw_set_802_11_add_key:((key->KeyIndex & 0x40000000) > 0)[=%d]" , (int)(key->KeyIndex & 0x40000000) > 0));
@@ -937,11 +936,11 @@ u8 rtw_set_802_11_add_key(_adapter* padapter, NDIS_802_11_KEY *key){
 	}
 
 	if(key->KeyIndex & 0x40000000)
-	{
+	{ 
 		// Pairwise key
 
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("OID_802_11_ADD_KEY: +++++ Pairwise key +++++\n"));
-
+	
 		pbssid=get_bssid(&padapter->mlmepriv);
 		stainfo=rtw_get_stainfo(&padapter->stapriv, pbssid);
 
@@ -961,7 +960,7 @@ u8 rtw_set_802_11_add_key(_adapter* padapter, NDIS_802_11_KEY *key){
 		if((stainfo!=NULL)){
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("rtw_set_802_11_add_key: (stainfo->dot118021XPrivacy ==%d)!\n", stainfo->dot118021XPrivacy));
 		}
-
+		
 		if(key->KeyIndex & 0x000000FF){
 			// The key index is specified in the lower 8 bits by values of zero to 255.
 			// The key index should be set to zero for a Pairwise key, and the driver should fail with
@@ -992,7 +991,7 @@ u8 rtw_set_802_11_add_key(_adapter* padapter, NDIS_802_11_KEY *key){
 		if((encryptionalgo== _AES_)&& (key->KeyLength != 16)) {
 			// For our supplicant, EAPPkt9x.vxd, cannot differentiate TKIP and AES case.
 			if(key->KeyLength == 32) {
-				key->KeyLength = 16;
+				key->KeyLength = 16; 
 			} else {
 				ret= _FAIL;
 				goto exit;
@@ -1015,10 +1014,10 @@ u8 rtw_set_802_11_add_key(_adapter* padapter, NDIS_802_11_KEY *key){
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("key index: 0x%8x(0x%8x)\n", key->KeyIndex,(key->KeyIndex&0x3)));
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("key Length: %d\n", key->KeyLength));
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("------------------------------------------\n"));
-
+	
 	}
-	else
-	{
+	else 
+	{	
 		// Group key - KeyIndex(BIT30==0)
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("OID_802_11_ADD_KEY: +++++ Group key +++++\n"));
 
@@ -1043,19 +1042,19 @@ u8 rtw_set_802_11_add_key(_adapter* padapter, NDIS_802_11_KEY *key){
 					RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("Adapter->securitypriv.dot11PrivacyAlgrthm= %x key->KeyLength=%u \n", padapter->securitypriv.dot11PrivacyAlgrthm,key->KeyLength));
 					break;
 			}
-
+			
 			encryptionalgo=padapter->securitypriv.dot11PrivacyAlgrthm;
-
+			
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,(" Adapter->securitypriv.dot11PrivacyAlgrthm=%x\n", padapter->securitypriv.dot11PrivacyAlgrthm));
-
+			
 		}
-		else
+		else 
 		{
 			encryptionalgo=padapter->securitypriv.dot118021XGrpPrivacy;
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("( Adapter->securitypriv.dot11PrivacyAlgrthm=%x  )encryptionalgo(%x)=padapter->securitypriv.dot118021XGrpPrivacy(%x)keylen=%d\n", padapter->securitypriv.dot11PrivacyAlgrthm,encryptionalgo,padapter->securitypriv.dot118021XGrpPrivacy,key->KeyLength));
 
 		}
-
+		
 		if((check_fwstate(&padapter->mlmepriv, WIFI_ADHOC_STATE)==_TRUE) && (IS_MAC_ADDRESS_BROADCAST(key->BSSID) == _FALSE)) {
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,(" IBSS but BSSID is not Broadcast Address.\n"));
 			ret= _FAIL;
@@ -1070,7 +1069,7 @@ u8 rtw_set_802_11_add_key(_adapter* padapter, NDIS_802_11_KEY *key){
 			goto exit;
 
 		} else if(encryptionalgo== _AES_ && (key->KeyLength != 16 && key->KeyLength != 32) ) {
-
+			
 			// Check key length for AES
 			// For NDTEST, we allow keylen=32 in this case. 2005.01.27, by rcnjko.
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("<=== SetInfo, OID_802_11_ADD_KEY: AES GTK KeyLength:%u != 16 or 32\n", key->KeyLength));
@@ -1080,7 +1079,7 @@ u8 rtw_set_802_11_add_key(_adapter* padapter, NDIS_802_11_KEY *key){
 
 		// Change the key length for EAPPkt9x.vxd. Added by Annie, 2005-11-03.
 		if((encryptionalgo==  _AES_) && (key->KeyLength == 32) ) {
-			key->KeyLength = 16;
+			key->KeyLength = 16; 
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("AES key length changed: %u\n", key->KeyLength) );
 		}
 
@@ -1101,36 +1100,36 @@ u8 rtw_set_802_11_add_key(_adapter* padapter, NDIS_802_11_KEY *key){
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("key index: 0x%8x(0x%8x)\n", key->KeyIndex,(key->KeyIndex&0x3)));
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("key Length: %d\n", key->KeyLength)) ;
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("------------------------------------------\n"));
-
-	}
+		
+	}	
 
 	// If WEP encryption algorithm, just call rtw_set_802_11_add_wep().
 	if((padapter->securitypriv.dot11AuthAlgrthm !=dot11AuthAlgrthm_8021X)&&(encryptionalgo== _WEP40_  || encryptionalgo== _WEP104_))
 	{
-		u8 ret;
-		u32 keyindex;
+		u8 ret;		
+		u32 keyindex;		
 		u32 len = FIELD_OFFSET(NDIS_802_11_KEY, KeyMaterial) + key->KeyLength;
 		NDIS_802_11_WEP *wep = &padapter->securitypriv.ndiswep;
-
+				
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("OID_802_11_ADD_KEY: +++++ WEP key +++++\n"));
 
 		wep->Length = len;
 		keyindex = key->KeyIndex&0x7fffffff;
 		wep->KeyIndex = keyindex ;
 		wep->KeyLength = key->KeyLength;
-
+		
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("OID_802_11_ADD_KEY:Before memcpy \n"));
 
-		_rtw_memcpy(wep->KeyMaterial, key->KeyMaterial, key->KeyLength);
+		_rtw_memcpy(wep->KeyMaterial, key->KeyMaterial, key->KeyLength);	
 		_rtw_memcpy(&(padapter->securitypriv.dot11DefKey[keyindex].skey[0]), key->KeyMaterial, key->KeyLength);
 
-		padapter->securitypriv.dot11DefKeylen[keyindex]=key->KeyLength;
+		padapter->securitypriv.dot11DefKeylen[keyindex]=key->KeyLength;		
 		padapter->securitypriv.dot11PrivacyKeyIndex=keyindex;
-
+		
 		ret = rtw_set_802_11_add_wep(padapter, wep);
-
+	
 		goto exit;
-
+		
 	}
 
 	if(key->KeyIndex & 0x20000000){
@@ -1139,14 +1138,14 @@ u8 rtw_set_802_11_add_key(_adapter* padapter, NDIS_802_11_KEY *key){
 		if(bgroup == _TRUE)
 		{
 			NDIS_802_11_KEY_RSC keysrc=key->KeyRSC & 0x00FFFFFFFFFFFFULL;
-			_rtw_memcpy(&padapter->securitypriv.dot11Grprxpn, &keysrc, 8);
-		}
-		else
-		{
-			NDIS_802_11_KEY_RSC keysrc=key->KeyRSC & 0x00FFFFFFFFFFFFULL;
-			_rtw_memcpy(&padapter->securitypriv.dot11Grptxpn, &keysrc, 8);
+			_rtw_memcpy(&padapter->securitypriv.dot11Grprxpn, &keysrc, 8);			
+		} 
+		else 
+		{		
+			NDIS_802_11_KEY_RSC keysrc=key->KeyRSC & 0x00FFFFFFFFFFFFULL;	
+			_rtw_memcpy(&padapter->securitypriv.dot11Grptxpn, &keysrc, 8);			
 		}
-
+			
 	}
 
 	// Indicate this key idx is used for TX
@@ -1154,26 +1153,26 @@ u8 rtw_set_802_11_add_key(_adapter* padapter, NDIS_802_11_KEY *key){
 	if(bgroup == _TRUE) // Group transmit key
 	{
 		int res;
-
+		
 		if(bgrouptkey == _TRUE)
-		{
+		{		
 			padapter->securitypriv.dot118021XGrpKeyid=(u8)key->KeyIndex;
 		}
-
+		
 		if((key->KeyIndex&0x3) == 0){
 			ret = _FAIL;
 			goto exit;
-		}
-
+		}		
+		
 		_rtw_memset(&padapter->securitypriv.dot118021XGrpKey[(u8)((key->KeyIndex) & 0x03)], 0, 16);
 		_rtw_memset(&padapter->securitypriv.dot118021XGrptxmickey[(u8)((key->KeyIndex) & 0x03)], 0, 16);
 		_rtw_memset(&padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)], 0, 16);
-
+		
 		if((key->KeyIndex & 0x10000000))
 		{
 			_rtw_memcpy(&padapter->securitypriv.dot118021XGrptxmickey[(u8)((key->KeyIndex) & 0x03)], key->KeyMaterial + 16, 8);
 			_rtw_memcpy(&padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)], key->KeyMaterial + 24, 8);
-
+			
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n rtw_set_802_11_add_key:rx mic :0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
 				padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)].skey[0],padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[1],
 				padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)].skey[2],padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[3],
@@ -1186,56 +1185,56 @@ u8 rtw_set_802_11_add_key(_adapter* padapter, NDIS_802_11_KEY *key){
 		{
 			_rtw_memcpy(&padapter->securitypriv.dot118021XGrptxmickey[(u8)((key->KeyIndex) & 0x03)], key->KeyMaterial + 24, 8);
 			_rtw_memcpy(&padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)], key->KeyMaterial + 16, 8);
-
+			
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n rtw_set_802_11_add_key:rx mic :0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
 				padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)].skey[0],padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[1],
 				padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)].skey[2],padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[3],
 				padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)].skey[4],padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[5],
 				padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)].skey[6],padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[7]));
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n rtw_set_802_11_add_key:set Group mic key!!!!!!!!\n"));
-
+		
 		}
 
 		//set group key by index
 		_rtw_memcpy(&padapter->securitypriv.dot118021XGrpKey[(u8)((key->KeyIndex) & 0x03)], key->KeyMaterial, key->KeyLength);
-
+		
 		key->KeyIndex=key->KeyIndex & 0x03;
-
+		
 		padapter->securitypriv.binstallGrpkey=_TRUE;
-
+		
 		padapter->securitypriv.bcheck_grpkey=_FALSE;
-
+		
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("reset group key"));
-
+		
 		res=rtw_set_key(padapter,&padapter->securitypriv, key->KeyIndex, 1);
 
 		if(res==_FAIL)
 			ret= _FAIL;
 
 		goto exit;
-
+			
 	}
 	else // Pairwise Key
 	{
 		u8 res;
-
+		
 		pbssid=get_bssid(&padapter->mlmepriv);
 		stainfo=rtw_get_stainfo(&padapter->stapriv , pbssid );
-
+		
 		if(stainfo!=NULL)
-		{
+		{			
 			_rtw_memset( &stainfo->dot118021x_UncstKey, 0, 16);// clear keybuffer
-
+			
 			_rtw_memcpy(&stainfo->dot118021x_UncstKey, key->KeyMaterial, 16);
-
+			
 			if(encryptionalgo== _TKIP_)
 			{
 				padapter->securitypriv.busetkipkey=_FALSE;
-
+				
 				//_set_timer(&padapter->securitypriv.tkip_timer, 50);
-
+				
 				RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n ==========_set_timer\n"));
-
+				
 				// if TKIP, save the Receive/Transmit MIC key in KeyMaterial[128-255]
 				if((key->KeyIndex & 0x10000000)){
 					_rtw_memcpy(&stainfo->dot11tkiptxmickey, key->KeyMaterial + 16, 8);
@@ -1246,14 +1245,14 @@ u8 rtw_set_802_11_add_key(_adapter* padapter, NDIS_802_11_KEY *key){
 					_rtw_memcpy(&stainfo->dot11tkiprxmickey, key->KeyMaterial + 16, 8);
 
 				}
-
+		
 			}
 			else if(encryptionalgo == _AES_)
-			{
-
+			{		
+	
 			}
 
-
+		
 			//Set key to CAM through H2C command
 			if(bgrouptkey)//never go to here
 			{
@@ -1264,30 +1263,30 @@ u8 rtw_set_802_11_add_key(_adapter* padapter, NDIS_802_11_KEY *key){
 				res=rtw_setstakey_cmd(padapter, (unsigned char *)stainfo, _TRUE);
 				RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n rtw_set_802_11_add_key:rtw_setstakey_cmd(unicast)\n"));
 			}
-
+			
 			if(res ==_FALSE)
 				ret= _FAIL;
-
+			
 		}
 
 	}
 
 exit:
-
+	
 _func_exit_;
 
-	return ret;
+	return ret;	
 }
 
 u8 rtw_set_802_11_remove_key(_adapter*	padapter, NDIS_802_11_REMOVE_KEY *key){
-
+	
 	uint				encryptionalgo;
 	u8 * pbssid;
 	struct sta_info *stainfo;
 	u8	bgroup = (key->KeyIndex & 0x4000000) > 0 ? _FALSE: _TRUE;
 	u8	keyIndex = (u8)key->KeyIndex & 0x03;
 	u8	ret=_SUCCESS;
-
+	
 _func_enter_;
 
 	if ((key->KeyIndex & 0xbffffffc) > 0) {
@@ -1300,13 +1299,13 @@ u8 rtw_set_802_11_remove_key(_adapter*	padapter, NDIS_802_11_REMOVE_KEY *key){
 		// clear group key by index
 		//NdisZeroMemory(Adapter->MgntInfo.SecurityInfo.KeyBuf[keyIndex], MAX_WEP_KEY_LEN);
 		//Adapter->MgntInfo.SecurityInfo.KeyLen[keyIndex] = 0;
-
+		
 		_rtw_memset(&padapter->securitypriv.dot118021XGrpKey[keyIndex], 0, 16);
-
+		
 		//! \todo Send a H2C Command to Firmware for removing this Key in CAM Entry.
-
+	
 	} else {
-
+	
 		pbssid=get_bssid(&padapter->mlmepriv);
 		stainfo=rtw_get_stainfo(&padapter->stapriv , pbssid );
 		if(stainfo !=NULL){
@@ -1314,7 +1313,7 @@ u8 rtw_set_802_11_remove_key(_adapter*	padapter, NDIS_802_11_REMOVE_KEY *key){
 
 		// clear key by BSSID
 		_rtw_memset(&stainfo->dot118021x_UncstKey, 0, 16);
-
+		
 		//! \todo Send a H2C Command to Firmware for disable this Key in CAM Entry.
 
 		}
@@ -1325,17 +1324,17 @@ u8 rtw_set_802_11_remove_key(_adapter*	padapter, NDIS_802_11_REMOVE_KEY *key){
 	}
 
 exit:
-
+	
 _func_exit_;
 
 	return _TRUE;
-
+	
 }
 
 /*
-* rtw_get_cur_max_rate -
+* rtw_get_cur_max_rate - 
 * @adapter: pointer to _adapter structure
-*
+* 
 * Return 0 or 100Kbps
 */
 u16 rtw_get_cur_max_rate(_adapter *adapter)
@@ -1353,18 +1352,18 @@ u16 rtw_get_cur_max_rate(_adapter *adapter)
 	u8	rf_type = 0;
 	u8	bw_40MHz=0, short_GI_20=0, short_GI_40=0;
 	u16	mcs_rate=0;
-	u32	ht_ielen = 0;
+	u32	ht_ielen = 0;	
 #endif
 
 #ifdef CONFIG_MP_INCLUDED
 	if (adapter->registrypriv.mp_mode == 1)
-	{
+	{	
 		if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE)
 			return 0;
 	}
 #endif
 
-	if((check_fwstate(pmlmepriv, _FW_LINKED) != _TRUE)
+	if((check_fwstate(pmlmepriv, _FW_LINKED) != _TRUE) 
 		&& (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) != _TRUE))
 		return 0;
 
@@ -1374,13 +1373,13 @@ u16 rtw_get_cur_max_rate(_adapter *adapter)
 		if(p && ht_ielen>0)
 		{
 			pht_capie = (struct rtw_ieee80211_ht_cap *)(p+2);
-
+		
 			_rtw_memcpy(&mcs_rate , pht_capie->supp_mcs_set, 2);
 
 			//bw_40MHz = (pht_capie->cap_info&IEEE80211_HT_CAP_SUP_WIDTH) ? 1:0;
 			//cur_bwmod is updated by beacon, pmlmeinfo is updated by association response
 			bw_40MHz = (pmlmeext->cur_bwmode && (HT_INFO_HT_PARAM_REC_TRANS_CHNL_WIDTH & pmlmeinfo->HT_info.infos[0])) ? 1:0;
-
+			
 			//short_GI = (pht_capie->cap_info&(IEEE80211_HT_CAP_SGI_20|IEEE80211_HT_CAP_SGI_40)) ? 1:0;
 			short_GI_20 = (pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info&IEEE80211_HT_CAP_SGI_20) ? 1:0;
 			short_GI_40 = (pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info&IEEE80211_HT_CAP_SGI_40) ? 1:0;
@@ -1388,13 +1387,13 @@ u16 rtw_get_cur_max_rate(_adapter *adapter)
 			rtw_hal_get_hwreg(adapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
 			max_rate = rtw_mcs_rate(
 				rf_type,
-				bw_40MHz & (pregistrypriv->cbw40_enable),
+				bw_40MHz & (pregistrypriv->cbw40_enable), 
 				short_GI_20,
 				short_GI_40,
 				pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate
 			);
 		}
-	}
+	} 
 	else
 #endif //CONFIG_80211N_HT
 	{
@@ -1405,7 +1404,7 @@ u16 rtw_get_cur_max_rate(_adapter *adapter)
 				max_rate = rate;
 			i++;
 		}
-
+	
 		max_rate = max_rate*10/2;
 	}
 
@@ -1413,27 +1412,27 @@ u16 rtw_get_cur_max_rate(_adapter *adapter)
 }
 
 /*
-* rtw_set_scan_mode -
+* rtw_set_scan_mode - 
 * @adapter: pointer to _adapter structure
-* @scan_mode:
-*
+* @scan_mode: 
+* 
 * Return _SUCCESS or _FAIL
 */
 int rtw_set_scan_mode(_adapter *adapter, RT_SCAN_TYPE scan_mode)
 {
 	if(scan_mode != SCAN_ACTIVE && scan_mode != SCAN_PASSIVE)
 		return _FAIL;
-
+	
 	adapter->mlmepriv.scan_mode = scan_mode;
 
 	return _SUCCESS;
 }
 
 /*
-* rtw_set_channel_plan -
+* rtw_set_channel_plan - 
 * @adapter: pointer to _adapter structure
-* @channel_plan:
-*
+* @channel_plan: 
+* 
 * Return _SUCCESS or _FAIL
 */
 int rtw_set_channel_plan(_adapter *adapter, u8 channel_plan)
@@ -1446,10 +1445,10 @@ int rtw_set_channel_plan(_adapter *adapter, u8 channel_plan)
 }
 
 /*
-* rtw_set_country -
+* rtw_set_country - 
 * @adapter: pointer to _adapter structure
 * @country_code: string of country code
-*
+* 
 * Return _SUCCESS or _FAIL
 */
 int rtw_set_country(_adapter *adapter, const char *country_code)
@@ -1470,15 +1469,15 @@ int rtw_set_country(_adapter *adapter, const char *country_code)
 		channel_plan = RT_CHANNEL_DOMAIN_CHINA;
 	else
 		DBG_871X("%s unknown country_code:%s\n", __FUNCTION__, country_code);
-
+	
 	return rtw_set_channel_plan(adapter, channel_plan);
 }
 
 /*
-* rtw_set_band -
+* rtw_set_band - 
 * @adapter: pointer to _adapter structure
 * @band: band to set
-*
+* 
 * Return _SUCCESS or _FAIL
 */
 int rtw_set_band(_adapter *adapter, enum _BAND band)
@@ -1492,3 +1491,4 @@ int rtw_set_band(_adapter *adapter, enum _BAND band)
 	DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" band:%d fail\n", FUNC_ADPT_ARG(adapter), band);
 	return _FAIL;
 }
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_iol.c b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_iol.c
old mode 100644
new mode 100755
index 20632d6..872cc42
--- a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_iol.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_iol.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -34,7 +34,7 @@ struct xmit_frame	*rtw_IOL_accquire_xmit_frame(ADAPTER *adapter)
 		DBG_871X("%s rtw_alloc_xmitframe return null\n", __FUNCTION__);
 		goto exit;
 	}
-
+	
 	if ((xmitbuf = rtw_alloc_xmitbuf(pxmitpriv)) == NULL)
 	{
 		DBG_871X("%s rtw_alloc_xmitbuf return null\n", __FUNCTION__);
@@ -42,7 +42,7 @@ struct xmit_frame	*rtw_IOL_accquire_xmit_frame(ADAPTER *adapter)
 		xmit_frame=NULL;
 		goto exit;
 	}
-
+	
 	xmit_frame->frame_tag = MGNT_FRAMETAG;
 	xmit_frame->pxmitbuf = xmitbuf;
 	xmit_frame->buf_addr = xmitbuf->pbuf;
@@ -98,14 +98,14 @@ int rtw_IOL_append_cmds(struct xmit_frame *xmit_frame, u8 *IOL_cmds, u32 cmd_len
 	pattrib->last_txcmdsz += cmd_len;
 
 	//DBG_871X("%s ori:%u + cmd_len:%u = %u\n", __FUNCTION__, ori_len, cmd_len, buf_offset+pattrib->pktlen);
-
+	
 	return _SUCCESS;
 }
 
 int rtw_IOL_append_LLT_cmd(struct xmit_frame *xmit_frame, u8 page_boundary)
 {
 	IOL_CMD cmd = {0x0, IOL_CMD_LLT, 0x0, 0x0};
-
+	
 	RTW_PUT_BE32((u8*)&cmd.value, (u32)page_boundary);
 
 	return rtw_IOL_append_cmds(xmit_frame, (u8*)&cmd, 8);
@@ -114,7 +114,7 @@ int rtw_IOL_append_LLT_cmd(struct xmit_frame *xmit_frame, u8 page_boundary)
 int _rtw_IOL_append_WB_cmd(struct xmit_frame *xmit_frame, u16 addr, u8 value)
 {
 	IOL_CMD cmd = {0x0, IOL_CMD_WB_REG, 0x0, 0x0};
-
+	
 	RTW_PUT_BE16((u8*)&cmd.address, (u16)addr);
 	RTW_PUT_BE32((u8*)&cmd.value, (u32)value);
 
@@ -124,7 +124,7 @@ int _rtw_IOL_append_WB_cmd(struct xmit_frame *xmit_frame, u16 addr, u8 value)
 int _rtw_IOL_append_WW_cmd(struct xmit_frame *xmit_frame, u16 addr, u16 value)
 {
 	IOL_CMD cmd = {0x0, IOL_CMD_WW_REG, 0x0, 0x0};
-
+	
 	RTW_PUT_BE16((u8*)&cmd.address, (u16)addr);
 	RTW_PUT_BE32((u8*)&cmd.value, (u32)value);
 
@@ -135,7 +135,7 @@ int _rtw_IOL_append_WD_cmd(struct xmit_frame *xmit_frame, u16 addr, u32 value)
 {
 	IOL_CMD cmd = {0x0, IOL_CMD_WD_REG, 0x0, 0x0};
 	u8* pos = (u8 *)&cmd;
-
+	
 	RTW_PUT_BE16((u8*)&cmd.address, (u16)addr);
 	RTW_PUT_BE32((u8*)&cmd.value, (u32)value);
 
@@ -171,7 +171,7 @@ int dbg_rtw_IOL_append_WD_cmd(struct xmit_frame *xmit_frame, u16 addr, u32 value
 int rtw_IOL_append_DELAY_US_cmd(struct xmit_frame *xmit_frame, u16 us)
 {
 	IOL_CMD cmd = {0x0, IOL_CMD_DELAY_US, 0x0, 0x0};
-
+	
 	RTW_PUT_BE32((u8*)&cmd.value, (u32)us);
 
 	//DBG_871X("%s %u\n", __FUNCTION__, us);
@@ -182,7 +182,7 @@ int rtw_IOL_append_DELAY_US_cmd(struct xmit_frame *xmit_frame, u16 us)
 int rtw_IOL_append_DELAY_MS_cmd(struct xmit_frame *xmit_frame, u16 ms)
 {
 	IOL_CMD cmd = {0x0, IOL_CMD_DELAY_MS, 0x0, 0x0};
-
+	
 	RTW_PUT_BE32((u8*)&cmd.value, (u32)ms);
 
 	//DBG_871X("%s %u\n", __FUNCTION__, ms);
@@ -218,7 +218,7 @@ int rtw_IOL_append_END_cmd(struct xmit_frame *xmit_frame)
 	pattrib->last_txcmdsz += 8;
 
 	//DBG_871X("%s ori:%u + 8 = %u\n", __FUNCTION__ , ori_len, buf_offset+pattrib->pktlen);
-
+	
 	return _SUCCESS;
 }
 
@@ -260,3 +260,4 @@ bool rtw_IOL_applied(ADAPTER *adapter)
 }
 
 #endif //CONFIG_IOL
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_mlme.c b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_mlme.c
old mode 100644
new mode 100755
index 2dc13a4..00edd9c
--- a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_mlme.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_mlme.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -63,26 +63,26 @@ sint	_rtw_init_mlme_priv (_adapter* padapter)
 	pmlmepriv->cur_network.network.InfrastructureMode = Ndis802_11AutoUnknown;
 	pmlmepriv->scan_mode=SCAN_ACTIVE;// 1: active, 0: pasive. Maybe someday we should rename this varable to "active_mode" (Jeff)
 
-	_rtw_spinlock_init(&(pmlmepriv->lock));
+	_rtw_spinlock_init(&(pmlmepriv->lock));	
 	_rtw_init_queue(&(pmlmepriv->free_bss_pool));
 	_rtw_init_queue(&(pmlmepriv->scanned_queue));
 
 	set_scanned_network_val(pmlmepriv, 0);
-
+	
 	_rtw_memset(&pmlmepriv->assoc_ssid,0,sizeof(NDIS_802_11_SSID));
 
 	pbuf = rtw_zvmalloc(MAX_BSS_CNT * (sizeof(struct wlan_network)));
-
+	
 	if (pbuf == NULL){
 		res=_FAIL;
 		goto exit;
 	}
 	pmlmepriv->free_bss_buf = pbuf;
-
+		
 	pnetwork = (struct wlan_network *)pbuf;
-
+	
 	for(i = 0; i < MAX_BSS_CNT; i++)
-	{
+	{		
 		_rtw_init_listhead(&(pnetwork->list));
 
 		rtw_list_insert_tail(&(pnetwork->list), &(pmlmepriv->free_bss_pool.queue));
@@ -101,7 +101,7 @@ sint	_rtw_init_mlme_priv (_adapter* padapter)
 _func_exit_;
 
 	return res;
-}
+}	
 
 void rtw_mfree_mlme_priv_lock (struct mlme_priv *pmlmepriv);
 void rtw_mfree_mlme_priv_lock (struct mlme_priv *pmlmepriv)
@@ -114,11 +114,11 @@ void rtw_mfree_mlme_priv_lock (struct mlme_priv *pmlmepriv)
 static void rtw_free_mlme_ie_data(u8 **ppie, u32 *plen)
 {
 	if(*ppie)
-	{
+	{		
 		rtw_mfree(*ppie, *plen);
 		*plen = 0;
 		*ppie=NULL;
-	}
+	}	
 }
 
 void rtw_free_mlme_priv_ie_data(struct mlme_priv *pmlmepriv)
@@ -130,7 +130,7 @@ void rtw_free_mlme_priv_ie_data(struct mlme_priv *pmlmepriv)
 	rtw_free_mlme_ie_data(&pmlmepriv->wps_probe_req_ie, &pmlmepriv->wps_probe_req_ie_len);
 	rtw_free_mlme_ie_data(&pmlmepriv->wps_probe_resp_ie, &pmlmepriv->wps_probe_resp_ie_len);
 	rtw_free_mlme_ie_data(&pmlmepriv->wps_assoc_resp_ie, &pmlmepriv->wps_assoc_resp_ie_len);
-
+	
 	rtw_free_mlme_ie_data(&pmlmepriv->p2p_beacon_ie, &pmlmepriv->p2p_beacon_ie_len);
 	rtw_free_mlme_ie_data(&pmlmepriv->p2p_probe_req_ie, &pmlmepriv->p2p_probe_req_ie_len);
 	rtw_free_mlme_ie_data(&pmlmepriv->p2p_probe_resp_ie, &pmlmepriv->p2p_probe_resp_ie_len);
@@ -138,7 +138,7 @@ void rtw_free_mlme_priv_ie_data(struct mlme_priv *pmlmepriv)
 	rtw_free_mlme_ie_data(&pmlmepriv->p2p_assoc_req_ie, &pmlmepriv->p2p_assoc_req_ie_len);
 #endif
 
-#if defined(CONFIG_WFD) && defined(CONFIG_IOCTL_CFG80211)
+#if defined(CONFIG_WFD) && defined(CONFIG_IOCTL_CFG80211)	
 	rtw_free_mlme_ie_data(&pmlmepriv->wfd_beacon_ie, &pmlmepriv->wfd_beacon_ie_len);
 	rtw_free_mlme_ie_data(&pmlmepriv->wfd_probe_req_ie, &pmlmepriv->wfd_probe_req_ie_len);
 	rtw_free_mlme_ie_data(&pmlmepriv->wfd_probe_resp_ie, &pmlmepriv->wfd_probe_resp_ie_len);
@@ -161,27 +161,27 @@ void _rtw_free_mlme_priv (struct mlme_priv *pmlmepriv)
 			rtw_vmfree(pmlmepriv->free_bss_buf, MAX_BSS_CNT * sizeof(struct wlan_network));
 		}
 	}
-_func_exit_;
+_func_exit_;	
 }
 
 sint	_rtw_enqueue_network(_queue *queue, struct wlan_network *pnetwork)
 {
 	_irqL irqL;
 
-_func_enter_;
+_func_enter_;	
 
 	if (pnetwork == NULL)
 		goto exit;
-
+	
 	_enter_critical_bh(&queue->lock, &irqL);
 
 	rtw_list_insert_tail(&pnetwork->list, &queue->queue);
 
 	_exit_critical_bh(&queue->lock, &irqL);
 
-exit:
+exit:	
 
-_func_exit_;
+_func_exit_;		
 
 	return _SUCCESS;
 }
@@ -192,24 +192,24 @@ struct	wlan_network *_rtw_dequeue_network(_queue *queue)
 
 	struct wlan_network *pnetwork;
 
-_func_enter_;
+_func_enter_;	
 
 	_enter_critical_bh(&queue->lock, &irqL);
 
 	if (_rtw_queue_empty(queue) == _TRUE)
 
 		pnetwork = NULL;
-
+	
 	else
 	{
 		pnetwork = LIST_CONTAINOR(get_next(&queue->queue), struct wlan_network, list);
-
+		
 		rtw_list_delete(&(pnetwork->list));
 	}
-
+	
 	_exit_critical_bh(&queue->lock, &irqL);
 
-_func_exit_;
+_func_exit_;		
 
 	return pnetwork;
 }
@@ -217,49 +217,49 @@ struct	wlan_network *_rtw_dequeue_network(_queue *queue)
 struct	wlan_network *_rtw_alloc_network(struct	mlme_priv *pmlmepriv )//(_queue *free_queue)
 {
 	_irqL	irqL;
-	struct	wlan_network	*pnetwork;
+	struct	wlan_network	*pnetwork;	
 	_queue *free_queue = &pmlmepriv->free_bss_pool;
 	_list* plist = NULL;
-
-_func_enter_;
+	
+_func_enter_;	
 
 	_enter_critical_bh(&free_queue->lock, &irqL);
-
+	
 	if (_rtw_queue_empty(free_queue) == _TRUE) {
 		pnetwork=NULL;
 		goto exit;
 	}
 	plist = get_next(&(free_queue->queue));
-
+	
 	pnetwork = LIST_CONTAINOR(plist , struct wlan_network, list);
-
+	
 	rtw_list_delete(&pnetwork->list);
-
+	
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("_rtw_alloc_network: ptr=%p\n", plist));
 	pnetwork->network_type = 0;
 	pnetwork->fixed = _FALSE;
 	pnetwork->last_scanned = rtw_get_current_time();
-	pnetwork->aid=0;
+	pnetwork->aid=0;	
 	pnetwork->join_res=0;
 
 	pmlmepriv->num_of_scanned ++;
-
+	
 exit:
 	_exit_critical_bh(&free_queue->lock, &irqL);
 
-_func_exit_;
+_func_exit_;		
 
-	return pnetwork;
+	return pnetwork;	
 }
 
 void _rtw_free_network(struct	mlme_priv *pmlmepriv ,struct wlan_network *pnetwork, u8 isfreeall)
 {
 	u32 curr_time, delta_time;
 	u32 lifetime = SCANQUEUE_LIFETIME;
-	_irqL irqL;
+	_irqL irqL;	
 	_queue *free_queue = &(pmlmepriv->free_bss_pool);
-
-_func_enter_;
+	
+_func_enter_;		
 
 	if (pnetwork == NULL)
 		goto exit;
@@ -267,9 +267,9 @@ void _rtw_free_network(struct	mlme_priv *pmlmepriv ,struct wlan_network *pnetwor
 	if (pnetwork->fixed == _TRUE)
 		goto exit;
 
-	curr_time = rtw_get_current_time();
+	curr_time = rtw_get_current_time();	
 
-	if ( (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)==_TRUE ) ||
+	if ( (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)==_TRUE ) || 
 		(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)==_TRUE ) )
 		lifetime = 1;
 
@@ -288,10 +288,10 @@ void _rtw_free_network(struct	mlme_priv *pmlmepriv ,struct wlan_network *pnetwor
 
 #ifdef PLATFORM_LINUX
 
-		delta_time = (curr_time -pnetwork->last_scanned)/HZ;
+		delta_time = (curr_time -pnetwork->last_scanned)/HZ;	
 
 		if(delta_time < lifetime)// unit:sec
-		{
+		{		
 			goto exit;
 		}
 
@@ -299,10 +299,10 @@ void _rtw_free_network(struct	mlme_priv *pmlmepriv ,struct wlan_network *pnetwor
 
 #ifdef PLATFORM_FREEBSD
         //i think needs to check again
-		delta_time = (curr_time -pnetwork->last_scanned)/hz;
+		delta_time = (curr_time -pnetwork->last_scanned)/hz;	
 
 		if(delta_time < lifetime)// unit:sec
-		{
+		{		
 			goto exit;
 		}
 
@@ -310,21 +310,21 @@ void _rtw_free_network(struct	mlme_priv *pmlmepriv ,struct wlan_network *pnetwor
 	}
 
 	_enter_critical_bh(&free_queue->lock, &irqL);
-
+	
 	rtw_list_delete(&(pnetwork->list));
 
 	rtw_list_insert_tail(&(pnetwork->list),&(free_queue->queue));
-
+		
 	pmlmepriv->num_of_scanned --;
-
+	
 
 	//DBG_871X("_rtw_free_network:SSID=%s\n", pnetwork->network.Ssid.Ssid);
-
+	
 	_exit_critical_bh(&free_queue->lock, &irqL);
-
-exit:
-
-_func_exit_;
+	
+exit:		
+	
+_func_exit_;			
 
 }
 
@@ -333,7 +333,7 @@ void _rtw_free_network_nolock(struct	mlme_priv *pmlmepriv, struct wlan_network *
 
 	_queue *free_queue = &(pmlmepriv->free_bss_pool);
 
-_func_enter_;
+_func_enter_;		
 
 	if (pnetwork == NULL)
 		goto exit;
@@ -342,18 +342,18 @@ void _rtw_free_network_nolock(struct	mlme_priv *pmlmepriv, struct wlan_network *
 		goto exit;
 
 	//_enter_critical(&free_queue->lock, &irqL);
-
+	
 	rtw_list_delete(&(pnetwork->list));
 
 	rtw_list_insert_tail(&(pnetwork->list), get_list_head(free_queue));
-
+		
 	pmlmepriv->num_of_scanned --;
-
+	
 	//_exit_critical(&free_queue->lock, &irqL);
+	
+exit:		
 
-exit:
-
-_func_exit_;
+_func_exit_;			
 
 }
 
@@ -370,26 +370,26 @@ struct wlan_network *_rtw_find_network(_queue *scanned_queue, u8 *addr)
 	_list	*phead, *plist;
 	struct	wlan_network *pnetwork = NULL;
 	u8 zero_addr[ETH_ALEN] = {0,0,0,0,0,0};
-
-_func_enter_;
+	
+_func_enter_;	
 
 	if(_rtw_memcmp(zero_addr, addr, ETH_ALEN)){
 		pnetwork=NULL;
 		goto exit;
 	}
-
+	
 	//_enter_critical_bh(&scanned_queue->lock, &irqL);
-
+	
 	phead = get_list_head(scanned_queue);
 	plist = get_next(phead);
-
+	 
 	while (plist != phead)
        {
                 pnetwork = LIST_CONTAINOR(plist, struct wlan_network ,list);
 
 		if (_rtw_memcmp(addr, pnetwork->network.MacAddress, ETH_ALEN) == _TRUE)
                         break;
-
+		
 		plist = get_next(plist);
         }
 
@@ -397,13 +397,13 @@ struct wlan_network *_rtw_find_network(_queue *scanned_queue, u8 *addr)
 		pnetwork = NULL;
 
 	//_exit_critical_bh(&scanned_queue->lock, &irqL);
-
-exit:
-
-_func_exit_;
+	
+exit:		
+	
+_func_exit_;		
 
 	return pnetwork;
-
+	
 }
 
 
@@ -415,8 +415,8 @@ void _rtw_free_network_queue(_adapter *padapter, u8 isfreeall)
 	struct mlme_priv* pmlmepriv = &padapter->mlmepriv;
 	_queue *scanned_queue = &pmlmepriv->scanned_queue;
 
-_func_enter_;
-
+_func_enter_;	
+	
 
 	_enter_critical_bh(&scanned_queue->lock, &irqL);
 
@@ -431,12 +431,12 @@ void _rtw_free_network_queue(_adapter *padapter, u8 isfreeall)
 		plist = get_next(plist);
 
 		_rtw_free_network(pmlmepriv,pnetwork, isfreeall);
-
+		
 	}
 
 	_exit_critical_bh(&scanned_queue->lock, &irqL);
-
-_func_exit_;
+	
+_func_exit_;		
 
 }
 
@@ -446,16 +446,16 @@ void _rtw_free_network_queue(_adapter *padapter, u8 isfreeall)
 sint rtw_if_up(_adapter *padapter)	{
 
 	sint res;
-_func_enter_;
+_func_enter_;		
 
 	if( padapter->bDriverStopped || padapter->bSurpriseRemoved ||
-		(check_fwstate(&padapter->mlmepriv, _FW_LINKED)== _FALSE)){
-		RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_if_up:bDriverStopped(%d) OR bSurpriseRemoved(%d)", padapter->bDriverStopped, padapter->bSurpriseRemoved));
+		(check_fwstate(&padapter->mlmepriv, _FW_LINKED)== _FALSE)){		
+		RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_if_up:bDriverStopped(%d) OR bSurpriseRemoved(%d)", padapter->bDriverStopped, padapter->bSurpriseRemoved));	
 		res=_FALSE;
 	}
 	else
 		res=  _TRUE;
-
+	
 _func_exit_;
 	return res;
 }
@@ -485,31 +485,31 @@ u8 *rtw_get_capability_from_ie(u8 *ie)
 u16 rtw_get_capability(WLAN_BSSID_EX *bss)
 {
 	u16	val;
-_func_enter_;
+_func_enter_;	
 
-	_rtw_memcpy((u8 *)&val, rtw_get_capability_from_ie(bss->IEs), 2);
+	_rtw_memcpy((u8 *)&val, rtw_get_capability_from_ie(bss->IEs), 2); 
 
-_func_exit_;
+_func_exit_;		
 	return le16_to_cpu(val);
 }
 
 u8 *rtw_get_timestampe_from_ie(u8 *ie)
 {
-	return (ie + 0);
+	return (ie + 0);	
 }
 
 u8 *rtw_get_beacon_interval_from_ie(u8 *ie)
 {
-	return (ie + 8);
+	return (ie + 8);	
 }
 
 
 int	rtw_init_mlme_priv (_adapter *padapter)//(struct	mlme_priv *pmlmepriv)
 {
 	int	res;
-_func_enter_;
+_func_enter_;	
 	res = _rtw_init_mlme_priv(padapter);// (pmlmepriv);
-_func_exit_;
+_func_exit_;	
 	return res;
 }
 
@@ -518,16 +518,16 @@ void rtw_free_mlme_priv (struct mlme_priv *pmlmepriv)
 _func_enter_;
 	RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("rtw_free_mlme_priv\n"));
 	_rtw_free_mlme_priv (pmlmepriv);
-_func_exit_;
+_func_exit_;	
 }
 
 int	rtw_enqueue_network(_queue *queue, struct wlan_network *pnetwork);
 int	rtw_enqueue_network(_queue *queue, struct wlan_network *pnetwork)
 {
 	int	res;
-_func_enter_;
+_func_enter_;		
 	res = _rtw_enqueue_network(queue, pnetwork);
-_func_exit_;
+_func_exit_;		
 	return res;
 }
 
@@ -536,9 +536,9 @@ int	rtw_enqueue_network(_queue *queue, struct wlan_network *pnetwork)
 static struct	wlan_network *rtw_dequeue_network(_queue *queue)
 {
 	struct wlan_network *pnetwork;
-_func_enter_;
+_func_enter_;		
 	pnetwork = _rtw_dequeue_network(queue);
-_func_exit_;
+_func_exit_;		
 	return pnetwork;
 }
 #endif //PLATFORM_FREEBSD
@@ -547,36 +547,36 @@ static struct	wlan_network *rtw_dequeue_network(_queue *queue)
 struct	wlan_network *rtw_alloc_network(struct	mlme_priv *pmlmepriv )//(_queue	*free_queue)
 {
 	struct	wlan_network	*pnetwork;
-_func_enter_;
+_func_enter_;			
 	pnetwork = _rtw_alloc_network(pmlmepriv);
-_func_exit_;
+_func_exit_;			
 	return pnetwork;
 }
 
 void rtw_free_network(struct mlme_priv *pmlmepriv, struct	wlan_network *pnetwork, u8 is_freeall);
 void rtw_free_network(struct mlme_priv *pmlmepriv, struct	wlan_network *pnetwork, u8 is_freeall)//(struct	wlan_network *pnetwork, _queue	*free_queue)
 {
-_func_enter_;
+_func_enter_;		
 	RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("rtw_free_network==> ssid = %s \n\n" , pnetwork->network.Ssid.Ssid));
 	_rtw_free_network(pmlmepriv, pnetwork, is_freeall);
-_func_exit_;
+_func_exit_;		
 }
 
 void rtw_free_network_nolock(struct mlme_priv *pmlmepriv, struct wlan_network *pnetwork );
 void rtw_free_network_nolock(struct mlme_priv *pmlmepriv, struct wlan_network *pnetwork )
 {
-_func_enter_;
+_func_enter_;		
 	//RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("rtw_free_network==> ssid = %s \n\n" , pnetwork->network.Ssid.Ssid));
 	_rtw_free_network_nolock(pmlmepriv, pnetwork);
-_func_exit_;
+_func_exit_;		
 }
 
 
 void rtw_free_network_queue(_adapter* dev, u8 isfreeall)
 {
-_func_enter_;
+_func_enter_;		
 	_rtw_free_network_queue(dev, isfreeall);
-_func_exit_;
+_func_exit_;			
 }
 
 /*
@@ -610,9 +610,9 @@ int rtw_is_same_ibss(_adapter *adapter, struct wlan_network *pnetwork)
 	{
 		ret=_TRUE;
 	}
-
+	
 	return ret;
-
+	
 }
 
 inline int is_same_ess(WLAN_BSSID_EX *a, WLAN_BSSID_EX *b);
@@ -620,24 +620,24 @@ inline int is_same_ess(WLAN_BSSID_EX *a, WLAN_BSSID_EX *b)
 {
 	//RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("(%s,%d)(%s,%d)\n",
 	//		a->Ssid.Ssid,a->Ssid.SsidLength,b->Ssid.Ssid,b->Ssid.SsidLength));
-	return (a->Ssid.SsidLength == b->Ssid.SsidLength)
+	return (a->Ssid.SsidLength == b->Ssid.SsidLength) 
 		&&  _rtw_memcmp(a->Ssid.Ssid, b->Ssid.Ssid, a->Ssid.SsidLength)==_TRUE;
 }
 
 int is_same_network(WLAN_BSSID_EX *src, WLAN_BSSID_EX *dst)
 {
 	 u16 s_cap, d_cap;
-
-_func_enter_;
+	 
+_func_enter_;	
 
 #ifdef PLATFORM_OS_XP
-	 if ( ((uint)dst) <= 0x7fffffff ||
-		((uint)src) <= 0x7fffffff ||
-		((uint)&s_cap) <= 0x7fffffff ||
-		((uint)&d_cap) <= 0x7fffffff)
+	 if ( ((uint)dst) <= 0x7fffffff || 
+	 	((uint)src) <= 0x7fffffff ||
+	 	((uint)&s_cap) <= 0x7fffffff ||
+	 	((uint)&d_cap) <= 0x7fffffff)
 	{
 		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n@@@@ error address of dst\n"));
-
+			
 		KeBugCheckEx(0x87110000, (ULONG_PTR)dst, (ULONG_PTR)src,(ULONG_PTR)&s_cap, (ULONG_PTR)&d_cap);
 
 		return _FALSE;
@@ -648,54 +648,54 @@ int is_same_network(WLAN_BSSID_EX *src, WLAN_BSSID_EX *dst)
 	_rtw_memcpy((u8 *)&s_cap, rtw_get_capability_from_ie(src->IEs), 2);
 	_rtw_memcpy((u8 *)&d_cap, rtw_get_capability_from_ie(dst->IEs), 2);
 
-
+	
 	s_cap = le16_to_cpu(s_cap);
 	d_cap = le16_to_cpu(d_cap);
-
-_func_exit_;
+	
+_func_exit_;			
 
 	return ((src->Ssid.SsidLength == dst->Ssid.SsidLength) &&
 		//	(src->Configuration.DSConfig == dst->Configuration.DSConfig) &&
 			( (_rtw_memcmp(src->MacAddress, dst->MacAddress, ETH_ALEN)) == _TRUE) &&
 			( (_rtw_memcmp(src->Ssid.Ssid, dst->Ssid.Ssid, src->Ssid.SsidLength)) == _TRUE) &&
-			((s_cap & WLAN_CAPABILITY_IBSS) ==
+			((s_cap & WLAN_CAPABILITY_IBSS) == 
 			(d_cap & WLAN_CAPABILITY_IBSS)) &&
-			((s_cap & WLAN_CAPABILITY_BSS) ==
+			((s_cap & WLAN_CAPABILITY_BSS) == 
 			(d_cap & WLAN_CAPABILITY_BSS)));
-
+	
 }
 
 struct	wlan_network	* rtw_get_oldest_wlan_network(_queue *scanned_queue)
 {
 	_list	*plist, *phead;
 
-
+	
 	struct	wlan_network	*pwlan = NULL;
 	struct	wlan_network	*oldest = NULL;
-_func_enter_;
+_func_enter_;		
 	phead = get_list_head(scanned_queue);
-
+	
 	plist = get_next(phead);
 
 	while(1)
 	{
-
+		
 		if (rtw_end_of_queue_search(phead,plist)== _TRUE)
 			break;
-
+		
 		pwlan= LIST_CONTAINOR(plist, struct wlan_network, list);
 
 		if(pwlan->fixed!=_TRUE)
-		{
+		{		
 			if (oldest == NULL ||time_after(oldest->last_scanned, pwlan->last_scanned))
 				oldest = pwlan;
 		}
-
+		
 		plist = get_next(plist);
 	}
-_func_exit_;
+_func_exit_;		
 	return oldest;
-
+	
 }
 
 static void update_network(WLAN_BSSID_EX *dst, WLAN_BSSID_EX *src,
@@ -713,7 +713,7 @@ static void update_network(WLAN_BSSID_EX *dst, WLAN_BSSID_EX *src,
 	u8 sq_final;
 	long rssi_final;
 
-_func_enter_;
+_func_enter_;		
 
 #ifdef CONFIG_ANTENNA_DIVERSITY
 	rtw_hal_antdiv_rssi_compared(padapter, dst, src); //this will update src.Rssi, need consider again
@@ -752,7 +752,7 @@ static void update_network(WLAN_BSSID_EX *dst, WLAN_BSSID_EX *src,
 			sq_final = dst->PhyInfo.SignalQuality;
 			rssi_final = dst->Rssi;
 		}
-
+		
 	}
 
 	if (update_ie)
@@ -774,7 +774,7 @@ static void update_network(WLAN_BSSID_EX *dst, WLAN_BSSID_EX *src,
 //	DBG_871X("update_network: rssi=0x%lx dst->Rssi=%d ,dst->Rssi=0x%lx , src->Rssi=0x%lx",(dst->Rssi+src->Rssi)/2,dst->Rssi,dst->Rssi,src->Rssi);
 	if (check_fwstate(&padapter->mlmepriv, _FW_LINKED) && is_same_network(&(padapter->mlmepriv.cur_network.network), src))
 	{
-
+	
 		//DBG_871X("b:ssid=%s update_network: src->rssi=0x%d padapter->recvpriv.ui_rssi=%d\n",src->Ssid.Ssid,src->Rssi,padapter->recvpriv.signal);
 		if(padapter->recvpriv.signal_qual_data.total_num++ >= PHY_LINKQUALITY_SLID_WIN_MAX)
 	        {
@@ -782,9 +782,9 @@ static void update_network(WLAN_BSSID_EX *dst, WLAN_BSSID_EX *src,
 	              last_evm = padapter->recvpriv.signal_qual_data.elements[padapter->recvpriv.signal_qual_data.index];
 	              padapter->recvpriv.signal_qual_data.total_val -= last_evm;
 	        }
-		padapter->recvpriv.signal_qual_data.total_val += query_rx_pwr_percentage(src->Rssi);
+               	padapter->recvpriv.signal_qual_data.total_val += query_rx_pwr_percentage(src->Rssi);
 
-		padapter->recvpriv.signal_qual_data.elements[padapter->recvpriv.signal_qual_data.index++] = query_rx_pwr_percentage(src->Rssi);
+              	padapter->recvpriv.signal_qual_data.elements[padapter->recvpriv.signal_qual_data.index++] = query_rx_pwr_percentage(src->Rssi);
                 if(padapter->recvpriv.signal_qual_data.index >= PHY_LINKQUALITY_SLID_WIN_MAX)
                        padapter->recvpriv.signal_qual_data.index = 0;
 
@@ -799,24 +799,24 @@ static void update_network(WLAN_BSSID_EX *dst, WLAN_BSSID_EX *src,
 	else{
 //	DBG_871X("ELSE:ssid=%s update_network: src->rssi=0x%d dst->rssi=%d\n",src->Ssid.Ssid,src->Rssi,dst->Rssi);
 		src->Rssi=(src->Rssi +dst->Rssi)/2;//dBM
-	}
+	}	
 
 //	DBG_871X("a:update_network: src->rssi=0x%d padapter->recvpriv.ui_rssi=%d\n",src->Rssi,padapter->recvpriv.signal);
 
 #endif
 
-_func_exit_;
+_func_exit_;		
 }
 
 static void update_current_network(_adapter *adapter, WLAN_BSSID_EX *pnetwork)
 {
 	struct	mlme_priv	*pmlmepriv = &(adapter->mlmepriv);
-
-_func_enter_;
+	
+_func_enter_;		
 
 #ifdef PLATFORM_OS_XP
 	if ((unsigned long)(&(pmlmepriv->cur_network.network)) < 0x7ffffff)
-	{
+	{		
 		KeBugCheckEx(0x87111c1c, (ULONG_PTR)(&(pmlmepriv->cur_network.network)), 0, 0,0);
 	}
 #endif
@@ -828,12 +828,12 @@ static void update_current_network(_adapter *adapter, WLAN_BSSID_EX *pnetwork)
 		//if(pmlmepriv->cur_network.network.IELength<= pnetwork->IELength)
 		{
 			update_network(&(pmlmepriv->cur_network.network), pnetwork,adapter, _TRUE);
-			rtw_update_protection(adapter, (pmlmepriv->cur_network.network.IEs) + sizeof (NDIS_802_11_FIXED_IEs),
+			rtw_update_protection(adapter, (pmlmepriv->cur_network.network.IEs) + sizeof (NDIS_802_11_FIXED_IEs), 
 									pmlmepriv->cur_network.network.IELength);
 		}
 	}
 
-_func_exit_;
+_func_exit_;			
 
 }
 
@@ -884,12 +884,12 @@ void rtw_update_scanned_network(_adapter *adapter, WLAN_BSSID_EX *target)
 		plist = get_next(plist);
 
 	}
-
-
+	
+	
 	/* If we didn't find a match, then get a new network slot to initialize
 	 * with this beacon's information */
 	if (rtw_end_of_queue_search(phead,plist)== _TRUE) {
-
+		
 		if (_rtw_queue_empty(&(pmlmepriv->free_bss_pool)) == _TRUE) {
 			/* If there are no more slots, expire the oldest */
 			//list_del_init(&oldest->list);
@@ -905,8 +905,8 @@ void rtw_update_scanned_network(_adapter *adapter, WLAN_BSSID_EX *target)
 			pnetwork->fixed = _FALSE;
 			pnetwork->last_scanned = rtw_get_current_time();
 
-			pnetwork->network_type = 0;
-			pnetwork->aid=0;
+			pnetwork->network_type = 0;	
+			pnetwork->aid=0;		
 			pnetwork->join_res=0;
 
 			/* bss info not receving from the right channel */
@@ -918,7 +918,7 @@ void rtw_update_scanned_network(_adapter *adapter, WLAN_BSSID_EX *target)
 
 			pnetwork = rtw_alloc_network(pmlmepriv); // will update scan_time
 
-			if(pnetwork==NULL){
+			if(pnetwork==NULL){ 
 				RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n\n\nsomething wrong here\n\n\n"));
 				goto exit;
 			}
@@ -937,13 +937,13 @@ void rtw_update_scanned_network(_adapter *adapter, WLAN_BSSID_EX *target)
 			if (pnetwork->network.PhyInfo.SignalQuality == 101)
 				pnetwork->network.PhyInfo.SignalQuality = 0;
 
-			rtw_list_insert_tail(&(pnetwork->list),&(queue->queue));
+			rtw_list_insert_tail(&(pnetwork->list),&(queue->queue)); 
 
 		}
 	}
 	else {
 		/* we have an entry and we are going to update it. But this entry may
-		 * be already expired. In this case we do the same as we found a new
+		 * be already expired. In this case we do the same as we found a new 
 		 * net and call the new_net handler
 		 */
 		bool update_ie = _TRUE;
@@ -970,21 +970,21 @@ void rtw_add_network(_adapter *adapter, WLAN_BSSID_EX *pnetwork)
 	struct	mlme_priv	*pmlmepriv = &(((_adapter *)adapter)->mlmepriv);
 	//_queue	*queue	= &(pmlmepriv->scanned_queue);
 
-_func_enter_;
+_func_enter_;		
 
 	//_enter_critical_bh(&queue->lock, &irqL);
 
 	#if defined(CONFIG_P2P) && defined(CONFIG_P2P_REMOVE_GROUP_INFO)
 	rtw_WLAN_BSSID_EX_remove_p2p_attr(pnetwork, P2P_ATTR_GROUP_INFO);
 	#endif
-
+	
 	update_current_network(adapter, pnetwork);
-
+	
 	rtw_update_scanned_network(adapter, pnetwork);
 
 	//_exit_critical_bh(&queue->lock, &irqL);
-
-_func_exit_;
+	
+_func_exit_;		
 }
 
 //select the desired network based on the capability of the (i)bss.
@@ -1005,7 +1005,7 @@ int rtw_is_desired_network(_adapter *adapter, struct wlan_network *pnetwork)
 	uint wps_ielen;
 
 	int bselected = _TRUE;
-
+	
 	desired_encmode = psecuritypriv->ndisencryptstatus;
 	privacy = pnetwork->network.Privacy;
 
@@ -1016,9 +1016,9 @@ int rtw_is_desired_network(_adapter *adapter, struct wlan_network *pnetwork)
 			return _TRUE;
 		}
 		else
-		{
+		{	
 			return _FALSE;
-		}
+		}	
 	}
 	if (adapter->registrypriv.wifi_spec == 1) //for  correct flow of 8021X  to do....
 	{
@@ -1037,19 +1037,19 @@ int rtw_is_desired_network(_adapter *adapter, struct wlan_network *pnetwork)
 			}
 		}
 	}
+	
 
-
-	if ((desired_encmode != Ndis802_11EncryptionDisabled) && (privacy == 0)) {
+ 	if ((desired_encmode != Ndis802_11EncryptionDisabled) && (privacy == 0)) {
 		DBG_871X("desired_encmode: %d, privacy: %d\n", desired_encmode, privacy);
 		bselected = _FALSE;
-	}
+ 	}
 
 	if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE)
 	{
 		if(pnetwork->network.InfrastructureMode != pmlmepriv->cur_network.network.InfrastructureMode)
 			bselected = _FALSE;
-	}
-
+	}	
+		
 
 	return bselected;
 }
@@ -1058,10 +1058,10 @@ int rtw_is_desired_network(_adapter *adapter, struct wlan_network *pnetwork)
 void rtw_atimdone_event_callback(_adapter	*adapter , u8 *pbuf)
 {
 
-_func_enter_;
-	RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("receive atimdone_evet\n"));
-_func_exit_;
-	return;
+_func_enter_;		
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("receive atimdone_evet\n"));	
+_func_exit_;			
+	return;	
 }
 
 
@@ -1072,7 +1072,7 @@ void rtw_survey_event_callback(_adapter	*adapter, u8 *pbuf)
 	WLAN_BSSID_EX *pnetwork;
 	struct	mlme_priv	*pmlmepriv = &(adapter->mlmepriv);
 
-_func_enter_;
+_func_enter_;		
 
 	pnetwork = (WLAN_BSSID_EX *)pbuf;
 
@@ -1080,22 +1080,22 @@ void rtw_survey_event_callback(_adapter	*adapter, u8 *pbuf)
 
 #ifdef CONFIG_RTL8712
         //endian_convert
-	pnetwork->Length = le32_to_cpu(pnetwork->Length);
-	pnetwork->Ssid.SsidLength = le32_to_cpu(pnetwork->Ssid.SsidLength);
+ 	pnetwork->Length = le32_to_cpu(pnetwork->Length);
+  	pnetwork->Ssid.SsidLength = le32_to_cpu(pnetwork->Ssid.SsidLength);	
 	pnetwork->Privacy =le32_to_cpu( pnetwork->Privacy);
 	pnetwork->Rssi = le32_to_cpu(pnetwork->Rssi);
-	pnetwork->NetworkTypeInUse =le32_to_cpu(pnetwork->NetworkTypeInUse);
+	pnetwork->NetworkTypeInUse =le32_to_cpu(pnetwork->NetworkTypeInUse);	
 	pnetwork->Configuration.ATIMWindow = le32_to_cpu(pnetwork->Configuration.ATIMWindow);
 	pnetwork->Configuration.BeaconPeriod = le32_to_cpu(pnetwork->Configuration.BeaconPeriod);
 	pnetwork->Configuration.DSConfig =le32_to_cpu(pnetwork->Configuration.DSConfig);
 	pnetwork->Configuration.FHConfig.DwellTime=le32_to_cpu(pnetwork->Configuration.FHConfig.DwellTime);
 	pnetwork->Configuration.FHConfig.HopPattern=le32_to_cpu(pnetwork->Configuration.FHConfig.HopPattern);
 	pnetwork->Configuration.FHConfig.HopSet=le32_to_cpu(pnetwork->Configuration.FHConfig.HopSet);
-	pnetwork->Configuration.FHConfig.Length=le32_to_cpu(pnetwork->Configuration.FHConfig.Length);
+	pnetwork->Configuration.FHConfig.Length=le32_to_cpu(pnetwork->Configuration.FHConfig.Length);	
 	pnetwork->Configuration.Length = le32_to_cpu(pnetwork->Configuration.Length);
 	pnetwork->InfrastructureMode = le32_to_cpu(pnetwork->InfrastructureMode);
 	pnetwork->IELength = le32_to_cpu(pnetwork->IELength);
-#endif
+#endif	
 
 	len = get_WLAN_BSSID_EX_sz(pnetwork);
 	if(len > (sizeof(WLAN_BSSID_EX)))
@@ -1115,14 +1115,14 @@ void rtw_survey_event_callback(_adapter	*adapter, u8 *pbuf)
 		{
 			struct wlan_network* ibss_wlan = NULL;
 			_irqL	irqL;
-
+			
 			_rtw_memcpy(pmlmepriv->cur_network.network.IEs, pnetwork->IEs, 8);
 			_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
 			ibss_wlan = rtw_find_network(&pmlmepriv->scanned_queue,  pnetwork->MacAddress);
 			if(ibss_wlan)
 			{
-				_rtw_memcpy(ibss_wlan->network.IEs , pnetwork->IEs, 8);
-				_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+				_rtw_memcpy(ibss_wlan->network.IEs , pnetwork->IEs, 8);			
+				_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);		
 				goto exit;
 			}
 			_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
@@ -1131,21 +1131,21 @@ void rtw_survey_event_callback(_adapter	*adapter, u8 *pbuf)
 
 	// lock pmlmepriv->lock when you accessing network_q
 	if ((check_fwstate(pmlmepriv, _FW_UNDER_LINKING)) == _FALSE)
-	{
-	        if( pnetwork->Ssid.Ssid[0] == 0 )
+	{		
+   	        if( pnetwork->Ssid.Ssid[0] == 0 )
 		{
 			pnetwork->Ssid.SsidLength = 0;
-		}
+		}	
 		rtw_add_network(adapter, pnetwork);
-	}
-
-exit:
+	}	
 
+exit:	
+		
 	_exit_critical_bh(&pmlmepriv->lock, &irqL);
 
-_func_exit_;
+_func_exit_;		
 
-	return;
+	return;	
 }
 
 
@@ -1155,14 +1155,14 @@ void rtw_surveydone_event_callback(_adapter	*adapter, u8 *pbuf)
 	_irqL  irqL;
 	u8 timer_cancelled = _FALSE;
 	struct	mlme_priv	*pmlmepriv = &(adapter->mlmepriv);
-
-#ifdef CONFIG_MLME_EXT
+	
+#ifdef CONFIG_MLME_EXT	
 
 	mlmeext_surveydone_event_callback(adapter);
 
 #endif
 
-_func_enter_;
+_func_enter_;			
 
 	_enter_critical_bh(&pmlmepriv->lock, &irqL);
 	if(pmlmepriv->wps_probe_req_ie)
@@ -1170,23 +1170,23 @@ void rtw_surveydone_event_callback(_adapter	*adapter, u8 *pbuf)
 		u32 free_len = pmlmepriv->wps_probe_req_ie_len;
 		pmlmepriv->wps_probe_req_ie_len = 0;
 		rtw_mfree(pmlmepriv->wps_probe_req_ie, free_len);
-		pmlmepriv->wps_probe_req_ie = NULL;
+		pmlmepriv->wps_probe_req_ie = NULL;			
 	}
-
+	
 	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_surveydone_event_callback: fw_state:%x\n\n", get_fwstate(pmlmepriv)));
-
+	
 	if (check_fwstate(pmlmepriv,_FW_UNDER_SURVEY))
 	{
 		//u8 timer_cancelled;
 
 		timer_cancelled = _TRUE;
 		//_cancel_timer(&pmlmepriv->scan_to_timer, &timer_cancelled);
-
+		
 		_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY);
 	}
 	else {
-
-		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("nic status =%x, survey done event comes too late!\n", get_fwstate(pmlmepriv)));
+	
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("nic status =%x, survey done event comes too late!\n", get_fwstate(pmlmepriv)));	
 	}
 	_exit_critical_bh(&pmlmepriv->lock, &irqL);
 
@@ -1206,38 +1206,38 @@ void rtw_surveydone_event_callback(_adapter	*adapter, u8 *pbuf)
 		{
 			if(check_fwstate(pmlmepriv, _FW_LINKED)==_FALSE)
 			{
-				set_fwstate(pmlmepriv, _FW_UNDER_LINKING);
-
-				if(rtw_select_and_join_from_scanned_queue(pmlmepriv)==_SUCCESS)
-				{
-					_set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT );
-				}
-				else
-				{
-					WLAN_BSSID_EX    *pdev_network = &(adapter->registrypriv.dev_network);
+				set_fwstate(pmlmepriv, _FW_UNDER_LINKING);	
+				
+		   		if(rtw_select_and_join_from_scanned_queue(pmlmepriv)==_SUCCESS)
+		   		{
+		       			_set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT );	 
+                  		}
+		   		else	
+		  		{
+					WLAN_BSSID_EX    *pdev_network = &(adapter->registrypriv.dev_network); 			
 					u8 *pibss = adapter->registrypriv.dev_network.MacAddress;
 
 					//pmlmepriv->fw_state ^= _FW_UNDER_SURVEY;//because don't set assoc_timer
 					_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY);
 
 					RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("switching to adhoc master\n"));
-
+				
 					_rtw_memset(&pdev_network->Ssid, 0, sizeof(NDIS_802_11_SSID));
 					_rtw_memcpy(&pdev_network->Ssid, &pmlmepriv->assoc_ssid, sizeof(NDIS_802_11_SSID));
-
+	
 					rtw_update_registrypriv_dev_network(adapter);
 					rtw_generate_random_ibss(pibss);
 
-					pmlmepriv->fw_state = WIFI_ADHOC_MASTER_STATE;
-
+                       			pmlmepriv->fw_state = WIFI_ADHOC_MASTER_STATE;
+			
 					if(rtw_createbss_cmd(adapter)!=_SUCCESS)
 					{
-					RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("Error=>rtw_createbss_cmd status FAIL\n"));
-					}
+	                     		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("Error=>rtw_createbss_cmd status FAIL\n"));						
+					}	
 
-					pmlmepriv->to_join = _FALSE;
-				}
-			}
+			     		pmlmepriv->to_join = _FALSE;
+		   		}
+		 	}
 		}
 		else
 		{
@@ -1246,7 +1246,7 @@ void rtw_surveydone_event_callback(_adapter	*adapter, u8 *pbuf)
 			pmlmepriv->to_join = _FALSE;
 			if(_SUCCESS == (s_ret=rtw_select_and_join_from_scanned_queue(pmlmepriv)))
 			{
-			     _set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT);
+	     		     _set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT);	 
 			}
 			else if(s_ret == 2)//there is no need to wait for join
 			{
@@ -1310,7 +1310,7 @@ void rtw_surveydone_event_callback(_adapter	*adapter, u8 *pbuf)
 	if (adapter->mlmepriv.widi_state == INTEL_WIDI_STATE_NONE)
 #endif
 	{
-		struct mlme_ext_priv *pmlmeext = &adapter->mlmeextpriv;
+		struct mlme_ext_priv *pmlmeext = &adapter->mlmeextpriv;		
 		if(pmlmeext->sitesurvey_res.bss_cnt == 0){
 			rtw_hal_sreset_reset(adapter);
 		}
@@ -1321,7 +1321,7 @@ void rtw_surveydone_event_callback(_adapter	*adapter, u8 *pbuf)
 	rtw_cfg80211_surveydone_event_callback(adapter);
 #endif //CONFIG_IOCTL_CFG80211
 
-_func_exit_;
+_func_exit_;	
 
 }
 
@@ -1341,9 +1341,9 @@ static void free_scanqueue(struct	mlme_priv *pmlmepriv)
 	_queue *free_queue = &pmlmepriv->free_bss_pool;
 	_queue *scan_queue = &pmlmepriv->scanned_queue;
 	_list	*plist, *phead, *ptemp;
-
-_func_enter_;
-
+	
+_func_enter_;		
+	
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_, ("+free_scanqueue\n"));
 	_enter_critical_bh(&scan_queue->lock, &irqL0);
 	_enter_critical_bh(&free_queue->lock, &irqL);
@@ -1359,13 +1359,13 @@ static void free_scanqueue(struct	mlme_priv *pmlmepriv)
 		plist =ptemp;
 		pmlmepriv->num_of_scanned --;
         }
-
+	
 	_exit_critical_bh(&free_queue->lock, &irqL);
 	_exit_critical_bh(&scan_queue->lock, &irqL0);
-
+	
 _func_exit_;
 }
-
+	
 /*
 *rtw_free_assoc_resources: the caller has to lock pmlmepriv->lock
 */
@@ -1373,14 +1373,14 @@ void rtw_free_assoc_resources(_adapter *adapter, int lock_scanned_queue)
 {
 	_irqL irqL;
 	struct wlan_network* pwlan = NULL;
-	struct	mlme_priv *pmlmepriv = &adapter->mlmepriv;
-	struct	sta_priv *pstapriv = &adapter->stapriv;
+     	struct	mlme_priv *pmlmepriv = &adapter->mlmepriv;
+   	struct	sta_priv *pstapriv = &adapter->stapriv;
 	struct wlan_network *tgt_network = &pmlmepriv->cur_network;
-
+	
 #ifdef CONFIG_TDLS
 	struct tdls_info *ptdlsinfo = &adapter->tdlsinfo;
-#endif //CONFIG_TDLS
-_func_enter_;
+#endif //CONFIG_TDLS	
+_func_enter_;			
 
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_, ("+rtw_free_assoc_resources\n"));
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("tgt_network->network.MacAddress="MAC_FMT" ssid=%s\n",
@@ -1389,7 +1389,7 @@ void rtw_free_assoc_resources(_adapter *adapter, int lock_scanned_queue)
 	if(check_fwstate( pmlmepriv, WIFI_STATION_STATE|WIFI_AP_STATE))
 	{
 		struct sta_info* psta;
-
+		
 		psta = rtw_get_stainfo(&adapter->stapriv, tgt_network->network.MacAddress);
 
 #ifdef CONFIG_TDLS
@@ -1408,26 +1408,26 @@ void rtw_free_assoc_resources(_adapter *adapter, int lock_scanned_queue)
 		}
 
 		_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
-
+		
 	}
 
 	if(check_fwstate( pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE|WIFI_AP_STATE))
 	{
 		struct sta_info* psta;
-
+	
 		rtw_free_all_stainfo(adapter);
 
 		psta = rtw_get_bcmc_stainfo(adapter);
-		_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+		_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);		
 		rtw_free_stainfo(adapter, psta);
-		_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+		_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);		
 
-		rtw_init_bcmc_stainfo(adapter);
+		rtw_init_bcmc_stainfo(adapter);	
 	}
 
 	if(lock_scanned_queue)
 		_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
-
+	
 	pwlan = rtw_find_network(&pmlmepriv->scanned_queue, tgt_network->network.MacAddress);
 	if(pwlan)
 	{
@@ -1473,11 +1473,11 @@ void rtw_free_assoc_resources(_adapter *adapter, int lock_scanned_queue)
 
 	if(lock_scanned_queue)
 		_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
-
+	
 	adapter->securitypriv.key_mask = 0;
 
 _func_exit_;
-
+	
 }
 
 /*
@@ -1487,14 +1487,14 @@ void rtw_indicate_connect(_adapter *padapter)
 {
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
-
+	
 _func_enter_;
 
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("+rtw_indicate_connect\n"));
-
+ 
 	pmlmepriv->to_join = _FALSE;
 
-	if(!check_fwstate(&padapter->mlmepriv, _FW_LINKED))
+	if(!check_fwstate(&padapter->mlmepriv, _FW_LINKED)) 
 	{
 
 #ifdef CONFIG_SW_ANTENNA_DIVERSITY
@@ -1531,7 +1531,7 @@ void rtw_indicate_connect(_adapter *padapter)
 	rtw_set_scan_deny(padapter, 3000);
 
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("-rtw_indicate_connect: fw_state=0x%08x\n", get_fwstate(pmlmepriv)));
-
+ 
 _func_exit_;
 
 }
@@ -1542,10 +1542,10 @@ void rtw_indicate_connect(_adapter *padapter)
 */
 void rtw_indicate_disconnect( _adapter *padapter )
 {
-	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
-
-_func_enter_;
+	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;	
 
+_func_enter_;	
+	
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("+rtw_indicate_disconnect\n"));
 
 	_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING|WIFI_UNDER_WPS);
@@ -1553,7 +1553,7 @@ void rtw_indicate_disconnect( _adapter *padapter )
 	if(rtw_to_roaming(padapter) > 0)
 		_clr_fwstate_(pmlmepriv, _FW_LINKED);
 
-	if(check_fwstate(&padapter->mlmepriv, _FW_LINKED)
+	if(check_fwstate(&padapter->mlmepriv, _FW_LINKED) 
 		|| (rtw_to_roaming(padapter) <= 0)
 	)
 	{
@@ -1582,7 +1582,7 @@ void rtw_indicate_disconnect( _adapter *padapter )
 
 #endif
 
-_func_exit_;
+_func_exit_;	
 }
 
 inline void rtw_indicate_scan_done( _adapter *padapter, bool aborted)
@@ -1627,7 +1627,7 @@ static struct sta_info *rtw_joinbss_update_stainfo(_adapter *padapter, struct wl
 	int i;
 	struct sta_info *bmc_sta, *psta=NULL;
 	struct recv_reorder_ctrl *preorder_ctrl;
-	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct sta_priv *pstapriv = &padapter->stapriv;	
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 
 	psta = rtw_get_stainfo(pstapriv, pnetwork->network.MacAddress);
@@ -1638,9 +1638,9 @@ static struct sta_info *rtw_joinbss_update_stainfo(_adapter *padapter, struct wl
 	if(psta) //update ptarget_sta
 	{
 		DBG_871X("%s\n", __FUNCTION__);
-
+	
 		psta->aid  = pnetwork->join_res;
-#ifdef CONFIG_CONCURRENT_MODE
+#ifdef CONFIG_CONCURRENT_MODE	
 
 		if(PRIMARY_ADAPTER == padapter->adapter_type)
 			psta->mac_id=0;
@@ -1654,24 +1654,24 @@ static struct sta_info *rtw_joinbss_update_stainfo(_adapter *padapter, struct wl
 
 		//security related
 		if(padapter->securitypriv.dot11AuthAlgrthm== dot11AuthAlgrthm_8021X)
-		{
+		{						
 			padapter->securitypriv.binstallGrpkey=_FALSE;
-			padapter->securitypriv.busetkipkey=_FALSE;
+			padapter->securitypriv.busetkipkey=_FALSE;						
 			padapter->securitypriv.bgrpkey_handshake=_FALSE;
 
 			psta->ieee8021x_blocked=_TRUE;
 			psta->dot118021XPrivacy=padapter->securitypriv.dot11PrivacyAlgrthm;
-
+						
 			_rtw_memset((u8 *)&psta->dot118021x_UncstKey, 0, sizeof (union Keytype));
-
+						
 			_rtw_memset((u8 *)&psta->dot11tkiprxmickey, 0, sizeof (union Keytype));
 			_rtw_memset((u8 *)&psta->dot11tkiptxmickey, 0, sizeof (union Keytype));
-
+						
 			_rtw_memset((u8 *)&psta->dot11txpn, 0, sizeof (union pn48));
 #ifdef CONFIG_IEEE80211W
 			_rtw_memset((u8 *)&psta->dot11wtxpn, 0, sizeof (union pn48));
 #endif //CONFIG_IEEE80211W
-			_rtw_memset((u8 *)&psta->dot11rxpn, 0, sizeof (union pn48));
+			_rtw_memset((u8 *)&psta->dot11rxpn, 0, sizeof (union pn48));	
 		}
 
 		//	Commented by Albert 2012/07/21
@@ -1701,7 +1701,7 @@ static struct sta_info *rtw_joinbss_update_stainfo(_adapter *padapter, struct wl
 			preorder_ctrl->wsize_b = 64;//max_ampdu_sz;//ex. 32(kbytes) -> wsize_b=32
 		}
 
-
+		
 		bmc_sta = rtw_get_bcmc_stainfo(padapter);
 		if(bmc_sta)
 		{
@@ -1720,35 +1720,35 @@ static struct sta_info *rtw_joinbss_update_stainfo(_adapter *padapter, struct wl
 			}
 		}
 
-
+	
 		//misc.
 		update_sta_info(padapter, psta);
-
+		
 	}
-
+					
 	return psta;
-
+	
 }
 
 //pnetwork : returns from rtw_joinbss_event_callback
 //ptarget_wlan: found from scanned_queue
 static void rtw_joinbss_update_network(_adapter *padapter, struct wlan_network *ptarget_wlan, struct wlan_network  *pnetwork)
 {
-	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);	
 	struct wlan_network  *cur_network = &(pmlmepriv->cur_network);
 
 	DBG_871X("%s\n", __FUNCTION__);
-
+	
 	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("\nfw_state:%x, BSSID:"MAC_FMT"\n"
 		,get_fwstate(pmlmepriv), MAC_ARG(pnetwork->network.MacAddress)));
 
-
+				
 	// why not use ptarget_wlan??
 	_rtw_memcpy(&cur_network->network, &pnetwork->network, pnetwork->network.Length);
 
 	cur_network->aid = pnetwork->join_res;
 
-
+				
 #ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
 	rtw_set_signal_stat_timer(&padapter->recvpriv);
 #endif
@@ -1768,19 +1768,19 @@ static void rtw_joinbss_update_network(_adapter *padapter, struct wlan_network *
 #ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
 	rtw_set_signal_stat_timer(&padapter->recvpriv);
 #endif
-
+				
 	//update fw_state //will clr _FW_UNDER_LINKING here indirectly
 	switch(pnetwork->network.InfrastructureMode)
-	{
-		case Ndis802_11Infrastructure:
-
+	{	
+		case Ndis802_11Infrastructure:						
+			
 				if(pmlmepriv->fw_state&WIFI_UNDER_WPS)
 					pmlmepriv->fw_state = WIFI_STATION_STATE|WIFI_UNDER_WPS;
 				else
 					pmlmepriv->fw_state = WIFI_STATION_STATE;
-
+				
 				break;
-		case Ndis802_11IBSS:
+		case Ndis802_11IBSS:		
 				pmlmepriv->fw_state = WIFI_ADHOC_STATE;
 				break;
 		default:
@@ -1789,10 +1789,10 @@ static void rtw_joinbss_update_network(_adapter *padapter, struct wlan_network *
 				break;
 	}
 
-	rtw_update_protection(padapter, (cur_network->network.IEs) + sizeof (NDIS_802_11_FIXED_IEs),
+	rtw_update_protection(padapter, (cur_network->network.IEs) + sizeof (NDIS_802_11_FIXED_IEs), 
 									(cur_network->network.IELength));
-
-#ifdef CONFIG_80211N_HT
+			
+#ifdef CONFIG_80211N_HT			
 	rtw_update_ht_cap(padapter, cur_network->network.IEs, cur_network->network.IELength, (u8) cur_network->network.Configuration.DSConfig);
 #endif
 
@@ -1802,7 +1802,7 @@ static void rtw_joinbss_update_network(_adapter *padapter, struct wlan_network *
 //Notes: the fucntion could be > passive_level (the same context as Rx tasklet)
 //pnetwork : returns from rtw_joinbss_event_callback
 //ptarget_wlan: found from scanned_queue
-//if join_res > 0, for (fw_state==WIFI_STATION_STATE), we check if  "ptarget_sta" & "ptarget_wlan" exist.
+//if join_res > 0, for (fw_state==WIFI_STATION_STATE), we check if  "ptarget_sta" & "ptarget_wlan" exist.	
 //if join_res > 0, for (fw_state==WIFI_ADHOC_STATE), we only check if "ptarget_wlan" exist.
 //if join_res > 0, update "cur_network->network" from "pnetwork->network" if (ptarget_wlan !=NULL).
 //
@@ -1813,14 +1813,14 @@ void rtw_joinbss_event_prehandle(_adapter *adapter, u8 *pbuf)
 	static u8 retry=0;
 	u8 timer_cancelled;
 	struct sta_info *ptarget_sta= NULL, *pcur_sta = NULL;
-	struct	sta_priv *pstapriv = &adapter->stapriv;
+   	struct	sta_priv *pstapriv = &adapter->stapriv;
 	struct	mlme_priv	*pmlmepriv = &(adapter->mlmepriv);
 	struct wlan_network 	*pnetwork	= (struct wlan_network *)pbuf;
 	struct wlan_network 	*cur_network = &(pmlmepriv->cur_network);
 	struct wlan_network	*pcur_wlan = NULL, *ptarget_wlan = NULL;
-	unsigned int 		the_same_macaddr = _FALSE;
+	unsigned int 		the_same_macaddr = _FALSE;	
 
-_func_enter_;
+_func_enter_;	
 
 #ifdef CONFIG_RTL8712
        //endian_convert
@@ -1830,14 +1830,14 @@ void rtw_joinbss_event_prehandle(_adapter *adapter, u8 *pbuf)
 	pnetwork->network.Ssid.SsidLength = le32_to_cpu(pnetwork->network.Ssid.SsidLength);
 	pnetwork->network.Privacy =le32_to_cpu( pnetwork->network.Privacy);
 	pnetwork->network.Rssi = le32_to_cpu(pnetwork->network.Rssi);
-	pnetwork->network.NetworkTypeInUse =le32_to_cpu(pnetwork->network.NetworkTypeInUse) ;
+	pnetwork->network.NetworkTypeInUse =le32_to_cpu(pnetwork->network.NetworkTypeInUse) ;	
 	pnetwork->network.Configuration.ATIMWindow = le32_to_cpu(pnetwork->network.Configuration.ATIMWindow);
 	pnetwork->network.Configuration.BeaconPeriod = le32_to_cpu(pnetwork->network.Configuration.BeaconPeriod);
 	pnetwork->network.Configuration.DSConfig = le32_to_cpu(pnetwork->network.Configuration.DSConfig);
 	pnetwork->network.Configuration.FHConfig.DwellTime=le32_to_cpu(pnetwork->network.Configuration.FHConfig.DwellTime);
 	pnetwork->network.Configuration.FHConfig.HopPattern=le32_to_cpu(pnetwork->network.Configuration.FHConfig.HopPattern);
 	pnetwork->network.Configuration.FHConfig.HopSet=le32_to_cpu(pnetwork->network.Configuration.FHConfig.HopSet);
-	pnetwork->network.Configuration.FHConfig.Length=le32_to_cpu(pnetwork->network.Configuration.FHConfig.Length);
+	pnetwork->network.Configuration.FHConfig.Length=le32_to_cpu(pnetwork->network.Configuration.FHConfig.Length);	
 	pnetwork->network.Configuration.Length = le32_to_cpu(pnetwork->network.Configuration.Length);
 	pnetwork->network.InfrastructureMode = le32_to_cpu(pnetwork->network.InfrastructureMode);
 	pnetwork->network.IELength = le32_to_cpu(pnetwork->network.IELength );
@@ -1846,17 +1846,17 @@ void rtw_joinbss_event_prehandle(_adapter *adapter, u8 *pbuf)
 	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("joinbss event call back received with res=%d\n", pnetwork->join_res));
 
 	rtw_get_encrypt_decrypt_from_registrypriv(adapter);
-
+	
 
 	if (pmlmepriv->assoc_ssid.SsidLength == 0)
 	{
-		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("@@@@@   joinbss event call back  for Any SSid\n"));
+		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("@@@@@   joinbss event call back  for Any SSid\n"));		
 	}
 	else
 	{
 		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("@@@@@   rtw_joinbss_event_callback for SSid:%s\n", pmlmepriv->assoc_ssid.Ssid));
 	}
-
+	
 	the_same_macaddr = _rtw_memcmp(pnetwork->network.MacAddress, cur_network->network.MacAddress, ETH_ALEN);
 
 	pnetwork->network.Length = get_WLAN_BSSID_EX_sz(&pnetwork->network);
@@ -1867,7 +1867,7 @@ void rtw_joinbss_event_prehandle(_adapter *adapter, u8 *pbuf)
 	}
 
 	_enter_critical_bh(&pmlmepriv->lock, &irqL);
-
+	
 	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("\n rtw_joinbss_event_callback !! _enter_critical \n"));
 
 	if(pnetwork->join_res > 0)
@@ -1881,7 +1881,7 @@ void rtw_joinbss_event_prehandle(_adapter *adapter, u8 *pbuf)
 			{
 				if(the_same_macaddr == _TRUE)
 				{
-					ptarget_wlan = rtw_find_network(&pmlmepriv->scanned_queue, cur_network->network.MacAddress);
+					ptarget_wlan = rtw_find_network(&pmlmepriv->scanned_queue, cur_network->network.MacAddress);					
 				}
 				else
 				{
@@ -1897,7 +1897,7 @@ void rtw_joinbss_event_prehandle(_adapter *adapter, u8 *pbuf)
 
 					ptarget_wlan = rtw_find_network(&pmlmepriv->scanned_queue, pnetwork->network.MacAddress);
 					if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE){
-						if(ptarget_wlan)	ptarget_wlan->fixed = _TRUE;
+						if(ptarget_wlan)	ptarget_wlan->fixed = _TRUE;			
 					}
 				}
 
@@ -1906,13 +1906,13 @@ void rtw_joinbss_event_prehandle(_adapter *adapter, u8 *pbuf)
 			{
 				ptarget_wlan = rtw_find_network(&pmlmepriv->scanned_queue, pnetwork->network.MacAddress);
 				if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE){
-					if(ptarget_wlan)	ptarget_wlan->fixed = _TRUE;
+					if(ptarget_wlan)	ptarget_wlan->fixed = _TRUE;			
 				}
 			}
-
-			//s2. update cur_network
+		
+			//s2. update cur_network 
 			if(ptarget_wlan)
-			{
+			{			
 				rtw_joinbss_update_network(adapter, ptarget_wlan, pnetwork);
 			}
 			else
@@ -1921,9 +1921,9 @@ void rtw_joinbss_event_prehandle(_adapter *adapter, u8 *pbuf)
 				_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
 				goto ignore_joinbss_callback;
 			}
-
-
-			//s3. find ptarget_sta & update ptarget_sta after update cur_network only for station mode
+			
+			
+			//s3. find ptarget_sta & update ptarget_sta after update cur_network only for station mode 
 			if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)
 			{
 				ptarget_sta = rtw_joinbss_update_stainfo(adapter, pnetwork);
@@ -1933,9 +1933,9 @@ void rtw_joinbss_event_prehandle(_adapter *adapter, u8 *pbuf)
 					_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
 					goto ignore_joinbss_callback;
 				}
-			}
-
-			//s4. indicate connect
+			}	
+					
+			//s4. indicate connect			
 			if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)
 			{
 				rtw_indicate_connect(adapter);
@@ -1947,39 +1947,39 @@ void rtw_joinbss_event_prehandle(_adapter *adapter, u8 *pbuf)
 			}
 
 
-			//s5. Cancle assoc_timer
+			//s5. Cancle assoc_timer					
 			_cancel_timer(&pmlmepriv->assoc_timer, &timer_cancelled);
-
+			
 			RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("Cancle assoc_timer\n"));
-
+				
 		}
 		else
 		{
-			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("rtw_joinbss_event_callback err: fw_state:%x", get_fwstate(pmlmepriv)));
+			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("rtw_joinbss_event_callback err: fw_state:%x", get_fwstate(pmlmepriv)));	
 			_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
 			goto ignore_joinbss_callback;
 		}
-
+		
 		_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
-
+				
 	}
-	else if(pnetwork->join_res == -4)
+	else if(pnetwork->join_res == -4) 
 	{
 		rtw_reset_securitypriv(adapter);
-		_set_timer(&pmlmepriv->assoc_timer, 1);
+		_set_timer(&pmlmepriv->assoc_timer, 1);					
 
 		//rtw_free_assoc_resources(adapter, 1);
 
 		if((check_fwstate(pmlmepriv, _FW_UNDER_LINKING)) == _TRUE)
-		{
+		{		
 			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("fail! clear _FW_UNDER_LINKING ^^^fw_state=%x\n", get_fwstate(pmlmepriv)));
 			_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
-		}
-
+		}	
+		
 	}
 	else //if join_res < 0 (join fails), then try again
 	{
-
+	
 		#ifdef REJOIN
 		res = _FAIL;
 		if(retry < 2) {
@@ -1997,18 +1997,18 @@ void rtw_joinbss_event_prehandle(_adapter *adapter, u8 *pbuf)
 		{
 			_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
 			rtw_indicate_connect(adapter);
-		}
+		}	
 		else
 		{
 			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("Set Assoc_Timer = 1; can't find match ssid in scanned_q \n"));
 		#endif
-
+			
 			_set_timer(&pmlmepriv->assoc_timer, 1);
 			//rtw_free_assoc_resources(adapter, 1);
 			_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
-
+			
 		#ifdef REJOIN
-			retry = 0;
+			retry = 0;	
 		}
 		#endif
 	}
@@ -2016,7 +2016,7 @@ void rtw_joinbss_event_prehandle(_adapter *adapter, u8 *pbuf)
 ignore_joinbss_callback:
 
 	_exit_critical_bh(&pmlmepriv->lock, &irqL);
-	_func_exit_;
+	_func_exit_;	
 }
 
 void rtw_joinbss_event_callback(_adapter *adapter, u8 *pbuf)
@@ -2029,7 +2029,7 @@ void rtw_joinbss_event_callback(_adapter *adapter, u8 *pbuf)
 
 	rtw_os_xmit_schedule(adapter);
 
-#ifdef CONFIG_CONCURRENT_MODE
+#ifdef CONFIG_CONCURRENT_MODE	
 	rtw_os_xmit_schedule(adapter->pbuddy_adapter);
 #endif
 
@@ -2042,22 +2042,22 @@ void rtw_joinbss_event_callback(_adapter *adapter, u8 *pbuf)
 
 void rtw_stassoc_event_callback(_adapter *adapter, u8 *pbuf)
 {
-	_irqL irqL;
+	_irqL irqL;	
 	struct sta_info *psta;
 	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
 	struct stassoc_event	*pstassoc	= (struct stassoc_event*)pbuf;
 	struct wlan_network 	*cur_network = &(pmlmepriv->cur_network);
 	struct wlan_network	*ptarget_wlan = NULL;
 
-_func_enter_;
-
+_func_enter_;	
+	
 	if(rtw_access_ctrl(adapter, pstassoc->macaddr) == _FALSE)
 		return;
 
 #if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
 	if(check_fwstate(pmlmepriv, WIFI_AP_STATE))
 	{
-		psta = rtw_get_stainfo(&adapter->stapriv, pstassoc->macaddr);
+		psta = rtw_get_stainfo(&adapter->stapriv, pstassoc->macaddr);	
 		if(psta)
 		{
 #ifdef CONFIG_IOCTL_CFG80211
@@ -2069,18 +2069,18 @@ void rtw_stassoc_event_callback(_adapter *adapter, u8 *pbuf)
 
 			_enter_critical_bh(&psta->lock, &irqL);
 			if(psta->passoc_req && psta->assoc_req_len>0)
-			{
+			{				
 				passoc_req = rtw_zmalloc(psta->assoc_req_len);
 				if(passoc_req)
 				{
 					assoc_req_len = psta->assoc_req_len;
 					_rtw_memcpy(passoc_req, psta->passoc_req, assoc_req_len);
-
+					
 					rtw_mfree(psta->passoc_req , psta->assoc_req_len);
 					psta->passoc_req = NULL;
 					psta->assoc_req_len = 0;
 				}
-			}
+			}			
 			_exit_critical_bh(&psta->lock, &irqL);
 
 			if(passoc_req && assoc_req_len>0)
@@ -2090,46 +2090,46 @@ void rtw_stassoc_event_callback(_adapter *adapter, u8 *pbuf)
 				rtw_mfree(passoc_req, assoc_req_len);
 			}
 #endif //(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37)) || defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER)
-#endif //CONFIG_IOCTL_CFG80211
+#endif //CONFIG_IOCTL_CFG80211	
 
 			//bss_cap_update_on_sta_join(adapter, psta);
 			//sta_info_update(adapter, psta);
 			ap_sta_info_defer_update(adapter, psta);
-		}
-
+		}	
+		
 		goto exit;
-	}
-#endif
+	}	
+#endif	
 
-	psta = rtw_get_stainfo(&adapter->stapriv, pstassoc->macaddr);
+	psta = rtw_get_stainfo(&adapter->stapriv, pstassoc->macaddr);	
 	if( psta != NULL)
 	{
-		//the sta have been in sta_info_queue => do nothing
-
+		//the sta have been in sta_info_queue => do nothing 
+		
 		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("Error: rtw_stassoc_event_callback: sta has been in sta_hash_queue \n"));
-
+		
 		goto exit; //(between drv has received this event before and  fw have not yet to set key to CAM_ENTRY)
 	}
 
-	psta = rtw_alloc_stainfo(&adapter->stapriv, pstassoc->macaddr);
+	psta = rtw_alloc_stainfo(&adapter->stapriv, pstassoc->macaddr);	
 	if (psta == NULL) {
 		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("Can't alloc sta_info when rtw_stassoc_event_callback\n"));
 		goto exit;
-	}
-
+	}	
+	
 	//to do : init sta_info variable
 	psta->qos_option = 0;
 	psta->mac_id = (uint)pstassoc->cam_id;
 	//psta->aid = (uint)pstassoc->cam_id;
-
+	
 	if(adapter->securitypriv.dot11AuthAlgrthm==dot11AuthAlgrthm_8021X)
 		psta->dot118021XPrivacy = adapter->securitypriv.dot11PrivacyAlgrthm;
 
-	psta->ieee8021x_blocked = _FALSE;
-
+	psta->ieee8021x_blocked = _FALSE;		
+	
 	_enter_critical_bh(&pmlmepriv->lock, &irqL);
 
-	if ( (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)==_TRUE ) ||
+	if ( (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)==_TRUE ) || 
 		(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)==_TRUE ) )
 	{
 		if(adapter->stapriv.asoc_sta_count== 2)
@@ -2147,31 +2147,31 @@ void rtw_stassoc_event_callback(_adapter *adapter, u8 *pbuf)
 
 
 	mlmeext_sta_add_event_callback(adapter, psta);
-
+	
 #ifdef CONFIG_RTL8711
-	//submit SetStaKey_cmd to tell fw, fw will allocate an CAM entry for this sta
+	//submit SetStaKey_cmd to tell fw, fw will allocate an CAM entry for this sta	
 	rtw_setstakey_cmd(adapter, (unsigned char*)psta, _FALSE);
 #endif
-
+		
 exit:
-
-_func_exit_;
+	
+_func_exit_;	
 
 }
 
 void rtw_stadel_event_callback(_adapter *adapter, u8 *pbuf)
 {
-	_irqL irqL,irqL2;
+	_irqL irqL,irqL2;	
 	struct sta_info *psta;
 	struct wlan_network* pwlan = NULL;
 	WLAN_BSSID_EX    *pdev_network=NULL;
 	u8* pibss = NULL;
 	struct	mlme_priv	*pmlmepriv = &(adapter->mlmepriv);
 	struct 	stadel_event *pstadel	= (struct stadel_event*)pbuf;
-	struct	sta_priv *pstapriv = &adapter->stapriv;
+   	struct	sta_priv *pstapriv = &adapter->stapriv;
 	struct wlan_network *tgt_network = &(pmlmepriv->cur_network);
-
-_func_enter_;
+	
+_func_enter_;	
 
         if(check_fwstate(pmlmepriv, WIFI_AP_STATE))
         {
@@ -2211,56 +2211,56 @@ void rtw_stadel_event_callback(_adapter *adapter, u8 *pbuf)
 		rtw_indicate_disconnect(adapter);
 		_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
 		// remove the network entry in scanned_queue
-		pwlan = rtw_find_network(&pmlmepriv->scanned_queue, tgt_network->network.MacAddress);
-		if (pwlan) {
+		pwlan = rtw_find_network(&pmlmepriv->scanned_queue, tgt_network->network.MacAddress);	
+		if (pwlan) {			
 			pwlan->fixed = _FALSE;
 			rtw_free_network_nolock(pmlmepriv, pwlan);
 		}
 		_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
 
 		_rtw_roaming(adapter, tgt_network);
-
+		
 #ifdef CONFIG_INTEL_WIDI
 		if (!rtw_to_roaming(adapter))
 			process_intel_widi_disconnect(adapter, 1);
 #endif // CONFIG_INTEL_WIDI
 	}
 
-	if ( check_fwstate(pmlmepriv,WIFI_ADHOC_MASTER_STATE) ||
+	if ( check_fwstate(pmlmepriv,WIFI_ADHOC_MASTER_STATE) || 
 	      check_fwstate(pmlmepriv,WIFI_ADHOC_STATE))
 	{
 		psta = rtw_get_stainfo(&adapter->stapriv, pstadel->macaddr);
-
+		
 		_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
 		rtw_free_stainfo(adapter,  psta);
 		_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
-
+		
 		if(adapter->stapriv.asoc_sta_count== 1) //a sta + bc/mc_stainfo (not Ibss_stainfo)
-		{
+		{ 
 			//rtw_indicate_disconnect(adapter);//removed@20091105
 			_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
 			//free old ibss network
 			//pwlan = rtw_find_network(&pmlmepriv->scanned_queue, pstadel->macaddr);
 			pwlan = rtw_find_network(&pmlmepriv->scanned_queue, tgt_network->network.MacAddress);
-			if(pwlan)
+			if(pwlan)	
 			{
 				pwlan->fixed = _FALSE;
-				rtw_free_network_nolock(pmlmepriv, pwlan);
+				rtw_free_network_nolock(pmlmepriv, pwlan); 
 			}
 			_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
 			//re-create ibss
-			pdev_network = &(adapter->registrypriv.dev_network);
+			pdev_network = &(adapter->registrypriv.dev_network);			
 			pibss = adapter->registrypriv.dev_network.MacAddress;
 
 			_rtw_memcpy(pdev_network, &tgt_network->network, get_WLAN_BSSID_EX_sz(&tgt_network->network));
-
+			
 			_rtw_memset(&pdev_network->Ssid, 0, sizeof(NDIS_802_11_SSID));
 			_rtw_memcpy(&pdev_network->Ssid, &pmlmepriv->assoc_ssid, sizeof(NDIS_802_11_SSID));
-
-			rtw_update_registrypriv_dev_network(adapter);
+	
+			rtw_update_registrypriv_dev_network(adapter);			
 
 			rtw_generate_random_ibss(pibss);
-
+			
 			if(check_fwstate(pmlmepriv,WIFI_ADHOC_STATE))
 			{
 				set_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE);
@@ -2270,18 +2270,18 @@ void rtw_stadel_event_callback(_adapter *adapter, u8 *pbuf)
 			if(rtw_createbss_cmd(adapter)!=_SUCCESS)
 			{
 
-				RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("***Error=>stadel_event_callback: rtw_createbss_cmd status FAIL*** \n "));
+				RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("***Error=>stadel_event_callback: rtw_createbss_cmd status FAIL*** \n "));										
 
 			}
 
-
+			
 		}
-
+		
 	}
-
+	
 	_exit_critical_bh(&pmlmepriv->lock, &irqL2);
-
-_func_exit_;
+	
+_func_exit_;	
 
 }
 
@@ -2322,9 +2322,9 @@ void _rtw_join_timeout_handler (_adapter *adapter)
 		_rtw_up_sema(&pmlmepriv->assoc_terminate);
 		return;
 	}
-#endif
+#endif	
 
-_func_enter_;
+_func_enter_;		
 #ifdef PLATFORM_FREEBSD
 		rtw_mtx_lock(NULL);
 		 if (callout_pending(&adapter->mlmepriv.assoc_timer.callout)) {
@@ -2340,16 +2340,16 @@ void _rtw_join_timeout_handler (_adapter *adapter)
 			 return;
 		 }
 		 callout_deactivate(&adapter->mlmepriv.assoc_timer.callout);
-
-
+	
+	
 #endif
 
 	DBG_871X("%s, fw_state=%x\n", __FUNCTION__, get_fwstate(pmlmepriv));
-
+	
 	if(adapter->bDriverStopped ||adapter->bSurpriseRemoved)
 		return;
 
-
+	
 	_enter_critical_bh(&pmlmepriv->lock, &irqL);
 
 	#ifdef CONFIG_LAYER2_ROAMING
@@ -2377,8 +2377,8 @@ void _rtw_join_timeout_handler (_adapter *adapter)
 				break;
 			}
 		}
-
-	} else
+		
+	} else 
 	#endif
 	{
 		rtw_indicate_disconnect(adapter);
@@ -2389,18 +2389,18 @@ void _rtw_join_timeout_handler (_adapter *adapter)
 		rtw_cfg80211_indicate_disconnect(adapter);
 #endif //CONFIG_IOCTL_CFG80211
 
-	}
+ 	}
 
 	_exit_critical_bh(&pmlmepriv->lock, &irqL);
+	
 
-
-#ifdef CONFIG_DRVEXT_MODULE_WSC
-	drvext_assoc_fail_indicate(&adapter->drvextpriv);
-#endif
+#ifdef CONFIG_DRVEXT_MODULE_WSC	
+	drvext_assoc_fail_indicate(&adapter->drvextpriv);	
+#endif	
 #ifdef PLATFORM_FREEBSD
 		rtw_mtx_unlock(NULL);
 #endif
-
+	
 _func_exit_;
 
 }
@@ -2410,14 +2410,14 @@ void _rtw_join_timeout_handler (_adapter *adapter)
 * @adapter: pointer to _adapter structure
 */
 void rtw_scan_timeout_handler (_adapter *adapter)
-{
+{	
 	_irqL irqL;
 	struct	mlme_priv *pmlmepriv = &adapter->mlmepriv;
-
+	
 	DBG_871X(FUNC_ADPT_FMT" fw_state=%x\n", FUNC_ADPT_ARG(adapter), get_fwstate(pmlmepriv));
 
 	_enter_critical_bh(&pmlmepriv->lock, &irqL);
-
+	
 	_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY);
 
 	_exit_critical_bh(&pmlmepriv->lock, &irqL);
@@ -2437,13 +2437,13 @@ static void rtw_auto_scan_handler(_adapter *padapter)
 		pmlmepriv->scan_interval--;
 		if(pmlmepriv->scan_interval==0)
 		{
-/*
-			if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE)
+/*		
+			if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE) 
 			{
 				DBG_871X("exit %s when _FW_UNDER_SURVEY|_FW_UNDER_LINKING -> \n", __FUNCTION__);
 				return;
 			}
-
+			
 			if(pmlmepriv->sitesurveyctrl.traffic_busy == _TRUE)
 			{
 				DBG_871X("%s exit cause traffic_busy(%x)\n",__FUNCTION__, pmlmepriv->sitesurveyctrl.traffic_busy);
@@ -2456,7 +2456,7 @@ static void rtw_auto_scan_handler(_adapter *padapter)
 			{
 				if ((check_buddy_fwstate(padapter, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE) ||
 					(padapter->pbuddy_adapter->mlmepriv.LinkDetectInfo.bBusyTraffic == _TRUE))
-				{
+				{		
 					DBG_871X("%s, but buddy_intf is under scanning or linking or BusyTraffic\n", __FUNCTION__);
 					return;
 				}
@@ -2465,12 +2465,12 @@ static void rtw_auto_scan_handler(_adapter *padapter)
 
 			DBG_871X("%s\n", __FUNCTION__);
 
-			rtw_set_802_11_bssid_list_scan(padapter, NULL, 0);
-
+			rtw_set_802_11_bssid_list_scan(padapter, NULL, 0);			
+			
 			pmlmepriv->scan_interval = SCAN_INTERVAL;// 30*2 sec = 60sec
-
+			
 		}
-
+		
 	}
 
 }
@@ -2481,12 +2481,12 @@ void rtw_dynamic_check_timer_handlder(_adapter *adapter)
 	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
 #endif //CONFIG_AP_MODE
 	struct registry_priv *pregistrypriv = &adapter->registrypriv;
-#ifdef CONFIG_CONCURRENT_MODE
-	PADAPTER pbuddy_adapter = adapter->pbuddy_adapter;
+#ifdef CONFIG_CONCURRENT_MODE	
+	PADAPTER pbuddy_adapter = adapter->pbuddy_adapter;	
 #endif
 
 	if(!adapter)
-		return;
+		return;	
 
 	if(adapter->hw_init_completed == _FALSE)
 		return;
@@ -2501,27 +2501,27 @@ void rtw_dynamic_check_timer_handlder(_adapter *adapter)
 		if(adapter->net_closed == _TRUE && pbuddy_adapter->net_closed == _TRUE)
 		{
 			return;
-		}
+		}		
 	}
 	else
 #endif //CONFIG_CONCURRENT_MODE
 	if(adapter->net_closed == _TRUE)
 	{
 		return;
-	}
+	}	
 
 	rtw_dynamic_chk_wk_cmd(adapter);
 
 	if(pregistrypriv->wifi_spec==1)
-	{
+	{	
 #ifdef CONFIG_P2P
 		struct wifidirect_info *pwdinfo = &adapter->wdinfo;
 		if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
-#endif
+#endif	
 		{
 			//auto site survey
 			rtw_auto_scan_handler(adapter);
-		}
+		}	
 	}
 
 #ifndef CONFIG_ACTIVE_KEEP_ALIVE_CHECK
@@ -2529,7 +2529,7 @@ void rtw_dynamic_check_timer_handlder(_adapter *adapter)
 	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
 	{
 		expire_timeout_chk(adapter);
-	}
+	}	
 #endif
 #endif //!CONFIG_ACTIVE_KEEP_ALIVE_CHECK
 
@@ -2539,8 +2539,8 @@ void rtw_dynamic_check_timer_handlder(_adapter *adapter)
 	rcu_read_lock();
 #endif	// (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35))
 
-#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
-	if( adapter->pnetdev->br_port
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35)) 
+	if( adapter->pnetdev->br_port 
 #else	// (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
 	if( rcu_dereference(adapter->pnetdev->rx_handler_data)
 #endif	// (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
@@ -2553,7 +2553,7 @@ void rtw_dynamic_check_timer_handlder(_adapter *adapter)
 		if (adapter->pppoe_connection_in_progress > 0) {
 			adapter->pppoe_connection_in_progress--;
 		}
-
+		
 		// due to rtw_dynamic_check_timer_handlder() is called every 2 seconds
 		if (adapter->pppoe_connection_in_progress > 0) {
 			adapter->pppoe_connection_in_progress--;
@@ -2565,7 +2565,7 @@ void rtw_dynamic_check_timer_handlder(_adapter *adapter)
 #endif	// (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35))
 
 #endif	// CONFIG_BR_EXT
-
+	
 }
 
 
@@ -2600,18 +2600,18 @@ void rtw_set_scan_deny(_adapter *adapter, u32 ms)
 	DBG_871X(FUNC_ADPT_FMT"\n", FUNC_ADPT_ARG(adapter));
 	ATOMIC_SET(&mlmepriv->set_scan_deny, 1);
 	_set_timer(&mlmepriv->set_scan_deny_timer, ms);
-
+	
 #ifdef CONFIG_CONCURRENT_MODE
 	if (!adapter->pbuddy_adapter)
 		return;
 
 	if (0)
 	DBG_871X(FUNC_ADPT_FMT"\n", FUNC_ADPT_ARG(adapter->pbuddy_adapter));
-	b_mlmepriv = &adapter->pbuddy_adapter->mlmepriv;
+ 	b_mlmepriv = &adapter->pbuddy_adapter->mlmepriv;
 	ATOMIC_SET(&b_mlmepriv->set_scan_deny, 1);
-	_set_timer(&b_mlmepriv->set_scan_deny_timer, ms);
+	_set_timer(&b_mlmepriv->set_scan_deny_timer, ms);	
 #endif
-
+	
 }
 #endif
 
@@ -2659,7 +2659,7 @@ static int rtw_check_join_candidate(struct mlme_priv *pmlmepriv
 			goto exit;
 	}
 #endif
-
+	
 	if(*candidate == NULL ||(*candidate)->network.Rssi<competitor->network.Rssi )
 	{
 		*candidate = competitor;
@@ -2683,7 +2683,7 @@ static int rtw_check_join_candidate(struct mlme_priv *pmlmepriv
 #ifdef  CONFIG_LAYER2_ROAMING
 	if(rtw_to_roaming(adapter)) { // roaming
 		if(	(*candidate == NULL ||(*candidate)->network.Rssi<competitor->network.Rssi )
-			&& is_same_ess(&competitor->network, &pmlmepriv->cur_network.network)
+			&& is_same_ess(&competitor->network, &pmlmepriv->cur_network.network) 
 			//&&(!is_same_network(&competitor->network, &pmlmepriv->cur_network.network))
 			&& rtw_get_passing_time_ms((u32)competitor->last_scanned) < RTW_SCAN_RESULT_EXPIRE
 			&& rtw_is_desired_network(adapter, competitor)
@@ -2691,7 +2691,7 @@ static int rtw_check_join_candidate(struct mlme_priv *pmlmepriv
 			*candidate = competitor;
 			updated = _TRUE;
 		}
-
+		
 	} else
 #endif
 	{ // associate with ssid
@@ -2744,7 +2744,7 @@ int rtw_select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv )
 	_irqL	irqL;
 	int ret;
 	_list	*phead;
-	_adapter *adapter;
+	_adapter *adapter;	
 	_queue	*queue	= &(pmlmepriv->scanned_queue);
 	struct	wlan_network	*pnetwork = NULL;
 	struct	wlan_network	*candidate = NULL;
@@ -2753,7 +2753,7 @@ int rtw_select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv )
 _func_enter_;
 
 	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
-	phead = get_list_head(queue);
+	phead = get_list_head(queue);		
 	adapter = (_adapter *)pmlmepriv->nic_hdl;
 
 	pmlmepriv->pscanned = get_next( phead );
@@ -2766,7 +2766,7 @@ int rtw_select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv )
 			ret = _FAIL;
 			goto exit;
 		}
-
+		
 		pmlmepriv->pscanned = get_next(pmlmepriv->pscanned);
 
 		#if 0
@@ -2774,8 +2774,8 @@ int rtw_select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv )
 		#endif
 
 		rtw_check_join_candidate(pmlmepriv, &candidate, pnetwork);
-
-	}
+ 
+ 	}
 
 	if(candidate == NULL) {
 		DBG_871X("%s: return _FAIL(candidate == NULL)\n", __FUNCTION__);
@@ -2786,9 +2786,9 @@ int rtw_select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv )
 			candidate->network.Ssid.Ssid, MAC_ARG(candidate->network.MacAddress),
 			candidate->network.Configuration.DSConfig);
 	}
+	
 
-
-	// check for situation of  _FW_LINKED
+	// check for situation of  _FW_LINKED 
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
 	{
 		DBG_871X("%s: _FW_LINKED while ask_for_joinbss!!!\n", __FUNCTION__);
@@ -2799,7 +2799,7 @@ int rtw_select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv )
 			DBG_871X("%s: _FW_LINKED and is same network, it needn't join again\n", __FUNCTION__);
 
 			rtw_indicate_connect(adapter);//rtw_indicate_connect again
-
+				
 			ret = 2;
 			goto exit;
 		}
@@ -2811,13 +2811,13 @@ int rtw_select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv )
 			rtw_free_assoc_resources(adapter, 0);
 		}
 	}
-
+	
 	#ifdef CONFIG_ANTENNA_DIVERSITY
 	rtw_hal_get_def_var(adapter, HAL_DEF_IS_SUPPORT_ANT_DIV, &(bSupportAntDiv));
-	if(_TRUE == bSupportAntDiv)
+	if(_TRUE == bSupportAntDiv)	
 	{
 		u8 CurrentAntenna;
-		rtw_hal_get_def_var(adapter, HAL_DEF_CURRENT_ANTENNA, &(CurrentAntenna));
+		rtw_hal_get_def_var(adapter, HAL_DEF_CURRENT_ANTENNA, &(CurrentAntenna));			
 		DBG_871X("#### Opt_Ant_(%s) , cur_Ant(%s)\n",
 			(2==candidate->network.PhyInfo.Optimum_antenna)?"A":"B",
 			(2==CurrentAntenna)?"A":"B"
@@ -2826,7 +2826,7 @@ int rtw_select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv )
 	#endif
 	set_fwstate(pmlmepriv, _FW_UNDER_LINKING);
 	ret = rtw_joinbss_cmd(adapter, candidate);
-
+	
 exit:
 	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
 
@@ -2836,14 +2836,14 @@ int rtw_select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv )
 }
 #else
 int rtw_select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv )
-{
+{	
 	_irqL	irqL;
 	_list	*phead;
 #ifdef CONFIG_ANTENNA_DIVERSITY
 	u8 CurrentAntenna;
 #endif
 	unsigned char *dst_ssid, *src_ssid;
-	_adapter *adapter;
+	_adapter *adapter;	
 	_queue	*queue	= &(pmlmepriv->scanned_queue);
 	struct	wlan_network	*pnetwork = NULL;
 	struct	wlan_network	*pnetwork_max_rssi = NULL;
@@ -2854,7 +2854,7 @@ int rtw_select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv )
 
 _func_enter_;
 	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
-	phead = get_list_head(queue);
+	phead = get_list_head(queue);		
 	adapter = (_adapter *)pmlmepriv->nic_hdl;
 
 	pmlmepriv->pscanned = get_next( phead );
@@ -2865,12 +2865,12 @@ int rtw_select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv )
 		if(pnetwork==NULL){
 			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("(2)rtw_select_and_join_from_scanned_queue return _FAIL:(pnetwork==NULL)\n"));
 			_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
-			return _FAIL;
+			return _FAIL;	
 		}
 
 		dst_ssid = pnetwork->network.Ssid.Ssid;
 		src_ssid = pmlmepriv->assoc_ssid.Ssid;
-
+		
 		pmlmepriv->pscanned = get_next(pmlmepriv->pscanned);
 
 		#if 0
@@ -2885,7 +2885,7 @@ int rtw_select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv )
 				//if((pmlmepriv->cur_network.network.InfrastructureMode==Ndis802_11AutoUnknown)||
 				//	pmlmepriv->cur_network.network.InfrastructureMode == pnetwork->network.InfrastructureMode)
 				//		goto ask_for_joinbss;
-
+				
 				if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
 				{
 					if(is_same_network(&pmlmepriv->cur_network.network, &pnetwork->network))
@@ -2893,7 +2893,7 @@ int rtw_select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv )
 						//DBG_871X("select_and_join(1): _FW_LINKED and is same network, it needn't join again\n");
 
 						rtw_indicate_connect(adapter);//rtw_indicate_connect again
-						_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
+						_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);	
 						return 2;
 					}
 					else
@@ -2903,7 +2903,7 @@ int rtw_select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv )
 						rtw_free_assoc_resources(adapter, 0);
 						_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
 						goto ask_for_joinbss;
-
+						
 					}
 				}
 				else
@@ -2911,18 +2911,18 @@ int rtw_select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv )
 					_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
 					goto ask_for_joinbss;
 				}
-
+							
 			}
-
+			
 		} else if (pmlmepriv->assoc_ssid.SsidLength == 0) {
 			_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
-			goto ask_for_joinbss;//anyway, join first selected(dequeued) pnetwork if ssid_len=0
-
+			goto ask_for_joinbss;//anyway, join first selected(dequeued) pnetwork if ssid_len=0				
+	
 		#ifdef CONFIG_LAYER2_ROAMING
 		} else if (rtw_to_roaming(adapter) > 0) {
-
+		
 			if(	(roaming_candidate == NULL ||roaming_candidate->network.Rssi<pnetwork->network.Rssi )
-				&& is_same_ess(&pnetwork->network, &pmlmepriv->cur_network.network)
+				&& is_same_ess(&pnetwork->network, &pmlmepriv->cur_network.network) 
 				//&&(!is_same_network(&pnetwork->network, &pmlmepriv->cur_network.network))
 				&&  rtw_get_time_interval_ms((u32)pnetwork->last_scanned,cur_time) < 5000
 				) {
@@ -2943,7 +2943,7 @@ int rtw_select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv )
 		{
 			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("dst_ssid=%s, src_ssid=%s \n", dst_ssid, src_ssid));
 #ifdef CONFIG_ANTENNA_DIVERSITY
-			rtw_hal_get_def_var(adapter, HAL_DEF_CURRENT_ANTENNA, &(CurrentAntenna));
+			rtw_hal_get_def_var(adapter, HAL_DEF_CURRENT_ANTENNA, &(CurrentAntenna));			
 			DBG_871X("#### dst_ssid=(%s) Opt_Ant_(%s) , cur_Ant(%s)\n", dst_ssid,
 				(2==pnetwork->network.PhyInfo.Optimum_antenna)?"A":"B",
 				(2==CurrentAntenna)?"A":"B");
@@ -2959,43 +2959,43 @@ int rtw_select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv )
 			if(pmlmepriv->assoc_by_rssi==_TRUE)//if the ssid is the same, select the bss which has the max rssi
 			{
 				if( NULL==pnetwork_max_rssi|| pnetwork->network.Rssi > pnetwork_max_rssi->network.Rssi)
-						pnetwork_max_rssi = pnetwork;
+						pnetwork_max_rssi = pnetwork;					
 			}
 			else if(rtw_is_desired_network(adapter, pnetwork) == _TRUE)
 			{
 				if (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
 				{
-#if 0
+#if 0				
 					if(is_same_network(&pmlmepriv->cur_network.network, &pnetwork->network))
 					{
 						DBG_871X("select_and_join(2): _FW_LINKED and is same network, it needn't join again\n");
-
+						
 						rtw_indicate_connect(adapter);//rtw_indicate_connect again
-
+						
 						return 2;
 					}
 					else
-#endif
+#endif						
 					{
 						rtw_disassoc_cmd(adapter, 0, _TRUE);
 						//rtw_indicate_disconnect(adapter);//
 						rtw_free_assoc_resources(adapter, 0);
 						_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
-						goto ask_for_joinbss;
+						goto ask_for_joinbss;						
 					}
 				}
 				else
 				{
 					_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
 					goto ask_for_joinbss;
-				}
+				}				
 
 			}
-
-
+		
+			
 		}
-
-	}
+ 	
+ 	}
 	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
 	#ifdef CONFIG_LAYER2_ROAMING
 	if(rtw_to_roaming(adapter) > 0 && roaming_candidate ){
@@ -3015,13 +3015,13 @@ int rtw_select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv )
 	}
 
 	DBG_871X("(1)rtw_select_and_join_from_scanned_queue return _FAIL\n");
-
-_func_exit_;
+	
+_func_exit_;	
 
      return _FAIL;
 
 ask_for_joinbss:
-
+	
 _func_exit_;
 
 	return rtw_joinbss_cmd(adapter, pnetwork);
@@ -3036,15 +3036,15 @@ sint rtw_set_auth(_adapter * adapter,struct security_priv *psecuritypriv)
 	struct 	setauth_parm *psetauthparm;
 	struct	cmd_priv	*pcmdpriv=&(adapter->cmdpriv);
 	sint		res=_SUCCESS;
-
-_func_enter_;
+	
+_func_enter_;	
 
 	pcmd = (struct	cmd_obj*)rtw_zmalloc(sizeof(struct	cmd_obj));
 	if(pcmd==NULL){
 		res= _FAIL;  //try again
 		goto exit;
 	}
-
+	
 	psetauthparm=(struct setauth_parm*)rtw_zmalloc(sizeof(struct setauth_parm));
 	if(psetauthparm==NULL){
 		rtw_mfree((unsigned char *)pcmd, sizeof(struct	cmd_obj));
@@ -3054,10 +3054,10 @@ sint rtw_set_auth(_adapter * adapter,struct security_priv *psecuritypriv)
 
 	_rtw_memset(psetauthparm, 0, sizeof(struct setauth_parm));
 	psetauthparm->mode=(unsigned char)psecuritypriv->dot11AuthAlgrthm;
-
+	
 	pcmd->cmdcode = _SetAuth_CMD_;
-	pcmd->parmbuf = (unsigned char *)psetauthparm;
-	pcmd->cmdsz =  (sizeof(struct setauth_parm));
+	pcmd->parmbuf = (unsigned char *)psetauthparm;   
+	pcmd->cmdsz =  (sizeof(struct setauth_parm));  
 	pcmd->rsp = NULL;
 	pcmd->rspsz = 0;
 
@@ -3085,9 +3085,9 @@ sint rtw_set_key(_adapter * adapter,struct security_priv *psecuritypriv,sint key
 	struct cmd_priv		*pcmdpriv = &(adapter->cmdpriv);
 	struct mlme_priv		*pmlmepriv = &(adapter->mlmepriv);
 	sint	res=_SUCCESS;
-
+	
 _func_enter_;
-
+	
 	pcmd = (struct	cmd_obj*)rtw_zmalloc(sizeof(struct	cmd_obj));
 	if(pcmd==NULL){
 		res= _FAIL;  //try again
@@ -3102,10 +3102,10 @@ sint rtw_set_key(_adapter * adapter,struct security_priv *psecuritypriv,sint key
 
 	_rtw_memset(psetkeyparm, 0, sizeof(struct setkey_parm));
 
-	if(psecuritypriv->dot11AuthAlgrthm ==dot11AuthAlgrthm_8021X){
-		psetkeyparm->algorithm=(unsigned char)psecuritypriv->dot118021XGrpPrivacy;
+	if(psecuritypriv->dot11AuthAlgrthm ==dot11AuthAlgrthm_8021X){		
+		psetkeyparm->algorithm=(unsigned char)psecuritypriv->dot118021XGrpPrivacy;	
 		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n rtw_set_key: psetkeyparm->algorithm=(unsigned char)psecuritypriv->dot118021XGrpPrivacy=%d \n", psetkeyparm->algorithm));
-	}
+	}	
 	else{
 		psetkeyparm->algorithm=(u8)psecuritypriv->dot11PrivacyAlgrthm;
 		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n rtw_set_key: psetkeyparm->algorithm=(u8)psecuritypriv->dot11PrivacyAlgrthm=%d \n", psetkeyparm->algorithm));
@@ -3120,7 +3120,7 @@ sint rtw_set_key(_adapter * adapter,struct security_priv *psecuritypriv,sint key
 	RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n rtw_set_key: psetkeyparm->algorithm=%d psetkeyparm->keyid=(u8)keyid=%d \n",psetkeyparm->algorithm, keyid));
 
 	switch(psetkeyparm->algorithm){
-
+		
 		case _WEP40_:
 			keylen=5;
 			_rtw_memcpy(&(psetkeyparm->key[0]), &(psecuritypriv->dot11DefKey[keyid].skey[0]), keylen);
@@ -3130,12 +3130,12 @@ sint rtw_set_key(_adapter * adapter,struct security_priv *psecuritypriv,sint key
 			_rtw_memcpy(&(psetkeyparm->key[0]), &(psecuritypriv->dot11DefKey[keyid].skey[0]), keylen);
 			break;
 		case _TKIP_:
-			keylen=16;
+			keylen=16;			
 			_rtw_memcpy(&psetkeyparm->key, &psecuritypriv->dot118021XGrpKey[keyid], keylen);
 			psetkeyparm->grpkey=1;
 			break;
 		case _AES_:
-			keylen=16;
+			keylen=16;			
 			_rtw_memcpy(&psetkeyparm->key, &psecuritypriv->dot118021XGrpKey[keyid], keylen);
 			psetkeyparm->grpkey=1;
 			break;
@@ -3145,10 +3145,10 @@ sint rtw_set_key(_adapter * adapter,struct security_priv *psecuritypriv,sint key
 			goto exit;
 	}
 
-
+	
 	pcmd->cmdcode = _SetKey_CMD_;
-	pcmd->parmbuf = (u8 *)psetkeyparm;
-	pcmd->cmdsz =  (sizeof(struct setkey_parm));
+	pcmd->parmbuf = (u8 *)psetkeyparm;   
+	pcmd->cmdsz =  (sizeof(struct setkey_parm));  
 	pcmd->rsp = NULL;
 	pcmd->rspsz = 0;
 
@@ -3175,8 +3175,8 @@ int rtw_restruct_wmm_ie(_adapter *adapter, u8 *in_ie, u8 *out_ie, uint in_len, u
 	i = 12; //after the fixed IE
 	while(i<in_len)
 	{
-		ielength = initial_out_len;
-
+		ielength = initial_out_len;		
+		
 		if(in_ie[i] == 0xDD && in_ie[i+2] == 0x00 && in_ie[i+3] == 0x50  && in_ie[i+4] == 0xF2 && in_ie[i+5] == 0x02 && i+5 < in_len) //WMM element ID and OUI
 		{
 
@@ -3184,29 +3184,29 @@ int rtw_restruct_wmm_ie(_adapter *adapter, u8 *in_ie, u8 *out_ie, uint in_len, u
 			/*
 			for(j=i; j< i+(in_ie[i+1]+2); j++)
 			{
-				out_ie[ielength] = in_ie[j];
+				out_ie[ielength] = in_ie[j];				
 				ielength++;
 			}
 			out_ie[initial_out_len+8] = 0x00; //force the QoS Info Field to be zero
 	                */
-
+                       
                         for ( j = i; j < i + 9; j++ )
                         {
                             out_ie[ ielength] = in_ie[ j ];
                             ielength++;
-                        }
+                        } 
                         out_ie[ initial_out_len + 1 ] = 0x07;
                         out_ie[ initial_out_len + 6 ] = 0x00;
                         out_ie[ initial_out_len + 8 ] = 0x00;
-
+	
 			break;
 		}
 
 		i+=(in_ie[i+1]+2); // to the next IE element
 	}
-
+	
 	return ielength;
-
+	
 }
 
 
@@ -3228,30 +3228,30 @@ static int SecIsInPMKIDList(_adapter *Adapter, u8 *bssid)
 
 	do
 	{
-		if( ( psecuritypriv->PMKIDList[i].bUsed ) &&
+		if( ( psecuritypriv->PMKIDList[i].bUsed ) && 
                     (  _rtw_memcmp( psecuritypriv->PMKIDList[i].Bssid, bssid, ETH_ALEN ) == _TRUE ) )
 		{
 			break;
 		}
 		else
-		{
+		{	
 			i++;
 			//continue;
 		}
-
+		
 	}while(i<NUM_PMKID_CACHE);
 
 	if( i == NUM_PMKID_CACHE )
-	{
+	{ 
 		i = -1;// Could not find.
 	}
 	else
-	{
+	{ 
 		// There is one Pre-Authentication Key for the specific BSSID.
 	}
 
 	return (i);
-
+	
 }
 
 //
@@ -3259,27 +3259,27 @@ static int SecIsInPMKIDList(_adapter *Adapter, u8 *bssid)
 // If the RSN IE length <= 20, the RSN IE didn't include the PMKID information
 // 0-11th element in the array are the fixed IE
 // 12th element in the array is the IE
-// 13th element in the array is the IE length
+// 13th element in the array is the IE length  
 //
 
 static int rtw_append_pmkid(_adapter *Adapter,int iEntry, u8 *ie, uint ie_len)
 {
 	struct security_priv *psecuritypriv=&Adapter->securitypriv;
 
-	if(ie[13]<=20){
-		// The RSN IE didn't include the PMK ID, append the PMK information
+	if(ie[13]<=20){	
+		// The RSN IE didn't include the PMK ID, append the PMK information 
 			ie[ie_len]=1;
 			ie_len++;
 			ie[ie_len]=0;	//PMKID count = 0x0100
 			ie_len++;
 			_rtw_memcpy(	&ie[ie_len], &psecuritypriv->PMKIDList[iEntry].PMKID, 16);
-
+		
 			ie_len+=16;
 			ie[13]+=18;//PMKID length = 2+16
 
 	}
 	return (ie_len);
-
+	
 }
 sint rtw_restruct_sec_ie(_adapter *adapter,u8 *in_ie, u8 *out_ie, uint in_len)
 {
@@ -3293,13 +3293,13 @@ sint rtw_restruct_sec_ie(_adapter *adapter,u8 *in_ie, u8 *out_ie, uint in_len)
 	struct security_priv *psecuritypriv=&adapter->securitypriv;
 	uint 	ndisauthmode=psecuritypriv->ndisauthtype;
 	uint ndissecuritytype = psecuritypriv->ndisencryptstatus;
-
+	
 _func_enter_;
 
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_,
 		 ("+rtw_restruct_sec_ie: ndisauthmode=%d ndissecuritytype=%d\n",
 		  ndisauthmode, ndissecuritytype));
-
+	
 	//copy fixed ie only
 	_rtw_memcpy(out_ie, in_ie,12);
 	ielength=12;
@@ -3311,12 +3311,12 @@ sint rtw_restruct_sec_ie(_adapter *adapter,u8 *in_ie, u8 *out_ie, uint in_len)
 	if(check_fwstate(pmlmepriv, WIFI_UNDER_WPS))
 	{
 		_rtw_memcpy(out_ie+ielength, psecuritypriv->wps_ie, psecuritypriv->wps_ie_len);
-
+		
 		ielength += psecuritypriv->wps_ie_len;
 	}
 	else if((authmode==_WPA_IE_ID_)||(authmode==_WPA2_IE_ID_))
-	{
-		//copy RSN or SSN
+	{		
+		//copy RSN or SSN		
 		_rtw_memcpy(&out_ie[ielength], &psecuritypriv->supplicant_ie[0], psecuritypriv->supplicant_ie[1]+2);
 		/* debug for CONFIG_IEEE80211W
 		{
@@ -3328,9 +3328,9 @@ sint rtw_restruct_sec_ie(_adapter *adapter,u8 *in_ie, u8 *out_ie, uint in_len)
 		}*/
 		ielength+=psecuritypriv->supplicant_ie[1]+2;
 		rtw_report_sec_ie(adapter, authmode, psecuritypriv->supplicant_ie);
-
+	
 #ifdef CONFIG_DRVEXT_MODULE
-		drvext_report_sec_ie(&adapter->drvextpriv, authmode, sec_ie);
+		drvext_report_sec_ie(&adapter->drvextpriv, authmode, sec_ie);	
 #endif
 	}
 
@@ -3348,8 +3348,8 @@ sint rtw_restruct_sec_ie(_adapter *adapter,u8 *in_ie, u8 *out_ie, uint in_len)
 	}
 
 _func_exit_;
-
-	return ielength;
+	
+	return ielength;	
 }
 
 void rtw_init_registrypriv_dev_network(	_adapter* adapter)
@@ -3358,29 +3358,29 @@ void rtw_init_registrypriv_dev_network(	_adapter* adapter)
 	struct eeprom_priv* peepriv = &adapter->eeprompriv;
 	WLAN_BSSID_EX    *pdev_network = &pregistrypriv->dev_network;
 	u8 *myhwaddr = myid(peepriv);
-
+	
 _func_enter_;
 
 	_rtw_memcpy(pdev_network->MacAddress, myhwaddr, ETH_ALEN);
 
 	_rtw_memcpy(&pdev_network->Ssid, &pregistrypriv->ssid, sizeof(NDIS_802_11_SSID));
-
+	
 	pdev_network->Configuration.Length=sizeof(NDIS_802_11_CONFIGURATION);
-	pdev_network->Configuration.BeaconPeriod = 100;
+	pdev_network->Configuration.BeaconPeriod = 100;	
 	pdev_network->Configuration.FHConfig.Length = 0;
 	pdev_network->Configuration.FHConfig.HopPattern = 0;
 	pdev_network->Configuration.FHConfig.HopSet = 0;
 	pdev_network->Configuration.FHConfig.DwellTime = 0;
-
-
-_func_exit_;
-
+	
+	
+_func_exit_;	
+	
 }
 
-void rtw_update_registrypriv_dev_network(_adapter* adapter)
+void rtw_update_registrypriv_dev_network(_adapter* adapter) 
 {
 	int sz=0;
-	struct registry_priv* pregistrypriv = &adapter->registrypriv;
+	struct registry_priv* pregistrypriv = &adapter->registrypriv;	
 	WLAN_BSSID_EX    *pdev_network = &pregistrypriv->dev_network;
 	struct	security_priv*	psecuritypriv = &adapter->securitypriv;
 	struct	wlan_network	*cur_network = &adapter->mlmepriv.cur_network;
@@ -3394,9 +3394,9 @@ void rtw_update_registrypriv_dev_network(_adapter* adapter)
 	pxmitpriv->vcs_type = pregistrypriv->vcs_type;
 	//pxmitpriv->rts_thresh = pregistrypriv->rts_thresh;
 	pxmitpriv->frag_len = pregistrypriv->frag_thresh;
-
+	
 	adapter->qospriv.qos_option = pregistrypriv->wmm_enable;
-#endif
+#endif	
 
 	pdev_network->Privacy = (psecuritypriv->dot11PrivacyAlgrthm > 0 ? 1 : 0) ; // adhoc no 802.1x
 
@@ -3406,7 +3406,7 @@ void rtw_update_registrypriv_dev_network(_adapter* adapter)
 	{
 		case WIRELESS_11B:
 			pdev_network->NetworkTypeInUse = (Ndis802_11DS);
-			break;
+			break;	
 		case WIRELESS_11G:
 		case WIRELESS_11BG:
 		case WIRELESS_11_24N:
@@ -3428,9 +3428,9 @@ void rtw_update_registrypriv_dev_network(_adapter* adapter)
 			// TODO
 			break;
 	}
-
+	
 	pdev_network->Configuration.DSConfig = (pregistrypriv->channel);
-	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("pregistrypriv->channel=%d, pdev_network->Configuration.DSConfig=0x%x\n", pregistrypriv->channel, pdev_network->Configuration.DSConfig));
+	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("pregistrypriv->channel=%d, pdev_network->Configuration.DSConfig=0x%x\n", pregistrypriv->channel, pdev_network->Configuration.DSConfig));	
 
 	if(cur_network->network.InfrastructureMode == Ndis802_11IBSS)
 		pdev_network->Configuration.ATIMWindow = (0);
@@ -3449,8 +3449,8 @@ void rtw_update_registrypriv_dev_network(_adapter* adapter)
 
 	//notes: translate IELength & Length after assign the Length to cmdsz in createbss_cmd();
 	//pdev_network->IELength = cpu_to_le32(sz);
-
-_func_exit_;
+		
+_func_exit_;	
 
 }
 
@@ -3459,22 +3459,22 @@ void rtw_get_encrypt_decrypt_from_registrypriv(_adapter* adapter)
 _func_enter_;
 
 
-_func_exit_;
-
+_func_exit_;	
+	
 }
 
-//the fucntion is at passive_level
+//the fucntion is at passive_level 
 void rtw_joinbss_reset(_adapter *padapter)
 {
 	u8	threshold;
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 
-#ifdef CONFIG_80211N_HT
+#ifdef CONFIG_80211N_HT	
 	struct ht_priv		*phtpriv = &pmlmepriv->htpriv;
 #endif
 
 	//todo: if you want to do something io/reg/hw setting before join_bss, please add code here
-
+	
 
 
 
@@ -3491,7 +3491,7 @@ void rtw_joinbss_reset(_adapter *padapter)
 	// TH=0 => means that validate usb rx aggregation, use init value.
 	if(phtpriv->ht_option)
 	{
-		if(padapter->registrypriv.wifi_spec==1)
+		if(padapter->registrypriv.wifi_spec==1)		
 			threshold = 1;
 		else
 			threshold = 0;
@@ -3504,14 +3504,14 @@ void rtw_joinbss_reset(_adapter *padapter)
 	}
 #endif
 
-#endif
+#endif	
 
 }
 
 
 #ifdef CONFIG_80211N_HT
 
-//the fucntion is >= passive_level
+//the fucntion is >= passive_level 
 unsigned int rtw_restructure_ht_ie(_adapter *padapter, u8 *in_ie, u8 *out_ie, uint in_len, uint *pout_len, u8 channel)
 {
 	u32 ielen, out_len;
@@ -3533,7 +3533,7 @@ unsigned int rtw_restructure_ht_ie(_adapter *padapter, u8 *in_ie, u8 *out_ie, ui
 		if(pqospriv->qos_option == 0)
 		{
 			out_len = *pout_len;
-			pframe = rtw_set_ie(out_ie+out_len, _VENDOR_SPECIFIC_IE_,
+			pframe = rtw_set_ie(out_ie+out_len, _VENDOR_SPECIFIC_IE_, 
 								_WMM_IE_Length_, WMM_IE, pout_len);
 
 			pqospriv->qos_option = 1;
@@ -3557,7 +3557,7 @@ unsigned int rtw_restructure_ht_ie(_adapter *padapter, u8 *in_ie, u8 *out_ie, ui
 
 		if ( cbw40_enable != 0 )
 			ht_capie.cap_info |= IEEE80211_HT_CAP_SUP_WIDTH | IEEE80211_HT_CAP_SGI_40;
-
+				
 
 
 		{
@@ -3569,44 +3569,44 @@ unsigned int rtw_restructure_ht_ie(_adapter *padapter, u8 *in_ie, u8 *out_ie, ui
 			//	ht_capie.cap_info = ht_capie.cap_info |IEEE80211_HT_CAP_MAX_AMSDU;
 			//}
 		}
-
+		
 		ht_capie.ampdu_params_info = (IEEE80211_HT_CAP_AMPDU_FACTOR&0x03);
 
 		if(padapter->securitypriv.dot11PrivacyAlgrthm == _AES_ )
 			ht_capie.ampdu_params_info |= (IEEE80211_HT_CAP_AMPDU_DENSITY&(0x07<<2));
 		else
-			ht_capie.ampdu_params_info |= (IEEE80211_HT_CAP_AMPDU_DENSITY&0x00);
-
+			ht_capie.ampdu_params_info |= (IEEE80211_HT_CAP_AMPDU_DENSITY&0x00);										
 
-		pframe = rtw_set_ie(out_ie+out_len, _HT_CAPABILITY_IE_,
+		
+		pframe = rtw_set_ie(out_ie+out_len, _HT_CAPABILITY_IE_, 
 							sizeof(struct rtw_ieee80211_ht_cap), (unsigned char*)&ht_capie, pout_len);
 
 
 		//_rtw_memcpy(out_ie+out_len, p, ielen+2);//gtest
 		//*pout_len = *pout_len + (ielen+2);
 
-
+							
 		phtpriv->ht_option = _TRUE;
 
 		p = rtw_get_ie(in_ie+12, _HT_ADD_INFO_IE_, &ielen, in_len-12);
 		if(p && (ielen==sizeof(struct ieee80211_ht_addt_info)))
 		{
-			out_len = *pout_len;
+			out_len = *pout_len;		
 			pframe = rtw_set_ie(out_ie+out_len, _HT_ADD_INFO_IE_, ielen, p+2 , pout_len);
 		}
 
 	}
-
+	
 	return (phtpriv->ht_option);
-
+	
 }
 
 //the fucntion is > passive_level (in critical_section)
 void rtw_update_ht_cap(_adapter *padapter, u8 *pie, uint ie_len, u8 channel)
-{
+{	
 	u8 *p, max_ampdu_sz;
-	int len;
-	//struct sta_info *bmc_sta, *psta;
+	int len;		
+	//struct sta_info *bmc_sta, *psta;	
 	struct rtw_ieee80211_ht_cap *pht_capie;
 	struct ieee80211_ht_addt_info *pht_addtinfo;
 	//struct recv_reorder_ctrl *preorder_ctrl;
@@ -3616,7 +3616,7 @@ void rtw_update_ht_cap(_adapter *padapter, u8 *pie, uint ie_len, u8 channel)
 	struct registry_priv *pregistrypriv = &padapter->registrypriv;
 	//struct wlan_network *pcur_network = &(pmlmepriv->cur_network);;
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
-	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);	
 	u8 cbw40_enable=0;
 
 	if(!phtpriv->ht_option)
@@ -3645,25 +3645,25 @@ void rtw_update_ht_cap(_adapter *padapter, u8 *pie, uint ie_len, u8 channel)
 		phtpriv->ampdu_enable = _TRUE;
 	}
 
-
-	//check Max Rx A-MPDU Size
+	
+	//check Max Rx A-MPDU Size 
 	len = 0;
 	p = rtw_get_ie(pie+sizeof (NDIS_802_11_FIXED_IEs), _HT_CAPABILITY_IE_, &len, ie_len-sizeof (NDIS_802_11_FIXED_IEs));
-	if(p && len>0)
+	if(p && len>0)	
 	{
 		pht_capie = (struct rtw_ieee80211_ht_cap *)(p+2);
 		max_ampdu_sz = (pht_capie->ampdu_params_info & IEEE80211_HT_CAP_AMPDU_FACTOR);
 		max_ampdu_sz = 1 << (max_ampdu_sz+3); // max_ampdu_sz (kbytes);
-
+		
 		//DBG_871X("rtw_update_ht_cap(): max_ampdu_sz=%d\n", max_ampdu_sz);
 		phtpriv->rx_ampdu_maxlen = max_ampdu_sz;
-
+		
 	}
 
 
 	len=0;
 	p = rtw_get_ie(pie+sizeof (NDIS_802_11_FIXED_IEs), _HT_ADD_INFO_IE_, &len, ie_len-sizeof (NDIS_802_11_FIXED_IEs));
-	if(p && len>0)
+	if(p && len>0)	
 	{
 		pht_addtinfo = (struct ieee80211_ht_addt_info *)(p+2);
 		//todo:
@@ -3681,7 +3681,7 @@ void rtw_update_ht_cap(_adapter *padapter, u8 *pie, uint ie_len, u8 channel)
 
 	//update cur_bwmode & cur_ch_offset
 	if ((cbw40_enable) &&
-		(pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info & BIT(1)) &&
+		(pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info & BIT(1)) && 
 		(pmlmeinfo->HT_info.infos[0] & BIT(2)))
 	{
 		int i;
@@ -3726,15 +3726,15 @@ void rtw_update_ht_cap(_adapter *padapter, u8 *pie, uint ie_len, u8 channel)
 			case HT_EXTCHNL_OFFSET_UPPER:
 				pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;
 				break;
-
+			
 			case HT_EXTCHNL_OFFSET_LOWER:
 				pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER;
 				break;
-
+				
 			default:
 				pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
 				break;
-		}
+		}		
 	}
 
 	//
@@ -3757,8 +3757,8 @@ void rtw_update_ht_cap(_adapter *padapter, u8 *pie, uint ie_len, u8 channel)
 	//
 	pmlmeinfo->HT_protection = pmlmeinfo->HT_info.infos[1] & 0x3;
 
-
-
+	
+	
 #if 0 //move to rtw_update_sta_info_client()
 	//for A-MPDU Rx reordering buffer control for bmc_sta & sta_info
 	//if A-MPDU Rx is enabled, reseting  rx_ordering_ctrl wstart_b(indicate_seq) to default value=0xffff
@@ -3798,7 +3798,7 @@ void rtw_update_ht_cap(_adapter *padapter, u8 *pie, uint ie_len, u8 channel)
 			preorder_ctrl->wsize_b = 64;//max_ampdu_sz;//ex. 32(kbytes) -> wsize_b=32
 		}
 	}
-#endif
+#endif	
 
 }
 
@@ -3813,7 +3813,7 @@ void rtw_issue_addbareq_cmd(_adapter *padapter, struct xmit_frame *pxmitframe)
 
 	if(bmcst || (padapter->mlmepriv.LinkDetectInfo.bTxBusyTraffic == _FALSE))
 		return;
-
+	
 	priority = pattrib->priority;
 
 	if (pattrib->psta)
@@ -3822,8 +3822,8 @@ void rtw_issue_addbareq_cmd(_adapter *padapter, struct xmit_frame *pxmitframe)
 	{
 		DBG_871X("%s, call rtw_get_stainfo()\n", __func__);
 		psta = rtw_get_stainfo(&padapter->stapriv, pattrib->ra);
-	}
-
+	}	
+	
 	if(psta==NULL)
 	{
 		DBG_871X("%s, psta==NUL\n", __func__);
@@ -3834,12 +3834,12 @@ void rtw_issue_addbareq_cmd(_adapter *padapter, struct xmit_frame *pxmitframe)
 	{
 		DBG_871X("%s, psta->state(0x%x) != _FW_LINKED\n", __func__, psta->state);
 		return;
-	}
-
+	}	
 
+	
 	phtpriv = &psta->htpriv;
 
-	if((phtpriv->ht_option==_TRUE) && (phtpriv->ampdu_enable==_TRUE))
+	if((phtpriv->ht_option==_TRUE) && (phtpriv->ampdu_enable==_TRUE)) 
 	{
 		issued = (phtpriv->agg_enable_bitmap>>priority)&0x1;
 		issued |= (phtpriv->candidate_tid_bitmap>>priority)&0x1;
@@ -3851,7 +3851,7 @@ void rtw_issue_addbareq_cmd(_adapter *padapter, struct xmit_frame *pxmitframe)
 			rtw_addbareq_cmd(padapter,(u8) priority, pattrib->ra);
 		}
 	}
-
+	
 }
 
 #endif
@@ -3889,7 +3889,7 @@ void _rtw_roaming(_adapter *padapter, struct wlan_network *tgt_network)
 		pnetwork = tgt_network;
 	else
 		pnetwork = &pmlmepriv->cur_network;
-
+	
 	if(0 < rtw_to_roaming(padapter)) {
 		DBG_871X("roaming from %s("MAC_FMT"), length:%d\n",
 				pnetwork->network.Ssid.Ssid, MAC_ARG(pnetwork->network.MacAddress),
@@ -3904,7 +3904,7 @@ void _rtw_roaming(_adapter *padapter, struct wlan_network *tgt_network)
 			} else {
 				DBG_871X("roaming do_join return %d\n", do_join_r);
 				pmlmepriv->to_roaming--;
-
+				
 				if(0< rtw_to_roaming(padapter)) {
 					continue;
 				} else {
@@ -3915,15 +3915,15 @@ void _rtw_roaming(_adapter *padapter, struct wlan_network *tgt_network)
 			}
 		}
 	}
-
+	
 }
 #endif
 
 #ifdef CONFIG_CONCURRENT_MODE
 sint rtw_buddy_adapter_up(_adapter *padapter)
-{
+{	
 	sint res = _FALSE;
-
+	
 	if(padapter == NULL)
 		return res;
 
@@ -3934,33 +3934,34 @@ sint rtw_buddy_adapter_up(_adapter *padapter)
 	}
 	else if( (padapter->pbuddy_adapter->bDriverStopped) || (padapter->pbuddy_adapter->bSurpriseRemoved) ||
 		(padapter->pbuddy_adapter->bup == _FALSE) || (padapter->pbuddy_adapter->hw_init_completed == _FALSE))
-	{
+	{		
 		res = _FALSE;
 	}
 	else
 	{
 		res = _TRUE;
-	}
+	}	
 
-	return res;
+	return res;	
 
 }
 
 sint check_buddy_fwstate(_adapter *padapter, sint state)
 {
 	if(padapter == NULL)
-		return _FALSE;
-
+		return _FALSE;	
+	
 	if(padapter->pbuddy_adapter == NULL)
-		return _FALSE;
-
-	if ((state == WIFI_FW_NULL_STATE) &&
+		return _FALSE;	
+		
+	if ((state == WIFI_FW_NULL_STATE) && 
 		(padapter->pbuddy_adapter->mlmepriv.fw_state == WIFI_FW_NULL_STATE))
 		return _TRUE;
-
+	
 	if (padapter->pbuddy_adapter->mlmepriv.fw_state & state)
 		return _TRUE;
 
 	return _FALSE;
 }
 #endif //CONFIG_CONCURRENT_MODE
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_mlme_ext.c b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_mlme_ext.c
old mode 100644
new mode 100755
index 6ea5261..d29a20c
--- a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_mlme_ext.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_mlme_ext.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -89,8 +89,8 @@ struct action_handler OnAction_tbl[]={
 	//add for CONFIG_IEEE80211W
 	{RTW_WLAN_CATEGORY_UNPROTECTED_WNM, "ACTION_UNPROTECTED_WNM", &DoReserved},
 	{RTW_WLAN_CATEGORY_SELF_PROTECTED, "ACTION_SELF_PROTECTED", &DoReserved},
-	{RTW_WLAN_CATEGORY_WMM, "ACTION_WMM", &OnAction_wmm},
-	{RTW_WLAN_CATEGORY_P2P, "ACTION_P2P", &OnAction_p2p},
+	{RTW_WLAN_CATEGORY_WMM, "ACTION_WMM", &OnAction_wmm},	
+	{RTW_WLAN_CATEGORY_P2P, "ACTION_P2P", &OnAction_p2p},	
 };
 
 
@@ -261,7 +261,7 @@ struct action_handler OnAction_tbl[]={
  * Search the @param ch in given @param ch_set
  * @ch_set: the given channel set
  * @ch: the given channel number
- *
+ * 
  * return the index of channel_num in channel_set, -1 if not found
  */
 int rtw_ch_set_search_ch(RT_CHANNEL_INFO *ch_set, const u32 ch)
@@ -271,7 +271,7 @@ int rtw_ch_set_search_ch(RT_CHANNEL_INFO *ch_set, const u32 ch)
 		if(ch == ch_set[i].ChannelNum)
 			break;
 	}
-
+	
 	if(i >= ch_set[i].ChannelNum)
 		return -1;
 	return i;
@@ -281,7 +281,7 @@ int rtw_ch_set_search_ch(RT_CHANNEL_INFO *ch_set, const u32 ch)
  * Check the @param ch is fit with setband setting of @param adapter
  * @adapter: the given adapter
  * @ch: the given channel number
- *
+ * 
  * return _TRUE when check valid, _FALSE not valid
  */
 bool rtw_mlme_band_check(_adapter *adapter, const u32 ch)
@@ -429,7 +429,7 @@ static void init_channel_list(_adapter *padapter, RT_CHANNEL_INFO *channel_set,
 			if ((0 == (padapter->registrypriv.cbw40_enable & BIT(1))) &&
 				((BW40MINUS == o->bw) || (BW40PLUS == o->bw)))
 				continue;
-
+				
 			if (reg == NULL) {
 				reg = &channel_list->reg_class[cla];
 				cla++;
@@ -487,7 +487,7 @@ static u8 init_channel_set(_adapter* padapter, u8 ChannelPlan, RT_CHANNEL_INFO *
 				if(channel_set[chanset_size].ChannelNum >= 1 && channel_set[chanset_size].ChannelNum <= 11)
 					channel_set[chanset_size].ScanType = SCAN_ACTIVE;
 				else if((channel_set[chanset_size].ChannelNum  >= 12 && channel_set[chanset_size].ChannelNum  <= 14))
-					channel_set[chanset_size].ScanType  = SCAN_PASSIVE;
+					channel_set[chanset_size].ScanType  = SCAN_PASSIVE;			
 			}
 			else if(RT_CHANNEL_DOMAIN_WORLD_WIDE_13 == ChannelPlan ||
 				RT_CHANNEL_DOMAIN_WORLD_WIDE_5G == ChannelPlan ||
@@ -513,7 +513,7 @@ static u8 init_channel_set(_adapter* padapter, u8 ChannelPlan, RT_CHANNEL_INFO *
 		{
 #ifdef CONFIG_DFS
 			channel_set[chanset_size].ChannelNum = RTW_ChannelPlan5G[Index5G].Channel[index];
-			if ( channel_set[chanset_size].ChannelNum <= 48
+			if ( channel_set[chanset_size].ChannelNum <= 48 
 				|| channel_set[chanset_size].ChannelNum >= 149 )
 			{
 				if(RT_CHANNEL_DOMAIN_WORLD_WIDE_5G == ChannelPlan)//passive scan for all 5G channels
@@ -527,7 +527,7 @@ static u8 init_channel_set(_adapter* padapter, u8 ChannelPlan, RT_CHANNEL_INFO *
 			}
 			chanset_size++;
 #else /* CONFIG_DFS */
-			if ( RTW_ChannelPlan5G[Index5G].Channel[index] <= 48
+			if ( RTW_ChannelPlan5G[Index5G].Channel[index] <= 48 
 				|| RTW_ChannelPlan5G[Index5G].Channel[index] >= 149 ) {
 				channel_set[chanset_size].ChannelNum = RTW_ChannelPlan5G[Index5G].Channel[index];
 				if(RT_CHANNEL_DOMAIN_WORLD_WIDE_5G == ChannelPlan)//passive scan for all 5G channels
@@ -561,21 +561,21 @@ int	init_mlme_ext_priv(_adapter* padapter)
 
 	init_mlme_ext_priv_value(padapter);
 	pmlmeinfo->bAcceptAddbaReq = pregistrypriv->bAcceptAddbaReq;
-
+	
 	init_mlme_ext_timer(padapter);
 
 #ifdef CONFIG_AP_MODE
-	init_mlme_ap_info(padapter);
+	init_mlme_ap_info(padapter);	
 #endif
 
 	pmlmeext->max_chan_nums = init_channel_set(padapter, pmlmepriv->ChannelPlan,pmlmeext->channel_set);
 	init_channel_list(padapter, pmlmeext->channel_set, pmlmeext->max_chan_nums, &pmlmeext->channel_list);
-
+	
 	pmlmeext->chan_scan_time = SURVEY_TO;
 	pmlmeext->mlmeext_init = _TRUE;
 
 
-#ifdef CONFIG_ACTIVE_KEEP_ALIVE_CHECK
+#ifdef CONFIG_ACTIVE_KEEP_ALIVE_CHECK	
 	pmlmeext->active_keep_alive_check = _TRUE;
 #endif
 
@@ -599,46 +599,46 @@ void free_mlme_ext_priv (struct mlme_ext_priv *pmlmeext)
 }
 
 static u8 cmp_pkt_chnl_diff(_adapter *padapter,u8* pframe,uint packet_len)
-{	// if the channel is same, return 0. else return channel differential
+{	// if the channel is same, return 0. else return channel differential	
 	uint len;
-	u8 channel;
-	u8 *p;
-	p = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + _BEACON_IE_OFFSET_, _DSSET_IE_, &len, packet_len - _BEACON_IE_OFFSET_);
-	if (p)
-	{
-		channel = *(p + 2);
-		if(padapter->mlmeextpriv.cur_channel >= channel)
-		{
-			return (padapter->mlmeextpriv.cur_channel - channel);
-		}
-		else
-		{
-			return (channel-padapter->mlmeextpriv.cur_channel);
-		}
-	}
+	u8 channel;	
+	u8 *p;		
+	p = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + _BEACON_IE_OFFSET_, _DSSET_IE_, &len, packet_len - _BEACON_IE_OFFSET_);	
+	if (p)	
+	{	
+		channel = *(p + 2);		
+		if(padapter->mlmeextpriv.cur_channel >= channel)		
+		{			
+			return (padapter->mlmeextpriv.cur_channel - channel);		
+		}		
+		else		
+		{			
+			return (channel-padapter->mlmeextpriv.cur_channel);		
+		}	
+	}	
 	else
-	{
-		return 0;
+	{		
+		return 0;	
 	}
 }
 
 static void _mgt_dispatcher(_adapter *padapter, struct mlme_handler *ptable, union recv_frame *precv_frame)
 {
 	u8 bc_addr[ETH_ALEN] = {0xff,0xff,0xff,0xff,0xff,0xff};
-	u8 *pframe = precv_frame->u.hdr.rx_data;
+	u8 *pframe = precv_frame->u.hdr.rx_data; 
 
 	  if(ptable->func)
         {
-	 //receive the frames that ra(a1) is my address or ra(a1) is bc address.
+       	 //receive the frames that ra(a1) is my address or ra(a1) is bc address.
 		if (!_rtw_memcmp(GetAddr1Ptr(pframe), myid(&padapter->eeprompriv), ETH_ALEN) &&
-			!_rtw_memcmp(GetAddr1Ptr(pframe), bc_addr, ETH_ALEN))
+			!_rtw_memcmp(GetAddr1Ptr(pframe), bc_addr, ETH_ALEN)) 
 		{
 			return;
 		}
-
+		
 		ptable->func(padapter, precv_frame);
         }
-
+	
 }
 
 void mgt_dispatcher(_adapter *padapter, union recv_frame *precv_frame)
@@ -728,7 +728,7 @@ void mgt_dispatcher(_adapter *padapter, union recv_frame *precv_frame)
 #endif
 
 #ifdef CONFIG_AP_MODE
-	switch (GetFrameSubType(pframe))
+	switch (GetFrameSubType(pframe)) 
 	{
 		case WIFI_AUTH:
 			if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
@@ -738,17 +738,17 @@ void mgt_dispatcher(_adapter *padapter, union recv_frame *precv_frame)
 			//pass through
 		case WIFI_ASSOCREQ:
 		case WIFI_REASSOCREQ:
-			_mgt_dispatcher(padapter, ptable, precv_frame);
-#ifdef CONFIG_HOSTAPD_MLME
+			_mgt_dispatcher(padapter, ptable, precv_frame);	
+#ifdef CONFIG_HOSTAPD_MLME				
 			if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
 				rtw_hostapd_mlme_rx(padapter, precv_frame);
-#endif
+#endif			
 			break;
 		case WIFI_PROBEREQ:
 			if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
 			{
-#ifdef CONFIG_HOSTAPD_MLME
-				rtw_hostapd_mlme_rx(padapter, precv_frame);
+#ifdef CONFIG_HOSTAPD_MLME		
+				rtw_hostapd_mlme_rx(padapter, precv_frame);		
 #else
 				_mgt_dispatcher(padapter, ptable, precv_frame);
 #endif
@@ -756,23 +756,23 @@ void mgt_dispatcher(_adapter *padapter, union recv_frame *precv_frame)
 			else
 				_mgt_dispatcher(padapter, ptable, precv_frame);
 			break;
-		case WIFI_BEACON:
+		case WIFI_BEACON:			
 			_mgt_dispatcher(padapter, ptable, precv_frame);
 			break;
 		case WIFI_ACTION:
 			//if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
-			_mgt_dispatcher(padapter, ptable, precv_frame);
+			_mgt_dispatcher(padapter, ptable, precv_frame);		
 			break;
 		default:
-			_mgt_dispatcher(padapter, ptable, precv_frame);
+			_mgt_dispatcher(padapter, ptable, precv_frame);	
 			if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
-				rtw_hostapd_mlme_rx(padapter, precv_frame);
+				rtw_hostapd_mlme_rx(padapter, precv_frame);			
 			break;
 	}
 #else
 
-	_mgt_dispatcher(padapter, ptable, precv_frame);
-
+	_mgt_dispatcher(padapter, ptable, precv_frame);	
+	
 #endif
 
 }
@@ -810,7 +810,7 @@ u32 p2p_listen_state_process(_adapter *padapter, unsigned char *da)
 
 	if (response == _TRUE)
 		issue_probersp_p2p( padapter, da);
-
+	
 	return _SUCCESS;
 }
 #endif //CONFIG_P2P
@@ -838,9 +838,9 @@ unsigned int OnProbeReq(_adapter *padapter, union recv_frame *precv_frame)
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 	struct rx_pkt_attrib	*pattrib = &precv_frame->u.hdr.attrib;
 	u8 wifi_test_chk_rate = 1;
-
-	if (	!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) &&
-		!rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE) &&
+	
+	if (	!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) && 
+		!rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE) && 
 		!rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT) &&
 		!rtw_p2p_chk_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH) &&
 		!rtw_p2p_chk_state(pwdinfo, P2P_STATE_SCAN)
@@ -870,7 +870,7 @@ unsigned int OnProbeReq(_adapter *padapter, union recv_frame *precv_frame)
 				{
 					p2p_listen_state_process( padapter,  get_sa(pframe));
 
-					return _SUCCESS;
+					return _SUCCESS;	
 				}
 
 				if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
@@ -889,7 +889,7 @@ unsigned int OnProbeReq(_adapter *padapter, union recv_frame *precv_frame)
 		return _SUCCESS;
 	}
 
-	if(check_fwstate(pmlmepriv, _FW_LINKED) == _FALSE &&
+	if(check_fwstate(pmlmepriv, _FW_LINKED) == _FALSE && 
 		check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE|WIFI_AP_STATE)==_FALSE)
 	{
 		return _SUCCESS;
@@ -978,7 +978,7 @@ unsigned int OnProbeReq(_adapter *padapter, union recv_frame *precv_frame)
 					DBG_871X("allocate new AID = (%d)\n", psta->aid);
 				}
 			}
-
+			
 			psta->qos_option = 1;
 			psta->htpriv.ht_option = _TRUE;
 			psta->ieee8021x_blocked = _FALSE;
@@ -1021,13 +1021,13 @@ unsigned int OnProbeReq(_adapter *padapter, union recv_frame *precv_frame)
 		//don't process probe req
 		return _SUCCESS;
 	}
-#endif
+#endif		
 
 	p = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + _PROBEREQ_IE_OFFSET_, _SSID_IE_, (int *)&ielen,
 			len - WLAN_HDR_A3_LEN - _PROBEREQ_IE_OFFSET_);
 
 
-	//check (wildcard) SSID
+	//check (wildcard) SSID 
 	if (p != NULL)
 	{
 		if(is_valid_p2p_probereq == _TRUE)
@@ -1044,11 +1044,11 @@ unsigned int OnProbeReq(_adapter *padapter, union recv_frame *precv_frame)
 
 _issue_probersp:
 
-		if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE &&
+		if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE && 
 			pmlmepriv->cur_network.join_res == _TRUE)
 		{
 			//DBG_871X("+issue_probersp during ap mode\n");
-			issue_probersp(padapter, get_sa(pframe), is_valid_p2p_probereq);
+			issue_probersp(padapter, get_sa(pframe), is_valid_p2p_probereq);		
 		}
 
 	}
@@ -1080,7 +1080,7 @@ unsigned int OnProbeRsp(_adapter *padapter, union recv_frame *precv_frame)
 				{
 					pwdinfo->tx_prov_disc_info.benable = _FALSE;
 					issue_p2p_provision_request( padapter,
-												pwdinfo->tx_prov_disc_info.ssid.Ssid,
+												pwdinfo->tx_prov_disc_info.ssid.Ssid, 
 												pwdinfo->tx_prov_disc_info.ssid.SsidLength,
 												pwdinfo->tx_prov_disc_info.peerDevAddr );
 				}
@@ -1088,11 +1088,11 @@ unsigned int OnProbeRsp(_adapter *padapter, union recv_frame *precv_frame)
 				{
 					pwdinfo->tx_prov_disc_info.benable = _FALSE;
 					issue_p2p_provision_request( padapter,
-												NULL,
+												NULL, 
 												0,
 												pwdinfo->tx_prov_disc_info.peerDevAddr );
 				}
-			}
+			}		
 		}
 		return _SUCCESS;
 	}
@@ -1125,9 +1125,9 @@ unsigned int OnProbeRsp(_adapter *padapter, union recv_frame *precv_frame)
 
 	if (pmlmeext->sitesurvey_res.state == SCAN_PROCESS)
 	{
-		report_survey_event(padapter, precv_frame);
+		report_survey_event(padapter, precv_frame);	
 #ifdef CONFIG_CONCURRENT_MODE
-		report_survey_event(padapter->pbuddy_adapter, precv_frame);
+		report_survey_event(padapter->pbuddy_adapter, precv_frame);	
 #endif
 #ifdef CONFIG_DUALMAC_CONCURRENT
 		dc_report_survey_event(padapter, precv_frame);
@@ -1147,9 +1147,9 @@ unsigned int OnProbeRsp(_adapter *padapter, union recv_frame *precv_frame)
 		}
 	}
 	#endif
-
+	
 	return _SUCCESS;
-
+	
 }
 
 unsigned int OnBeacon(_adapter *padapter, union recv_frame *precv_frame)
@@ -1170,9 +1170,9 @@ unsigned int OnBeacon(_adapter *padapter, union recv_frame *precv_frame)
 	{
 		if ((*(p + 1 + ielen) == 0x2D) && (*(p + 2 + ielen) != 0x2D))
 		{
-			/* Invalid value 0x2D is detected in Extended Supported Rates (ESR) IE. Try to fix the IE length to avoid failed Beacon parsing. */
-			DBG_871X("[WIFIDBG] Error in ESR IE is detected in Beacon of BSSID:"MAC_FMT". Fix the length of ESR IE to avoid failed Beacon parsing.\n", MAC_ARG(GetAddr3Ptr(pframe)));
-			*(p + 1) = ielen - 1;
+			/* Invalid value 0x2D is detected in Extended Supported Rates (ESR) IE. Try to fix the IE length to avoid failed Beacon parsing. */	
+		       	DBG_871X("[WIFIDBG] Error in ESR IE is detected in Beacon of BSSID:"MAC_FMT". Fix the length of ESR IE to avoid failed Beacon parsing.\n", MAC_ARG(GetAddr3Ptr(pframe)));
+		       	*(p + 1) = ielen - 1;
 		}
 	}
 #endif
@@ -1181,7 +1181,7 @@ unsigned int OnBeacon(_adapter *padapter, union recv_frame *precv_frame)
 	{
 		report_survey_event(padapter, precv_frame);
 #ifdef CONFIG_CONCURRENT_MODE
-		report_survey_event(padapter->pbuddy_adapter, precv_frame);
+		report_survey_event(padapter->pbuddy_adapter, precv_frame);	
 #endif
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
@@ -1196,7 +1196,7 @@ unsigned int OnBeacon(_adapter *padapter, union recv_frame *precv_frame)
 		if (pmlmeinfo->state & WIFI_FW_AUTH_NULL)
 		{
 			//check the vendor of the assoc AP
-			pmlmeinfo->assoc_AP_vendor = check_assoc_AP(pframe+sizeof(struct rtw_ieee80211_hdr_3addr), len-sizeof(struct rtw_ieee80211_hdr_3addr));
+			pmlmeinfo->assoc_AP_vendor = check_assoc_AP(pframe+sizeof(struct rtw_ieee80211_hdr_3addr), len-sizeof(struct rtw_ieee80211_hdr_3addr));				
 #ifdef CONFIG_P2P_PS
 			// do P2P PS Before link ? , ToDo
 			//process_p2p_ps_ie(padapter, (pframe + WLAN_HDR_A3_LEN), (len - WLAN_HDR_A3_LEN));
@@ -1215,16 +1215,16 @@ unsigned int OnBeacon(_adapter *padapter, union recv_frame *precv_frame)
 		{
 			if ((psta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe))) != NULL)
 			{
-				#ifdef CONFIG_PATCH_JOIN_WRONG_CHANNEL
+				#ifdef CONFIG_PATCH_JOIN_WRONG_CHANNEL        
 				//Merge from 8712 FW code
-				if (cmp_pkt_chnl_diff(padapter,pframe,len) != 0)
-				{            // join wrong channel, deauth and reconnect
+				if (cmp_pkt_chnl_diff(padapter,pframe,len) != 0)        
+				{            // join wrong channel, deauth and reconnect           
 					issue_deauth(padapter, (&(pmlmeinfo->network))->MacAddress, WLAN_REASON_DEAUTH_LEAVING);
 
-					report_del_sta_event(padapter,(&(pmlmeinfo->network))->MacAddress, WLAN_REASON_JOIN_WRONG_CHANNEL);
-					pmlmeinfo->state &= (~WIFI_FW_ASSOC_SUCCESS);
+					report_del_sta_event(padapter,(&(pmlmeinfo->network))->MacAddress, WLAN_REASON_JOIN_WRONG_CHANNEL);    		
+					pmlmeinfo->state &= (~WIFI_FW_ASSOC_SUCCESS);    		
 					return _SUCCESS;
-				}
+				}        
 				#endif //CONFIG_PATCH_JOIN_WRONG_CHANNEL
 
 				//update WMM, ERP in the beacon
@@ -1234,7 +1234,7 @@ unsigned int OnBeacon(_adapter *padapter, union recv_frame *precv_frame)
 					//DBG_871X("update_bcn_info\n");
 					update_beacon_info(padapter, pframe, len, psta);
 				}
-
+				
 #ifdef CONFIG_DFS
 				process_csa_ie(padapter, pframe, len);	//channel switch announcement
 #endif //CONFIG_DFS
@@ -1281,7 +1281,7 @@ unsigned int OnBeacon(_adapter *padapter, union recv_frame *precv_frame)
 				}
 
 				//update TSF Value
-				update_TSF(pmlmeext, pframe, len);
+				update_TSF(pmlmeext, pframe, len);			
 
 				//report sta add event
 				report_add_sta_event(padapter, GetAddr2Ptr(pframe), cam_idx);
@@ -1299,21 +1299,21 @@ unsigned int OnAuth(_adapter *padapter, union recv_frame *precv_frame)
 {
 #ifdef CONFIG_AP_MODE
 	_irqL irqL;
-	unsigned int	auth_mode, seq, ie_len;
-	unsigned char	*sa, *p;
+	unsigned int	auth_mode, seq, ie_len;	
+	unsigned char	*sa, *p;	
 	u16	algorithm;
 	int	status;
-	static struct sta_info stat;
-	struct	sta_info	*pstat=NULL;
+	static struct sta_info stat;	
+	struct	sta_info	*pstat=NULL;	
 	struct	sta_priv *pstapriv = &padapter->stapriv;
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-	u8 *pframe = precv_frame->u.hdr.rx_data;
+	u8 *pframe = precv_frame->u.hdr.rx_data; 
 	uint len = precv_frame->u.hdr.len;
 
-
-#ifdef CONFIG_CONCURRENT_MODE
+	
+#ifdef CONFIG_CONCURRENT_MODE	
 	if(((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE) &&
 		check_buddy_fwstate(padapter, _FW_UNDER_LINKING|_FW_UNDER_SURVEY))
 	{
@@ -1326,15 +1326,15 @@ unsigned int OnAuth(_adapter *padapter, union recv_frame *precv_frame)
 		return _FAIL;
 
 	DBG_871X("+OnAuth\n");
-
+	
 	sa = GetAddr2Ptr(pframe);
-
+	
 	auth_mode = psecuritypriv->dot11AuthAlgrthm;
 	seq = cpu_to_le16(*(u16*)((SIZE_PTR)pframe + WLAN_HDR_A3_LEN + 2));
 	algorithm = cpu_to_le16(*(u16*)((SIZE_PTR)pframe + WLAN_HDR_A3_LEN));
 
 	if (GetPrivacy(pframe))
-	{
+	{	
 #if 0 //TODO: SW rtw_wep_decrypt
 		if (SWCRYPTO)
 		{
@@ -1364,16 +1364,16 @@ unsigned int OnAuth(_adapter *padapter, union recv_frame *precv_frame)
 
 	if ((algorithm > 0 && auth_mode == 0) ||	// rx a shared-key auth but shared not enabled
 		(algorithm == 0 && auth_mode == 1) )	// rx a open-system auth but shared-key is enabled
-	{
+	{		
 		DBG_871X("auth rejected due to bad alg [alg=%d, auth_mib=%d] %02X%02X%02X%02X%02X%02X\n",
 			algorithm, auth_mode, sa[0], sa[1], sa[2], sa[3], sa[4], sa[5]);
-
+		
 		status = _STATS_NO_SUPP_ALG_;
-
+		
 		goto auth_fail;
 	}
-
-#if 0 //ACL control
+	
+#if 0 //ACL control	
 	phead = &priv->wlan_acl_list;
 	plist = phead->next;
 	//check sa
@@ -1407,7 +1407,7 @@ unsigned int OnAuth(_adapter *padapter, union recv_frame *precv_frame)
 	{
 		status = _STATS_UNABLE_HANDLE_STA_;
 		goto auth_fail;
-	}
+	}	
 #endif
 
 	pstat = rtw_get_stainfo(pstapriv, sa);
@@ -1422,18 +1422,18 @@ unsigned int OnAuth(_adapter *padapter, union recv_frame *precv_frame)
 			status = _STATS_UNABLE_HANDLE_STA_;
 			goto auth_fail;
 		}
-
+		
 		pstat->state = WIFI_FW_AUTH_NULL;
 		pstat->auth_seq = 0;
-
+		
 		//pstat->flags = 0;
 		//pstat->capability = 0;
 	}
 	else
-	{
+	{		
 		_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 		if(rtw_is_list_empty(&pstat->asoc_list)==_FALSE)
-		{
+		{			
 			rtw_list_delete(&pstat->asoc_list);
 			pstapriv->asoc_list_cnt--;
 			if (pstat->expire_to > 0)
@@ -1442,18 +1442,18 @@ unsigned int OnAuth(_adapter *padapter, union recv_frame *precv_frame)
 			}
 		}
 		_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
-
+		
 		if (seq==1) {
-			//TODO: STA re_auth and auth timeout
+			//TODO: STA re_auth and auth timeout 
 		}
 	}
 
 	_enter_critical_bh(&pstapriv->auth_list_lock, &irqL);
 	if (rtw_is_list_empty(&pstat->auth_list))
-	{
+	{		
 		rtw_list_insert_tail(&pstat->auth_list, &pstapriv->auth_list);
 		pstapriv->auth_list_cnt++;
-	}
+	}	
 	_exit_critical_bh(&pstapriv->auth_list_lock, &irqL);
 
 	if (pstat->auth_seq == 0)
@@ -1489,9 +1489,9 @@ unsigned int OnAuth(_adapter *padapter, union recv_frame *precv_frame)
 		if (seq == 1)
 		{
 			//prepare for the challenging txt...
-
+			
 			//get_random_bytes((void *)pstat->chg_txt, 128);//TODO:
-
+			
 			pstat->state &= ~WIFI_FW_AUTH_NULL;
 			pstat->state |= WIFI_FW_AUTH_STATE;
 			pstat->authalg = algorithm;
@@ -1501,7 +1501,7 @@ unsigned int OnAuth(_adapter *padapter, union recv_frame *precv_frame)
 		{
 			//checking for challenging txt...
 			DBG_871X("checking for challenging txt...\n");
-
+			
 			p = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + 4 + _AUTH_IE_OFFSET_ , _CHLGETXT_IE_, (int *)&ie_len,
 					len - WLAN_HDR_A3_LEN - _AUTH_IE_OFFSET_ - 4);
 
@@ -1511,7 +1511,7 @@ unsigned int OnAuth(_adapter *padapter, union recv_frame *precv_frame)
 				status = _STATS_CHALLENGE_FAIL_;
 				goto auth_fail;
 			}
-
+			
 			if (_rtw_memcmp((void *)(p + 2), pstat->chg_txt, 128))
 			{
 				pstat->state &= (~WIFI_FW_AUTH_STATE);
@@ -1537,8 +1537,8 @@ unsigned int OnAuth(_adapter *padapter, union recv_frame *precv_frame)
 
 
 	// Now, we are going to issue_auth...
-	pstat->auth_seq = seq + 1;
-
+	pstat->auth_seq = seq + 1;	
+	
 #ifdef CONFIG_NATIVEAP_MLME
 	issue_auth(padapter, pstat, (unsigned short)(_STATS_SUCCESSFUL_));
 #endif
@@ -1546,21 +1546,21 @@ unsigned int OnAuth(_adapter *padapter, union recv_frame *precv_frame)
 	if (pstat->state & WIFI_FW_AUTH_SUCCESS)
 		pstat->auth_seq = 0;
 
-
+		
 	return _SUCCESS;
 
 auth_fail:
 
 	if(pstat)
 		rtw_free_stainfo(padapter , pstat);
-
+	
 	pstat = &stat;
 	_rtw_memset((char *)pstat, '\0', sizeof(stat));
 	pstat->auth_seq = 2;
-	_rtw_memcpy(pstat->hwaddr, sa, 6);
-
+	_rtw_memcpy(pstat->hwaddr, sa, 6);	
+	
 #ifdef CONFIG_NATIVEAP_MLME
-	issue_auth(padapter, pstat, (unsigned short)status);
+	issue_auth(padapter, pstat, (unsigned short)status);	
 #endif
 
 #endif
@@ -1604,7 +1604,7 @@ unsigned int OnAuthClient(_adapter *padapter, union recv_frame *precv_frame)
 				pmlmeinfo->auth_algo = dot11AuthAlgrthm_Shared;
 			//pmlmeinfo->reauth_count = 0;
 		}
-
+		
 		set_link_timer(pmlmeext, 1);
 		goto authclnt_fail;
 	}
@@ -1673,7 +1673,7 @@ unsigned int OnAssocReq(_adapter *padapter, union recv_frame *precv_frame)
 #ifdef CONFIG_AP_MODE
 	_irqL irqL;
 	u16 capab_info, listen_interval;
-	struct rtw_ieee802_11_elems elems;
+	struct rtw_ieee802_11_elems elems;	
 	struct sta_info	*pstat;
 	unsigned char		reassoc, *p, *pos, *wpa_ie;
 	unsigned char WMM_IE[] = {0x00, 0x50, 0xf2, 0x02, 0x00, 0x01};
@@ -1681,11 +1681,11 @@ unsigned int OnAssocReq(_adapter *padapter, union recv_frame *precv_frame)
 	unsigned char		supportRate[16];
 	int					supportRateNum;
 	unsigned short		status = _STATS_SUCCESSFUL_;
-	unsigned short		frame_type, ie_offset=0;
+	unsigned short		frame_type, ie_offset=0;	
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
 	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
-	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);	
 	WLAN_BSSID_EX 	*cur = &(pmlmeinfo->network);
 	struct sta_priv *pstapriv = &padapter->stapriv;
 	u8 *pframe = precv_frame->u.hdr.rx_data;
@@ -1712,26 +1712,26 @@ unsigned int OnAssocReq(_adapter *padapter, union recv_frame *precv_frame)
 
 	if((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE)
 		return _FAIL;
-
+	
 	frame_type = GetFrameSubType(pframe);
 	if (frame_type == WIFI_ASSOCREQ)
 	{
 		reassoc = 0;
 		ie_offset = _ASOCREQ_IE_OFFSET_;
-	}
+	}	
 	else // WIFI_REASSOCREQ
 	{
 		reassoc = 1;
 		ie_offset = _REASOCREQ_IE_OFFSET_;
 	}
-
+	
 
 	if (pkt_len < IEEE80211_3ADDR_LEN + ie_offset) {
 		DBG_871X("handle_assoc(reassoc=%d) - too short payload (len=%lu)"
 		       "\n", reassoc, (unsigned long)pkt_len);
 		return _FAIL;
 	}
-
+	
 	pstat = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));
 	if (pstat == (struct sta_info *)NULL)
 	{
@@ -1740,13 +1740,13 @@ unsigned int OnAssocReq(_adapter *padapter, union recv_frame *precv_frame)
 	}
 
 	capab_info = RTW_GET_LE16(pframe + WLAN_HDR_A3_LEN);
-	//capab_info = le16_to_cpu(*(unsigned short *)(pframe + WLAN_HDR_A3_LEN));
+	//capab_info = le16_to_cpu(*(unsigned short *)(pframe + WLAN_HDR_A3_LEN));	
 	//listen_interval = le16_to_cpu(*(unsigned short *)(pframe + WLAN_HDR_A3_LEN+2));
 	listen_interval = RTW_GET_LE16(pframe + WLAN_HDR_A3_LEN+2);
 
 	left = pkt_len - (IEEE80211_3ADDR_LEN + ie_offset);
 	pos = pframe + (IEEE80211_3ADDR_LEN + ie_offset);
-
+	
 
 	DBG_871X("%s\n", __FUNCTION__);
 
@@ -1761,7 +1761,7 @@ unsigned int OnAssocReq(_adapter *padapter, union recv_frame *precv_frame)
 		else
 		{
 			pstat->state &= (~WIFI_FW_ASSOC_SUCCESS);
-			pstat->state |= WIFI_FW_ASSOC_STATE;
+			pstat->state |= WIFI_FW_ASSOC_STATE;				
 		}
 	}
 	else
@@ -1790,7 +1790,7 @@ unsigned int OnAssocReq(_adapter *padapter, union recv_frame *precv_frame)
 		resp = WLAN_STATUS_ASSOC_DENIED_LISTEN_INT_TOO_LARGE;
 		goto fail;
 	}
-
+	
 	pstat->listen_interval = listen_interval;
 #endif
 
@@ -1799,7 +1799,7 @@ unsigned int OnAssocReq(_adapter *padapter, union recv_frame *precv_frame)
 	    !elems.ssid) {
 		DBG_871X("STA " MAC_FMT " sent invalid association request\n",
 		       MAC_ARG(pstat->hwaddr));
-		status = _STATS_FAILURE_;
+		status = _STATS_FAILURE_;		
 		goto OnAssocReqFail;
 	}
 
@@ -1810,7 +1810,7 @@ unsigned int OnAssocReq(_adapter *padapter, union recv_frame *precv_frame)
 		pkt_len - WLAN_HDR_A3_LEN - ie_offset);
 	if (p == NULL)
 	{
-		status = _STATS_FAILURE_;
+		status = _STATS_FAILURE_;		
 	}
 
 	if (ie_len == 0) // broadcast ssid, however it is not allowed in assocreq
@@ -1835,7 +1835,7 @@ unsigned int OnAssocReq(_adapter *padapter, union recv_frame *precv_frame)
 		// use our own rate set as statoin used
 		//_rtw_memcpy(supportRate, AP_BSSRATE, AP_BSSRATE_LEN);
 		//supportRateNum = AP_BSSRATE_LEN;
-
+		
 		status = _STATS_FAILURE_;
 		goto OnAssocReqFail;
 	}
@@ -1846,26 +1846,26 @@ unsigned int OnAssocReq(_adapter *padapter, union recv_frame *precv_frame)
 		p = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + ie_offset, _EXT_SUPPORTEDRATES_IE_ , &ie_len,
 				pkt_len - WLAN_HDR_A3_LEN - ie_offset);
 		if (p !=  NULL) {
-
+			
 			if(supportRateNum<=sizeof(supportRate))
 			{
 				_rtw_memcpy(supportRate+supportRateNum, p+2, ie_len);
 				supportRateNum += ie_len;
-			}
+			}			
 		}
 	}
 
 	//todo: mask supportRate between AP & STA -> move to update raid
 	//get_matched_rate(pmlmeext, supportRate, &supportRateNum, 0);
 
-	//update station supportRate
+	//update station supportRate	
 	pstat->bssratelen = supportRateNum;
 	_rtw_memcpy(pstat->bssrateset, supportRate, supportRateNum);
 
 
 	//check RSN/WPA/WPS
 	pstat->dot8021xalg = 0;
-	pstat->wpa_psk = 0;
+      	pstat->wpa_psk = 0;
 	pstat->wpa_group_cipher = 0;
 	pstat->wpa2_group_cipher = 0;
 	pstat->wpa_pairwise_cipher = 0;
@@ -1873,19 +1873,19 @@ unsigned int OnAssocReq(_adapter *padapter, union recv_frame *precv_frame)
 	_rtw_memset(pstat->wpa_ie, 0, sizeof(pstat->wpa_ie));
 	if((psecuritypriv->wpa_psk & BIT(1)) && elems.rsn_ie) {
 
-		int group_cipher=0, pairwise_cipher=0;
-
+		int group_cipher=0, pairwise_cipher=0;	
+		
 		wpa_ie = elems.rsn_ie;
 		wpa_ie_len = elems.rsn_ie_len;
 
 		if(rtw_parse_wpa2_ie(wpa_ie-2, wpa_ie_len+2, &group_cipher, &pairwise_cipher) == _SUCCESS)
 		{
-			pstat->dot8021xalg = 1;//psk,  todo:802.1x
+			pstat->dot8021xalg = 1;//psk,  todo:802.1x						
 			pstat->wpa_psk |= BIT(1);
 
-			pstat->wpa2_group_cipher = group_cipher&psecuritypriv->wpa2_group_cipher;
+			pstat->wpa2_group_cipher = group_cipher&psecuritypriv->wpa2_group_cipher;				
 			pstat->wpa2_pairwise_cipher = pairwise_cipher&psecuritypriv->wpa2_pairwise_cipher;
-
+			
 			if(!pstat->wpa2_group_cipher)
 				status = WLAN_STATUS_GROUP_CIPHER_NOT_VALID;
 
@@ -1895,35 +1895,35 @@ unsigned int OnAssocReq(_adapter *padapter, union recv_frame *precv_frame)
 		else
 		{
 			status = WLAN_STATUS_INVALID_IE;
-		}
-
+		}	
+			
 	} else if ((psecuritypriv->wpa_psk & BIT(0)) && elems.wpa_ie) {
 
-		int group_cipher=0, pairwise_cipher=0;
-
+		int group_cipher=0, pairwise_cipher=0;	
+		
 		wpa_ie = elems.wpa_ie;
 		wpa_ie_len = elems.wpa_ie_len;
 
 		if(rtw_parse_wpa_ie(wpa_ie-2, wpa_ie_len+2, &group_cipher, &pairwise_cipher) == _SUCCESS)
 		{
-			pstat->dot8021xalg = 1;//psk,  todo:802.1x
+			pstat->dot8021xalg = 1;//psk,  todo:802.1x						
 			pstat->wpa_psk |= BIT(0);
 
-			pstat->wpa_group_cipher = group_cipher&psecuritypriv->wpa_group_cipher;
+			pstat->wpa_group_cipher = group_cipher&psecuritypriv->wpa_group_cipher;				
 			pstat->wpa_pairwise_cipher = pairwise_cipher&psecuritypriv->wpa_pairwise_cipher;
-
+			
 			if(!pstat->wpa_group_cipher)
 				status = WLAN_STATUS_GROUP_CIPHER_NOT_VALID;
 
 			if(!pstat->wpa_pairwise_cipher)
 				status = WLAN_STATUS_PAIRWISE_CIPHER_NOT_VALID;
-
+		
 		}
 		else
 		{
 			status = WLAN_STATUS_INVALID_IE;
 		}
-
+		
 	} else {
 		wpa_ie = NULL;
 		wpa_ie_len = 0;
@@ -1953,26 +1953,26 @@ unsigned int OnAssocReq(_adapter *padapter, union recv_frame *precv_frame)
 
 		// AP support WPA/RSN, and sta is going to do WPS, but AP is not ready
 		// that the selected registrar of AP is _FLASE
-		if((psecuritypriv->wpa_psk >0)
+		if((psecuritypriv->wpa_psk >0)  
 			&& (pstat->flags & (WLAN_STA_WPS|WLAN_STA_MAYBE_WPS)))
 		{
 			if(pmlmepriv->wps_beacon_ie)
-			{
+			{	
 				u8 selected_registrar = 0;
-
+				
 				rtw_get_wps_attr_content(pmlmepriv->wps_beacon_ie, pmlmepriv->wps_beacon_ie_len, WPS_ATTR_SELECTED_REGISTRAR , &selected_registrar, NULL);
 
 				if(!selected_registrar)
-				{
+				{						
 					DBG_871X("selected_registrar is _FALSE , or AP is not ready to do WPS\n");
-
+						
 					status = _STATS_UNABLE_HANDLE_STA_;
-
+			
 					goto OnAssocReqFail;
-				}
-			}
+				}						
+			}			
 		}
-
+			
 	}
 	else
 	{
@@ -1981,10 +1981,10 @@ unsigned int OnAssocReq(_adapter *padapter, union recv_frame *precv_frame)
 		if(psecuritypriv->wpa_psk == 0)
 		{
 			DBG_871X("STA " MAC_FMT ": WPA/RSN IE in association "
-			"request, but AP don't support WPA/RSN\n", MAC_ARG(pstat->hwaddr));
-
+		       	"request, but AP don't support WPA/RSN\n", MAC_ARG(pstat->hwaddr));
+			
 			status = WLAN_STATUS_INVALID_IE;
-
+			
 			goto OnAssocReqFail;
 
 		}
@@ -2001,10 +2001,10 @@ unsigned int OnAssocReq(_adapter *padapter, union recv_frame *precv_frame)
 			copy_len = ((wpa_ie_len+2) > sizeof(pstat->wpa_ie)) ? (sizeof(pstat->wpa_ie)):(wpa_ie_len+2);
 		}
 
-
+		
 		if(copy_len>0)
 			_rtw_memcpy(pstat->wpa_ie, wpa_ie-2, copy_len);
-
+		
 	}
 
 
@@ -2017,51 +2017,51 @@ unsigned int OnAssocReq(_adapter *padapter, union recv_frame *precv_frame)
 	pstat->uapsd_vi = 0;
 	pstat->uapsd_be = 0;
 	pstat->uapsd_bk = 0;
-	if (pmlmepriv->qospriv.qos_option)
+	if (pmlmepriv->qospriv.qos_option) 
 	{
 		p = pframe + WLAN_HDR_A3_LEN + ie_offset; ie_len = 0;
-		for (;;)
+		for (;;) 
 		{
 			p = rtw_get_ie(p, _VENDOR_SPECIFIC_IE_, &ie_len, pkt_len - WLAN_HDR_A3_LEN - ie_offset);
 			if (p != NULL) {
 				if (_rtw_memcmp(p+2, WMM_IE, 6)) {
 
 					pstat->flags |= WLAN_STA_WME;
-
-					pstat->qos_option = 1;
+					
+					pstat->qos_option = 1;				
 					pstat->qos_info = *(p+8);
-
+					
 					pstat->max_sp_len = (pstat->qos_info>>5)&0x3;
 
 					if((pstat->qos_info&0xf) !=0xf)
 						pstat->has_legacy_ac = _TRUE;
 					else
 						pstat->has_legacy_ac = _FALSE;
-
+					
 					if(pstat->qos_info&0xf)
 					{
 						if(pstat->qos_info&BIT(0))
 							pstat->uapsd_vo = BIT(0)|BIT(1);
 						else
 							pstat->uapsd_vo = 0;
-
+		
 						if(pstat->qos_info&BIT(1))
 							pstat->uapsd_vi = BIT(0)|BIT(1);
 						else
 							pstat->uapsd_vi = 0;
-
+			
 						if(pstat->qos_info&BIT(2))
 							pstat->uapsd_bk = BIT(0)|BIT(1);
 						else
 							pstat->uapsd_bk = 0;
-
-						if(pstat->qos_info&BIT(3))
+			
+						if(pstat->qos_info&BIT(3))			
 							pstat->uapsd_be = BIT(0)|BIT(1);
 						else
 							pstat->uapsd_be = 0;
-
+		
 					}
-
+	
 					break;
 				}
 			}
@@ -2076,32 +2076,32 @@ unsigned int OnAssocReq(_adapter *padapter, union recv_frame *precv_frame)
 #ifdef CONFIG_80211N_HT
 	/* save HT capabilities in the sta object */
 	_rtw_memset(&pstat->htpriv.ht_cap, 0, sizeof(struct rtw_ieee80211_ht_cap));
-	if (elems.ht_capabilities && elems.ht_capabilities_len >= sizeof(struct rtw_ieee80211_ht_cap))
+	if (elems.ht_capabilities && elems.ht_capabilities_len >= sizeof(struct rtw_ieee80211_ht_cap)) 
 	{
 		pstat->flags |= WLAN_STA_HT;
-
+		
 		pstat->flags |= WLAN_STA_WME;
-
-		_rtw_memcpy(&pstat->htpriv.ht_cap, elems.ht_capabilities, sizeof(struct rtw_ieee80211_ht_cap));
-
+		
+		_rtw_memcpy(&pstat->htpriv.ht_cap, elems.ht_capabilities, sizeof(struct rtw_ieee80211_ht_cap));			
+		
 	} else
 		pstat->flags &= ~WLAN_STA_HT;
 
-
+	
 	if((pmlmepriv->htpriv.ht_option == _FALSE) && (pstat->flags&WLAN_STA_HT))
 	{
 		status = _STATS_FAILURE_;
 		goto OnAssocReqFail;
 	}
-
+		
 
 	if ((pstat->flags & WLAN_STA_HT) &&
 		    ((pstat->wpa2_pairwise_cipher&WPA_CIPHER_TKIP) ||
 		      (pstat->wpa_pairwise_cipher&WPA_CIPHER_TKIP)))
-	{
+	{		    
 		DBG_871X("HT: " MAC_FMT " tried to "
 				   "use TKIP with HT association\n", MAC_ARG(pstat->hwaddr));
-
+		
 		//status = WLAN_STATUS_CIPHER_REJECTED_PER_POLICY;
 		//goto OnAssocReqFail;
 	}
@@ -2109,7 +2109,7 @@ unsigned int OnAssocReq(_adapter *padapter, union recv_frame *precv_frame)
 
        //
        //if (hapd->iface->current_mode->mode == HOSTAPD_MODE_IEEE80211G)//?
-	pstat->flags |= WLAN_STA_NONERP;
+	pstat->flags |= WLAN_STA_NONERP;	
 	for (i = 0; i < pstat->bssratelen; i++) {
 		if ((pstat->bssrateset[i] & 0x7f) > 22) {
 			pstat->flags &= ~WLAN_STA_NONERP;
@@ -2122,15 +2122,15 @@ unsigned int OnAssocReq(_adapter *padapter, union recv_frame *precv_frame)
 	else
 		pstat->flags &= ~WLAN_STA_SHORT_PREAMBLE;
 
-
-
+	
+	
 	if (status != _STATS_SUCCESSFUL_)
 		goto OnAssocReqFail;
 
 #ifdef CONFIG_P2P
 	pstat->is_p2p_device = _FALSE;
 	if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
-	{
+	{		
 		if( (p2pie=rtw_get_p2p_ie(pframe + WLAN_HDR_A3_LEN + ie_offset , pkt_len - WLAN_HDR_A3_LEN - ie_offset , NULL, &p2pielen)))
 		{
 			pstat->is_p2p_device = _TRUE;
@@ -2166,7 +2166,7 @@ unsigned int OnAssocReq(_adapter *padapter, union recv_frame *precv_frame)
 	// identify if this is ralink sta
 	// Customer proprietary IE
 
-
+	
 
 	/* get a unique AID */
 	if (pstat->aid > 0) {
@@ -2175,29 +2175,29 @@ unsigned int OnAssocReq(_adapter *padapter, union recv_frame *precv_frame)
 		for (pstat->aid = 1; pstat->aid <= NUM_STA; pstat->aid++)
 			if (pstapriv->sta_aid[pstat->aid - 1] == NULL)
 				break;
-
+				
 		//if (pstat->aid > NUM_STA) {
 		if (pstat->aid > pstapriv->max_num_sta) {
-
+				
 			pstat->aid = 0;
-
+				
 			DBG_871X("  no room for more AIDs\n");
 
 			status = WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA;
-
+				
 			goto OnAssocReqFail;
-
-
+				
+			
 		} else {
 			pstapriv->sta_aid[pstat->aid - 1] = pstat;
 			DBG_871X("allocate new AID = (%d)\n", pstat->aid);
-		}
+		}	
 	}
 
 
-	pstat->state &= (~WIFI_FW_ASSOC_STATE);
+	pstat->state &= (~WIFI_FW_ASSOC_STATE);	
 	pstat->state |= WIFI_FW_ASSOC_SUCCESS;
-
+	
 	_enter_critical_bh(&pstapriv->auth_list_lock, &irqL);
 	if (!rtw_is_list_empty(&pstat->auth_list))
 	{
@@ -2206,7 +2206,7 @@ unsigned int OnAssocReq(_adapter *padapter, union recv_frame *precv_frame)
 	}
 	_exit_critical_bh(&pstapriv->auth_list_lock, &irqL);
 
-	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
+	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);	
 	if (rtw_is_list_empty(&pstat->asoc_list))
 	{
 		pstat->expire_to = pstapriv->expire_to;
@@ -2215,7 +2215,7 @@ unsigned int OnAssocReq(_adapter *padapter, union recv_frame *precv_frame)
 	}
 	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 
-	// now the station is qualified to join our BSS...
+	// now the station is qualified to join our BSS...	
 	if(pstat && (pstat->state & WIFI_FW_ASSOC_SUCCESS) && (_STATS_SUCCESSFUL_==status))
 	{
 #ifdef CONFIG_NATIVEAP_MLME
@@ -2229,7 +2229,7 @@ unsigned int OnAssocReq(_adapter *padapter, union recv_frame *precv_frame)
 		else
 			issue_asocrsp(padapter, status, pstat, WIFI_REASSOCRSP);
 
-		//.2 - report to upper layer
+		//.2 - report to upper layer 
 		DBG_871X("indicate_sta_join_event to upper layer - hostapd\n");
 
 #ifdef CONFIG_IOCTL_CFG80211
@@ -2252,7 +2252,7 @@ unsigned int OnAssocReq(_adapter *padapter, union recv_frame *precv_frame)
 			_rtw_memcpy(pstat->passoc_req, pframe, pkt_len);
 			pstat->assoc_req_len = pkt_len;
 		}
-		_exit_critical_bh(&pstat->lock, &irqL);
+		_exit_critical_bh(&pstat->lock, &irqL);		
 		#endif //(LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) && !defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER)
 #else
 		rtw_indicate_sta_assoc_event(padapter, pstat);
@@ -2260,15 +2260,15 @@ unsigned int OnAssocReq(_adapter *padapter, union recv_frame *precv_frame)
 
 		//.3-(1) report sta add event
 		report_add_sta_event(padapter, pstat->hwaddr, pstat->aid);
-
-/*
+		
+/*		
 		//issue assoc rsp before notify station join event.
 		if (frame_type == WIFI_ASSOCREQ)
 			issue_asocrsp(padapter, status, pstat, WIFI_ASSOCRSP);
 		else
 			issue_asocrsp(padapter, status, pstat, WIFI_REASSOCRSP);
-*/
-
+*/			
+	
 #endif
 	}
 
@@ -2280,7 +2280,7 @@ unsigned int OnAssocReq(_adapter *padapter, union recv_frame *precv_frame)
 	issue_deauth(padapter, (void *)GetAddr2Ptr(pframe), status);
 #endif
 
-	return _FAIL;
+	return _FAIL;		
 
 OnAssocReqFail:
 
@@ -2296,7 +2296,7 @@ unsigned int OnAssocReq(_adapter *padapter, union recv_frame *precv_frame)
 
 #endif /* CONFIG_AP_MODE */
 
-	return _FAIL;
+	return _FAIL;		
 
 }
 
@@ -2314,7 +2314,7 @@ unsigned int OnAssocRsp(_adapter *padapter, union recv_frame *precv_frame)
 	uint pkt_len = precv_frame->u.hdr.len;
 
 	DBG_871X("%s\n", __FUNCTION__);
-
+	
 	//check A1 matches or not
 	if (!_rtw_memcmp(myid(&(padapter->eeprompriv)), get_da(pframe), ETH_ALEN))
 		return _SUCCESS;
@@ -2365,7 +2365,7 @@ unsigned int OnAssocRsp(_adapter *padapter, union recv_frame *precv_frame)
 					DBG_871X( "[%s] Found WFD IE\n", __FUNCTION__ );
 					WFD_info_handler( padapter, pIE );
 				}
-#endif
+#endif				
 				break;
 
 			case _HT_CAPABILITY_IE_:	//HT caps
@@ -2440,25 +2440,25 @@ unsigned int OnDeAuth(_adapter *padapter, union recv_frame *precv_frame)
 
 #ifdef CONFIG_AP_MODE
 	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
-	{
+	{		
 		_irqL irqL;
 		struct sta_info *psta;
 		struct sta_priv *pstapriv = &padapter->stapriv;
-
-		//_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+		
+		//_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);		
 		//rtw_free_stainfo(padapter, psta);
-		//_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+		//_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);		
 
 		DBG_871X("%s, STA:" MAC_FMT "\n", __FUNCTION__, MAC_ARG(GetAddr2Ptr(pframe)));
 
-		psta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));
+		psta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));	
 		if(psta)
 		{
-			u8 updated = _FALSE;
-
+			u8 updated;
+		
 			_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 			if(rtw_is_list_empty(&psta->asoc_list)==_FALSE)
-			{
+			{			
 				rtw_list_delete(&psta->asoc_list);
 				pstapriv->asoc_list_cnt--;
 				updated = ap_free_sta(padapter, psta, _FALSE, reason);
@@ -2468,7 +2468,7 @@ unsigned int OnDeAuth(_adapter *padapter, union recv_frame *precv_frame)
 
 			associated_clients_update(padapter, updated);
 		}
-
+		
 
 		return _SUCCESS;
 	}
@@ -2478,7 +2478,7 @@ unsigned int OnDeAuth(_adapter *padapter, union recv_frame *precv_frame)
 		int	ignore_received_deauth = 0;
 
 		//	Commented by Albert 20130604
-		//	Before sending the auth frame to start the STA/GC mode connection with AP/GO,
+		//	Before sending the auth frame to start the STA/GC mode connection with AP/GO, 
 		//	we will send the deauth first.
 		//	However, the Win8.1 with BRCM Wi-Fi will send the deauth with reason code 6 to us after receieving our deauth.
 		//	Added the following code to avoid this case.
@@ -2499,7 +2499,7 @@ unsigned int OnDeAuth(_adapter *padapter, union recv_frame *precv_frame)
 		{
 			receive_disconnect(padapter, GetAddr3Ptr(pframe) ,reason);
 		}
-	}
+	}	
 	pmlmepriv->LinkDetectInfo.bBusyTraffic = _FALSE;
 	return _SUCCESS;
 
@@ -2534,29 +2534,29 @@ unsigned int OnDisassoc(_adapter *padapter, union recv_frame *precv_frame)
 
 #ifdef CONFIG_AP_MODE
 	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
-	{
+	{	
 		_irqL irqL;
 		struct sta_info *psta;
 		struct sta_priv *pstapriv = &padapter->stapriv;
-
-		//_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+		
+		//_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);	
 		//rtw_free_stainfo(padapter, psta);
-		//_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+		//_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);		
 
 		DBG_871X("%s, STA:" MAC_FMT "\n", __FUNCTION__, MAC_ARG(GetAddr2Ptr(pframe)));
 
-		psta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));
+		psta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));	
 		if(psta)
 		{
-			u8 updated = _FALSE;
-
+			u8 updated;
+			
 			_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 			if(rtw_is_list_empty(&psta->asoc_list)==_FALSE)
 			{
 				rtw_list_delete(&psta->asoc_list);
 				pstapriv->asoc_list_cnt--;
 				updated = ap_free_sta(padapter, psta, _FALSE, reason);
-
+			
 			}
 			_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 
@@ -2569,9 +2569,9 @@ unsigned int OnDisassoc(_adapter *padapter, union recv_frame *precv_frame)
 #endif
 	{
 		DBG_871X("%s, STA:" MAC_FMT "\n", __FUNCTION__, MAC_ARG(GetAddr3Ptr(pframe)));
-
+		
 		receive_disconnect(padapter, GetAddr3Ptr(pframe), reason);
-	}
+	}	
 	pmlmepriv->LinkDetectInfo.bBusyTraffic = _FALSE;
 	return _SUCCESS;
 
@@ -2590,12 +2590,12 @@ unsigned int on_action_spct_ch_switch(_adapter *padapter, struct sta_info *psta,
 	struct mlme_ext_info	*pmlmeinfo = &(mlmeext->mlmext_info);
 
 	if (!(pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS)) {
-		ret = _SUCCESS;
+		ret = _SUCCESS;	
 		goto exit;
 	}
 
 	if ((pmlmeinfo->state & 0x03) == WIFI_FW_STATION_STATE) {
-
+		
 		int ch_switch_mode = -1, ch = -1, ch_switch_cnt = -1;
 		int ch_offset = -1;
 		u8 bwmode;
@@ -2707,7 +2707,7 @@ unsigned int OnAction_back(_adapter *padapter, union recv_frame *precv_frame)
 	u8 *pframe = precv_frame->u.hdr.rx_data;
 	struct sta_priv *pstapriv = &padapter->stapriv;
 
-	//check RA matches or not
+	//check RA matches or not	
 	if (!_rtw_memcmp(myid(&(padapter->eeprompriv)), GetAddr1Ptr(pframe), ETH_ALEN))//for if1, sta/ap mode
 		return _SUCCESS;
 
@@ -2718,7 +2718,7 @@ unsigned int OnAction_back(_adapter *padapter, union recv_frame *precv_frame)
 */
 	DBG_871X("%s\n", __FUNCTION__);
 
-	if((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE)
+	if((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE)	
 		if (!(pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS))
 			return _SUCCESS;
 
@@ -2734,7 +2734,7 @@ unsigned int OnAction_back(_adapter *padapter, union recv_frame *precv_frame)
 	if (category == RTW_WLAN_CATEGORY_BACK)// representing Block Ack
 	{
 #ifdef CONFIG_TDLS
-		if((psta->tdls_sta_state & TDLS_LINKED_STATE) &&
+		if((psta->tdls_sta_state & TDLS_LINKED_STATE) && 
 			(psta->htpriv.ht_option==_TRUE) &&
 			(psta->htpriv.ampdu_enable==_TRUE) )
 		{
@@ -2756,7 +2756,7 @@ unsigned int OnAction_back(_adapter *padapter, union recv_frame *precv_frame)
 				_rtw_memcpy(&(pmlmeinfo->ADDBA_req), &(frame_body[2]), sizeof(struct ADDBA_request));
 				//process_addba_req(padapter, (u8*)&(pmlmeinfo->ADDBA_req), GetAddr3Ptr(pframe));
 				process_addba_req(padapter, (u8*)&(pmlmeinfo->ADDBA_req), addr);
-
+				
 				if(pmlmeinfo->bAcceptAddbaReq == _TRUE)
 				{
 					issue_action_BA(padapter, addr, RTW_WLAN_ACTION_ADDBA_RESP, 0);
@@ -2765,7 +2765,7 @@ unsigned int OnAction_back(_adapter *padapter, union recv_frame *precv_frame)
 				{
 					issue_action_BA(padapter, addr, RTW_WLAN_ACTION_ADDBA_RESP, 37);//reject ADDBA Req
 				}
-
+								
 				break;
 
 			case RTW_WLAN_ACTION_ADDBA_RESP: //ADDBA response
@@ -2775,14 +2775,14 @@ unsigned int OnAction_back(_adapter *padapter, union recv_frame *precv_frame)
 				tid = ((frame_body[5] >> 2) & 0x7);
 
 				if (status == 0)
-				{	//successful
+				{	//successful					
 					DBG_871X("agg_enable for TID=%d\n", tid);
-					psta->htpriv.agg_enable_bitmap |= 1 << tid;
-					psta->htpriv.candidate_tid_bitmap &= ~BIT(tid);
+					psta->htpriv.agg_enable_bitmap |= 1 << tid;					
+					psta->htpriv.candidate_tid_bitmap &= ~BIT(tid);				
 				}
 				else
-				{
-					psta->htpriv.agg_enable_bitmap &= ~BIT(tid);
+				{					
+					psta->htpriv.agg_enable_bitmap &= ~BIT(tid);					
 				}
 
 				//DBG_871X("marc: ADDBA RSP: %x\n", pmlmeinfo->agg_enable_bitmap);
@@ -2793,14 +2793,14 @@ unsigned int OnAction_back(_adapter *padapter, union recv_frame *precv_frame)
 				{
 					psta->htpriv.agg_enable_bitmap &= ~(1 << ((frame_body[3] >> 4) & 0xf));
 					psta->htpriv.candidate_tid_bitmap &= ~(1 << ((frame_body[3] >> 4) & 0xf));
-
+					
 					//reason_code = frame_body[4] | (frame_body[5] << 8);
 					reason_code = RTW_GET_LE16(&frame_body[4]);
 				}
 				else if((frame_body[3] & BIT(3)) == BIT(3))
-				{
+				{						
 					tid = (frame_body[3] >> 4) & 0x0F;
-
+				
 					preorder_ctrl =  &psta->recvreorder_ctrl[tid];
 					preorder_ctrl->enable = _FALSE;
 					preorder_ctrl->indicate_seq = 0xffff;
@@ -2809,7 +2809,7 @@ unsigned int OnAction_back(_adapter *padapter, union recv_frame *precv_frame)
 						preorder_ctrl->indicate_seq);
 					#endif
 				}
-
+				
 				DBG_871X("%s(): DELBA: %x(%x)\n", __FUNCTION__,pmlmeinfo->agg_enable_bitmap, reason_code);
 				//todo: how to notify the host while receiving DELETE BA
 				break;
@@ -2841,8 +2841,8 @@ static void get_channel_cnt_24g_5gl_5gh(  struct mlme_ext_priv *pmlmeext, u8* p2
 
 	*p24g_cnt = 0;
 	*p5gl_cnt = 0;
-	*p5gh_cnt = 0;
-
+	*p5gh_cnt = 0;	
+	
 	for( i = 0; i < pmlmeext->max_chan_nums; i++ )
 	{
 		if ( pmlmeext->channel_set[ i ].ChannelNum <= 14 )
@@ -2875,8 +2875,8 @@ void issue_p2p_GO_request(_adapter *padapter, u8* raddr)
 	u16			len_channellist_attr = 0;
 #ifdef CONFIG_WFD
 	u32					wfdielen = 0;
-#endif //CONFIG_WFD
-
+#endif //CONFIG_WFD		
+	
 	struct xmit_frame			*pmgntframe;
 	struct pkt_attrib			*pattrib;
 	unsigned char					*pframe;
@@ -2920,11 +2920,11 @@ void issue_p2p_GO_request(_adapter *padapter, u8* raddr)
 	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 4, (unsigned char *) &(p2poui), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));	
 	pwdinfo->negotiation_dialog_token = 1;	//	Initialize the dialog value
 	pframe = rtw_set_fixed_ie(pframe, 1, &pwdinfo->negotiation_dialog_token, &(pattrib->pktlen));
 
-
+	
 
 	//	WPS Section
 	wpsielen = 0;
@@ -3055,17 +3055,17 @@ void issue_p2p_GO_request(_adapter *padapter, u8* raddr)
 	//	Country String
 	p2pie[ p2pielen++ ] = 'X';
 	p2pie[ p2pielen++ ] = 'X';
-
+	
 	//	The third byte should be set to 0x04.
 	//	Described in the "Operating Channel Attribute" section.
 	p2pie[ p2pielen++ ] = 0x04;
 
 	//	Operating Class
 	p2pie[ p2pielen++ ] = 0x51;	//	Copy from SD7
-
+	
 	//	Channel Number
 	p2pie[ p2pielen++ ] = pwdinfo->listen_channel;	//	listening channel number
-
+	
 
 	//	Extended Listen Timing ATTR
 	//	Type:
@@ -3130,7 +3130,7 @@ void issue_p2p_GO_request(_adapter *padapter, u8* raddr)
 	//	Country String
 	p2pie[ p2pielen++ ] = 'X';
 	p2pie[ p2pielen++ ] = 'X';
-
+	
 	//	The third byte should be set to 0x04.
 	//	Described in the "Operating Channel Attribute" section.
 	p2pie[ p2pielen++ ] = 0x04;
@@ -3140,7 +3140,7 @@ void issue_p2p_GO_request(_adapter *padapter, u8* raddr)
 #ifdef CONFIG_CONCURRENT_MODE
 	if ( check_buddy_fwstate(padapter, _FW_LINKED ) )
 	{
-		_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
+		_adapter *pbuddy_adapter = padapter->pbuddy_adapter;	
 		struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 
 		//	Operating Class
@@ -3206,7 +3206,7 @@ void issue_p2p_GO_request(_adapter *padapter, u8* raddr)
 	p2pie[ p2pielen++ ] = P2P_ATTR_DEVICE_INFO;
 
 	//	Length:
-	//	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes)
+	//	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) 
 	//	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes)
 	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 21 + pwdinfo->device_name_len );
 	p2pielen += 2;
@@ -3250,8 +3250,8 @@ void issue_p2p_GO_request(_adapter *padapter, u8* raddr)
 
 	//	Value:
 	_rtw_memcpy( p2pie + p2pielen, pwdinfo->device_name , pwdinfo->device_name_len );
-	p2pielen += pwdinfo->device_name_len;
-
+	p2pielen += pwdinfo->device_name_len;	
+	
 
 	//	Operating Channel
 	//	Type:
@@ -3265,7 +3265,7 @@ void issue_p2p_GO_request(_adapter *padapter, u8* raddr)
 	//	Country String
 	p2pie[ p2pielen++ ] = 'X';
 	p2pie[ p2pielen++ ] = 'X';
-
+	
 	//	The third byte should be set to 0x04.
 	//	Described in the "Operating Channel Attribute" section.
 	p2pie[ p2pielen++ ] = 0x04;
@@ -3290,7 +3290,7 @@ void issue_p2p_GO_request(_adapter *padapter, u8* raddr)
 	//	Channel Number
 	p2pie[ p2pielen++ ] = pwdinfo->operating_channel;	//	operating channel number
 
-	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2pie, &pattrib->pktlen );
+	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2pie, &pattrib->pktlen );		
 
 #ifdef CONFIG_WFD
 	wfdielen = build_nego_req_wfd_ie(pwdinfo, pframe);
@@ -3321,7 +3321,7 @@ void issue_p2p_GO_response(_adapter *padapter, u8* raddr, u8* frame_body,uint le
 	uint			wps_devicepassword_id_len = 0;
 	u8			channel_cnt_24g = 0, channel_cnt_5gl = 0, channel_cnt_5gh;
 	u16			len_channellist_attr = 0;
-
+	
 	struct xmit_frame			*pmgntframe;
 	struct pkt_attrib			*pattrib;
 	unsigned char					*pframe;
@@ -3368,7 +3368,7 @@ void issue_p2p_GO_response(_adapter *padapter, u8* raddr, u8* frame_body,uint le
 	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 4, (unsigned char *) &(p2poui), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));	
 	pwdinfo->negotiation_dialog_token = frame_body[7];	//	The Dialog Token of provisioning discovery request frame.
 	pframe = rtw_set_fixed_ie(pframe, 1, &(pwdinfo->negotiation_dialog_token), &(pattrib->pktlen));
 
@@ -3435,11 +3435,11 @@ void issue_p2p_GO_response(_adapter *padapter, u8* raddr, u8* frame_body,uint le
 		}
 		else if ( wps_devicepassword_id == WPS_DPID_REGISTRAR_SPEC )
 		{
-			_rtw_memcpy( pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "pad", 3 );
+			_rtw_memcpy( pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "pad", 3 );	
 		}
 		else
 		{
-			_rtw_memcpy( pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "pbc", 3 );
+			_rtw_memcpy( pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "pbc", 3 );	
 		}
 	}
 
@@ -3480,7 +3480,7 @@ void issue_p2p_GO_response(_adapter *padapter, u8* raddr, u8* frame_body,uint le
 
 	//	Value:
 	p2pie[ p2pielen++ ] = result;
-
+	
 	//	P2P Capability
 	//	Type:
 	p2pie[ p2pielen++ ] = P2P_ATTR_CAPABILITY;
@@ -3504,7 +3504,7 @@ void issue_p2p_GO_response(_adapter *padapter, u8* raddr, u8* frame_body,uint le
 		//	Be group owner or meet the error case
 		p2pie[ p2pielen++ ] = DMP_P2P_DEVCAP_SUPPORT;
 	}
-
+	
 	//	Group Capability Bitmap, 1 byte
 	if ( pwdinfo->persistent_supported )
 	{
@@ -3560,7 +3560,7 @@ void issue_p2p_GO_response(_adapter *padapter, u8* raddr, u8* frame_body,uint le
 	//	Country String
 	p2pie[ p2pielen++ ] = 'X';
 	p2pie[ p2pielen++ ] = 'X';
-
+	
 	//	The third byte should be set to 0x04.
 	//	Described in the "Operating Channel Attribute" section.
 	p2pie[ p2pielen++ ] = 0x04;
@@ -3581,11 +3581,11 @@ void issue_p2p_GO_response(_adapter *padapter, u8* raddr, u8* frame_body,uint le
 		//	Operating Class
 		p2pie[ p2pielen++ ] = 0x7c;
 	}
-
+	
 	//	Channel Number
 	p2pie[ p2pielen++ ] = pwdinfo->operating_channel;	//	operating channel number
 
-	//	Intended P2P Interface Address
+	//	Intended P2P Interface Address	
 	//	Type:
 	p2pie[ p2pielen++ ] = P2P_ATTR_INTENTED_IF_ADDR;
 
@@ -3628,7 +3628,7 @@ void issue_p2p_GO_response(_adapter *padapter, u8* raddr, u8* frame_body,uint le
 	//	Country String
 	p2pie[ p2pielen++ ] = 'X';
 	p2pie[ p2pielen++ ] = 'X';
-
+	
 	//	The third byte should be set to 0x04.
 	//	Described in the "Operating Channel Attribute" section.
 	p2pie[ p2pielen++ ] = 0x04;
@@ -3638,7 +3638,7 @@ void issue_p2p_GO_response(_adapter *padapter, u8* raddr, u8* frame_body,uint le
 #ifdef CONFIG_CONCURRENT_MODE
 	if ( check_buddy_fwstate(padapter, _FW_LINKED ) )
 	{
-		_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
+		_adapter *pbuddy_adapter = padapter->pbuddy_adapter;	
 		struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 
 		//	Operating Class
@@ -3698,13 +3698,13 @@ void issue_p2p_GO_response(_adapter *padapter, u8* raddr, u8* frame_body,uint le
 		}
 	}
 #endif // CONFIG_CONCURRENT_MODE
-
+	
 	//	Device Info
 	//	Type:
 	p2pie[ p2pielen++ ] = P2P_ATTR_DEVICE_INFO;
 
 	//	Length:
-	//	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes)
+	//	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) 
 	//	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes)
 	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 21 + pwdinfo->device_name_len );
 	p2pielen += 2;
@@ -3748,8 +3748,8 @@ void issue_p2p_GO_response(_adapter *padapter, u8* raddr, u8* frame_body,uint le
 
 	//	Value:
 	_rtw_memcpy( p2pie + p2pielen, pwdinfo->device_name , pwdinfo->device_name_len );
-	p2pielen += pwdinfo->device_name_len;
-
+	p2pielen += pwdinfo->device_name_len;	
+	
 	if ( rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO) )
 	{
 		//	Group ID Attribute
@@ -3768,11 +3768,11 @@ void issue_p2p_GO_response(_adapter *padapter, u8* raddr, u8* frame_body,uint le
 		//	SSID
 		_rtw_memcpy( p2pie + p2pielen, pwdinfo->nego_ssid, pwdinfo->nego_ssidlen );
 		p2pielen += pwdinfo->nego_ssidlen;
-
+		
 	}
-
-	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2pie, &pattrib->pktlen );
-
+	
+	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2pie, &pattrib->pktlen );	
+	
 #ifdef CONFIG_WFD
 	wfdielen = build_nego_resp_wfd_ie(pwdinfo, pframe);
 	pframe += wfdielen;
@@ -3796,7 +3796,7 @@ void issue_p2p_GO_confirm(_adapter *padapter, u8* raddr, u8 result)
 	u8			oui_subtype = P2P_GO_NEGO_CONF;
 	u8			wpsie[ 255 ] = { 0x00 }, p2pie[ 255 ] = { 0x00 };
 	u8			wpsielen = 0, p2pielen = 0;
-
+	
 	struct xmit_frame			*pmgntframe;
 	struct pkt_attrib			*pattrib;
 	unsigned char					*pframe;
@@ -3842,10 +3842,10 @@ void issue_p2p_GO_confirm(_adapter *padapter, u8* raddr, u8 result)
 	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 4, (unsigned char *) &(p2poui), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));	
 	pframe = rtw_set_fixed_ie(pframe, 1, &(pwdinfo->negotiation_dialog_token), &(pattrib->pktlen));
 
-
+	
 
 	//	P2P IE Section.
 
@@ -3886,7 +3886,7 @@ void issue_p2p_GO_confirm(_adapter *padapter, u8* raddr, u8 result)
 	//	Value:
 	//	Device Capability Bitmap, 1 byte
 	p2pie[ p2pielen++ ] = DMP_P2P_DEVCAP_SUPPORT;
-
+	
 	//	Group Capability Bitmap, 1 byte
 	if ( pwdinfo->persistent_supported )
 	{
@@ -3910,7 +3910,7 @@ void issue_p2p_GO_confirm(_adapter *padapter, u8* raddr, u8 result)
 	//	Country String
 	p2pie[ p2pielen++ ] = 'X';
 	p2pie[ p2pielen++ ] = 'X';
-
+	
 	//	The third byte should be set to 0x04.
 	//	Described in the "Operating Channel Attribute" section.
 	p2pie[ p2pielen++ ] = 0x04;
@@ -3933,7 +3933,7 @@ void issue_p2p_GO_confirm(_adapter *padapter, u8* raddr, u8 result)
 			//	Operating Class
 			p2pie[ p2pielen++ ] = 0x7c;
 		}
-
+		
 		p2pie[ p2pielen++ ] = pwdinfo->peer_operating_ch;
 	}
 	else
@@ -3953,7 +3953,7 @@ void issue_p2p_GO_confirm(_adapter *padapter, u8* raddr, u8 result)
 			//	Operating Class
 			p2pie[ p2pielen++ ] = 0x7c;
 		}
-
+		
 		//	Channel Number
 		p2pie[ p2pielen++ ] = pwdinfo->operating_channel;		//	Use the listen channel as the operating channel
 	}
@@ -3969,7 +3969,7 @@ void issue_p2p_GO_confirm(_adapter *padapter, u8* raddr, u8 result)
 	//	Country String
 	p2pie[ p2pielen++ ] = 'X';
 	p2pie[ p2pielen++ ] = 'X';
-
+	
 	//	The third byte should be set to 0x04.
 	//	Described in the "Operating Channel Attribute" section.
 	p2pie[ p2pielen++ ] = 0x04;
@@ -4012,7 +4012,7 @@ void issue_p2p_GO_confirm(_adapter *padapter, u8* raddr, u8 result)
 			//	Operating Class
 			p2pie[ p2pielen++ ] = 0x7c;
 		}
-
+		
 		//	Channel Number
 		p2pie[ p2pielen++ ] = 1;
 		p2pie[ p2pielen++ ] = pwdinfo->operating_channel;		//	Use the listen channel as the operating channel
@@ -4037,9 +4037,9 @@ void issue_p2p_GO_confirm(_adapter *padapter, u8* raddr, u8 result)
 		_rtw_memcpy( p2pie + p2pielen, pwdinfo->nego_ssid, pwdinfo->nego_ssidlen );
 		p2pielen += pwdinfo->nego_ssidlen;
 	}
-
+	
 	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2pie, &pattrib->pktlen );
-
+	
 #ifdef CONFIG_WFD
 	wfdielen = build_nego_confirm_wfd_ie(pwdinfo, pframe);
 	pframe += wfdielen;
@@ -4065,7 +4065,7 @@ void issue_p2p_invitation_request(_adapter *padapter, u8* raddr )
 	u8			p2pielen = 0, i;
 	u8			dialogToken = 3;
 	u8			channel_cnt_24g = 0, channel_cnt_5gl = 0, channel_cnt_5gh = 0;
-	u16			len_channellist_attr = 0;
+	u16			len_channellist_attr = 0;	
 #ifdef CONFIG_WFD
 	u32					wfdielen = 0;
 #endif //CONFIG_WFD
@@ -4118,7 +4118,7 @@ void issue_p2p_invitation_request(_adapter *padapter, u8* raddr )
 	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 4, (unsigned char *) &(p2poui), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));	
 	pframe = rtw_set_fixed_ie(pframe, 1, &(dialogToken), &(pattrib->pktlen));
 
 	//	P2P IE Section.
@@ -4176,7 +4176,7 @@ void issue_p2p_invitation_request(_adapter *padapter, u8* raddr )
 	//	Country String
 	p2pie[ p2pielen++ ] = 'X';
 	p2pie[ p2pielen++ ] = 'X';
-
+	
 	//	The third byte should be set to 0x04.
 	//	Described in the "Operating Channel Attribute" section.
 	p2pie[ p2pielen++ ] = 0x04;
@@ -4188,7 +4188,7 @@ void issue_p2p_invitation_request(_adapter *padapter, u8* raddr )
 		p2pie[ p2pielen++ ] = 0x73;
 	else
 		p2pie[ p2pielen++ ] = 0x7c;
-
+	
 	//	Channel Number
 	p2pie[ p2pielen++ ] = pwdinfo->invitereq_info.operating_ch;	//	operating channel number
 
@@ -4212,7 +4212,7 @@ void issue_p2p_invitation_request(_adapter *padapter, u8* raddr )
 	//	Type:
 	p2pie[ p2pielen++ ] = P2P_ATTR_CH_LIST;
 
-
+	
 	//	Length:
 	// Country String(3)
 	// + ( Operating Class (1) + Number of Channels(1) ) * Operation Classes (?)
@@ -4241,7 +4241,7 @@ void issue_p2p_invitation_request(_adapter *padapter, u8* raddr )
 	//	Country String
 	p2pie[ p2pielen++ ] = 'X';
 	p2pie[ p2pielen++ ] = 'X';
-
+	
 	//	The third byte should be set to 0x04.
 	//	Described in the "Operating Channel Attribute" section.
 	p2pie[ p2pielen++ ] = 0x04;
@@ -4250,7 +4250,7 @@ void issue_p2p_invitation_request(_adapter *padapter, u8* raddr )
 #ifdef CONFIG_CONCURRENT_MODE
 	if ( check_buddy_fwstate(padapter, _FW_LINKED ) )
 	{
-		_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
+		_adapter *pbuddy_adapter = padapter->pbuddy_adapter;	
 		struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 
 		//	Operating Class
@@ -4328,18 +4328,18 @@ void issue_p2p_invitation_request(_adapter *padapter, u8* raddr )
 	//	SSID
 	_rtw_memcpy( p2pie + p2pielen, pwdinfo->invitereq_info.go_ssid, pwdinfo->invitereq_info.ssidlen );
 	p2pielen += pwdinfo->invitereq_info.ssidlen;
-
+	
 
 	//	Device Info
 	//	Type:
 	p2pie[ p2pielen++ ] = P2P_ATTR_DEVICE_INFO;
 
 	//	Length:
-	//	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes)
+	//	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) 
 	//	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes)
 	*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 21 + pwdinfo->device_name_len );
 	p2pielen += 2;
-
+	
 	//	Value:
 	//	P2P Device Address
 	_rtw_memcpy( p2pie + p2pielen, myid( &padapter->eeprompriv ), ETH_ALEN );
@@ -4378,14 +4378,14 @@ void issue_p2p_invitation_request(_adapter *padapter, u8* raddr )
 	//	Value:
 	_rtw_memcpy( p2pie + p2pielen, pwdinfo->device_name, pwdinfo->device_name_len );
 	p2pielen += pwdinfo->device_name_len;
-
-	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2pie, &pattrib->pktlen );
+		
+	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2pie, &pattrib->pktlen );	
 
 #ifdef CONFIG_WFD
 	wfdielen = build_invitation_req_wfd_ie(pwdinfo, pframe);
 	pframe += wfdielen;
 	pattrib->pktlen += wfdielen;
-#endif //CONFIG_WFD
+#endif //CONFIG_WFD	
 
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
@@ -4411,11 +4411,11 @@ void issue_p2p_invitation_response(_adapter *padapter, u8* raddr, u8 dialogToken
 	struct wifidirect_info	*pbuddy_wdinfo = &pbuddy_adapter->wdinfo;
 	struct mlme_priv		*pbuddy_mlmepriv = &pbuddy_adapter->mlmepriv;
 	struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
-#endif
+#endif	
 #ifdef CONFIG_WFD
 	u32					wfdielen = 0;
 #endif //CONFIG_WFD
-
+	
 	struct xmit_frame			*pmgntframe;
 	struct pkt_attrib			*pattrib;
 	unsigned char					*pframe;
@@ -4458,7 +4458,7 @@ void issue_p2p_invitation_response(_adapter *padapter, u8* raddr, u8 dialogToken
 	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 4, (unsigned char *) &(p2poui), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));	
 	pframe = rtw_set_fixed_ie(pframe, 1, &(dialogToken), &(pattrib->pktlen));
 
 	//	P2P IE Section.
@@ -4494,7 +4494,7 @@ void issue_p2p_invitation_response(_adapter *padapter, u8* raddr, u8 dialogToken
 	//	If the UI found the corresponding profile, the WiFi driver sends the P2P Invitation Req
 	//	to NB to rebuild the persistent group.
 	p2pie[ p2pielen++ ] = status_code;
-
+	
 	//	Configuration Timeout
 	//	Type:
 	p2pie[ p2pielen++ ] = P2P_ATTR_CONF_TIMEOUT;
@@ -4528,17 +4528,17 @@ void issue_p2p_invitation_response(_adapter *padapter, u8* raddr, u8 dialogToken
 			//	Country String
 			p2pie[ p2pielen++ ] = 'X';
 			p2pie[ p2pielen++ ] = 'X';
-
+		
 			//	The third byte should be set to 0x04.
 			//	Described in the "Operating Channel Attribute" section.
 			p2pie[ p2pielen++ ] = 0x04;
 
 			//	Operating Class
 			p2pie[ p2pielen++ ] = 0x51;	//	Copy from SD7
-
+		
 			//	Channel Number
 			p2pie[ p2pielen++ ] = pwdinfo->operating_channel;	//	operating channel number
-
+			
 
 			//	P2P Group BSSID
 			//	Type:
@@ -4596,7 +4596,7 @@ void issue_p2p_invitation_response(_adapter *padapter, u8* raddr, u8 dialogToken
 #ifdef CONFIG_CONCURRENT_MODE
 		if ( check_buddy_fwstate(padapter, _FW_LINKED ) )
 		{
-			_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
+			_adapter *pbuddy_adapter = padapter->pbuddy_adapter;	
 			struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 
 			//	Operating Class
@@ -4657,9 +4657,9 @@ void issue_p2p_invitation_response(_adapter *padapter, u8* raddr, u8 dialogToken
 		}
 #endif // CONFIG_CONCURRENT_MODE
 	}
-
-	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2pie, &pattrib->pktlen );
-
+		
+	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2pie, &pattrib->pktlen );	
+	
 #ifdef CONFIG_WFD
 	wfdielen = build_invitation_resp_wfd_ie(pwdinfo, pframe);
 	pframe += wfdielen;
@@ -4686,8 +4686,8 @@ void issue_p2p_provision_request(_adapter *padapter, u8* pssid, u8 ussidlen, u8*
 	u32			p2pielen = 0;
 #ifdef CONFIG_WFD
 	u32					wfdielen = 0;
-#endif //CONFIG_WFD
-
+#endif //CONFIG_WFD		
+	
 	struct xmit_frame			*pmgntframe;
 	struct pkt_attrib			*pattrib;
 	unsigned char					*pframe;
@@ -4731,8 +4731,8 @@ void issue_p2p_provision_request(_adapter *padapter, u8* pssid, u8 ussidlen, u8*
 	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 4, (unsigned char *) &(p2poui), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(dialogToken), &(pattrib->pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));	
+	pframe = rtw_set_fixed_ie(pframe, 1, &(dialogToken), &(pattrib->pktlen));		
 
 	p2pielen = build_prov_disc_request_p2p_ie( pwdinfo, pframe, pssid, ussidlen, pdev_raddr );
 
@@ -4792,12 +4792,12 @@ u8 is_matched_in_profilelist( u8* peermacaddr, struct profile_info* profileinfo
 	u8 i, match_result = 0;
 
 	DBG_871X( "[%s] peermac = %.2X %.2X %.2X %.2X %.2X %.2X\n", __FUNCTION__,
-		    peermacaddr[0], peermacaddr[1],peermacaddr[2],peermacaddr[3],peermacaddr[4],peermacaddr[5]);
-
+	  	    peermacaddr[0], peermacaddr[1],peermacaddr[2],peermacaddr[3],peermacaddr[4],peermacaddr[5]);
+	
 	for( i = 0; i < P2P_MAX_PERSISTENT_GROUP_NUM; i++, profileinfo++ )
 	{
 	       DBG_871X( "[%s] profileinfo_mac = %.2X %.2X %.2X %.2X %.2X %.2X\n", __FUNCTION__,
-			    profileinfo->peermac[0], profileinfo->peermac[1],profileinfo->peermac[2],profileinfo->peermac[3],profileinfo->peermac[4],profileinfo->peermac[5]);
+		   	    profileinfo->peermac[0], profileinfo->peermac[1],profileinfo->peermac[2],profileinfo->peermac[3],profileinfo->peermac[4],profileinfo->peermac[5]);		   
 		if ( _rtw_memcmp( peermacaddr, profileinfo->peermac, ETH_ALEN ) )
 		{
 			match_result = 1;
@@ -4805,7 +4805,7 @@ u8 is_matched_in_profilelist( u8* peermacaddr, struct profile_info* profileinfo
 			break;
 		}
 	}
-
+	
 	return (match_result );
 }
 
@@ -4815,7 +4815,7 @@ void issue_probersp_p2p(_adapter *padapter, unsigned char *da)
 	struct pkt_attrib			*pattrib;
 	unsigned char					*pframe;
 	struct rtw_ieee80211_hdr	*pwlanhdr;
-	unsigned short				*fctrl;
+	unsigned short				*fctrl;	
 	unsigned char					*mac;
 	struct xmit_priv	*pxmitpriv = &(padapter->xmitpriv);
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
@@ -4835,35 +4835,35 @@ void issue_probersp_p2p(_adapter *padapter, unsigned char *da)
 #endif //CONFIG_INTEL_WIDI
 
 	//DBG_871X("%s\n", __FUNCTION__);
-
+	
 	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
 	{
 		return;
 	}
-
+	
 	//update attribute
 	pattrib = &pmgntframe->attrib;
-	update_mgntframe_attrib(padapter, pattrib);
-
+	update_mgntframe_attrib(padapter, pattrib);	
+	
 	_rtw_memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
-
+		
 	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
-	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
-
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;	
+	
 	mac = myid(&(padapter->eeprompriv));
-
+	
 	fctrl = &(pwlanhdr->frame_ctl);
 	*(fctrl) = 0;
 	_rtw_memcpy(pwlanhdr->addr1, da, ETH_ALEN);
 	_rtw_memcpy(pwlanhdr->addr2, mac, ETH_ALEN);
-
-	//	Use the device address for BSSID field.
+	
+	//	Use the device address for BSSID field.	
 	_rtw_memcpy(pwlanhdr->addr3, mac, ETH_ALEN);
 
 	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
 	pmlmeext->mgnt_seq++;
 	SetFrameSubType(fctrl, WIFI_PROBERSP);
-
+	
 	pattrib->hdrlen = sizeof(struct rtw_ieee80211_hdr_3addr);
 	pattrib->pktlen = pattrib->hdrlen;
 	pframe += pattrib->hdrlen;
@@ -4873,7 +4873,7 @@ void issue_probersp_p2p(_adapter *padapter, unsigned char *da)
 	pattrib->pktlen += 8;
 
 	// beacon interval: 2 bytes
-	_rtw_memcpy(pframe, (unsigned char *) &beacon_interval, 2);
+	_rtw_memcpy(pframe, (unsigned char *) &beacon_interval, 2); 
 	pframe += 2;
 	pattrib->pktlen += 2;
 
@@ -4881,7 +4881,7 @@ void issue_probersp_p2p(_adapter *padapter, unsigned char *da)
 	//	ESS and IBSS bits must be 0 (defined in the 3.1.2.1.1 of WiFi Direct Spec)
 	capInfo |= cap_ShortPremble;
 	capInfo |= cap_ShortSlot;
-
+	
 	_rtw_memcpy(pframe, (unsigned char *) &capInfo, 2);
 	pframe += 2;
 	pattrib->pktlen += 2;
@@ -4914,7 +4914,7 @@ void issue_probersp_p2p(_adapter *padapter, unsigned char *da)
 		}
 	}
 	else
-#endif //CONFIG_IOCTL_CFG80211
+#endif //CONFIG_IOCTL_CFG80211		
 	{
 
 		//	Todo: WPS IE
@@ -4941,7 +4941,7 @@ void issue_probersp_p2p(_adapter *padapter, unsigned char *da)
 #ifdef CONFIG_INTEL_WIDI
 		//	Commented by Kurt
 		//	Appended WiDi info. only if we did issued_probereq_widi(), and then we saved ven. ext. in pmlmepriv->sa_ext.
-		if(  _rtw_memcmp(pmlmepriv->sa_ext, zero_array_check, L2SDTA_SERVICE_VE_LEN) == _FALSE
+		if(  _rtw_memcmp(pmlmepriv->sa_ext, zero_array_check, L2SDTA_SERVICE_VE_LEN) == _FALSE 
 			|| pmlmepriv->num_p2p_sdt != 0 )
 		{
 			//Sec dev type
@@ -5035,7 +5035,7 @@ void issue_probersp_p2p(_adapter *padapter, unsigned char *da)
 
 		//	Length:
 		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( 0x0006 );
-		wpsielen += 2;
+		wpsielen += 2;	
 
 		//	Value:
 		_rtw_memcpy( wpsie + wpsielen, "8192CU", 6 );
@@ -5113,10 +5113,10 @@ void issue_probersp_p2p(_adapter *padapter, unsigned char *da)
 		//	Value:
 		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( pwdinfo->supported_wps_cm );
 		wpsielen += 2;
-
+		
 
 		pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wpsielen, (unsigned char *) wpsie, &pattrib->pktlen );
-
+		
 
 		p2pielen = build_probe_resp_p2p_ie(pwdinfo, pframe);
 		pframe += p2pielen;
@@ -5138,16 +5138,16 @@ void issue_probersp_p2p(_adapter *padapter, unsigned char *da)
 		//WFD IE
 		_rtw_memcpy(pframe, pmlmepriv->wfd_probe_resp_ie, pmlmepriv->wfd_probe_resp_ie_len);
 		pattrib->pktlen += pmlmepriv->wfd_probe_resp_ie_len;
-		pframe += pmlmepriv->wfd_probe_resp_ie_len;
+		pframe += pmlmepriv->wfd_probe_resp_ie_len;		
 	}
 #endif //CONFIG_IOCTL_CFG80211
-#endif //CONFIG_WFD
+#endif //CONFIG_WFD	
 
 	pattrib->last_txcmdsz = pattrib->pktlen;
-
+	
 
 	dump_mgntframe(padapter, pmgntframe);
-
+	
 	return;
 
 }
@@ -5167,7 +5167,7 @@ int _issue_probereq_p2p(_adapter *padapter, u8 *da, int wait_ack)
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	int	bssrate_len = 0;
 	u8	bc_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
-	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
+	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);	
 	u8					wpsie[255] = { 0x00 }, p2pie[ 255 ] = { 0x00 };
 	u16					wpsielen = 0, p2pielen = 0;
 #ifdef CONFIG_WFD
@@ -5213,7 +5213,7 @@ int _issue_probereq_p2p(_adapter *padapter, u8 *da, int wait_ack)
 			_rtw_memcpy(pwlanhdr->addr1, bc_addr, ETH_ALEN);
 			_rtw_memcpy(pwlanhdr->addr3, bc_addr, ETH_ALEN);
 		}
-	}
+ 	}
 	_rtw_memcpy(pwlanhdr->addr2, mac, ETH_ALEN);
 
 	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
@@ -5355,10 +5355,10 @@ int _issue_probereq_p2p(_adapter *padapter, u8 *da, int wait_ack)
 
 		//	Value:
 		*(u16*) ( wpsie + wpsielen ) = cpu_to_be16( WPS_DPID_REGISTRAR_SPEC );	//	Registrar-specified
-		wpsielen += 2;
+		wpsielen += 2;	
 
 		pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wpsielen, (unsigned char *) wpsie, &pattrib->pktlen );
-
+		
 		//	P2P OUI
 		p2pielen = 0;
 		p2pie[ p2pielen++ ] = 0x50;
@@ -5385,7 +5385,7 @@ int _issue_probereq_p2p(_adapter *padapter, u8 *da, int wait_ack)
 		//	Value:
 		//	Device Capability Bitmap, 1 byte
 		p2pie[ p2pielen++ ] = DMP_P2P_DEVCAP_SUPPORT;
-
+		
 		//	Group Capability Bitmap, 1 byte
 		if ( pwdinfo->persistent_supported )
 			p2pie[ p2pielen++ ] = P2P_GRPCAP_PERSISTENT_GROUP | DMP_P2P_GRPCAP_SUPPORT;
@@ -5404,17 +5404,17 @@ int _issue_probereq_p2p(_adapter *padapter, u8 *da, int wait_ack)
 		//	Country String
 		p2pie[ p2pielen++ ] = 'X';
 		p2pie[ p2pielen++ ] = 'X';
-
+		
 		//	The third byte should be set to 0x04.
 		//	Described in the "Operating Channel Attribute" section.
 		p2pie[ p2pielen++ ] = 0x04;
 
 		//	Operating Class
 		p2pie[ p2pielen++ ] = 0x51;	//	Copy from SD7
-
+		
 		//	Channel Number
 		p2pie[ p2pielen++ ] = pwdinfo->listen_channel;	//	listen channel
-
+		
 
 		//	Extended Listen Timing
 		//	Type:
@@ -5447,17 +5447,17 @@ int _issue_probereq_p2p(_adapter *padapter, u8 *da, int wait_ack)
 			//	Country String
 			p2pie[ p2pielen++ ] = 'X';
 			p2pie[ p2pielen++ ] = 'X';
-
+		
 			//	The third byte should be set to 0x04.
 			//	Described in the "Operating Channel Attribute" section.
 			p2pie[ p2pielen++ ] = 0x04;
 
 			//	Operating Class
 			p2pie[ p2pielen++ ] = 0x51;	//	Copy from SD7
-
+		
 			//	Channel Number
 			p2pie[ p2pielen++ ] = pwdinfo->operating_channel;	//	operating channel number
-
+			
 		}
 
 		pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2pie, &pattrib->pktlen );
@@ -5481,12 +5481,12 @@ int _issue_probereq_p2p(_adapter *padapter, u8 *da, int wait_ack)
 		pattrib->pktlen += wfdielen;
 	}
 #ifdef CONFIG_IOCTL_CFG80211
-	else if (pmlmepriv->wfd_probe_req_ie != NULL && pmlmepriv->wfd_probe_req_ie_len>0)
+	else if (pmlmepriv->wfd_probe_req_ie != NULL && pmlmepriv->wfd_probe_req_ie_len>0)		
 	{
 		//WFD IE
 		_rtw_memcpy(pframe, pmlmepriv->wfd_probe_req_ie, pmlmepriv->wfd_probe_req_ie_len);
 		pattrib->pktlen += pmlmepriv->wfd_probe_req_ie_len;
-		pframe += pmlmepriv->wfd_probe_req_ie_len;
+		pframe += pmlmepriv->wfd_probe_req_ie_len;		
 	}
 #endif //CONFIG_IOCTL_CFG80211
 #endif //CONFIG_WFD
@@ -5561,7 +5561,7 @@ s32 rtw_action_public_decache(union recv_frame *recv_frame, s32 token)
 	u8 *frame = recv_frame->u.hdr.rx_data;
 	u16 seq_ctrl = ( (recv_frame->u.hdr.attrib.seq_num&0xffff) << 4) |
 		(recv_frame->u.hdr.attrib.frag_num & 0xf);
-
+	
 	if (GetRetry(frame)) {
 		if (token >= 0) {
 			if ((seq_ctrl == mlmeext->action_public_rxseq)
@@ -5579,9 +5579,9 @@ s32 rtw_action_public_decache(union recv_frame *recv_frame, s32 token)
 			}
 		}
 	}
-
+	
 	mlmeext->action_public_rxseq = seq_ctrl;
-
+	
 	if (token >= 0)
 		mlmeext->action_public_dialog_token = token;
 
@@ -5611,7 +5611,7 @@ unsigned int on_action_public_p2p(union recv_frame *precv_frame)
 
 	if (rtw_action_public_decache(precv_frame, dialogToken) == _FAIL)
 		return _FAIL;
-
+	
 #ifdef CONFIG_P2P
 	_cancel_timer_ex( &pwdinfo->reset_ch_sitesurvey );
 #ifdef CONFIG_IOCTL_CFG80211
@@ -5647,8 +5647,8 @@ unsigned int on_action_public_p2p(union recv_frame *precv_frame)
 					_cancel_timer_ex( &pwdinfo->restore_p2p_state_timer );
 					//	Restore the previous p2p state
 					rtw_p2p_set_state(pwdinfo, rtw_p2p_pre_state(pwdinfo));
-					DBG_871X( "[%s] Restore the previous p2p state to %d\n", __FUNCTION__, rtw_p2p_state(pwdinfo) );
-				}
+					DBG_871X( "[%s] Restore the previous p2p state to %d\n", __FUNCTION__, rtw_p2p_state(pwdinfo) );						
+				}					
 #ifdef CONFIG_CONCURRENT_MODE
 				if ( check_buddy_fwstate(padapter, _FW_LINKED ) )
 				{
@@ -5663,7 +5663,7 @@ unsigned int on_action_public_p2p(union recv_frame *precv_frame)
 
 				//	Commented by Kurt 20120113
 				//	Get peer_dev_addr here if peer doesn't issue prov_disc frame.
-				if( _rtw_memcmp(pwdinfo->rx_prov_disc_info.peerDevAddr, empty_addr, ETH_ALEN) )
+				if( _rtw_memcmp(pwdinfo->rx_prov_disc_info.peerDevAddr, empty_addr, ETH_ALEN) );
 					_rtw_memcpy(pwdinfo->rx_prov_disc_info.peerDevAddr, GetAddr2Ptr(pframe), ETH_ALEN);
 
 				result = process_p2p_group_negotation_req( pwdinfo, frame_body, len );
@@ -5685,7 +5685,7 @@ unsigned int on_action_public_p2p(union recv_frame *precv_frame)
 #else // CONFIG_CONCURRENT_MODE
 				_set_timer( &pwdinfo->restore_p2p_state_timer, 5000 );
 #endif // CONFIG_CONCURRENT_MODE
-				break;
+				break;					
 			}
 			case P2P_GO_NEGO_RESP:
 			{
@@ -5712,7 +5712,7 @@ unsigned int on_action_public_p2p(union recv_frame *precv_frame)
 							pwdinfo->p2p_info.scan_op_ch_only = 1;
 							_set_timer( &pwdinfo->reset_ch_sitesurvey2, P2P_RESET_SCAN_CH );
 						}
-					}
+ 					}
 
 					//	Reset the dialog token for group negotiation frames.
 					pwdinfo->negotiation_dialog_token = 1;
@@ -5726,7 +5726,7 @@ unsigned int on_action_public_p2p(union recv_frame *precv_frame)
 				{
 					DBG_871X( "[%s] Skipped GO Nego Resp Frame (p2p_state != P2P_STATE_GONEGO_ING)\n", __FUNCTION__);
 				}
-
+						
 				break;
 			}
 			case P2P_GO_NEGO_CONF:
@@ -5746,14 +5746,14 @@ unsigned int on_action_public_p2p(union recv_frame *precv_frame)
 						pwdinfo->p2p_info.scan_op_ch_only = 1;
 						_set_timer( &pwdinfo->reset_ch_sitesurvey2, P2P_RESET_SCAN_CH );
 					}
-				}
+ 				}
 				break;
 			}
 			case P2P_INVIT_REQ:
 			{
 				//	Added by Albert 2010/10/05
 				//	Received the P2P Invite Request frame.
-
+						
 				DBG_871X( "[%s] Got invite request frame!\n", __FUNCTION__ );
 				if ( (p2p_ie=rtw_get_p2p_ie( frame_body + _PUBLIC_ACTION_IE_OFFSET_, len - _PUBLIC_ACTION_IE_OFFSET_, NULL, &p2p_ielen)) )
 				{
@@ -5772,7 +5772,7 @@ unsigned int on_action_public_p2p(union recv_frame *precv_frame)
 						DBG_871X( "[%s] Malloc p2p ie fail\n", __FUNCTION__);
 						goto exit;
 					}
-					_rtw_memset(merged_p2pie, 0x00, merged_p2p_ielen);
+					_rtw_memset(merged_p2pie, 0x00, merged_p2p_ielen);					
 
 					merged_p2p_ielen = rtw_p2p_merge_ies(frame_body + _PUBLIC_ACTION_IE_OFFSET_, len - _PUBLIC_ACTION_IE_OFFSET_, merged_p2pie);
 
@@ -5793,12 +5793,12 @@ unsigned int on_action_public_p2p(union recv_frame *precv_frame)
 									pwdinfo->p2p_peer_interface_addr[0], pwdinfo->p2p_peer_interface_addr[1],
 									pwdinfo->p2p_peer_interface_addr[2], pwdinfo->p2p_peer_interface_addr[3],
 									pwdinfo->p2p_peer_interface_addr[4], pwdinfo->p2p_peer_interface_addr[5] );
-						}
+						}								
 
 						if ( invitation_flag & P2P_INVITATION_FLAGS_PERSISTENT )
 						{
 							//	Re-invoke the persistent group.
-
+							
 							_rtw_memset( &group_id, 0x00, sizeof( struct group_id_info ) );
 							rtw_get_p2p_attr_content( merged_p2pie, merged_p2p_ielen, P2P_ATTR_GROUP_ID, ( u8* ) &group_id, &attr_contentlen);
 							if ( attr_contentlen )
@@ -5869,7 +5869,7 @@ unsigned int on_action_public_p2p(union recv_frame *precv_frame)
 							{
 								DBG_871X( "[%s] P2P Group ID Attribute NOT FOUND!\n", __FUNCTION__ );
 								status_code = P2P_STATUS_FAIL_INFO_UNAVAILABLE;
-							}
+							}									
 						}
 						else
 						{
@@ -5893,7 +5893,7 @@ unsigned int on_action_public_p2p(union recv_frame *precv_frame)
 									//	The peer device address should be the destination address for the provisioning discovery request.
 									//	Then, this Wi-Fi device should use the iwpriv command to get the peer interface address.
 									//	The peer interface address should be the address for WPS mac address
-									_rtw_memcpy( pwdinfo->p2p_peer_device_addr, group_id.go_device_addr , ETH_ALEN );
+									_rtw_memcpy( pwdinfo->p2p_peer_device_addr, group_id.go_device_addr , ETH_ALEN );											
 									rtw_p2p_set_role( pwdinfo, P2P_ROLE_CLIENT );
 									rtw_p2p_set_state(pwdinfo, P2P_STATE_RECV_INVITE_REQ_JOIN );
 									status_code = P2P_STATUS_SUCCESS;
@@ -5910,7 +5910,7 @@ unsigned int on_action_public_p2p(union recv_frame *precv_frame)
 					{
 						DBG_871X( "[%s] P2P Invitation Flags Attribute NOT FOUND!\n", __FUNCTION__ );
 						status_code = P2P_STATUS_FAIL_INFO_UNAVAILABLE;
-					}
+					}							
 
 					DBG_871X( "[%s] status_code = %d\n", __FUNCTION__, status_code );
 
@@ -5932,13 +5932,13 @@ unsigned int on_action_public_p2p(union recv_frame *precv_frame)
 			{
 				u8	attr_content = 0x00;
 				u32	attr_contentlen = 0;
-
+				
 				DBG_871X( "[%s] Got invite response frame!\n", __FUNCTION__ );
 				_cancel_timer_ex( &pwdinfo->restore_p2p_state_timer );
 				if ( (p2p_ie=rtw_get_p2p_ie( frame_body + _PUBLIC_ACTION_IE_OFFSET_, len - _PUBLIC_ACTION_IE_OFFSET_, NULL, &p2p_ielen)) )
 				{
 					rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_STATUS, &attr_content, &attr_contentlen);
-
+									
 					if ( attr_contentlen == 1 )
 					{
 						DBG_871X( "[%s] Status = %d\n", __FUNCTION__, attr_content );
@@ -6001,7 +6001,7 @@ unsigned int on_action_public_p2p(union recv_frame *precv_frame)
 				//Add the following statement to avoid receiving duplicate prov disc req. such that pre_p2p_state would be covered.
 				if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_RX_PROVISION_DIS_REQ))
 					rtw_p2p_set_pre_state(pwdinfo, rtw_p2p_state(pwdinfo));
-
+				
 				rtw_p2p_set_state(pwdinfo, P2P_STATE_RX_PROVISION_DIS_REQ);
 				_set_timer( &pwdinfo->restore_p2p_state_timer, P2P_PROVISION_TIMEOUT );
 #ifdef CONFIG_INTEL_WIDI
@@ -6076,7 +6076,7 @@ unsigned int on_action_public_default(union recv_frame *precv_frame, u8 action)
 	#endif
 
 	ret = _SUCCESS;
-
+	
 exit:
 	return ret;
 }
@@ -6124,9 +6124,9 @@ unsigned int OnAction_sa_query(_adapter *padapter, union recv_frame *precv_frame
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	unsigned short tid;
 	//Baron
-
+	
 	DBG_871X("OnAction_sa_query\n");
-
+	
 	switch (pframe[WLAN_HDR_A3_LEN+1])
 	{
 		case 0: //SA Query req
@@ -6149,8 +6149,8 @@ unsigned int OnAction_sa_query(_adapter *padapter, union recv_frame *precv_frame
 		for(pp=0;pp< pattrib->pkt_len; pp++)
 			printk(" %02x ", pframe[pp]);
 		printk("\n");
-	}
-
+	}	
+	
 	return _SUCCESS;
 }
 #endif //CONFIG_IEEE80211W
@@ -6168,10 +6168,10 @@ unsigned int OnAction_p2p(_adapter *padapter, union recv_frame *precv_frame)
 	u8 *pframe = precv_frame->u.hdr.rx_data;
 	uint len = precv_frame->u.hdr.len;
 	struct	wifidirect_info	*pwdinfo = &( padapter->wdinfo );
-
+	
 
 	DBG_871X("%s\n", __FUNCTION__);
-
+	
 	//check RA matches or not
 	if (!_rtw_memcmp(myid(&(padapter->eeprompriv)), GetAddr1Ptr(pframe), ETH_ALEN))//for if1, sta/ap mode
 		return _SUCCESS;
@@ -6201,26 +6201,26 @@ unsigned int OnAction_p2p(_adapter *padapter, union recv_frame *precv_frame)
 		switch(OUI_Subtype)
 		{
 			case P2P_NOTICE_OF_ABSENCE:
-
+				
 				break;
-
+				
 			case P2P_PRESENCE_REQUEST:
 
-				process_p2p_presence_req(pwdinfo, pframe, len);
-
+				process_p2p_presence_req(pwdinfo, pframe, len);			
+				
 				break;
-
+				
 			case P2P_PRESENCE_RESPONSE:
-
+				
 				break;
-
+				
 			case P2P_GO_DISC_REQUEST:
-
+				
 				break;
-
+				
 			default:
 				break;
-
+				
 		}
 	}
 #endif //CONFIG_P2P
@@ -6235,19 +6235,19 @@ unsigned int OnAction(_adapter *padapter, union recv_frame *precv_frame)
 	unsigned char	category;
 	struct action_handler *ptable;
 	unsigned char	*frame_body;
-	u8 *pframe = precv_frame->u.hdr.rx_data;
+	u8 *pframe = precv_frame->u.hdr.rx_data; 
 
 	frame_body = (unsigned char *)(pframe + sizeof(struct rtw_ieee80211_hdr_3addr));
-
+	
 	category = frame_body[0];
-
-	for(i = 0; i < sizeof(OnAction_tbl)/sizeof(struct action_handler); i++)
+	
+	for(i = 0; i < sizeof(OnAction_tbl)/sizeof(struct action_handler); i++)	
 	{
 		ptable = &OnAction_tbl[i];
-
+		
 		if(category == ptable->num)
 			ptable->func(padapter, precv_frame);
-
+	
 	}
 
 	return _SUCCESS;
@@ -6339,7 +6339,7 @@ void update_mgntframe_attrib(_adapter *padapter, struct pkt_attrib *pattrib)
 		pattrib->raid = 5;//a/g mode
 
 	pattrib->encrypt = _NO_PRIVACY_;
-	pattrib->bswenc = _FALSE;
+	pattrib->bswenc = _FALSE;	
 
 	pattrib->qos_en = _FALSE;
 	pattrib->ht_en = _FALSE;
@@ -6432,7 +6432,7 @@ s32 dump_mgntframe_and_wait_ack(_adapter *padapter, struct xmit_frame *pmgntfram
 	dump_mgntframe(padapter, pmgntframe);
 	rtw_msleep_os(50);
 	return _SUCCESS;
-#endif //!CONFIG_XMIT_ACK
+#endif //!CONFIG_XMIT_ACK	 
 }
 
 int update_hidden_ssid(u8 *ies, u32 ies_len, u8 hidden_ssid_mode)
@@ -6440,11 +6440,11 @@ int update_hidden_ssid(u8 *ies, u32 ies_len, u8 hidden_ssid_mode)
 	u8 *ssid_ie;
 	sint ssid_len_ori;
 	int len_diff = 0;
-
+	
 	ssid_ie = rtw_get_ie(ies,  WLAN_EID_SSID, &ssid_len_ori, ies_len);
 
 	//DBG_871X("%s hidden_ssid_mode:%u, ssid_ie:%p, ssid_len_ori:%d\n", __FUNCTION__, hidden_ssid_mode, ssid_ie, ssid_len_ori);
-
+	
 	if(ssid_ie && ssid_len_ori>0)
 	{
 		switch(hidden_ssid_mode)
@@ -6453,15 +6453,15 @@ int update_hidden_ssid(u8 *ies, u32 ies_len, u8 hidden_ssid_mode)
 			{
 				u8 *next_ie = ssid_ie + 2 + ssid_len_ori;
 				u32 remain_len = 0;
-
+				
 				remain_len = ies_len -(next_ie-ies);
-
-				ssid_ie[1] = 0;
+				
+				ssid_ie[1] = 0;				
 				_rtw_memcpy(ssid_ie+2, next_ie, remain_len);
 				len_diff -= ssid_len_ori;
-
+				
 				break;
-			}
+			}		
 			case 2:
 				_rtw_memset(&ssid_ie[2], 0, ssid_len_ori);
 				break;
@@ -6510,16 +6510,16 @@ void issue_beacon(_adapter *padapter)
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
 	pattrib->qsel = 0x10;
-
+	
 	_rtw_memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
-
+		
 	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
-	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
-
-
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;	
+	
+	
 	fctrl = &(pwlanhdr->frame_ctl);
 	*(fctrl) = 0;
-
+	
 	_rtw_memcpy(pwlanhdr->addr1, bc_addr, ETH_ALEN);
 	_rtw_memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);
 	_rtw_memcpy(pwlanhdr->addr3, get_my_bssid(cur_network), ETH_ALEN);
@@ -6527,24 +6527,24 @@ void issue_beacon(_adapter *padapter)
 	SetSeqNum(pwlanhdr, 0/*pmlmeext->mgnt_seq*/);
 	//pmlmeext->mgnt_seq++;
 	SetFrameSubType(pframe, WIFI_BEACON);
-
-	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);
+	
+	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);	
 	pattrib->pktlen = sizeof (struct rtw_ieee80211_hdr_3addr);
-
+	
 	if( (pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
 	{
 		//DBG_871X("ie len=%d\n", cur_network->IELength);
 #ifdef CONFIG_P2P
 		// for P2P : Primary Device Type & Device Name
 		u32 wpsielen=0, insert_len=0;
-		u8 *wpsie=NULL;
+		u8 *wpsie=NULL;		
 		wpsie = rtw_get_wps_ie(cur_network->IEs+_FIXED_IE_LENGTH_, cur_network->IELength-_FIXED_IE_LENGTH_, NULL, &wpsielen);
-
+		
 		if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO) && wpsie && wpsielen>0)
 		{
 			uint wps_offset, remainder_ielen;
 			u8 *premainder_ie, *pframe_wscie;
-
+	
 			wps_offset = (uint)(wpsie - cur_network->IEs);
 
 			premainder_ie = wpsie + wpsielen;
@@ -6566,7 +6566,7 @@ void issue_beacon(_adapter *padapter)
 
 					//copy remainder_ie to pframe
 					_rtw_memcpy(pframe, premainder_ie, remainder_ielen);
-					pframe += remainder_ielen;
+					pframe += remainder_ielen;		
 					pattrib->pktlen += remainder_ielen;
 				}
 				else
@@ -6580,8 +6580,8 @@ void issue_beacon(_adapter *padapter)
 #endif //CONFIG_IOCTL_CFG80211
 			{
 				pframe_wscie = pframe + wps_offset;
-				_rtw_memcpy(pframe, cur_network->IEs, wps_offset+wpsielen);
-				pframe += (wps_offset + wpsielen);
+				_rtw_memcpy(pframe, cur_network->IEs, wps_offset+wpsielen);			
+				pframe += (wps_offset + wpsielen);		
 				pattrib->pktlen += (wps_offset + wpsielen);
 
 				//now pframe is end of wsc ie, insert Primary Device Type & Device Name
@@ -6589,11 +6589,11 @@ void issue_beacon(_adapter *padapter)
 				//	Type:
 				*(u16*) ( pframe + insert_len) = cpu_to_be16( WPS_ATTR_PRIMARY_DEV_TYPE );
 				insert_len += 2;
-
+				
 				//	Length:
 				*(u16*) ( pframe + insert_len ) = cpu_to_be16( 0x0008 );
 				insert_len += 2;
-
+				
 				//	Value:
 				//	Category ID
 				*(u16*) ( pframe + insert_len ) = cpu_to_be16( WPS_PDT_CID_MULIT_MEDIA );
@@ -6631,7 +6631,7 @@ void issue_beacon(_adapter *padapter)
 
 				//copy remainder_ie to pframe
 				_rtw_memcpy(pframe, premainder_ie, remainder_ielen);
-				pframe += remainder_ielen;
+				pframe += remainder_ielen;		
 				pattrib->pktlen += remainder_ielen;
 			}
 		}
@@ -6672,7 +6672,7 @@ void issue_beacon(_adapter *padapter)
 			if(wdev_to_priv(padapter->rtw_wdev)->p2p_enabled && pwdinfo->driver_interface == DRIVER_CFG80211 )
 			{
 				len = pmlmepriv->p2p_beacon_ie_len;
-				if(pmlmepriv->p2p_beacon_ie && len>0)
+				if(pmlmepriv->p2p_beacon_ie && len>0)				
 					_rtw_memcpy(pframe, pmlmepriv->p2p_beacon_ie, len);
 			}
 			else
@@ -6692,12 +6692,12 @@ void issue_beacon(_adapter *padapter)
 			}
 #ifdef CONFIG_IOCTL_CFG80211
 			else
-			{
+			{	
 				len = 0;
 				if(pmlmepriv->wfd_beacon_ie && pmlmepriv->wfd_beacon_ie_len>0)
 				{
 					len = pmlmepriv->wfd_beacon_ie_len;
-					_rtw_memcpy(pframe, pmlmepriv->wfd_beacon_ie, len);
+					_rtw_memcpy(pframe, pmlmepriv->wfd_beacon_ie, len);	
 				}
 			}
 #endif //CONFIG_IOCTL_CFG80211
@@ -6719,7 +6719,7 @@ void issue_beacon(_adapter *padapter)
 
 	// beacon interval: 2 bytes
 
-	_rtw_memcpy(pframe, (unsigned char *)(rtw_get_beacon_interval_from_ie(cur_network->IEs)), 2);
+	_rtw_memcpy(pframe, (unsigned char *)(rtw_get_beacon_interval_from_ie(cur_network->IEs)), 2); 
 
 	pframe += 2;
 	pattrib->pktlen += 2;
@@ -6752,7 +6752,7 @@ void issue_beacon(_adapter *padapter)
 
 		//ERP IE
 		pframe = rtw_set_ie(pframe, _ERPINFO_IE_, 1, &erpinfo, &pattrib->pktlen);
-	}
+	}	
 
 
 	// EXTERNDED SUPPORTED RATE
@@ -6768,8 +6768,8 @@ void issue_beacon(_adapter *padapter)
 
 #if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
 	pmlmepriv->update_bcn = _FALSE;
-
-	_exit_critical_bh(&pmlmepriv->bcn_update_lock, &irqL);
+	
+	_exit_critical_bh(&pmlmepriv->bcn_update_lock, &irqL);	
 #endif //#if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
 
 	if ((pattrib->pktlen + TXDESC_SIZE) > 512)
@@ -6777,7 +6777,7 @@ void issue_beacon(_adapter *padapter)
 		DBG_871X("beacon frame too large\n");
 		return;
 	}
-
+	
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
 	//DBG_871X("issue bcn_sz=%d\n", pattrib->last_txcmdsz);
@@ -6792,7 +6792,7 @@ void issue_probersp(_adapter *padapter, unsigned char *da, u8 is_valid_p2p_probe
 	struct pkt_attrib			*pattrib;
 	unsigned char					*pframe;
 	struct rtw_ieee80211_hdr	*pwlanhdr;
-	unsigned short				*fctrl;
+	unsigned short				*fctrl;	
 	unsigned char					*mac, *bssid;
 	struct xmit_priv	*pxmitpriv = &(padapter->xmitpriv);
 #if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
@@ -6822,16 +6822,16 @@ void issue_probersp(_adapter *padapter, unsigned char *da, u8 is_valid_p2p_probe
 
 	//update attribute
 	pattrib = &pmgntframe->attrib;
-	update_mgntframe_attrib(padapter, pattrib);
-
+	update_mgntframe_attrib(padapter, pattrib);	
+	
 	_rtw_memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
-
+		
 	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
-	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
-
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;	
+	
 	mac = myid(&(padapter->eeprompriv));
 	bssid = cur_network->MacAddress;
-
+	
 	fctrl = &(pwlanhdr->frame_ctl);
 	*(fctrl) = 0;
 	_rtw_memcpy(pwlanhdr->addr1, da, ETH_ALEN);
@@ -6841,7 +6841,7 @@ void issue_probersp(_adapter *padapter, unsigned char *da, u8 is_valid_p2p_probe
 	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
 	pmlmeext->mgnt_seq++;
 	SetFrameSubType(fctrl, WIFI_PROBERSP);
-
+	
 	pattrib->hdrlen = sizeof(struct rtw_ieee80211_hdr_3addr);
 	pattrib->pktlen = pattrib->hdrlen;
 	pframe += pattrib->hdrlen;
@@ -6849,41 +6849,41 @@ void issue_probersp(_adapter *padapter, unsigned char *da, u8 is_valid_p2p_probe
 
 	if(cur_network->IELength>MAX_IE_SZ)
 		return;
-
+	
 #if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
 	if( (pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
 	{
 		pwps_ie = rtw_get_wps_ie(cur_network->IEs+_FIXED_IE_LENGTH_, cur_network->IELength-_FIXED_IE_LENGTH_, NULL, &wps_ielen);
-
+	
 		//inerset & update wps_probe_resp_ie
 		if((pmlmepriv->wps_probe_resp_ie!=NULL) && pwps_ie && (wps_ielen>0))
 		{
 			uint wps_offset, remainder_ielen;
-			u8 *premainder_ie;
-
+			u8 *premainder_ie;		
+	
 			wps_offset = (uint)(pwps_ie - cur_network->IEs);
 
 			premainder_ie = pwps_ie + wps_ielen;
 
 			remainder_ielen = cur_network->IELength - wps_offset - wps_ielen;
 
-			_rtw_memcpy(pframe, cur_network->IEs, wps_offset);
-			pframe += wps_offset;
-			pattrib->pktlen += wps_offset;
+			_rtw_memcpy(pframe, cur_network->IEs, wps_offset);		
+			pframe += wps_offset;		
+			pattrib->pktlen += wps_offset;		
 
 			wps_ielen = (uint)pmlmepriv->wps_probe_resp_ie[1];//to get ie data len
 			if((wps_offset+wps_ielen+2)<=MAX_IE_SZ)
 			{
 				_rtw_memcpy(pframe, pmlmepriv->wps_probe_resp_ie, wps_ielen+2);
-				pframe += wps_ielen+2;
-				pattrib->pktlen += wps_ielen+2;
+				pframe += wps_ielen+2;		
+				pattrib->pktlen += wps_ielen+2;	
 			}
 
 			if((wps_offset+wps_ielen+2+remainder_ielen)<=MAX_IE_SZ)
 			{
 				_rtw_memcpy(pframe, premainder_ie, remainder_ielen);
-				pframe += remainder_ielen;
-				pattrib->pktlen += remainder_ielen;
+				pframe += remainder_ielen;		
+				pattrib->pktlen += remainder_ielen;	
 			}
 		}
 		else
@@ -6926,18 +6926,18 @@ void issue_probersp(_adapter *padapter, unsigned char *da, u8 is_valid_p2p_probe
 				pattrib->pktlen += ssid_ielen_diff;
 			}
 		}
-	}
-	else
-#endif
+	}	
+	else		
+#endif		
 	{
-
+	
 		//timestamp will be inserted by hardware
 		pframe += 8;
 		pattrib->pktlen += 8;
 
 		// beacon interval: 2 bytes
 
-		_rtw_memcpy(pframe, (unsigned char *)(rtw_get_beacon_interval_from_ie(cur_network->IEs)), 2);
+		_rtw_memcpy(pframe, (unsigned char *)(rtw_get_beacon_interval_from_ie(cur_network->IEs)), 2); 
 
 		pframe += 2;
 		pattrib->pktlen += 2;
@@ -6974,7 +6974,7 @@ void issue_probersp(_adapter *padapter, unsigned char *da, u8 is_valid_p2p_probe
 			pframe = rtw_set_ie(pframe, _ERPINFO_IE_, 1, &erpinfo, &pattrib->pktlen);
 		}
 
-
+		
 		// EXTERNDED SUPPORTED RATE
 		if (rate_len > 8)
 		{
@@ -6984,7 +6984,7 @@ void issue_probersp(_adapter *padapter, unsigned char *da, u8 is_valid_p2p_probe
 
 		//todo:HT for adhoc
 
-	}
+	}	
 
 #ifdef CONFIG_P2P
 	if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO) /*&& is_valid_p2p_probereq*/)
@@ -7006,7 +7006,7 @@ void issue_probersp(_adapter *padapter, unsigned char *da, u8 is_valid_p2p_probe
 
 		pframe += len;
 		pattrib->pktlen += len;
-
+		
 #ifdef CONFIG_WFD
 #ifdef CONFIG_IOCTL_CFG80211
 		if(_TRUE == pwdinfo->wfd_info->wfd_enable)
@@ -7016,15 +7016,15 @@ void issue_probersp(_adapter *padapter, unsigned char *da, u8 is_valid_p2p_probe
 		}
 #ifdef CONFIG_IOCTL_CFG80211
 		else
-		{
+		{	
 			len = 0;
 			if(pmlmepriv->wfd_probe_resp_ie && pmlmepriv->wfd_probe_resp_ie_len>0)
 			{
 				len = pmlmepriv->wfd_probe_resp_ie_len;
-				_rtw_memcpy(pframe, pmlmepriv->wfd_probe_resp_ie, len);
-			}
+				_rtw_memcpy(pframe, pmlmepriv->wfd_probe_resp_ie, len);	
+			}	
 		}
-#endif //CONFIG_IOCTL_CFG80211
+#endif //CONFIG_IOCTL_CFG80211		
 		pframe += len;
 		pattrib->pktlen += len;
 #endif //CONFIG_WFD
@@ -7065,10 +7065,10 @@ void issue_probersp(_adapter *padapter, unsigned char *da, u8 is_valid_p2p_probe
 
 
 	pattrib->last_txcmdsz = pattrib->pktlen;
-
+	
 
 	dump_mgntframe(padapter, pmgntframe);
-
+	
 	return;
 
 }
@@ -7158,8 +7158,8 @@ int _issue_probereq(_adapter *padapter, NDIS_802_11_SSID *pssid, u8 *da, int wai
 		_rtw_memcpy(pframe, pmlmepriv->probereq_wpsie, pmlmepriv->probereq_wpsie_len);
 		pframe += pmlmepriv->probereq_wpsie_len;
 		pattrib->pktlen += pmlmepriv->probereq_wpsie_len;
-		//pmlmepriv->probereq_wpsie_len = 0 ;//reset to zero
-	}
+		//pmlmepriv->probereq_wpsie_len = 0 ;//reset to zero		
+	}	
 #else
 	//add wps_ie for wps2.0
 	if(pmlmepriv->wps_probe_req_ie_len>0 && pmlmepriv->wps_probe_req_ie)
@@ -7167,8 +7167,8 @@ int _issue_probereq(_adapter *padapter, NDIS_802_11_SSID *pssid, u8 *da, int wai
 		_rtw_memcpy(pframe, pmlmepriv->wps_probe_req_ie, pmlmepriv->wps_probe_req_ie_len);
 		pframe += pmlmepriv->wps_probe_req_ie_len;
 		pattrib->pktlen += pmlmepriv->wps_probe_req_ie_len;
-		//pmlmepriv->wps_probe_req_ie_len = 0 ;//reset to zero
-	}
+		//pmlmepriv->wps_probe_req_ie_len = 0 ;//reset to zero		
+	}	
 #endif
 
 	pattrib->last_txcmdsz = pattrib->pktlen;
@@ -7277,19 +7277,19 @@ void issue_auth(_adapter *padapter, struct sta_info *psta, unsigned short status
 	{
 #ifdef CONFIG_NATIVEAP_MLME
 
-		_rtw_memcpy(pwlanhdr->addr1, psta->hwaddr, ETH_ALEN);
+		_rtw_memcpy(pwlanhdr->addr1, psta->hwaddr, ETH_ALEN);		
 		_rtw_memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);
 		_rtw_memcpy(pwlanhdr->addr3, myid(&(padapter->eeprompriv)), ETH_ALEN);
 
-
-		// setting auth algo number
+	
+		// setting auth algo number	
 		val16 = (u16)psta->authalg;
 
 		if(status != _STATS_SUCCESSFUL_)
 			val16 = 0;
 
 		if (val16)	{
-			val16 = cpu_to_le16(val16);
+			val16 = cpu_to_le16(val16);	
 			use_shared_key = 1;
 		}
 
@@ -7297,35 +7297,35 @@ void issue_auth(_adapter *padapter, struct sta_info *psta, unsigned short status
 
 		// setting auth seq number
 		val16 =(u16)psta->auth_seq;
-		val16 = cpu_to_le16(val16);
+		val16 = cpu_to_le16(val16);	
 		pframe = rtw_set_fixed_ie(pframe, _AUTH_SEQ_NUM_, (unsigned char *)&val16, &(pattrib->pktlen));
 
 		// setting status code...
 		val16 = status;
-		val16 = cpu_to_le16(val16);
+		val16 = cpu_to_le16(val16);	
 		pframe = rtw_set_fixed_ie(pframe, _STATUS_CODE_, (unsigned char *)&val16, &(pattrib->pktlen));
 
 		// added challenging text...
 		if ((psta->auth_seq == 2) && (psta->state & WIFI_FW_AUTH_STATE) && (use_shared_key==1))
 		{
-			pframe = rtw_set_ie(pframe, _CHLGETXT_IE_, 128, psta->chg_txt, &(pattrib->pktlen));
+			pframe = rtw_set_ie(pframe, _CHLGETXT_IE_, 128, psta->chg_txt, &(pattrib->pktlen));			
 		}
 #endif
 	}
 	else
-	{
+	{		
 		_rtw_memcpy(pwlanhdr->addr1, get_my_bssid(&pmlmeinfo->network), ETH_ALEN);
 		_rtw_memcpy(pwlanhdr->addr2, myid(&padapter->eeprompriv), ETH_ALEN);
 		_rtw_memcpy(pwlanhdr->addr3, get_my_bssid(&pmlmeinfo->network), ETH_ALEN);
-
-		// setting auth algo number
+	
+		// setting auth algo number		
 		val16 = (pmlmeinfo->auth_algo == dot11AuthAlgrthm_Shared)? 1: 0;// 0:OPEN System, 1:Shared key
 		if (val16)	{
-			val16 = cpu_to_le16(val16);
+			val16 = cpu_to_le16(val16);	
 			use_shared_key = 1;
-		}
+		}	
 		//DBG_871X("%s auth_algo= %s auth_seq=%d\n",__FUNCTION__,(pmlmeinfo->auth_algo==0)?"OPEN":"SHARED",pmlmeinfo->auth_seq);
-
+		
 		//setting IV for auth seq #3
 		if ((pmlmeinfo->auth_seq == 3) && (pmlmeinfo->state & WIFI_FW_AUTH_STATE) && (use_shared_key==1))
 		{
@@ -7338,16 +7338,16 @@ void issue_auth(_adapter *padapter, struct sta_info *psta, unsigned short status
 		}
 
 		pframe = rtw_set_fixed_ie(pframe, _AUTH_ALGM_NUM_, (unsigned char *)&val16, &(pattrib->pktlen));
-
+		
 		// setting auth seq number
 		val16 = pmlmeinfo->auth_seq;
-		val16 = cpu_to_le16(val16);
+		val16 = cpu_to_le16(val16);	
 		pframe = rtw_set_fixed_ie(pframe, _AUTH_SEQ_NUM_, (unsigned char *)&val16, &(pattrib->pktlen));
 
-
+		
 		// setting status code...
 		val16 = status;
-		val16 = cpu_to_le16(val16);
+		val16 = cpu_to_le16(val16);	
 		pframe = rtw_set_fixed_ie(pframe, _STATUS_CODE_, (unsigned char *)&val16, &(pattrib->pktlen));
 
 		// then checking to see if sending challenging text...
@@ -7356,17 +7356,17 @@ void issue_auth(_adapter *padapter, struct sta_info *psta, unsigned short status
 			pframe = rtw_set_ie(pframe, _CHLGETXT_IE_, 128, pmlmeinfo->chg_txt, &(pattrib->pktlen));
 
 			SetPrivacy(fctrl);
-
-			pattrib->hdrlen = sizeof(struct rtw_ieee80211_hdr_3addr);
-
+			
+			pattrib->hdrlen = sizeof(struct rtw_ieee80211_hdr_3addr);			
+			
 			pattrib->encrypt = _WEP40_;
 
 			pattrib->icv_len = 4;
-
-			pattrib->pktlen += pattrib->icv_len;
-
+			
+			pattrib->pktlen += pattrib->icv_len;			
+			
 		}
-
+		
 	}
 
 	pattrib->last_txcmdsz = pattrib->pktlen;
@@ -7386,14 +7386,14 @@ void issue_asocrsp(_adapter *padapter, unsigned short status, struct sta_info *p
 	struct rtw_ieee80211_hdr	*pwlanhdr;
 	struct pkt_attrib *pattrib;
 	unsigned char	*pbuf, *pframe;
-	unsigned short val;
+	unsigned short val;		
 	unsigned short *fctrl;
 	struct xmit_priv *pxmitpriv = &(padapter->xmitpriv);
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
-	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);	
 	WLAN_BSSID_EX *pnetwork = &(pmlmeinfo->network);
-	u8 *ie = pnetwork->IEs;
+	u8 *ie = pnetwork->IEs; 
 #ifdef CONFIG_P2P
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 #ifdef CONFIG_WFD
@@ -7429,7 +7429,7 @@ void issue_asocrsp(_adapter *padapter, unsigned short status, struct sta_info *p
 	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
 	pmlmeext->mgnt_seq++;
 	if ((pkt_type == WIFI_ASSOCRSP) || (pkt_type == WIFI_REASSOCRSP))
-		SetFrameSubType(pwlanhdr, pkt_type);
+		SetFrameSubType(pwlanhdr, pkt_type);		
 	else
 		return;
 
@@ -7444,15 +7444,15 @@ void issue_asocrsp(_adapter *padapter, unsigned short status, struct sta_info *p
 
 	status = cpu_to_le16(status);
 	pframe = rtw_set_fixed_ie(pframe , _STATUS_CODE_ , (unsigned char *)&status, &(pattrib->pktlen));
-
+	
 	val = cpu_to_le16(pstat->aid | BIT(14) | BIT(15));
 	pframe = rtw_set_fixed_ie(pframe, _ASOC_ID_ , (unsigned char *)&val, &(pattrib->pktlen));
 
 	if (pstat->bssratelen <= 8)
 	{
 		pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, pstat->bssratelen, pstat->bssrateset, &(pattrib->pktlen));
-	}
-	else
+	}	
+	else 
 	{
 		pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, 8, pstat->bssrateset, &(pattrib->pktlen));
 		pframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_, (pstat->bssratelen-8), pstat->bssrateset+8, &(pattrib->pktlen));
@@ -7462,7 +7462,7 @@ void issue_asocrsp(_adapter *padapter, unsigned short status, struct sta_info *p
 	if ((pstat->flags & WLAN_STA_HT) && (pmlmepriv->htpriv.ht_option))
 	{
 		uint ie_len=0;
-
+		
 		//FILL HT CAP INFO IE
 		//p = hostapd_eid_ht_capabilities_info(hapd, p);
 		pbuf = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _HT_CAPABILITY_IE_, &ie_len, (pnetwork->IELength - _BEACON_IE_OFFSET_));
@@ -7482,34 +7482,34 @@ void issue_asocrsp(_adapter *padapter, unsigned short status, struct sta_info *p
 			pframe += (ie_len+2);
 			pattrib->pktlen +=(ie_len+2);
 		}
-
-	}
+		
+	}	
 #endif
 
 	//FILL WMM IE
 	if ((pstat->flags & WLAN_STA_WME) && (pmlmepriv->qospriv.qos_option))
 	{
 		uint ie_len=0;
-		unsigned char WMM_PARA_IE[] = {0x00, 0x50, 0xf2, 0x02, 0x01, 0x01};
-
+		unsigned char WMM_PARA_IE[] = {0x00, 0x50, 0xf2, 0x02, 0x01, 0x01};	
+		
 		for (pbuf = ie + _BEACON_IE_OFFSET_; ;pbuf+= (ie_len + 2))
-		{
-			pbuf = rtw_get_ie(pbuf, _VENDOR_SPECIFIC_IE_, &ie_len, (pnetwork->IELength - _BEACON_IE_OFFSET_ - (ie_len + 2)));
-			if(pbuf && _rtw_memcmp(pbuf+2, WMM_PARA_IE, 6))
-			{
+		{			
+			pbuf = rtw_get_ie(pbuf, _VENDOR_SPECIFIC_IE_, &ie_len, (pnetwork->IELength - _BEACON_IE_OFFSET_ - (ie_len + 2)));	
+			if(pbuf && _rtw_memcmp(pbuf+2, WMM_PARA_IE, 6)) 
+			{				
 				_rtw_memcpy(pframe, pbuf, ie_len+2);
 				pframe += (ie_len+2);
 				pattrib->pktlen +=(ie_len+2);
-
-				break;
+				
+				break;				
 			}
-
+			
 			if ((pbuf == NULL) || (ie_len == 0))
 			{
 				break;
-			}
+			}			
 		}
-
+		
 	}
 
 
@@ -7522,7 +7522,7 @@ void issue_asocrsp(_adapter *padapter, unsigned short status, struct sta_info *p
 	if(pmlmepriv->wps_assoc_resp_ie && pmlmepriv->wps_assoc_resp_ie_len>0)
 	{
 		_rtw_memcpy(pframe, pmlmepriv->wps_assoc_resp_ie, pmlmepriv->wps_assoc_resp_ie_len);
-
+		
 		pframe += pmlmepriv->wps_assoc_resp_ie_len;
 		pattrib->pktlen += pmlmepriv->wps_assoc_resp_ie_len;
 	}
@@ -7542,9 +7542,9 @@ void issue_asocrsp(_adapter *padapter, unsigned short status, struct sta_info *p
 	}
 #ifdef CONFIG_WFD
 	if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)
-#ifdef CONFIG_IOCTL_CFG80211
+#ifdef CONFIG_IOCTL_CFG80211		
 		&& (_TRUE == pwdinfo->wfd_info->wfd_enable)
-#endif //CONFIG_IOCTL_CFG80211
+#endif //CONFIG_IOCTL_CFG80211	
 	)
 	{
 		wfdielen = build_assoc_resp_wfd_ie(pwdinfo, pframe);
@@ -7555,9 +7555,9 @@ void issue_asocrsp(_adapter *padapter, unsigned short status, struct sta_info *p
 #endif //CONFIG_P2P
 
 	pattrib->last_txcmdsz = pattrib->pktlen;
-
+	
 	dump_mgntframe(padapter, pmgntframe);
-
+	
 #endif
 }
 
@@ -7583,7 +7583,7 @@ void issue_assocreq(_adapter *padapter)
 #ifdef CONFIG_P2P
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 	u8					p2pie[ 255 ] = { 0x00 };
-	u16					p2pielen = 0;
+	u16					p2pielen = 0;	
 #ifdef CONFIG_WFD
 	u32					wfdielen = 0;
 #endif //CONFIG_WFD
@@ -7650,13 +7650,13 @@ void issue_assocreq(_adapter *padapter)
 #if 1	// Check if the AP's supported rates are also supported by STA.
 	get_rate_set(padapter, sta_bssrate, &sta_bssrate_len);
 	//DBG_871X("sta_bssrate_len=%d\n", sta_bssrate_len);
-
-	if(pmlmeext->cur_channel == 14)// for JAPAN, channel 14 can only uses B Mode(CCK)
+	
+	if(pmlmeext->cur_channel == 14)// for JAPAN, channel 14 can only uses B Mode(CCK) 
 	{
 		sta_bssrate_len = 4;
 	}
 
-
+	
 	//for (i = 0; i < sta_bssrate_len; i++) {
 	//	DBG_871X("sta_bssrate[%d]=%02X\n", i, sta_bssrate[i]);
 	//}
@@ -7665,16 +7665,16 @@ void issue_assocreq(_adapter *padapter)
 		if (pmlmeinfo->network.SupportedRates[i] == 0) break;
 		DBG_871X("network.SupportedRates[%d]=%02X\n", i, pmlmeinfo->network.SupportedRates[i]);
 	}
-
+	
 
 	for (i = 0; i < NDIS_802_11_LENGTH_RATES_EX; i++) {
 		if (pmlmeinfo->network.SupportedRates[i] == 0) break;
 
-
+		
 		// Check if the AP's supported rates are also supported by STA.
 		for (j=0; j < sta_bssrate_len; j++) {
 			 // Avoid the proprietary data rate (22Mbps) of Handlink WSG-4000 AP
-			if ( (pmlmeinfo->network.SupportedRates[i]|IEEE80211_BASIC_RATE_MASK)
+			if ( (pmlmeinfo->network.SupportedRates[i]|IEEE80211_BASIC_RATE_MASK) 
 					== (sta_bssrate[j]|IEEE80211_BASIC_RATE_MASK)) {
 				//DBG_871X("match i = %d, j=%d\n", i, j);
 				break;
@@ -7682,7 +7682,7 @@ void issue_assocreq(_adapter *padapter)
 				//DBG_871X("not match: %02X != %02X\n", (pmlmeinfo->network.SupportedRates[i]|IEEE80211_BASIC_RATE_MASK), (sta_bssrate[j]|IEEE80211_BASIC_RATE_MASK));
 			}
 		}
-
+		
 		if (j == sta_bssrate_len) {
 			// the rate is not supported by STA
 			DBG_871X("%s(): the rate[%d]=%02X is not supported by STA!\n",__FUNCTION__, i, pmlmeinfo->network.SupportedRates[i]);
@@ -7691,7 +7691,7 @@ void issue_assocreq(_adapter *padapter)
 			bssrate[index++] = pmlmeinfo->network.SupportedRates[i];
 		}
 	}
-
+	
 	bssrate_len = index;
 	DBG_871X("bssrate_len = %d\n", bssrate_len);
 
@@ -7796,17 +7796,17 @@ void issue_assocreq(_adapter *padapter)
 			switch(rf_type)
 			{
 				case RF_1T1R:
-
+				
 					if(pregpriv->rx_stbc)
 						pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info |= cpu_to_le16(0x0100);//RX STBC One spatial stream
-
+						
 					_rtw_memcpy(pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate, MCS_rate_1R, 16);
 					break;
 
 				case RF_2T2R:
 				case RF_1T2R:
 				default:
-
+					
 
 					if(pregpriv->special_rf_path)
 					{
@@ -7816,7 +7816,7 @@ void issue_assocreq(_adapter *padapter)
 						break;
 					}
 
-					if((pregpriv->rx_stbc == 0x3) ||//enable for 2.4/5 GHz
+					if((pregpriv->rx_stbc == 0x3) ||//enable for 2.4/5 GHz	
 						((pmlmeext->cur_wireless_mode & WIRELESS_11_24N) && (pregpriv->rx_stbc == 0x1)) || //enable for 2.4GHz
 						((pmlmeext->cur_wireless_mode & WIRELESS_11_5N) && (pregpriv->rx_stbc == 0x2)) || //enable for 5GHz
 						(pregpriv->wifi_spec==1))
@@ -7838,7 +7838,7 @@ void issue_assocreq(_adapter *padapter)
 			{
 				if(pregpriv->rx_stbc)
 					pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info |= cpu_to_le16(0x0100);//RX STBC One spatial stream
-
+			
 				_rtw_memcpy(pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate, MCS_rate_1R, 16);
 			}
 #endif
@@ -7903,9 +7903,9 @@ void issue_assocreq(_adapter *padapter)
 	{
 		if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) && !rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE))
 		{
-			//	Should add the P2P IE in the association request frame.
+			//	Should add the P2P IE in the association request frame.	
 			//	P2P OUI
-
+			
 			p2pielen = 0;
 			p2pie[ p2pielen++ ] = 0x50;
 			p2pie[ p2pielen++ ] = 0x6F;
@@ -7960,7 +7960,7 @@ void issue_assocreq(_adapter *padapter)
 			p2pie[ p2pielen++ ] = P2P_ATTR_DEVICE_INFO;
 
 			//	Length:
-			//	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes)
+			//	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) 
 			//	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes)
 			*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 21 + pwdinfo->device_name_len );
 			p2pielen += 2;
@@ -8012,24 +8012,24 @@ void issue_assocreq(_adapter *padapter)
 			//	Value:
 			_rtw_memcpy( p2pie + p2pielen, pwdinfo->device_name, pwdinfo->device_name_len );
 			p2pielen += pwdinfo->device_name_len;
-
+		
 			//	P2P Interface
 			//	Type:
 			p2pie[ p2pielen++ ] = P2P_ATTR_INTERFACE;
-
+			
 			//	Length:
 			*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 0x000D );
 			p2pielen += 2;
-
+			
 			//	Value:
 			_rtw_memcpy( p2pie + p2pielen, pwdinfo->device_addr, ETH_ALEN );	//	P2P Device Address
 			p2pielen += ETH_ALEN;
 
 			p2pie[ p2pielen++ ] = 1;	//	P2P Interface Address Count
-
+			
 			_rtw_memcpy( p2pie + p2pielen, pwdinfo->device_addr, ETH_ALEN );	//	P2P Interface Address List
 			p2pielen += ETH_ALEN;
-
+		
 			pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2pie, &pattrib->pktlen );
 
 #ifdef CONFIG_WFD
@@ -8052,15 +8052,15 @@ void issue_assocreq(_adapter *padapter)
 		pattrib->pktlen += wfdielen;
 	}
 #ifdef CONFIG_IOCTL_CFG80211
-	else if (pmlmepriv->wfd_assoc_req_ie != NULL && pmlmepriv->wfd_assoc_req_ie_len>0)
+	else if (pmlmepriv->wfd_assoc_req_ie != NULL && pmlmepriv->wfd_assoc_req_ie_len>0)		
 	{
 		//WFD IE
 		_rtw_memcpy(pframe, pmlmepriv->wfd_assoc_req_ie, pmlmepriv->wfd_assoc_req_ie_len);
 		pattrib->pktlen += pmlmepriv->wfd_assoc_req_ie_len;
-		pframe += pmlmepriv->wfd_assoc_req_ie_len;
+		pframe += pmlmepriv->wfd_assoc_req_ie_len;		
 	}
 #endif //CONFIG_IOCTL_CFG80211
-#endif //CONFIG_WFD
+#endif //CONFIG_WFD	
 
 	pattrib->last_txcmdsz = pattrib->pktlen;
 	dump_mgntframe(padapter, pmgntframe);
@@ -8124,7 +8124,7 @@ static int _issue_nulldata(_adapter *padapter, unsigned char *da, unsigned int p
 	{
 		SetToDs(fctrl);
 	}
-
+	
 	if (power_mode)
 	{
 		SetPwrMgt(fctrl);
@@ -8258,7 +8258,7 @@ static int _issue_qos_nulldata(_adapter *padapter, unsigned char *da, u16 tid, i
 		SetMData(fctrl);
 
 	qc = (unsigned short *)(pframe + pattrib->hdrlen - 2);
-
+	
 	SetPriority(qc, tid);
 
 	SetEOSP(qc, pattrib->eosp);
@@ -8277,7 +8277,7 @@ static int _issue_qos_nulldata(_adapter *padapter, unsigned char *da, u16 tid, i
 	pattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr_qos);
 
 	pattrib->last_txcmdsz = pattrib->pktlen;
-
+	
 	if(wait_ack)
 	{
 		ret = dump_mgntframe_and_wait_ack(padapter, pmgntframe);
@@ -8305,7 +8305,7 @@ int issue_qos_nulldata(_adapter *padapter, unsigned char *da, u16 tid, int try_c
 	/* da == NULL, assum it's null data for sta to ap*/
 	if (da == NULL)
 		da = get_my_bssid(&(pmlmeinfo->network));
-
+	
 	do
 	{
 		ret = _issue_qos_nulldata(padapter, da, tid, wait_ms>0?_TRUE:_FALSE);
@@ -8355,7 +8355,7 @@ static int _issue_deauth(_adapter *padapter, unsigned char *da, unsigned short r
 #ifdef CONFIG_P2P
 	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
 #endif //CONFIG_P2P
-
+	
 	//DBG_871X("%s to "MAC_FMT"\n", __func__, MAC_ARG(da));
 
 #ifdef CONFIG_P2P
@@ -8464,7 +8464,7 @@ int issue_deauth_ex(_adapter *padapter, u8 *da, unsigned short reason, int try_c
 }
 
 void issue_action_spct_ch_switch(_adapter *padapter, u8 *ra, u8 new_ch, u8 ch_offset)
-{
+{	
 	_irqL	irqL;
 	_list		*plist, *phead;
 	struct xmit_frame			*pmgntframe;
@@ -8661,7 +8661,7 @@ void issue_action_BA(_adapter *padapter, unsigned char *raddr, unsigned char act
 	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
 
       status = cpu_to_le16(status);
-
+	
 
 	if (category == 3)
 	{
@@ -8689,12 +8689,12 @@ void issue_action_BA(_adapter *padapter, unsigned char *raddr, unsigned char act
 					start_seq = (psta->sta_xmitpriv.txseq_tid[status & 0x07]&0xfff) + 1;
 
 					DBG_871X("BA_starting_seqctrl = %d for TID=%d\n", start_seq, status & 0x07);
-
+					
 					psta->BA_starting_seqctrl[status & 0x07] = start_seq;
-
+					
 					BA_starting_seqctrl = start_seq << 4;
 				}
-
+				
 				BA_starting_seqctrl = cpu_to_le16(BA_starting_seqctrl);
 				pframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&(BA_starting_seqctrl)), &(pattrib->pktlen));
 				break;
@@ -8712,13 +8712,13 @@ void issue_action_BA(_adapter *padapter, unsigned char *raddr, unsigned char act
 					BA_para_set = cpu_to_le16(BA_para_set | BIT(0));
 				else //auto
 					BA_para_set = cpu_to_le16(BA_para_set);
-
+				
 				pframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&(BA_para_set)), &(pattrib->pktlen));
 				pframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&(pmlmeinfo->ADDBA_req.BA_timeout_value)), &(pattrib->pktlen));
 				break;
 			case 2://DELBA
 				BA_para_set = (status & 0x1F) << 3;
-				BA_para_set = cpu_to_le16(BA_para_set);
+				BA_para_set = cpu_to_le16(BA_para_set);				
 				pframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&(BA_para_set)), &(pattrib->pktlen));
 
 				reason_code = 37;//Requested from peer STA as it does not want to use the mechanism
@@ -8736,7 +8736,7 @@ void issue_action_BA(_adapter *padapter, unsigned char *raddr, unsigned char act
 }
 
 static void issue_action_BSSCoexistPacket(_adapter *padapter)
-{
+{	
 	_irqL	irqL;
 	_list		*plist, *phead;
 	unsigned char category, action;
@@ -8753,13 +8753,13 @@ static void issue_action_BSSCoexistPacket(_adapter *padapter)
 	_queue		*queue	= &(pmlmepriv->scanned_queue);
 	u8 InfoContent[16] = {0};
 	u8 ICS[8][15];
-
+	
 	if((pmlmepriv->num_FortyMHzIntolerant==0) || (pmlmepriv->num_sta_no_ht==0))
 		return;
 
 	if(_TRUE == pmlmeinfo->bwmode_updated)
 		return;
-
+	
 
 	DBG_871X("%s\n", __FUNCTION__);
 
@@ -8803,36 +8803,36 @@ static void issue_action_BSSCoexistPacket(_adapter *padapter)
 	if(pmlmepriv->num_FortyMHzIntolerant>0)
 	{
 		u8 iedata=0;
-
+		
 		iedata |= BIT(2);//20 MHz BSS Width Request
 
 		pframe = rtw_set_ie(pframe, EID_BSSCoexistence,  1, &iedata, &(pattrib->pktlen));
-
+		
 	}
-
+	
 
 	//
 	_rtw_memset(ICS, 0, sizeof(ICS));
 	if(pmlmepriv->num_sta_no_ht>0)
-	{
+	{	
 		int i;
-
+	
 		_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
 
 		phead = get_list_head(queue);
 		plist = get_next(phead);
-
+       
 		while(1)
 		{
 			int len;
 			u8 *p;
 			WLAN_BSSID_EX *pbss_network;
-
+	
 			if (rtw_end_of_queue_search(phead,plist)== _TRUE)
-				break;
-
-			pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
+				break;		
 
+			pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);      
+		
 			plist = get_next(plist);
 
 			pbss_network = (WLAN_BSSID_EX *)&pnetwork->network;
@@ -8842,14 +8842,14 @@ static void issue_action_BSSCoexistPacket(_adapter *padapter)
 			{
 				if((pbss_network->Configuration.DSConfig<=0) || (pbss_network->Configuration.DSConfig>14))
 					continue;
-
+				
 				ICS[0][pbss_network->Configuration.DSConfig]=1;
-
+				
 				if(ICS[0][0] == 0)
-					ICS[0][0] = 1;
-			}
-
-		}
+					ICS[0][0] = 1;		
+			}		
+	
+		}        
 
 		_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
 
@@ -8859,11 +8859,11 @@ static void issue_action_BSSCoexistPacket(_adapter *padapter)
 			if(ICS[i][0] == 1)
 			{
 				int j, k = 0;
-
-				InfoContent[k] = i;
+				
+				InfoContent[k] = i;				
 				//SET_BSS_INTOLERANT_ELE_REG_CLASS(InfoContent,i);
 				k++;
-
+				
 				for(j=1;j<=14;j++)
 				{
 					if(ICS[i][j]==1)
@@ -8873,19 +8873,19 @@ static void issue_action_BSSCoexistPacket(_adapter *padapter)
 							InfoContent[k] = j; //channel number
 							//SET_BSS_INTOLERANT_ELE_CHANNEL(InfoContent+k, j);
 							k++;
-						}
-					}
-				}
+						}	
+					}	
+				}	
 
 				pframe = rtw_set_ie(pframe, EID_BSSIntolerantChlReport, k, InfoContent, &(pattrib->pktlen));
-
+				
 			}
-
+			
 		}
-
+		
 
 	}
-
+		
 
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
@@ -8902,16 +8902,16 @@ unsigned int send_delba(_adapter *padapter, u8 initiator, u8 *addr)
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	u16 tid;
 
-	if((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE)
+	if((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE)	
 		if (!(pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS))
 			return _SUCCESS;
-
+	
 	psta = rtw_get_stainfo(pstapriv, addr);
 	if(psta==NULL)
 		return _SUCCESS;
 
 	//DBG_871X("%s:%s\n", __FUNCTION__, (initiator==0)?"RX_DIR":"TX_DIR");
-
+	
 	if(initiator==0) // recipient
 	{
 		for(tid = 0;tid<MAXTID;tid++)
@@ -8926,7 +8926,7 @@ unsigned int send_delba(_adapter *padapter, u8 initiator, u8 *addr)
 				DBG_871X("DBG_RX_SEQ %s:%d indicate_seq:%u \n", __FUNCTION__, __LINE__,
 					psta->recvreorder_ctrl[tid].indicate_seq);
 				#endif
-			}
+			}		
 		}
 	}
 	else if(initiator == 1)// originator
@@ -8940,13 +8940,13 @@ unsigned int send_delba(_adapter *padapter, u8 initiator, u8 *addr)
 				issue_action_BA(padapter, addr, RTW_WLAN_ACTION_DELBA, (((tid <<1) |initiator)&0x1F) );
 				psta->htpriv.agg_enable_bitmap &= ~BIT(tid);
 				psta->htpriv.candidate_tid_bitmap &= ~BIT(tid);
-
-			}
+				
+			}			
 		}
 	}
-
+	
 	return _SUCCESS;
-
+	
 }
 
 unsigned int send_beacon(_adapter *padapter)
@@ -8959,7 +8959,7 @@ unsigned int send_beacon(_adapter *padapter)
 	//struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	//_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
 	//struct mlme_priv *pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
-//#endif
+//#endif		
 
 #ifdef CONFIG_PCI_HCI
 
@@ -9003,7 +9003,7 @@ unsigned int send_beacon(_adapter *padapter)
 			DBG_871X("%s success, issue:%d, poll:%d, %u ms\n", __FUNCTION__, issue, poll, rtw_get_passing_time_ms(start));
 		//else
 		//	DBG_871X("%s success, issue:%d, poll:%d, %u ms\n", __FUNCTION__, issue, poll, rtw_get_passing_time_ms(start));
-
+		
 		return _SUCCESS;
 	}
 
@@ -9021,7 +9021,7 @@ BOOLEAN IsLegal5GChannel(
 	IN PADAPTER			Adapter,
 	IN u8			channel)
 {
-
+	
 	int i=0;
 	u8 Channel_5G[45] = {36,38,40,42,44,46,48,50,52,54,56,58,
 		60,62,64,100,102,104,106,108,110,112,114,116,118,120,122,
@@ -9051,13 +9051,13 @@ void site_survey(_adapter *padapter)
 #endif //CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
 
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-	PADAPTER pbuddy_adapter = padapter->pbuddy_adapter;
+	PADAPTER pbuddy_adapter = padapter->pbuddy_adapter;			
 	struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 
 #endif //CONFIG_CONCURRENT_MODE
 	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
 	static unsigned char  prev_survey_channel = 0;
-	static unsigned int p2p_scan_count = 0;
+	static unsigned int p2p_scan_count = 0;	
 
 
 	if ( ( pwdinfo->rx_invitereq_info.scan_op_ch_only ) || ( pwdinfo->p2p_info.scan_op_ch_only ) )
@@ -9102,7 +9102,7 @@ void site_survey(_adapter *padapter)
 		, pwdinfo->find_phase_state_exchange_cnt, pmlmeext->sitesurvey_res.channel_idx
 		, rtw_get_passing_time_ms(padapter->mlmepriv.scan_start_time)
 		, ScanType?'A':'P', pmlmeext->sitesurvey_res.scan_mode?'A':'P'
-		, pmlmeext->sitesurvey_res.ssid[0].SsidLength?'S':' '
+		, pmlmeext->sitesurvey_res.ssid[0].SsidLength?'S':' ' 
 	);
 
 	if(survey_channel != 0)
@@ -9121,7 +9121,7 @@ void site_survey(_adapter *padapter)
 				survey_channel = pbuddy_mlmeext->cur_channel;
 				stay_buddy_ch = 1;
 			}
-			else
+			else 
 			{
 				if( pmlmeinfo->scan_cnt == 0 )
 					stay_buddy_ch = 2;
@@ -9161,7 +9161,7 @@ void site_survey(_adapter *padapter)
 		if(ScanType == SCAN_ACTIVE) //obey the channel plan setting...
 		{
 			#ifdef CONFIG_P2P
-			if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_SCAN) ||
+			if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_SCAN) || 
 				rtw_p2p_chk_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH)
 			)
 			{
@@ -9234,10 +9234,10 @@ void site_survey(_adapter *padapter)
 			cur_channel = pmlmeext->cur_channel;
 			cur_bwmode = pmlmeext->cur_bwmode;
 			cur_ch_offset = pmlmeext->cur_ch_offset;
-		}
+		}		
 #endif
 
-
+	
 #ifdef CONFIG_P2P
 		if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_SCAN) || rtw_p2p_chk_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH))
 		{
@@ -9262,7 +9262,7 @@ void site_survey(_adapter *padapter)
 			//turn on dynamic functions
 			Restore_DM_Func_Flag(padapter);
 			//Switch_DM_Func(padapter, DYNAMIC_FUNC_DIG|DYNAMIC_FUNC_HP|DYNAMIC_FUNC_SS, _TRUE);
-
+			
 			_set_timer( &pwdinfo->find_phase_timer, ( u32 ) ( ( u32 ) ( pwdinfo->listen_dwell ) * 100 ) );
 		}
 		else
@@ -9278,10 +9278,10 @@ void site_survey(_adapter *padapter)
 			// For SW antenna diversity before link, it needs to switch to another antenna and scan again.
 			// It compares the scan result and select beter one to do connection.
 			if(rtw_hal_antdiv_before_linked(padapter))
-			{
+			{				
 				pmlmeext->sitesurvey_res.bss_cnt = 0;
 				pmlmeext->sitesurvey_res.channel_idx = -1;
-				pmlmeext->chan_scan_time = SURVEY_TO /2;
+				pmlmeext->chan_scan_time = SURVEY_TO /2;			
 				set_survey_timer(pmlmeext, pmlmeext->chan_scan_time);
 				return;
 			}
@@ -9305,7 +9305,7 @@ void site_survey(_adapter *padapter)
 			}
 			rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_NONE);
 #endif //CONFIG_P2P
-
+			
 			pmlmeext->sitesurvey_res.state = SCAN_COMPLETE;
 
 			//switch back to the original channel
@@ -9356,7 +9356,7 @@ void site_survey(_adapter *padapter)
 			if(restore_initial_gain == 1)
 			{
 				initialgain = 0xff; //restore RX GAIN
-				rtw_hal_set_hwreg(padapter, HW_VAR_INITIAL_GAIN, (u8 *)(&initialgain));
+				rtw_hal_set_hwreg(padapter, HW_VAR_INITIAL_GAIN, (u8 *)(&initialgain));	
 			}
 
 			//turn on dynamic functions
@@ -9366,22 +9366,22 @@ void site_survey(_adapter *padapter)
 			if (is_client_associated_to_ap(padapter) == _TRUE)
 			{
 				issue_nulldata(padapter, NULL, 0, 3, 500);
-
+				
 #ifdef CONFIG_CONCURRENT_MODE
 				if(is_client_associated_to_ap(padapter->pbuddy_adapter) == _TRUE)
 				{
 					DBG_871X("adapter is surveydone(buddy_adapter is linked), issue nulldata(pwrbit=0)\n");
-
+					
 					issue_nulldata(padapter->pbuddy_adapter, NULL, 0, 3, 500);
 				}
-#endif
+#endif	
 			}
 #ifdef CONFIG_CONCURRENT_MODE
 			else if(is_client_associated_to_ap(padapter->pbuddy_adapter) == _TRUE)
 			{
 				issue_nulldata(padapter->pbuddy_adapter, NULL, 0, 3, 500);
 			}
-#endif
+#endif	
 
 			report_surveydone_event(padapter);
 
@@ -9402,7 +9402,7 @@ void site_survey(_adapter *padapter)
 			DBG_871X("survey done, current CH=%d, BW=%d, offset=%d\n", cur_channel, cur_bwmode, cur_ch_offset);
 
 			DBG_871X("restart pbuddy_adapter's beacon\n");
-
+		
 			update_beacon(padapter->pbuddy_adapter, 0, NULL, _TRUE);
 		}
 #endif
@@ -9442,7 +9442,7 @@ u8 collect_bss_info(_adapter *padapter, union recv_frame *precv_frame, WLAN_BSSI
 		bssid->Reserved[0] = 1;
 	else
 		bssid->Reserved[0] = 0;
-
+		
 	bssid->Length = sizeof(WLAN_BSSID_EX) - MAX_IE_SZ + len;
 
 	//below is to copy the information element
@@ -9450,10 +9450,10 @@ u8 collect_bss_info(_adapter *padapter, union recv_frame *precv_frame, WLAN_BSSI
 	_rtw_memcpy(bssid->IEs, (pframe + sizeof(struct rtw_ieee80211_hdr_3addr)), bssid->IELength);
 
 	//get the signal strength
-	bssid->PhyInfo.SignalQuality = precv_frame->u.hdr.attrib.signal_qual;//in percentage
+	bssid->PhyInfo.SignalQuality = precv_frame->u.hdr.attrib.signal_qual;//in percentage 
 	bssid->PhyInfo.SignalStrength = precv_frame->u.hdr.attrib.signal_strength;//in percentage
 	bssid->Rssi = precv_frame->u.hdr.attrib.RecvSignalPower; // in dBM.raw data
-
+	
 #ifdef CONFIG_ANTENNA_DIVERSITY
 	//rtw_hal_get_hwreg(padapter, HW_VAR_CURRENT_ANTENNA, (u8 *)(&bssid->PhyInfo.Optimum_antenna));
 	rtw_hal_get_def_var(padapter, HAL_DEF_CURRENT_ANTENNA,  &bssid->PhyInfo.Optimum_antenna);
@@ -9573,17 +9573,17 @@ u8 collect_bss_info(_adapter *padapter, union recv_frame *precv_frame, WLAN_BSSI
 
 	//20/40 BSS Coexistence check
 	if((pregistrypriv->wifi_spec==1) && (_FALSE == pmlmeinfo->bwmode_updated))
-	{
+	{	
 		struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-
+		
 		p = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _HT_CAPABILITY_IE_, &len, bssid->IELength - _FIXED_IE_LENGTH_);
 		if(p && len>0)
 		{
 			struct HT_caps_element	*pHT_caps;
 			pHT_caps = (struct HT_caps_element	*)(p + 2);
-
+			
 			if(pHT_caps->u.HT_cap_element.HT_caps_info&BIT(14))
-			{
+			{				
 				pmlmepriv->num_FortyMHzIntolerant++;
 			}
 		}
@@ -9591,7 +9591,7 @@ u8 collect_bss_info(_adapter *padapter, union recv_frame *precv_frame, WLAN_BSSI
 		{
 			pmlmepriv->num_sta_no_ht++;
 		}
-
+		
 	}
 
 #ifdef CONFIG_INTEL_WIDI
@@ -9722,7 +9722,7 @@ void start_clnt_join(_adapter* padapter)
 			_enter_critical_bh(&(padapter->mlmepriv.scanned_queue.lock), &irqL);
 
 			for (pos = get_next(head);!rtw_end_of_queue_search(head, pos); pos = get_next(pos)) {
-
+				
 				scanned = LIST_CONTAINOR(pos, struct wlan_network, list);
 				if(scanned==NULL)
 					rtw_warn_on(1);
@@ -9736,7 +9736,7 @@ void start_clnt_join(_adapter* padapter)
 					break;
 				}
 			}
-
+	
 			_exit_critical_bh(&(padapter->mlmepriv.scanned_queue.lock), &irqL);
 
 			if (scanned == NULL || rtw_end_of_queue_search(head, pos) || has_p2p_ie == _FALSE)
@@ -10120,7 +10120,7 @@ static void process_80211d(PADAPTER padapter, WLAN_BSSID_EX *bssid)
 				//5G Bnad 2, 3 (DFS) doesn't change to active scan
 				if(channel >= 52 && channel <= 144)
 					break;
-
+				
 				chplan_new[i].ScanType = SCAN_ACTIVE;
 				RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_,
 						 ("%s: change channel %d scan type from passive to active\n",
@@ -10156,7 +10156,7 @@ void report_survey_event(_adapter *padapter, union recv_frame *precv_frame)
 
 	pmlmeext = &padapter->mlmeextpriv;
 	pcmdpriv = &padapter->cmdpriv;
-
+	
 
 	if ((pcmd_obj = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj))) == NULL)
 	{
@@ -10294,11 +10294,11 @@ void report_join_res(_adapter *padapter, int res)
 	pjoinbss_evt->network.join_res 	= pjoinbss_evt->network.aid = res;
 
 	DBG_871X("report_join_res(%d)\n", res);
-
-
+	
+	
 	rtw_joinbss_event_prehandle(padapter, (u8 *)&pjoinbss_evt->network);
-
-
+	
+	
 	rtw_enqueue_cmd(pcmdpriv, pcmd_obj);
 
 	return;
@@ -10350,7 +10350,7 @@ void report_del_sta_event(_adapter *padapter, unsigned char* MacAddr, unsigned s
 
 	psta = rtw_get_stainfo(&padapter->stapriv, MacAddr);
 	if(psta)
-		mac_id = (int)psta->mac_id;
+		mac_id = (int)psta->mac_id;	
 	else
 		mac_id = (-1);
 
@@ -10439,31 +10439,31 @@ void update_sta_info(_adapter *padapter, struct sta_info *psta)
 			psta->htpriv.sgi = _TRUE;
 
 		psta->qos_option = _TRUE;
-
+		
 	}
 	else
 	{
 		psta->htpriv.ht_option = _FALSE;
 
 		psta->htpriv.ampdu_enable = _FALSE;
-
+		
 		psta->htpriv.sgi = _FALSE;
 
 		psta->qos_option = _FALSE;
 
 	}
-
+	
 	psta->htpriv.bwmode = pmlmeext->cur_bwmode;
 	psta->htpriv.ch_offset = pmlmeext->cur_ch_offset;
-
+	
 	psta->htpriv.agg_enable_bitmap = 0x0;//reset
 	psta->htpriv.candidate_tid_bitmap = 0x0;//reset
-
+	
 
 	//QoS
 	if(pmlmepriv->qospriv.qos_option)
 		psta->qos_option = _TRUE;
-
+	
 
 	psta->state = _FW_LINKED;
 
@@ -10542,7 +10542,7 @@ void mlmeext_joinbss_event_callback(_adapter *padapter, int join_res)
 		pmlmeinfo->FW_sta_info[psta->mac_id].psta = psta;
 
 		//DBG_871X("set_sta_rate\n");
-
+	
 		//set per sta rate after updating HT cap.
 		set_sta_rate(padapter, psta);
 	}
@@ -10554,7 +10554,7 @@ void mlmeext_joinbss_event_callback(_adapter *padapter, int join_res)
 	{
 		// correcting TSF
 		correct_TSF(padapter, pmlmeext);
-
+	
 		//set_link_timer(pmlmeext, DISCONNECT_TO);
 	}
 
@@ -10592,7 +10592,7 @@ void mlmeext_sta_add_event_callback(_adapter *padapter, struct sta_info *psta)
 		else//adhoc client
 		{
 			//update TSF Value
-			//update_TSF(pmlmeext, pframe, len);
+			//update_TSF(pmlmeext, pframe, len);			
 
 			// correcting TSF
 			correct_TSF(padapter, pmlmeext);
@@ -10608,7 +10608,7 @@ void mlmeext_sta_add_event_callback(_adapter *padapter, struct sta_info *psta)
 			}
 
 			pmlmeinfo->state |= WIFI_FW_ASSOC_SUCCESS;
-
+				
 		}
 
 		join_type = 2;
@@ -10654,7 +10654,7 @@ void mlmeext_sta_del_event_callback(_adapter *padapter)
 
 		//SelectChannel(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset);
 		set_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
-
+	
 #ifdef CONFIG_CONCURRENT_MODE
 		}
 #endif //CONFIG_CONCURRENT_MODE
@@ -10682,7 +10682,7 @@ void mlmeext_sta_del_event_callback(_adapter *padapter)
 void _linked_rx_signal_strehgth_display(_adapter *padapter)
 {
 	int	UndecoratedSmoothedPWDB;
-
+	
 #ifdef CONFIG_CONCURRENT_MODE
 	PADAPTER pbuddy_adapter = padapter->pbuddy_adapter;
 	DBG_871X("============ pbuddy_adapter linked status check ===================\n");
@@ -10721,7 +10721,7 @@ void _linked_rx_signal_strehgth_display(_adapter *padapter)
 
 	DBG_871X(" CCK -Alarm A5B(0x%02x),A5C(0x%02x)\n",rtw_read8(padapter,0xA5B),rtw_read8(padapter,0xA5C));
 	DBG_871X(" FalseAlmCnt_all(%d)\n",padapter->recvpriv.FalseAlmCnt_all);
-
+	
 }
 
 u8 chk_ap_is_alive(_adapter *padapter, struct sta_info *psta)
@@ -10780,7 +10780,7 @@ void linked_status_chk(_adapter *padapter)
 	if(padapter->bRxRSSIDisplay)
 		 _linked_rx_signal_strehgth_display(padapter);
 
-	#ifdef DBG_CONFIG_ERROR_DETECT
+	#ifdef DBG_CONFIG_ERROR_DETECT	
 	rtw_hal_sreset_linked_status_check(padapter);
 	#endif
 
@@ -10806,14 +10806,14 @@ void linked_status_chk(_adapter *padapter)
 		//if (padapter->mlmepriv.widi_state != INTEL_WIDI_STATE_NONE)
 		//	rx_chk_limit = 1;
 		//#endif
-
+		
 		if ((psta = rtw_get_stainfo(pstapriv, pmlmeinfo->network.MacAddress)) != NULL)
 		{
 			bool is_p2p_enable = _FALSE;
 			#ifdef CONFIG_P2P
 			is_p2p_enable = !rtw_p2p_chk_state(&padapter->wdinfo, P2P_STATE_NONE);
 			#endif
-
+			
 			if (chk_ap_is_alive(padapter, psta) == _FALSE)
 				rx_chk = _FAIL;
 
@@ -10915,7 +10915,7 @@ void linked_status_chk(_adapter *padapter)
 						report_del_sta_event(padapter, psta->hwaddr
 							, 65535// indicate disconnect caused by no rx
 						);
-					}
+					}	
 				}
 				else
 				{
@@ -11045,7 +11045,7 @@ void link_timer_hdl(_adapter *padapter)
 	 }
 	 callout_deactivate(&padapter->mlmeextpriv.survey_timer.callout);
 
-
+	
 #endif
 
 	if (pmlmeinfo->state & WIFI_FW_AUTH_NULL)
@@ -11071,7 +11071,7 @@ void link_timer_hdl(_adapter *padapter)
 			//	pmlmeinfo->reauth_count = 0;
 			//}
 		}
-
+		
 		DBG_871X("link_timer_hdl: auth timeout and try again\n");
 		pmlmeinfo->auth_seq = 1;
 		issue_auth(padapter, NULL, 0);
@@ -11167,14 +11167,14 @@ void addba_timer_hdl(struct sta_info *psta)
 
 	if(!psta)
 		return;
-
+	
 	phtpriv = &psta->htpriv;
 
-	if((phtpriv->ht_option==_TRUE) && (phtpriv->ampdu_enable==_TRUE))
+	if((phtpriv->ht_option==_TRUE) && (phtpriv->ampdu_enable==_TRUE)) 
 	{
 		if(phtpriv->candidate_tid_bitmap)
 			phtpriv->candidate_tid_bitmap=0x0;
-
+		
 	}
 }
 
@@ -11191,7 +11191,7 @@ void sa_query_timer_hdl(_adapter *padapter)
 	{
 		rtw_disassoc_cmd(padapter, 0, _TRUE);
 		rtw_indicate_disconnect(padapter);
-		rtw_free_assoc_resources(padapter, 1);
+		rtw_free_assoc_resources(padapter, 1);	
 	}
 
 	_exit_critical_bh(&pmlmepriv->lock, &irqL);
@@ -11355,7 +11355,7 @@ u8 setopmode_hdl(_adapter *padapter, u8 *pbuf)
 #endif
 
 	return H2C_SUCCESS;
-
+	
 }
 
 u8 createbss_hdl(_adapter *padapter, u8 *pbuf)
@@ -11366,16 +11366,16 @@ u8 createbss_hdl(_adapter *padapter, u8 *pbuf)
 	struct joinbss_parm *pparm = (struct joinbss_parm *)pbuf;
 	u32	initialgain;
 
-
+	
 	if(pparm->network.InfrastructureMode == Ndis802_11APMode)
 	{
 #ifdef CONFIG_AP_MODE
-
+	
 		if(pmlmeinfo->state == WIFI_FW_AP_STATE)
-		{
+		{		
 			//todo:
-			return H2C_SUCCESS;
-		}
+			return H2C_SUCCESS;		
+		}		
 #endif
 	}
 
@@ -11383,9 +11383,9 @@ u8 createbss_hdl(_adapter *padapter, u8 *pbuf)
 	if(pparm->network.InfrastructureMode == Ndis802_11IBSS)
 	{
 		rtw_joinbss_reset(padapter);
-
+	
 		pmlmeext->cur_bwmode = HT_CHANNEL_WIDTH_20;
-		pmlmeext->cur_ch_offset= HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+		pmlmeext->cur_ch_offset= HAL_PRIME_CHNL_OFFSET_DONT_CARE;	
 		pmlmeinfo->ERP_enable = 0;
 		pmlmeinfo->WMM_enable = 0;
 		pmlmeinfo->HT_enable = 0;
@@ -11402,23 +11402,23 @@ u8 createbss_hdl(_adapter *padapter, u8 *pbuf)
 		initialgain = 0x1E;
 		rtw_hal_set_hwreg(padapter, HW_VAR_INITIAL_GAIN, (u8 *)(&initialgain));
 
-		//cancel link timer
+		//cancel link timer 
 		_cancel_timer_ex(&pmlmeext->link_timer);
 
 		//clear CAM
-		flush_all_cam_entry(padapter);
+		flush_all_cam_entry(padapter);	
 
-		_rtw_memcpy(pnetwork, pbuf, FIELD_OFFSET(WLAN_BSSID_EX, IELength));
+		_rtw_memcpy(pnetwork, pbuf, FIELD_OFFSET(WLAN_BSSID_EX, IELength)); 
 		pnetwork->IELength = ((WLAN_BSSID_EX *)pbuf)->IELength;
 
 		if(pnetwork->IELength>MAX_IE_SZ)//Check pbuf->IELength
 			return H2C_PARAMETERS_ERROR;
 
 		_rtw_memcpy(pnetwork->IEs, ((WLAN_BSSID_EX *)pbuf)->IEs, pnetwork->IELength);
-
+	
 		start_create_ibss(padapter);
 
-	}
+	}	
 
 	return H2C_SUCCESS;
 
@@ -11448,16 +11448,16 @@ u8 join_cmd_hdl(_adapter *padapter, u8 *pbuf)
 		}
 
 		pmlmeinfo->state = WIFI_FW_NULL_STATE;
-
+		
 		//clear CAM
-		flush_all_cam_entry(padapter);
-
+		flush_all_cam_entry(padapter);		
+		
 		_cancel_timer_ex(&pmlmeext->link_timer);
-
-		//set MSR to nolink -> infra. mode
+		
+		//set MSR to nolink -> infra. mode		
 		//Set_MSR(padapter, _HW_STATE_NOLINK_);
-		Set_MSR(padapter, _HW_STATE_STATION_);
-
+		Set_MSR(padapter, _HW_STATE_STATION_);	
+		
 
 		rtw_hal_set_hwreg(padapter, HW_VAR_MLME_DISCONNECT, 0);
 	}
@@ -11467,9 +11467,9 @@ u8 join_cmd_hdl(_adapter *padapter, u8 *pbuf)
 #endif
 
 	rtw_joinbss_reset(padapter);
-
+	
 	pmlmeext->cur_bwmode = HT_CHANNEL_WIDTH_20;
-	pmlmeext->cur_ch_offset= HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+	pmlmeext->cur_ch_offset= HAL_PRIME_CHNL_OFFSET_DONT_CARE;	
 	pmlmeinfo->ERP_enable = 0;
 	pmlmeinfo->WMM_enable = 0;
 	pmlmeinfo->HT_enable = 0;
@@ -11480,13 +11480,13 @@ u8 join_cmd_hdl(_adapter *padapter, u8 *pbuf)
 	pmlmeinfo->bwmode_updated = _FALSE;
 	//pmlmeinfo->assoc_AP_vendor = maxAP;
 
-	_rtw_memcpy(pnetwork, pbuf, FIELD_OFFSET(WLAN_BSSID_EX, IELength));
+	_rtw_memcpy(pnetwork, pbuf, FIELD_OFFSET(WLAN_BSSID_EX, IELength)); 
 	pnetwork->IELength = ((WLAN_BSSID_EX *)pbuf)->IELength;
-
+	
 	if(pnetwork->IELength>MAX_IE_SZ)//Check pbuf->IELength
-		return H2C_PARAMETERS_ERROR;
-
-	_rtw_memcpy(pnetwork->IEs, ((WLAN_BSSID_EX *)pbuf)->IEs, pnetwork->IELength);
+		return H2C_PARAMETERS_ERROR;	
+		
+	_rtw_memcpy(pnetwork->IEs, ((WLAN_BSSID_EX *)pbuf)->IEs, pnetwork->IELength); 
 
 	pmlmeext->cur_channel = (u8)pnetwork->Configuration.DSConfig;
 	pmlmeinfo->bcn_interval = get_beacon_interval(pnetwork);
@@ -11514,13 +11514,13 @@ u8 join_cmd_hdl(_adapter *padapter, u8 *pbuf)
 			case _HT_EXTRA_INFO_IE_:	//Get HT Info IE.
 				pmlmeinfo->HT_info_enable = 1;
 
-				//spec case only for cisco's ap because cisco's ap issue assoc rsp using mcs rate @40MHz or @20MHz
+				//spec case only for cisco's ap because cisco's ap issue assoc rsp using mcs rate @40MHz or @20MHz	
 //#if !defined(CONFIG_CONCURRENT_MODE) && !defined(CONFIG_DUALMAC_CONCURRENT)
 //				if(pmlmeinfo->assoc_AP_vendor == ciscoAP)
 //#endif
-				{
+				{				
 					struct HT_info_element *pht_info = (struct HT_info_element *)(pIE->data);
-
+							
 					if( pnetwork->Configuration.DSConfig > 14 )
 					{
 						if( pregpriv->cbw40_enable & BIT(1) )
@@ -11529,7 +11529,7 @@ u8 join_cmd_hdl(_adapter *padapter, u8 *pbuf)
 					else
 						if( pregpriv->cbw40_enable & BIT(0) )
 							cbw40_enable = 1;
-
+						
 					if ((cbw40_enable) &&	 (pht_info->infos[0] & BIT(2)))
 					{
 						//switch to the 40M Hz mode according to the AP
@@ -11539,11 +11539,11 @@ u8 join_cmd_hdl(_adapter *padapter, u8 *pbuf)
 							case 1:
 								pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;
 								break;
-
+			
 							case 3:
 								pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER;
 								break;
-
+				
 							default:
 								pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
 								break;
@@ -11571,7 +11571,7 @@ u8 join_cmd_hdl(_adapter *padapter, u8 *pbuf)
 		rtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_BE, (u8 *)(&acparm));
 		acparm = 0x0000A549; // BK
 		rtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_BK, (u8 *)(&acparm));
-
+	
 		// for WiFi test, mixed mode with intel STA under bg mode throughput issue
 		if (padapter->mlmepriv.htpriv.ht_option == _FALSE){
 			acparm = 0x00004320;
@@ -11608,22 +11608,22 @@ u8 join_cmd_hdl(_adapter *padapter, u8 *pbuf)
 	//Switch_DM_Func(padapter, DYNAMIC_FUNC_DISABLE, _FALSE);
 
 	//config the initial gain under linking, need to write the BB registers
-
+	
 	initialgain = 0x1E;
 	rtw_hal_set_hwreg(padapter, HW_VAR_INITIAL_GAIN, (u8 *)(&initialgain));
-
+	
 
 	rtw_hal_set_hwreg(padapter, HW_VAR_BSSID, pmlmeinfo->network.MacAddress);
 	join_type = 0;
 	rtw_hal_set_hwreg(padapter, HW_VAR_MLME_JOIN, (u8 *)(&join_type));
 
-	//cancel link timer
+	//cancel link timer 
 	_cancel_timer_ex(&pmlmeext->link_timer);
-
+	
 	start_clnt_join(padapter);
-
+	
 	return H2C_SUCCESS;
-
+	
 }
 
 u8 disconnect_hdl(_adapter *padapter, unsigned char *pbuf)
@@ -11642,7 +11642,7 @@ u8 disconnect_hdl(_adapter *padapter, unsigned char *pbuf)
 	//set_opmode_cmd(padapter, infra_client_with_mlme);
 
 	//pmlmeinfo->state = WIFI_FW_NULL_STATE;
-
+	
 
 	rtw_hal_set_hwreg(padapter, HW_VAR_MLME_DISCONNECT, 0);
 	rtw_hal_set_hwreg(padapter, HW_VAR_BSSID, null_addr);
@@ -11666,7 +11666,7 @@ u8 disconnect_hdl(_adapter *padapter, unsigned char *pbuf)
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	dc_set_channel_bwmode_disconnect(padapter);
 #else
-#ifdef CONFIG_CONCURRENT_MODE
+#ifdef CONFIG_CONCURRENT_MODE	
 	if((check_buddy_fwstate(padapter, _FW_LINKED)) != _TRUE)
 	{
 #endif //CONFIG_CONCURRENT_MODE
@@ -11681,11 +11681,11 @@ u8 disconnect_hdl(_adapter *padapter, unsigned char *pbuf)
 #endif //CONFIG_DUALMAC_CONCURRENT
 
 	flush_all_cam_entry(padapter);
-
+		
 	_cancel_timer_ex(&pmlmeext->link_timer);
 
 	rtw_free_uc_swdec_pending_queue(padapter);
-
+	
 	return 	H2C_SUCCESS;
 }
 
@@ -11719,16 +11719,16 @@ int rtw_scan_ch_decision(_adapter *padapter, struct rtw_ieee80211_channel *out,
 			}
 
 			_rtw_memcpy(&out[j], &in[i], sizeof(struct rtw_ieee80211_channel));
-
+			
 			if(pmlmeext->channel_set[set_idx].ScanType == SCAN_PASSIVE)
 				out[j].flags &= RTW_IEEE80211_CHAN_PASSIVE_SCAN;
-
+				
 			j++;
 		}
 		if(j>=out_num)
 			break;
 	}
-
+	
 	/* if out is empty, use channel_set as default */
 	if(j == 0) {
 		for (i=0;i<pmlmeext->max_chan_nums;i++) {
@@ -11745,7 +11745,7 @@ int rtw_scan_ch_decision(_adapter *padapter, struct rtw_ieee80211_channel *out,
 				}
 
 				out[j].hw_value = pmlmeext->channel_set[i].ChannelNum;
-
+			
 				if(pmlmeext->channel_set[i].ScanType == SCAN_PASSIVE)
 					out[j].flags &= RTW_IEEE80211_CHAN_PASSIVE_SCAN;
 
@@ -11773,11 +11773,11 @@ u8 sitesurvey_cmd_hdl(_adapter *padapter, u8 *pbuf)
 
 	if (pmlmeext->sitesurvey_res.state == SCAN_DISABLE)
 	{
-#ifdef CONFIG_CONCURRENT_MODE
+#ifdef CONFIG_CONCURRENT_MODE	
 		//for first time sitesurvey_cmd
-		rtw_hal_set_hwreg(padapter, HW_VAR_CHECK_TXBUF, 0);
+		rtw_hal_set_hwreg(padapter, HW_VAR_CHECK_TXBUF, 0);	
 #endif //CONFIG_CONCURRENT_MODE
-
+		
 		pmlmeext->sitesurvey_res.state = SCAN_START;
 		pmlmeext->sitesurvey_res.bss_cnt = 0;
 		pmlmeext->sitesurvey_res.channel_idx = 0;
@@ -11813,7 +11813,7 @@ u8 sitesurvey_cmd_hdl(_adapter *padapter, u8 *pbuf)
 			if(is_client_associated_to_ap(padapter->pbuddy_adapter) == _TRUE)
 			{
 				DBG_871X("adapter is scanning(buddy_adapter is linked), issue nulldata(pwrbit=1)\n");
-
+				
 				issue_nulldata(padapter->pbuddy_adapter, NULL, 1, 3, 500);
 			}
 #endif
@@ -11833,9 +11833,9 @@ u8 sitesurvey_cmd_hdl(_adapter *padapter, u8 *pbuf)
 
 			issue_nulldata(padapter->pbuddy_adapter, NULL, 1, 3, 500);
 
-			bdelayscan = _TRUE;
+			bdelayscan = _TRUE;			
 		}
-#endif
+#endif		
 		if(bdelayscan)
 		{
 			//delay 50ms to protect nulldata(1).
@@ -11849,7 +11849,7 @@ u8 sitesurvey_cmd_hdl(_adapter *padapter, u8 *pbuf)
 #ifdef CONFIG_FIND_BEST_CHANNEL
 #if 0
 		for (i=0; pmlmeext->channel_set[i].ChannelNum !=0; i++) {
-			pmlmeext->channel_set[i].rx_count = 0;
+			pmlmeext->channel_set[i].rx_count = 0;				
 		}
 #endif
 #endif /* CONFIG_FIND_BEST_CHANNEL */
@@ -11889,7 +11889,7 @@ u8 sitesurvey_cmd_hdl(_adapter *padapter, u8 *pbuf)
 	site_survey(padapter);
 
 	return H2C_SUCCESS;
-
+	
 }
 
 u8 setauth_hdl(_adapter *padapter, unsigned char *pbuf)
@@ -11897,7 +11897,7 @@ u8 setauth_hdl(_adapter *padapter, unsigned char *pbuf)
 	struct setauth_parm		*pparm = (struct setauth_parm *)pbuf;
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-
+	
 	if (pparm->mode < 4)
 	{
 		pmlmeinfo->auth_algo = pparm->mode;
@@ -11917,9 +11917,9 @@ u8 setkey_hdl(_adapter *padapter, u8 *pbuf)
 	//main tx key for wep.
 	if(pparm->set_tx)
 		pmlmeinfo->key_index = pparm->keyid;
-
+	
 	//write cam
-	ctrl = BIT(15) | ((pparm->algorithm) << 2) | pparm->keyid;
+	ctrl = BIT(15) | ((pparm->algorithm) << 2) | pparm->keyid;	
 
 	write_cam(padapter, pparm->keyid, ctrl, null_sta, pparm->key);
 
@@ -11932,7 +11932,7 @@ u8 setkey_hdl(_adapter *padapter, u8 *pbuf)
 u8 set_stakey_hdl(_adapter *padapter, u8 *pbuf)
 {
 	u16 ctrl=0;
-	u8 cam_id=0;//cam_entry
+	u8 cam_id;//cam_entry
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct set_stakey_parm	*pparm = (struct set_stakey_parm *)pbuf;
@@ -11944,7 +11944,7 @@ u8 set_stakey_hdl(_adapter *padapter, u8 *pbuf)
 
 	//cam_entry:
 	//0~3 for default key
-
+	
 	//for concurrent mode (ap+sta):
 	//default key is disable, using sw encrypt/decrypt
 	//cam_entry = 4 //for sta mode (macid=0)
@@ -11960,7 +11960,7 @@ u8 set_stakey_hdl(_adapter *padapter, u8 *pbuf)
 	{
 		struct sta_priv	*pstapriv = &padapter->stapriv;
 		struct sta_info	*psta;
-
+		
 		psta = rtw_get_stainfo(pstapriv, pmlmeinfo->network.MacAddress);
 
 		if(psta && psta->mac_id==2)
@@ -11971,7 +11971,7 @@ u8 set_stakey_hdl(_adapter *padapter, u8 *pbuf)
 		{
 			cam_id = 4;
 		}
-/*
+/*		
 		if(padapter->iface_type > PRIMARY_IFACE)
 		{
 			cam_id = 5;
@@ -11980,8 +11980,8 @@ u8 set_stakey_hdl(_adapter *padapter, u8 *pbuf)
 		{
 			cam_id = 4;
 		}
-*/
-	}
+*/		
+	}	
 #else
 	cam_id = 4;
 #endif
@@ -11989,7 +11989,7 @@ u8 set_stakey_hdl(_adapter *padapter, u8 *pbuf)
 
 	if((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
 	{
-
+	
 		struct sta_info *psta;
 		struct sta_priv *pstapriv = &padapter->stapriv;
 
@@ -11998,10 +11998,10 @@ u8 set_stakey_hdl(_adapter *padapter, u8 *pbuf)
 			clear_cam_entry(padapter, pparm->id);
 			return H2C_SUCCESS_RSP;
 		}
-
+		
 		psta = rtw_get_stainfo(pstapriv, pparm->addr);
 		if(psta)
-		{
+		{			
 			ctrl = (BIT(15) | ((pparm->algorithm) << 2));
 
 			DBG_871X("r871x_set_stakey_hdl(): enc_algorithm=%d\n", pparm->algorithm);
@@ -12010,37 +12010,37 @@ u8 set_stakey_hdl(_adapter *padapter, u8 *pbuf)
 			{
 				DBG_871X("r871x_set_stakey_hdl():set_stakey failed, mac_id(aid)=%d\n", psta->mac_id);
 				return H2C_REJECTED;
-			}
-
+			}	
+				 
 			cam_id = (psta->mac_id + 3);//0~3 for default key, cmd_id=macid + 3, macid=aid+1;
 
-			DBG_871X("Write CAM, mac_addr=%x:%x:%x:%x:%x:%x, cam_entry=%d\n", pparm->addr[0],
+			DBG_871X("Write CAM, mac_addr=%x:%x:%x:%x:%x:%x, cam_entry=%d\n", pparm->addr[0], 
 						pparm->addr[1], pparm->addr[2], pparm->addr[3], pparm->addr[4],
 						pparm->addr[5], cam_id);
 
 			write_cam(padapter, cam_id, ctrl, pparm->addr, pparm->key);
-
+	
 			return H2C_SUCCESS_RSP;
-
+		
 		}
 		else
 		{
 			DBG_871X("r871x_set_stakey_hdl(): sta has been free\n");
 			return H2C_REJECTED;
 		}
-
+		
 	}
 
 	//below for sta mode
-
+	
 	if(pparm->algorithm == _NO_PRIVACY_)	// clear cam entry
 	{
 		clear_cam_entry(padapter, pparm->id);
 		return H2C_SUCCESS;
 	}
-
-	ctrl = BIT(15) | ((pparm->algorithm) << 2);
-
+	
+	ctrl = BIT(15) | ((pparm->algorithm) << 2);	
+	
 #ifdef CONFIG_TDLS
 	if(ptdlsinfo->clear_cam!=0){
 		clear_cam_entry(padapter, ptdlsinfo->clear_cam);
@@ -12054,11 +12054,11 @@ u8 set_stakey_hdl(_adapter *padapter, u8 *pbuf)
 		write_cam(padapter, psta->mac_id, ctrl, pparm->addr, pparm->key);
 	}
 	else
-#endif //CONFIG_TDLS
+#endif //CONFIG_TDLS	
 	write_cam(padapter, cam_id, ctrl, pparm->addr, pparm->key);
 
 	pmlmeinfo->enc_algo = pparm->algorithm;
-
+	
 	return H2C_SUCCESS;
 }
 
@@ -12069,57 +12069,57 @@ u8 add_ba_hdl(_adapter *padapter, unsigned char *pbuf)
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
 	struct sta_info *psta = rtw_get_stainfo(&padapter->stapriv, pparm->addr);
-
+	
 	if(!psta)
 		return 	H2C_SUCCESS;
-
+		
 
 	if (((pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS) && (pmlmeinfo->HT_enable)) ||
 		((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
 	{
 		//pmlmeinfo->ADDBA_retry_count = 0;
-		//pmlmeinfo->candidate_tid_bitmap |= (0x1 << pparm->tid);
+		//pmlmeinfo->candidate_tid_bitmap |= (0x1 << pparm->tid);		
 		//psta->htpriv.candidate_tid_bitmap |= BIT(pparm->tid);
-		issue_action_BA(padapter, pparm->addr, RTW_WLAN_ACTION_ADDBA_REQ, (u16)pparm->tid);
+		issue_action_BA(padapter, pparm->addr, RTW_WLAN_ACTION_ADDBA_REQ, (u16)pparm->tid);		
 		//_set_timer(&pmlmeext->ADDBA_timer, ADDBA_TO);
 		_set_timer(&psta->addba_retry_timer, ADDBA_TO);
 	}
 #ifdef CONFIG_TDLS
-	else if((psta->tdls_sta_state & TDLS_LINKED_STATE)&&
-		(psta->htpriv.ht_option==_TRUE) &&
+	else if((psta->tdls_sta_state & TDLS_LINKED_STATE)&& 
+		(psta->htpriv.ht_option==_TRUE) && 
 		(psta->htpriv.ampdu_enable==_TRUE) )
 	{
-		issue_action_BA(padapter, pparm->addr, RTW_WLAN_ACTION_ADDBA_REQ, (u16)pparm->tid);
+		issue_action_BA(padapter, pparm->addr, RTW_WLAN_ACTION_ADDBA_REQ, (u16)pparm->tid);		
 		//_set_timer(&pmlmeext->ADDBA_timer, ADDBA_TO);
 		_set_timer(&psta->addba_retry_timer, ADDBA_TO);
 	}
 #endif //CONFIG
 	else
-	{
-		psta->htpriv.candidate_tid_bitmap &= ~BIT(pparm->tid);
+	{		
+		psta->htpriv.candidate_tid_bitmap &= ~BIT(pparm->tid);		
 	}
-
+	
 	return 	H2C_SUCCESS;
 }
 
 u8 set_tx_beacon_cmd(_adapter* padapter)
 {
 	struct cmd_obj	*ph2c;
-	struct Tx_Beacon_param 	*ptxBeacon_parm;
+	struct Tx_Beacon_param 	*ptxBeacon_parm;	
 	struct cmd_priv	*pcmdpriv = &(padapter->cmdpriv);
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	u8	res = _SUCCESS;
 	int len_diff = 0;
-
-_func_enter_;
-
+	
+_func_enter_;	
+	
 	if ((ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj))) == NULL)
 	{
 		res= _FAIL;
 		goto exit;
 	}
-
+	
 	if ((ptxBeacon_parm = (struct Tx_Beacon_param *)rtw_zmalloc(sizeof(struct Tx_Beacon_param))) == NULL)
 	{
 		rtw_mfree((unsigned char *)ph2c, sizeof(struct	cmd_obj));
@@ -12128,21 +12128,21 @@ u8 set_tx_beacon_cmd(_adapter* padapter)
 	}
 
 	_rtw_memcpy(&(ptxBeacon_parm->network), &(pmlmeinfo->network), sizeof(WLAN_BSSID_EX));
-
+	
 	len_diff = update_hidden_ssid(
 		ptxBeacon_parm->network.IEs+_BEACON_IE_OFFSET_
 		, ptxBeacon_parm->network.IELength-_BEACON_IE_OFFSET_
 		, pmlmeinfo->hidden_ssid_mode
 	);
 	ptxBeacon_parm->network.IELength += len_diff;
-
+		
 	init_h2fwcmd_w_parm_no_rsp(ph2c, ptxBeacon_parm, GEN_CMD_CODE(_TX_Beacon));
 
 	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
 
-
+	
 exit:
-
+	
 _func_exit_;
 
 	return res;
@@ -12161,14 +12161,14 @@ u8 mlme_evt_hdl(_adapter *padapter, unsigned char *pbuf)
 	evt_sz = (u16)(*peventbuf&0xffff);
 	evt_seq = (u8)((*peventbuf>>24)&0x7f);
 	evt_code = (u8)((*peventbuf>>16)&0xff);
-
-
+	
+		
 	#ifdef CHECK_EVENT_SEQ
-	// checking event sequence...
+	// checking event sequence...		
 	if (evt_seq != (ATOMIC_READ(&pevt_priv->event_seq) & 0x7f) )
 	{
 		RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("Evetn Seq Error! %d vs %d\n", (evt_seq & 0x7f), (ATOMIC_READ(&pevt_priv->event_seq) & 0x7f)));
-
+	
 		pevt_priv->event_seq = (evt_seq+1)&0x7f;
 
 		goto _abort_event_;
@@ -12182,21 +12182,21 @@ u8 mlme_evt_hdl(_adapter *padapter, unsigned char *pbuf)
 		goto _abort_event_;
 	}
 
-	// checking if event size match the event parm size
-	if ((wlanevents[evt_code].parmsize != 0) &&
+	// checking if event size match the event parm size	
+	if ((wlanevents[evt_code].parmsize != 0) && 
 			(wlanevents[evt_code].parmsize != evt_sz))
 	{
-
-		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\nEvent(%d) Parm Size mismatch (%d vs %d)!\n",
+			
+		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\nEvent(%d) Parm Size mismatch (%d vs %d)!\n", 
 			evt_code, wlanevents[evt_code].parmsize, evt_sz));
-		goto _abort_event_;
-
+		goto _abort_event_;	
+			
 	}
 
 	ATOMIC_INC(&pevt_priv->event_seq);
 
 	peventbuf += 2;
-
+				
 	if(peventbuf)
 	{
 		event_callback = wlanevents[evt_code].event_callback;
@@ -12210,7 +12210,7 @@ u8 mlme_evt_hdl(_adapter *padapter, unsigned char *pbuf)
 
 
 	return H2C_SUCCESS;
-
+		
 }
 
 u8 h2c_msg_hdl(_adapter *padapter, unsigned char *pbuf)
@@ -12229,22 +12229,22 @@ u8 tx_beacon_hdl(_adapter *padapter, unsigned char *pbuf)
 		return H2C_PARAMETERS_ERROR;
 	}
 #ifdef CONFIG_AP_MODE
-	else //tx bc/mc frames after update TIM
-	{
+	else //tx bc/mc frames after update TIM 
+	{	
 		_irqL irqL;
 		struct sta_info *psta_bmc;
 		_list	*xmitframe_plist, *xmitframe_phead;
 		struct xmit_frame *pxmitframe=NULL;
 		struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
 		struct sta_priv  *pstapriv = &padapter->stapriv;
-
+		
 		//for BC/MC Frames
 		psta_bmc = rtw_get_bcmc_stainfo(padapter);
 		if(!psta_bmc)
 			return H2C_SUCCESS;
-
+	
 		if((pstapriv->tim_bitmap&BIT(0)) && (psta_bmc->sleepq_len>0))
-		{
+		{				
 #ifndef CONFIG_PCI_HCI
 			rtw_msleep_os(10);// 10ms, ATIM(HIQ) Windows
 #endif
@@ -12255,7 +12255,7 @@ u8 tx_beacon_hdl(_adapter *padapter, unsigned char *pbuf)
 			xmitframe_plist = get_next(xmitframe_phead);
 
 			while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == _FALSE)
-			{
+			{			
 				pxmitframe = LIST_CONTAINOR(xmitframe_plist, struct xmit_frame, list);
 
 				xmitframe_plist = get_next(xmitframe_plist);
@@ -12275,7 +12275,7 @@ u8 tx_beacon_hdl(_adapter *padapter, unsigned char *pbuf)
 #if 0
 				_exit_critical_bh(&psta_bmc->sleep_q.lock, &irqL);
 				if(rtw_hal_xmit(padapter, pxmitframe) == _TRUE)
-				{
+				{		
 					rtw_os_xmit_complete(padapter, pxmitframe);
 				}
 				_enter_critical_bh(&psta_bmc->sleep_q.lock, &irqL);
@@ -12283,10 +12283,10 @@ u8 tx_beacon_hdl(_adapter *padapter, unsigned char *pbuf)
 #endif
 				rtw_hal_xmitframe_enqueue(padapter, pxmitframe);
 
-				//pstapriv->tim_bitmap &= ~BIT(0);
-
-			}
-
+				//pstapriv->tim_bitmap &= ~BIT(0);				
+		
+			}	
+	
 			//_exit_critical_bh(&psta_bmc->sleep_q.lock, &irqL);
 	               _exit_critical_bh(&pxmitpriv->lock, &irqL);
 
@@ -12296,7 +12296,7 @@ u8 tx_beacon_hdl(_adapter *padapter, unsigned char *pbuf)
 #endif
 
 	return H2C_SUCCESS;
-
+	
 }
 
 void change_band_update_ie(_adapter *padapter, WLAN_BSSID_EX *pnetwork)
@@ -12357,7 +12357,7 @@ void dc_SelectChannel(_adapter *padapter, unsigned char channel)
 {
 	PADAPTER ptarget_adapter;
 
-	if( (padapter->pbuddy_adapter != NULL) &&
+	if( (padapter->pbuddy_adapter != NULL) && 
 		(padapter->DualMacConcurrent == _TRUE) &&
 		(padapter->adapter_type == SECONDARY_ADAPTER))
 	{
@@ -12380,7 +12380,7 @@ void dc_SetBWMode(_adapter *padapter, unsigned short bwmode, unsigned char chann
 {
 	PADAPTER ptarget_adapter;
 
-	if( (padapter->pbuddy_adapter != NULL) &&
+	if( (padapter->pbuddy_adapter != NULL) && 
 		(padapter->DualMacConcurrent == _TRUE) &&
 		(padapter->adapter_type == SECONDARY_ADAPTER))
 	{
@@ -12405,7 +12405,7 @@ void dc_set_channel_bwmode_disconnect(_adapter *padapter)
 	PADAPTER pbuddy_adapter = padapter->pbuddy_adapter;
 	struct mlme_priv *pbuddy_mlmepriv = NULL;
 
-	if(pbuddy_adapter != NULL &&
+	if(pbuddy_adapter != NULL && 
 		padapter->DualMacConcurrent == _TRUE)
 	{
 		pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
@@ -12433,12 +12433,12 @@ u8 dc_handle_join_request(_adapter *padapter)
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	WLAN_BSSID_EX		*pnetwork = (WLAN_BSSID_EX*)(&(pmlmeinfo->network));
-	PADAPTER pbuddy_adapter = padapter->pbuddy_adapter;
+	PADAPTER pbuddy_adapter = padapter->pbuddy_adapter;		
 	struct mlme_ext_priv *pbuddy_mlmeext = NULL;
 	struct mlme_priv	*pbuddy_mlmepriv = NULL;
 	u8	ret = _SUCCESS;
 
-	if(pbuddy_adapter != NULL &&
+	if(pbuddy_adapter != NULL && 
 		padapter->DualMacConcurrent == _TRUE)
 	{
 		pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
@@ -12496,14 +12496,14 @@ void dc_handle_join_done(_adapter *padapter, u8 join_res)
 	u8	change_band = _FALSE;
 
 
-	if(pbuddy_adapter != NULL &&
+	if(pbuddy_adapter != NULL && 
 		padapter->DualMacConcurrent == _TRUE)
 	{
 		pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
 		pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 		pbuddy_mlmeinfo = &(pbuddy_mlmeext->mlmext_info);
 		pbuddy_network_mlmeext = &(pbuddy_mlmeinfo->network);
-
+	
 		if(((pbuddy_mlmeinfo->state&0x03) == WIFI_FW_AP_STATE) &&
 				check_fwstate(pbuddy_mlmepriv, _FW_LINKED))
 		{
@@ -12524,7 +12524,7 @@ void dc_handle_join_done(_adapter *padapter, u8 join_res)
 
 				//sync channel/bwmode/ch_offset with another adapter
 				pbuddy_mlmeext->cur_channel = pmlmeext->cur_channel;
-
+				
 				if(pbuddy_mlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40)
 				{
 					p = rtw_get_ie((pbuddy_network_mlmeext->IEs + sizeof(NDIS_802_11_FIXED_IEs)), _HT_ADD_INFO_IE_, &ie_len, (pbuddy_network_mlmeext->IELength - sizeof(NDIS_802_11_FIXED_IEs)));
@@ -12532,8 +12532,8 @@ void dc_handle_join_done(_adapter *padapter, u8 join_res)
 					{
 						pht_info = (struct HT_info_element *)(p+2);
 						pht_info->infos[0] &= ~(BIT(0)|BIT(1)); //no secondary channel is present
-					}
-
+					}	
+				
 					if(pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40)
 					{
 						pbuddy_mlmeext->cur_ch_offset = pmlmeext->cur_ch_offset;
@@ -12549,9 +12549,9 @@ void dc_handle_join_done(_adapter *padapter, u8 join_res)
 								case HAL_PRIME_CHNL_OFFSET_UPPER:
 									pht_info->infos[0] |= 0x3;
 									break;
-								case HAL_PRIME_CHNL_OFFSET_DONT_CARE:
-								default:
-									break;
+								case HAL_PRIME_CHNL_OFFSET_DONT_CARE:							
+								default:							
+									break;					
 							}
 						}
 					}
@@ -12620,7 +12620,7 @@ void dc_handle_join_done(_adapter *padapter, u8 join_res)
 			{
 				set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
 			}
-
+		
 			issue_nulldata(pbuddy_adapter, NULL, 0, 0, 0);
 		}
 	}
@@ -12631,7 +12631,7 @@ sint	dc_check_fwstate(_adapter *padapter, sint fw_state)
 	PADAPTER pbuddy_adapter = padapter->pbuddy_adapter;
 	struct mlme_priv *pbuddy_mlmepriv = NULL;
 
-	if(padapter->pbuddy_adapter != NULL &&
+	if(padapter->pbuddy_adapter != NULL && 
 		padapter->DualMacConcurrent == _TRUE)
 
 	{
@@ -12647,17 +12647,17 @@ u8 dc_handle_site_survey(_adapter *padapter)
 {
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-	PADAPTER pbuddy_adapter = padapter->pbuddy_adapter;
+	PADAPTER pbuddy_adapter = padapter->pbuddy_adapter;		
 
 	// only mac0 can do scan request, help issue nulldata(1) for mac1
-	if(pbuddy_adapter != NULL &&
+	if(pbuddy_adapter != NULL && 
 		padapter->DualMacConcurrent == _TRUE)
 	{
 		if (is_client_associated_to_ap(pbuddy_adapter) == _TRUE)
 		{
 			pmlmeext->sitesurvey_res.state = SCAN_TXNULL;
-
-			issue_nulldata(pbuddy_adapter, NULL, 1, 2, 0);
+		
+			issue_nulldata(pbuddy_adapter, NULL, 1, 2, 0);			
 
 			return _TRUE;
 		}
@@ -12668,10 +12668,10 @@ u8 dc_handle_site_survey(_adapter *padapter)
 
 void	dc_report_survey_event(_adapter *padapter, union recv_frame *precv_frame)
 {
-	if(padapter->pbuddy_adapter != NULL &&
+	if(padapter->pbuddy_adapter != NULL && 
 		padapter->DualMacConcurrent == _TRUE)
 	{
-		report_survey_event(padapter->pbuddy_adapter, precv_frame);
+		report_survey_event(padapter->pbuddy_adapter, precv_frame);	
 	}
 }
 
@@ -12687,7 +12687,7 @@ void dc_set_channel_bwmode_survey_done(_adapter *padapter)
 	u8 cur_bwmode;
 	u8 cur_ch_offset;
 
-	if(pbuddy_adapter != NULL &&
+	if(pbuddy_adapter != NULL && 
 		padapter->DualMacConcurrent == _TRUE)
 	{
 		pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
@@ -12721,7 +12721,7 @@ void dc_set_channel_bwmode_survey_done(_adapter *padapter)
 
 		if (is_client_associated_to_ap(pbuddy_adapter) == _TRUE)
 		{
-			//issue null data
+			//issue null data 
 			issue_nulldata(pbuddy_adapter, NULL, 0, 0, 0);
 		}
 
@@ -12732,7 +12732,7 @@ void dc_set_channel_bwmode_survey_done(_adapter *padapter)
 			DBG_871X("survey done, current CH=%d, BW=%d, offset=%d\n", cur_channel, cur_bwmode, cur_ch_offset);
 
 			DBG_871X("restart pbuddy_adapter's beacon\n");
-
+		
 			update_beacon(pbuddy_adapter, 0, NULL, _TRUE);
 		}
 	}
@@ -12746,7 +12746,7 @@ void dc_set_ap_channel_bandwidth(_adapter *padapter, u8 channel, u8 channel_offs
 {
 	u8	*p;
 	u8	val8, cur_channel, cur_bwmode, cur_ch_offset, change_band;
-	int	ie_len;
+	int	ie_len;	
 	struct registry_priv	*pregpriv = &padapter->registrypriv;
 	struct mlme_priv		*pmlmepriv = &(padapter->mlmepriv);
 	WLAN_BSSID_EX		*pnetwork = (WLAN_BSSID_EX *)&pmlmepriv->cur_network.network;
@@ -12770,12 +12770,12 @@ void dc_set_ap_channel_bandwidth(_adapter *padapter, u8 channel, u8 channel_offs
 		pht_info = (struct HT_info_element *)(p+2);
 	}
 
-	if(pbuddy_adapter != NULL &&
+	if(pbuddy_adapter != NULL && 
 		padapter->DualMacConcurrent == _TRUE)
 	{
 		pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
 		pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
-
+		
 		if(!check_fwstate(pbuddy_mlmepriv, _FW_LINKED|_FW_UNDER_LINKING|_FW_UNDER_SURVEY))
 		{
 			set_channel_bwmode(padapter, cur_channel, cur_ch_offset, cur_bwmode);
@@ -12786,7 +12786,7 @@ void dc_set_ap_channel_bandwidth(_adapter *padapter, u8 channel, u8 channel_offs
 			DBG_871X("Another iface is at linked state, sync cur_channel/cur_bwmode/cur_ch_offset\n");
 			DBG_871X("Another adapter, CH=%d, BW=%d, offset=%d\n", pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_bwmode, pbuddy_mlmeext->cur_ch_offset);
 			DBG_871X("Current adapter, CH=%d, BW=%d, offset=%d\n", cur_channel, cur_bwmode, cur_ch_offset);
-
+			
 			cur_channel = pbuddy_mlmeext->cur_channel;
 			if(cur_bwmode == HT_CHANNEL_WIDTH_40)
 			{
@@ -12799,7 +12799,7 @@ void dc_set_ap_channel_bandwidth(_adapter *padapter, u8 channel, u8 channel_offs
 
 					//to update cur_ch_offset value in beacon
 					if(pht_info)
-					{
+					{				
 						switch(cur_ch_offset)
 						{
 							case HAL_PRIME_CHNL_OFFSET_LOWER:
@@ -12809,8 +12809,8 @@ void dc_set_ap_channel_bandwidth(_adapter *padapter, u8 channel, u8 channel_offs
 								pht_info->infos[0] |= 0x3;
 								break;
 							case HAL_PRIME_CHNL_OFFSET_DONT_CARE:
-							default:
-								break;
+							default:							
+								break;					
 						}
 					}
 				}
@@ -12822,7 +12822,7 @@ void dc_set_ap_channel_bandwidth(_adapter *padapter, u8 channel, u8 channel_offs
 					if(cur_channel>0 && cur_channel<5)
 					{
 						if(pht_info)
-							pht_info->infos[0] |= 0x1;
+							pht_info->infos[0] |= 0x1;		
 
 						cur_bwmode = HT_CHANNEL_WIDTH_40;
 						cur_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;
@@ -12842,7 +12842,7 @@ void dc_set_ap_channel_bandwidth(_adapter *padapter, u8 channel, u8 channel_offs
 			}
 
 			// to update channel value in beacon
-			pnetwork->Configuration.DSConfig = cur_channel;
+			pnetwork->Configuration.DSConfig = cur_channel;		
 			p = rtw_get_ie((pnetwork->IEs + sizeof(NDIS_802_11_FIXED_IEs)), _DSSET_IE_, &ie_len, (pnetwork->IELength - sizeof(NDIS_802_11_FIXED_IEs)));
 			if(p && ie_len>0)
 				*(p + 2) = cur_channel;
@@ -12877,8 +12877,8 @@ void dc_set_ap_channel_bandwidth(_adapter *padapter, u8 channel, u8 channel_offs
 void dc_resume_xmit(_adapter *padapter)
 {
 	PADAPTER pbuddy_adapter = padapter->pbuddy_adapter;
-
-	if(pbuddy_adapter != NULL &&
+	
+	if(pbuddy_adapter != NULL && 
 		padapter->DualMacConcurrent == _TRUE)
 	{
 		DBG_871X("dc_resume_xmit,  resume pbuddy_adapter Tx\n");
@@ -12891,7 +12891,7 @@ u8	dc_check_xmit(_adapter *padapter)
 	PADAPTER pbuddy_adapter = padapter->pbuddy_adapter;
 	struct mlme_priv *pbuddy_mlmepriv = NULL;
 
-	if(pbuddy_adapter != NULL &&
+	if(pbuddy_adapter != NULL && 
 		padapter->DualMacConcurrent == _TRUE)
 	{
 		pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
@@ -12914,28 +12914,28 @@ sint check_buddy_mlmeinfo_state(_adapter *padapter, u32 state)
 	struct mlme_ext_info *pbuddy_mlmeinfo;
 
 	if(padapter == NULL)
-		return _FALSE;
-
+		return _FALSE;	
+	
 	pbuddy_adapter = padapter->pbuddy_adapter;
 
 	if(pbuddy_adapter == NULL)
-		return _FALSE;
+		return _FALSE;	
 
 
 	pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 	pbuddy_mlmeinfo = &(pbuddy_mlmeext->mlmext_info);
-
+		
 	if((pbuddy_mlmeinfo->state&0x03) == state)
-		return _TRUE;
+		return _TRUE;		
 
 	return _FALSE;
-
+	
 }
 
 void concurrent_chk_joinbss_done(_adapter *padapter, int join_res)
 {
 	struct mlme_ext_priv	*pmlmeext;
-	struct mlme_ext_info	*pmlmeinfo;
+	struct mlme_ext_info	*pmlmeinfo;	
 	PADAPTER pbuddy_adapter;
 	struct mlme_priv *pbuddy_mlmepriv;
 	struct mlme_ext_priv *pbuddy_mlmeext;
@@ -12965,7 +12965,7 @@ void concurrent_chk_joinbss_done(_adapter *padapter, int join_res)
 
 		DBG_871X("after join,primary adapter, CH=%d, BW=%d, offset=%d\n"
 			, pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
-
+		
 
 		if(join_res >= 0)
 		{
@@ -12988,7 +12988,7 @@ void concurrent_chk_joinbss_done(_adapter *padapter, int join_res)
 					pht_info = (struct HT_info_element *)(p+2);
 					pht_info->infos[0] &= ~(BIT(0)|BIT(1)); //no secondary channel is present
 				}
-
+			
 				if(pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40)
 				{
 					pbuddy_mlmeext->cur_ch_offset = pmlmeext->cur_ch_offset;
@@ -13004,20 +13004,20 @@ void concurrent_chk_joinbss_done(_adapter *padapter, int join_res)
 							case HAL_PRIME_CHNL_OFFSET_UPPER:
 								pht_info->infos[0] |= 0x3;
 								break;
-							case HAL_PRIME_CHNL_OFFSET_DONT_CARE:
-							default:
-								break;
+							case HAL_PRIME_CHNL_OFFSET_DONT_CARE:							
+							default:							
+								break;					
 						}
-
-					}
-
+						
+					}					
+				
 				}
 				else if(pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_20)
 				{
 					if(pmlmeext->cur_channel>=1 && pmlmeext->cur_channel<=4)
 					{
 						if(pht_info)
-							pht_info->infos[0] |= HT_INFO_HT_PARAM_SECONDARY_CHNL_ABOVE;
+							pht_info->infos[0] |= HT_INFO_HT_PARAM_SECONDARY_CHNL_ABOVE;		
 
 						pbuddy_mlmeext->cur_bwmode = HT_CHANNEL_WIDTH_40;
 						pbuddy_mlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;
@@ -13026,9 +13026,9 @@ void concurrent_chk_joinbss_done(_adapter *padapter, int join_res)
 					{
 						if(pht_info)
 							pht_info->infos[0] |= HT_INFO_HT_PARAM_SECONDARY_CHNL_BELOW;
-
+						
 						pbuddy_mlmeext->cur_bwmode = HT_CHANNEL_WIDTH_40;
-						pbuddy_mlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER;
+						pbuddy_mlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER;						
 					}
 					else
 					{
@@ -13047,7 +13047,7 @@ void concurrent_chk_joinbss_done(_adapter *padapter, int join_res)
 							case 157:
 							{
 								if(pht_info)
-									pht_info->infos[0] |= HT_INFO_HT_PARAM_SECONDARY_CHNL_ABOVE;
+									pht_info->infos[0] |= HT_INFO_HT_PARAM_SECONDARY_CHNL_ABOVE;		
 								pbuddy_mlmeext->cur_bwmode = HT_CHANNEL_WIDTH_40;
 								pbuddy_mlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;
 								break;
@@ -13066,7 +13066,7 @@ void concurrent_chk_joinbss_done(_adapter *padapter, int join_res)
 							{
 								if(pht_info)
 									pht_info->infos[0] |= HT_INFO_HT_PARAM_SECONDARY_CHNL_BELOW;
-
+								
 								pbuddy_mlmeext->cur_bwmode = HT_CHANNEL_WIDTH_40;
 								pbuddy_mlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER;
 								break;
@@ -13076,16 +13076,16 @@ void concurrent_chk_joinbss_done(_adapter *padapter, int join_res)
 									pht_info->infos[0] &= ~HT_INFO_HT_PARAM_SECONDARY_CHNL_BELOW;
 								pbuddy_mlmeext->cur_bwmode = HT_CHANNEL_WIDTH_20;
 								pbuddy_mlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
-								break;
+								break;								
 
 						}
-
+						
 					}
 
 				}
 
 				set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
-
+				
 			}
 			else
 			{
@@ -13094,7 +13094,7 @@ void concurrent_chk_joinbss_done(_adapter *padapter, int join_res)
 
 
 			// to update channel value in beacon
-			pbuddy_network_mlmeext->Configuration.DSConfig = pmlmeext->cur_channel;
+			pbuddy_network_mlmeext->Configuration.DSConfig = pmlmeext->cur_channel;		
 			p = rtw_get_ie((pbuddy_network_mlmeext->IEs + sizeof(NDIS_802_11_FIXED_IEs)), _DSSET_IE_, &ie_len, (pbuddy_network_mlmeext->IELength - sizeof(NDIS_802_11_FIXED_IEs)));
 			if(p && ie_len>0)
 				*(p + 2) = pmlmeext->cur_channel;
@@ -13119,20 +13119,20 @@ void concurrent_chk_joinbss_done(_adapter *padapter, int join_res)
 		DBG_871X("after join, second adapter, CH=%d, BW=%d, offset=%d\n", pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_bwmode, pbuddy_mlmeext->cur_ch_offset);
 
 		DBG_871X("update pbuddy_adapter's beacon\n");
-
+		
 		update_beacon(pbuddy_adapter, 0, NULL, _TRUE);
 
 	}
 	else if(((pbuddy_mlmeinfo->state&0x03) == WIFI_FW_STATION_STATE) &&
 			check_fwstate(pbuddy_mlmepriv, _FW_LINKED))
-	{
+	{		
 		if(join_res >= 0)
-		{
+		{	
 			pbuddy_mlmeext->cur_channel = pmlmeext->cur_channel;
 			if(pbuddy_mlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40)
-				set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
+				set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);		
 			else if(pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40)
-				set_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
+				set_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);		
 			else
 				set_channel_bwmode(padapter, pmlmeext->cur_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 		}
@@ -13140,13 +13140,13 @@ void concurrent_chk_joinbss_done(_adapter *padapter, int join_res)
 		{
 			// switch back to original channel/bwmode/ch_offset;
 			set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
-		}
+		}			
 	}
 	else
 	{
 		set_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
 	}
-
+	
 }
 #endif //CONFIG_CONCURRENT_MODE
 
@@ -13160,7 +13160,7 @@ int rtw_chk_start_clnt_join(_adapter *padapter)
 	bool connect_allow = _TRUE;
 
 #ifdef CONFIG_CONCURRENT_MODE
-	PADAPTER pbuddy_adapter;
+	PADAPTER pbuddy_adapter;	
 	struct mlme_ext_priv *pbuddy_mlmeext;
 	struct mlme_ext_info	*pbuddy_pmlmeinfo;
 	struct mlme_priv *pbuddy_mlmepriv;
@@ -13169,7 +13169,7 @@ int rtw_chk_start_clnt_join(_adapter *padapter)
 		goto start_join_set_ch_bw;
 	}
 
-	pbuddy_adapter = padapter->pbuddy_adapter;
+	pbuddy_adapter = padapter->pbuddy_adapter;		
 	pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 	pbuddy_pmlmeinfo = &(pbuddy_mlmeext->mlmext_info);
 	pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
@@ -13256,7 +13256,7 @@ int rtw_chk_start_clnt_join(_adapter *padapter)
 			rtw_indicate_disconnect(pbuddy_adapter);
 			rtw_free_assoc_resources(pbuddy_adapter, 1);
 		}
-	}
+	}	
 
 start_join_set_ch_bw:
 #endif /* CONFIG_CONCURRENT_MODE */
@@ -13361,7 +13361,7 @@ u8 set_chplan_hdl(_adapter *padapter, unsigned char *pbuf)
 	setChannelPlan_param = (struct SetChannelPlan_param *)pbuf;
 
 	pmlmeext->max_chan_nums = init_channel_set(padapter, setChannelPlan_param->channel_plan, pmlmeext->channel_set);
-	init_channel_list(padapter, pmlmeext->channel_set, pmlmeext->max_chan_nums, &pmlmeext->channel_list);
+	init_channel_list(padapter, pmlmeext->channel_set, pmlmeext->max_chan_nums, &pmlmeext->channel_list);	
 
 	return 	H2C_SUCCESS;
 }
@@ -13462,7 +13462,7 @@ u8 tdls_hdl(_adapter *padapter, unsigned char *pbuf)
 
 	//_enter_critical_bh(&(ptdlsinfo->hdl_lock), &irqL);
 	DBG_871X("[%s] option:%d\n", __FUNCTION__, option);
-
+		
 	switch(option){
 		case TDLS_WRCR:
 			//As long as TDLS handshake success, we should set RCR_CBSSID_DATA bit to 0
@@ -13481,8 +13481,8 @@ u8 tdls_hdl(_adapter *padapter, unsigned char *pbuf)
 			_cancel_timer_ex(&ptdls_sta->base_ch_timer);
 			_cancel_timer_ex(&ptdls_sta->off_ch_timer);
 			SelectChannel(padapter, pmlmeext->cur_channel);
-			ptdls_sta->tdls_sta_state &= ~(TDLS_CH_SWITCH_ON_STATE |
-								TDLS_PEER_AT_OFF_STATE |
+			ptdls_sta->tdls_sta_state &= ~(TDLS_CH_SWITCH_ON_STATE | 
+								TDLS_PEER_AT_OFF_STATE | 
 								TDLS_AT_OFF_CH_STATE);
 			DBG_871X("go back to base channel\n ");
 			issue_nulldata(padapter, NULL, 0, 0, 0);
@@ -13549,8 +13549,8 @@ u8 tdls_hdl(_adapter *padapter, unsigned char *pbuf)
 			_cancel_timer_ex(&ptdls_sta->base_ch_timer);
 			_cancel_timer_ex(&ptdls_sta->off_ch_timer);
 			SelectChannel(padapter, pmlmeext->cur_channel);
-			ptdls_sta->tdls_sta_state &= ~(TDLS_CH_SWITCH_ON_STATE |
-								TDLS_PEER_AT_OFF_STATE |
+			ptdls_sta->tdls_sta_state &= ~(TDLS_CH_SWITCH_ON_STATE | 
+								TDLS_PEER_AT_OFF_STATE | 
 								TDLS_AT_OFF_CH_STATE);
 			DBG_871X("go back to base channel\n ");
 			issue_nulldata(padapter, NULL, 0, 0, 0);
@@ -13571,7 +13571,7 @@ u8 tdls_hdl(_adapter *padapter, unsigned char *pbuf)
 			if((ptdls_sta->tdls_sta_state & TDLS_PEER_AT_OFF_STATE) != TDLS_PEER_AT_OFF_STATE){
 				issue_nulldata_to_TDLS_peer_STA(padapter, ptdls_sta, 0);
 			}
-			_set_timer(&ptdls_sta->base_ch_timer, TDLS_STAY_TIME);
+			_set_timer(&ptdls_sta->base_ch_timer, TDLS_STAY_TIME);	
 			break;
 		case TDLS_RS_RCR:
 			rtw_hal_set_hwreg(padapter, HW_VAR_TDLS_RS_RCR, 0);
@@ -13586,7 +13586,7 @@ u8 tdls_hdl(_adapter *padapter, unsigned char *pbuf)
 		case TDLS_FREE_STA:
 			free_tdls_sta(padapter, ptdls_sta);
 			break;
-
+			
 	}
 
 	//_exit_critical_bh(&(ptdlsinfo->hdl_lock), &irqL);
@@ -13597,3 +13597,4 @@ u8 tdls_hdl(_adapter *padapter, unsigned char *pbuf)
 #endif //CONFIG_TDLS
 
 }
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_mp.c b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_mp.c
old mode 100644
new mode 100755
index 2695425..9af42cd
--- a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_mp.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_mp.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -62,7 +62,7 @@ u32 read_macreg(_adapter *padapter, u32 addr, u32 sz)
 	}
 
 	return val;
-
+	
 }
 
 void write_macreg(_adapter *padapter, u32 addr, u32 val, u32 sz)
@@ -835,7 +835,7 @@ void	SetAntennaPathPower(PADAPTER pAdapter)
 {
 	Hal_SetAntennaPathPower(pAdapter);
 }
-
+	
 void SetTxPower(PADAPTER pAdapter)
 {
 	Hal_SetTxPower(pAdapter);
@@ -1023,7 +1023,7 @@ static thread_return mp_xmit_packet_thread(thread_context context)
 }
 
 void fill_txdesc_for_mp(PADAPTER padapter, struct tx_desc *ptxdesc)
-{
+{		
 	struct mp_priv *pmp_priv = &padapter->mppriv;
 	_rtw_memcpy(ptxdesc, &(pmp_priv->tx.desc), TXDESC_SIZE);
 }
@@ -1177,9 +1177,9 @@ void SetPacketRx(PADAPTER pAdapter, u8 bStartRx)
 	if(bStartRx)
 	{
 		pHalData->ReceiveConfig = AAP | APM | AM | AB | APP_ICV | ADF | AMF | HTC_LOC_CTRL | APP_MIC | APP_PHYSTS;
-
+	
 		pHalData->ReceiveConfig |= ACRC32;
-
+	
 		rtw_write32(pAdapter, REG_RCR, pHalData->ReceiveConfig);
 
 		// Accept all data frames
@@ -1276,7 +1276,7 @@ u32 mp_query_psd(PADAPTER pAdapter, u8 *data)
 {
 	u32 i, psd_pts=0, psd_start=0, psd_stop=0;
 	u32 psd_data=0;
-
+	
 #ifdef PLATFORM_LINUX
 	if (!netif_running(pAdapter->pnetdev)) {
 		RT_TRACE(_module_mp_, _drv_warning_, ("mp_query_psd: Fail! interface not opened!\n"));
@@ -1292,7 +1292,7 @@ u32 mp_query_psd(PADAPTER pAdapter, u8 *data)
 	if (strlen(data) == 0) { //default value
 		psd_pts = 128;
 		psd_start = 64;
-		psd_stop = 128;
+		psd_stop = 128;   
 	} else {
 		sscanf(data, "pts=%d,start=%d,stop=%d", &psd_pts, &psd_start, &psd_stop);
 	}
@@ -1321,3 +1321,4 @@ u32 mp_query_psd(PADAPTER pAdapter, u8 *data)
 }
 
 #endif
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_mp_ioctl.c b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_mp_ioctl.c
old mode 100644
new mode 100755
index a0d8680..b941e2c
--- a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_mp_ioctl.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_mp_ioctl.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -176,7 +176,7 @@ NDIS_STATUS oid_rt_pro_write_rf_reg_hdl(struct oid_par_priv *poid_par_priv)
 		  path, offset, value));
 
 	_irqlevel_changed_(&oldirql, LOWER);
-	write_rfreg(Adapter, path, offset, value);
+ 	write_rfreg(Adapter, path, offset, value);
 	_irqlevel_changed_(&oldirql, RAISE);
 
 _func_exit_;
@@ -1125,7 +1125,7 @@ NDIS_STATUS oid_rt_pro_write_txcmd_hdl(struct oid_par_priv *poid_par_priv)
 	TxCmd_Info=(TX_CMD_Desc*)poid_par_priv->information_buf;
 
 	RT_TRACE(_module_mp_, _drv_info_, ("WRITE_TXCMD:Addr=%.8X\n", TxCmd_Info->offset));
-	RT_TRACE(_module_mp_, _drv_info_, ("WRITE_TXCMD:1.)%.8X\n", (ULONG)TxCmd_Info->TxCMD.value[0]));
+  	RT_TRACE(_module_mp_, _drv_info_, ("WRITE_TXCMD:1.)%.8X\n", (ULONG)TxCmd_Info->TxCMD.value[0]));
 	RT_TRACE(_module_mp_, _drv_info_, ("WRITE_TXCMD:2.)%.8X\n", (ULONG)TxCmd_Info->TxCMD.value[1]));
 	RT_TRACE(_module_mp_, _drv_info_, (("WRITE_TXCMD:3.)%.8X\n", (ULONG)TxCmd_Info->TxCMD.value[2]));
 	RT_TRACE(_module_mp_, _drv_info_, ("WRITE_TXCMD:4.)%.8X\n", (ULONG)TxCmd_Info->TxCMD.value[3]));
@@ -2951,3 +2951,4 @@ NDIS_STATUS oid_rt_get_power_mode_hdl(struct oid_par_priv *poid_par_priv)
 	return 0;
 #endif
 }
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_p2p.c b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_p2p.c
old mode 100644
new mode 100755
index 0fe0443..b41eb24
--- a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_p2p.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_p2p.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -68,19 +68,19 @@ static u32 go_add_group_info_attr(struct wifidirect_info *pwdinfo, u8 *pbuf)
 	plist = get_next(phead);
 
 	//look up sta asoc_queue
-	while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
-	{
+	while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)	
+	{		
 		psta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);
-
+		
 		plist = get_next(plist);
-
+		
 
 		if(psta->is_p2p_device)
 		{
 			tmplen = 0;
-
+			
 			pcur++;
-
+		
 			//P2P device address
 			_rtw_memcpy(pcur, psta->dev_addr, ETH_ALEN);
 			pcur += ETH_ALEN;
@@ -104,7 +104,7 @@ static u32 go_add_group_info_attr(struct wifidirect_info *pwdinfo, u8 *pbuf)
 
 			_rtw_memcpy(pcur, psta->secdev_types_list, psta->num_of_secdev_type*8);
 			pcur += psta->num_of_secdev_type*8;
-
+			
 			if(psta->dev_name_len>0)
 			{
 				//*(u16*)(pcur) = cpu_to_be16( WPS_ATTR_DEVICE_NAME );
@@ -121,17 +121,17 @@ static u32 go_add_group_info_attr(struct wifidirect_info *pwdinfo, u8 *pbuf)
 
 
 			tmplen = (u8)(pcur-pstart);
-
+			
 			*pstart = (tmplen-1);
 
 			attr_len += tmplen;
 
 			//pstart += tmplen;
 			pstart = pcur;
-
+			
 		}
-
-
+		
+		
 	}
 	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 
@@ -155,8 +155,8 @@ static void issue_group_disc_req(struct wifidirect_info *pwdinfo, u8 *da)
 	unsigned short				*fctrl;
 	_adapter *padapter = pwdinfo->padapter;
 	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
-	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
-	unsigned char category = RTW_WLAN_CATEGORY_P2P;//P2P action frame
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);	
+	unsigned char category = RTW_WLAN_CATEGORY_P2P;//P2P action frame	
 	u32	p2poui = cpu_to_be32(P2POUI);
 	u8	oui_subtype = P2P_GO_DISC_REQUEST;
 	u8	dialogToken=0;
@@ -192,10 +192,10 @@ static void issue_group_disc_req(struct wifidirect_info *pwdinfo, u8 *da)
 	pattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
 
 	//Build P2P action frame header
-	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));	
 	pframe = rtw_set_fixed_ie(pframe, 4, (unsigned char *) &(p2poui), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(dialogToken), &(pattrib->pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));	
+	pframe = rtw_set_fixed_ie(pframe, 1, &(dialogToken), &(pattrib->pktlen));		
 
 	//there is no IE in this P2P action frame
 
@@ -206,7 +206,7 @@ static void issue_group_disc_req(struct wifidirect_info *pwdinfo, u8 *da)
 }
 
 static void issue_p2p_devdisc_resp(struct wifidirect_info *pwdinfo, u8 *da, u8 status, u8 dialogToken)
-{
+{	
 	struct xmit_frame			*pmgntframe;
 	struct pkt_attrib			*pattrib;
 	unsigned char					*pframe;
@@ -214,16 +214,16 @@ static void issue_p2p_devdisc_resp(struct wifidirect_info *pwdinfo, u8 *da, u8 s
 	unsigned short				*fctrl;
 	_adapter *padapter = pwdinfo->padapter;
 	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
-	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);	
 	unsigned char category = RTW_WLAN_CATEGORY_PUBLIC;
 	u8			action = P2P_PUB_ACTION_ACTION;
 	u32			p2poui = cpu_to_be32(P2POUI);
 	u8			oui_subtype = P2P_DEVDISC_RESP;
 	u8 p2pie[8] = { 0x00 };
-	u32 p2pielen = 0;
+	u32 p2pielen = 0;	
 
 	DBG_871X("[%s]\n", __FUNCTION__);
-
+	
 	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
 	{
 		return;
@@ -256,8 +256,8 @@ static void issue_p2p_devdisc_resp(struct wifidirect_info *pwdinfo, u8 *da, u8 s
 	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 4, (unsigned char *) &(p2poui), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(dialogToken), &(pattrib->pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));	
+	pframe = rtw_set_fixed_ie(pframe, 1, &(dialogToken), &(pattrib->pktlen));		
 
 
 	//Build P2P IE
@@ -270,8 +270,8 @@ static void issue_p2p_devdisc_resp(struct wifidirect_info *pwdinfo, u8 *da, u8 s
 
 	// P2P_ATTR_STATUS
 	p2pielen += rtw_set_p2p_attr_content(&p2pie[p2pielen], P2P_ATTR_STATUS, 1, &status);
-
-	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, p2pie, &pattrib->pktlen);
+	
+	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, p2pie, &pattrib->pktlen);	
 
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
@@ -291,8 +291,8 @@ static void issue_p2p_provision_resp(struct wifidirect_info *pwdinfo, u8* raddr,
 	u8			wpsielen = 0;
 #ifdef CONFIG_WFD
 	u32					wfdielen = 0;
-#endif //CONFIG_WFD
-
+#endif //CONFIG_WFD		
+	
 	struct xmit_frame			*pmgntframe;
 	struct pkt_attrib			*pattrib;
 	unsigned char					*pframe;
@@ -334,8 +334,8 @@ static void issue_p2p_provision_resp(struct wifidirect_info *pwdinfo, u8* raddr,
 	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 4, (unsigned char *) &(p2poui), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(dialogToken), &(pattrib->pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));	
+	pframe = rtw_set_fixed_ie(pframe, 1, &(dialogToken), &(pattrib->pktlen));		
 
 	wpsielen = 0;
 	//	WPS OUI
@@ -373,7 +373,7 @@ static void issue_p2p_provision_resp(struct wifidirect_info *pwdinfo, u8* raddr,
 	RTW_PUT_BE16(wpsie + wpsielen, config_method);
 	wpsielen += 2;
 
-	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wpsielen, (unsigned char *) wpsie, &pattrib->pktlen );
+	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wpsielen, (unsigned char *) wpsie, &pattrib->pktlen );	
 
 #ifdef CONFIG_WFD
 	wfdielen = build_provdisc_resp_wfd_ie(pwdinfo, pframe);
@@ -398,10 +398,10 @@ static void issue_p2p_presence_resp(struct wifidirect_info *pwdinfo, u8 *da, u8
 	unsigned short				*fctrl;
 	_adapter *padapter = pwdinfo->padapter;
 	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
-	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
-	unsigned char category = RTW_WLAN_CATEGORY_P2P;//P2P action frame
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);	
+	unsigned char category = RTW_WLAN_CATEGORY_P2P;//P2P action frame	
 	u32	p2poui = cpu_to_be32(P2POUI);
-	u8	oui_subtype = P2P_PRESENCE_RESPONSE;
+	u8	oui_subtype = P2P_PRESENCE_RESPONSE;	
 	u8 p2pie[ MAX_P2P_IE_LEN] = { 0x00 };
 	u8 noa_attr_content[32] = { 0x00 };
 	u32 p2pielen = 0;
@@ -437,10 +437,10 @@ static void issue_p2p_presence_resp(struct wifidirect_info *pwdinfo, u8 *da, u8
 	pattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
 
 	//Build P2P action frame header
-	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));	
 	pframe = rtw_set_fixed_ie(pframe, 4, (unsigned char *) &(p2poui), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(dialogToken), &(pattrib->pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));	
+	pframe = rtw_set_fixed_ie(pframe, 1, &(dialogToken), &(pattrib->pktlen));	
 
 
 	//Add P2P IE header
@@ -451,22 +451,22 @@ static void issue_p2p_presence_resp(struct wifidirect_info *pwdinfo, u8 *da, u8
 	p2pie[ p2pielen++ ] = 0x9A;
 	p2pie[ p2pielen++ ] = 0x09;	//	WFA P2P v1.0
 
-	//Add Status attribute in P2P IE
+	//Add Status attribute in P2P IE 
 	p2pielen += rtw_set_p2p_attr_content(&p2pie[p2pielen], P2P_ATTR_STATUS, 1, &status);
 
 	//Add NoA attribute in P2P IE
 	noa_attr_content[0] = 0x1;//index
 	noa_attr_content[1] = 0x0;//CTWindow and OppPS Parameters
-
+	
 	//todo: Notice of Absence Descriptor(s)
-
+	
 	p2pielen += rtw_set_p2p_attr_content(&p2pie[p2pielen], P2P_ATTR_NOA, 2, noa_attr_content);
 
 
 
 	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, p2pie, &(pattrib->pktlen));
 
-
+	
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
 	dump_mgntframe(padapter, pmgntframe);
@@ -478,7 +478,7 @@ u32 build_beacon_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 	u8 p2pie[ MAX_P2P_IE_LEN] = { 0x00 };
 	u16 capability=0;
 	u32 len=0, p2pielen = 0;
-
+	
 
 	//	P2P OUI
 	p2pielen = 0;
@@ -491,7 +491,7 @@ u32 build_beacon_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 	//	According to the P2P Specification, the beacon frame should contain 3 P2P attributes
 	//	1. P2P Capability
 	//	2. P2P Device ID
-	//	3. Notice of Absence ( NOA )
+	//	3. Notice of Absence ( NOA )	
 
 	//	P2P Capability ATTR
 	//	Type:
@@ -499,8 +499,8 @@ u32 build_beacon_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 	//	Value:
 	//	Device Capability Bitmap, 1 byte
 	//	Be able to participate in additional P2P Groups and
-	//	support the P2P Invitation Procedure
-	//	Group Capability Bitmap, 1 byte
+	//	support the P2P Invitation Procedure	
+	//	Group Capability Bitmap, 1 byte	
 	capability = P2P_DEVCAP_INVITATION_PROC|P2P_DEVCAP_CLIENT_DISCOVERABILITY;
 	capability |=  ((P2P_GRPCAP_GO | P2P_GRPCAP_INTRABSS) << 8);
 	if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_PROVISIONING_ING))
@@ -510,24 +510,24 @@ u32 build_beacon_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 
 	p2pielen += rtw_set_p2p_attr_content(&p2pie[p2pielen], P2P_ATTR_CAPABILITY, 2, (u8*)&capability);
 
-
+	
 	// P2P Device ID ATTR
 	p2pielen += rtw_set_p2p_attr_content(&p2pie[p2pielen], P2P_ATTR_DEVICE_ID, ETH_ALEN, pwdinfo->device_addr);
 
-
+	
 	// Notice of Absence ATTR
-	//	Type:
+	//	Type: 
 	//	Length:
 	//	Value:
-
+	
 	//go_add_noa_attr(pwdinfo);
-
-
+	
+	
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2pie, &len);
-
-
+	
+	
 	return len;
-
+	
 }
 
 #ifdef CONFIG_WFD
@@ -570,7 +570,7 @@ u32 build_beacon_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 		if ( is_any_client_associated( pwdinfo->padapter ) )
 		{
 			//	WFD primary sink + WiFi Direct mode + WSD (WFD Service Discovery)
-			RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_WSD );
+			RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_WSD );			
 		}
 		else
 		{
@@ -584,7 +584,7 @@ u32 build_beacon_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 		//	WFD primary sink + available for WFD session + WiFi Direct mode + WSD ( WFD Service Discovery )
 		RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD );
 	}
-
+	
 	wfdielen += 2;
 
 	//	Value2:
@@ -645,7 +645,7 @@ u32 build_beacon_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *) wfdie, &len);
 
 	return len;
-
+	
 }
 
 u32 build_probe_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
@@ -681,23 +681,23 @@ u32 build_probe_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 
 	//	Value1:
 	//	WFD device information
-
+	
 	if ( 1 == pwdinfo->wfd_tdls_enable )
 	{
-		//	WFD primary sink + available for WFD session + WiFi TDLS mode + WSC ( WFD Service Discovery )
-		RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type |
-						WFD_DEVINFO_SESSION_AVAIL |
+		//	WFD primary sink + available for WFD session + WiFi TDLS mode + WSC ( WFD Service Discovery )	
+		RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | 
+						WFD_DEVINFO_SESSION_AVAIL | 
 						WFD_DEVINFO_WSD |
 						WFD_DEVINFO_PC_TDLS );
 	}
 	else
 	{
-		//	WFD primary sink + available for WFD session + WiFi Direct mode + WSC ( WFD Service Discovery )
+		//	WFD primary sink + available for WFD session + WiFi Direct mode + WSC ( WFD Service Discovery )	
 		RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type |
-						WFD_DEVINFO_SESSION_AVAIL |
+						WFD_DEVINFO_SESSION_AVAIL | 
 						WFD_DEVINFO_WSD );
 	}
-
+	
 	wfdielen += 2;
 
 	//	Value2:
@@ -758,7 +758,7 @@ u32 build_probe_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *) wfdie, &len);
 
 	return len;
-
+	
 }
 
 u32 build_probe_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8 tunneled)
@@ -796,7 +796,7 @@ u32 build_probe_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8 tunnel
 	//	Value1:
 	//	WFD device information
 	//	WFD primary sink + available for WFD session + WiFi Direct mode
-
+	
 	if (  _TRUE == pwdinfo->session_available )
 	{
 		if ( P2P_ROLE_GO == pwdinfo->role )
@@ -812,7 +812,7 @@ u32 build_probe_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8 tunnel
 				{
 					//	WiFi Direct mode + WSD ( WFD Service Discovery )
 					RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_WSD | WFD_DEVINFO_HDCP_SUPPORT);
-				}
+				}				
 			}
 			else
 			{
@@ -825,7 +825,7 @@ u32 build_probe_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8 tunnel
 				{
 					//	available for WFD session + WiFi Direct mode + WSD ( WFD Service Discovery )
 					RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD | WFD_DEVINFO_HDCP_SUPPORT);
-				}
+				}				
 			}
 		}
 		else
@@ -953,7 +953,7 @@ u32 build_probe_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8 tunnel
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *) wfdie, &len);
 
 	return len;
-
+	
 }
 
 u32 build_assoc_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
@@ -973,7 +973,7 @@ u32 build_assoc_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 	padapter = pwdinfo->padapter;
 	pmlmepriv = &padapter->mlmepriv;
 	pwfd_info = padapter->wdinfo.wfd_info;
-
+	
 	wfdielen = 0;
 	wfdie[ wfdielen++ ] = 0x50;
 	wfdie[ wfdielen++ ] = 0x6F;
@@ -1060,7 +1060,7 @@ u32 build_assoc_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *) wfdie, &len);
 
 	return len;
-
+	
 }
 
 u32 build_assoc_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
@@ -1158,7 +1158,7 @@ u32 build_assoc_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *) wfdie, &len);
 
 	return len;
-
+	
 }
 
 u32 build_nego_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
@@ -1256,7 +1256,7 @@ u32 build_nego_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *) wfdie, &len);
 
 	return len;
-
+	
 }
 
 u32 build_nego_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
@@ -1355,7 +1355,7 @@ u32 build_nego_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *) wfdie, &len);
 
 	return len;
-
+	
 }
 
 u32 build_nego_confirm_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
@@ -1454,7 +1454,7 @@ u32 build_nego_confirm_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *) wfdie, &len);
 
 	return len;
-
+	
 }
 
 u32 build_invitation_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
@@ -1567,7 +1567,7 @@ u32 build_invitation_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *) wfdie, &len);
 
 	return len;
-
+	
 }
 
 u32 build_invitation_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
@@ -1680,7 +1680,7 @@ u32 build_invitation_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *) wfdie, &len);
 
 	return len;
-
+	
 }
 
 u32 build_provdisc_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
@@ -1779,7 +1779,7 @@ u32 build_provdisc_req_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *) wfdie, &len);
 
 	return len;
-
+	
 }
 
 u32 build_provdisc_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
@@ -1877,7 +1877,7 @@ u32 build_provdisc_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *) wfdie, &len);
 
 	return len;
-
+	
 }
 
 #endif //CONFIG_WFD
@@ -1885,7 +1885,7 @@ u32 build_provdisc_resp_wfd_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 u32 build_probe_resp_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 {
 	u8 p2pie[ MAX_P2P_IE_LEN] = { 0x00 };
-	u32 len=0, p2pielen = 0;
+	u32 len=0, p2pielen = 0;	
 #ifdef CONFIG_INTEL_WIDI
 	struct mlme_priv *pmlmepriv = &(pwdinfo->padapter->mlmepriv);
 	u8 zero_array_check[L2SDTA_SERVICE_VE_LEN] = { 0x00 };
@@ -1928,7 +1928,7 @@ u32 build_probe_resp_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 	//	Value:
 	//	Device Capability Bitmap, 1 byte
 	p2pie[ p2pielen++ ] = DMP_P2P_DEVCAP_SUPPORT;
-
+	
 	//	Group Capability Bitmap, 1 byte
 	if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 	{
@@ -1971,20 +1971,20 @@ u32 build_probe_resp_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 
 
 	// Notice of Absence ATTR
-	//	Type:
+	//	Type: 
 	//	Length:
 	//	Value:
 	if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 	{
 		//go_add_noa_attr(pwdinfo);
-	}
+	}	
 
 	//	Device Info ATTR
 	//	Type:
 	p2pie[ p2pielen++ ] = P2P_ATTR_DEVICE_INFO;
 
 	//	Length:
-	//	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes)
+	//	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) 
 	//	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes)
 	//*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 21 + pwdinfo->device_name_len );
 #ifdef CONFIG_INTEL_WIDI
@@ -2056,7 +2056,7 @@ u32 build_probe_resp_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 	if( widi_version == 35 )
 	{
 		p2pie[ p2pielen++ ] = 0x01;
-
+		
 		RTW_PUT_BE16(p2pie + p2pielen, WPS_PDT_CID_DISPLAYS);
 		p2pielen += 2;
 
@@ -2109,18 +2109,18 @@ u32 build_probe_resp_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 		p2pielen += go_add_group_info_attr(pwdinfo, p2pie + p2pielen);
 	}
 
-
+	
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2pie, &len);
-
+	
 
 	return len;
-
+	
 }
 
 u32 build_prov_disc_request_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8* pssid, u8 ussidlen, u8* pdev_raddr )
 {
 	u8 p2pie[ MAX_P2P_IE_LEN] = { 0x00 };
-	u32 len=0, p2pielen = 0;
+	u32 len=0, p2pielen = 0;	
 
 	//	P2P OUI
 	p2pielen = 0;
@@ -2147,7 +2147,7 @@ u32 build_prov_disc_request_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8
 	//	Value:
 	//	Device Capability Bitmap, 1 byte
 	p2pie[ p2pielen++ ] = DMP_P2P_DEVCAP_SUPPORT;
-
+	
 	//	Group Capability Bitmap, 1 byte
 	if ( pwdinfo->persistent_supported )
 		p2pie[ p2pielen++ ] = P2P_GRPCAP_PERSISTENT_GROUP | DMP_P2P_GRPCAP_SUPPORT;
@@ -2160,7 +2160,7 @@ u32 build_prov_disc_request_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8
 	p2pie[ p2pielen++ ] = P2P_ATTR_DEVICE_INFO;
 
 	//	Length:
-	//	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes)
+	//	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) 
 	//	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes)
 	//*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 21 + pwdinfo->device_name_len );
 	RTW_PUT_LE16(p2pie + p2pielen, 21 + pwdinfo->device_name_len);
@@ -2224,7 +2224,7 @@ u32 build_prov_disc_request_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8
 	{
 		//	Added by Albert 2011/05/19
 		//	In this case, the pdev_raddr is the device address of the group owner.
-
+		
 		//	P2P Group ID ATTR
 		//	Type:
 		p2pie[ p2pielen++ ] = P2P_ATTR_GROUP_ID;
@@ -2240,21 +2240,21 @@ u32 build_prov_disc_request_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8
 
 		_rtw_memcpy( p2pie + p2pielen, pssid, ussidlen );
 		p2pielen += ussidlen;
-
+		
 	}
 
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2pie, &len);
-
+	
 
 	return len;
-
+	
 }
 
 
 u32 build_assoc_resp_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8 status_code)
 {
 	u8 p2pie[ MAX_P2P_IE_LEN] = { 0x00 };
-	u32 len=0, p2pielen = 0;
+	u32 len=0, p2pielen = 0;	
 
 	//	P2P OUI
 	p2pielen = 0;
@@ -2279,20 +2279,20 @@ u32 build_assoc_resp_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8 status
 
 
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2pie, &len);
-
+	
 	return len;
-
+	
 }
 
 u32 build_deauth_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 {
 	u32 len=0;
-
+	
 	return len;
 }
 
 u32 process_probe_req_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pframe, uint len)
-{
+{	
 	u8 *p;
 	u32 ret=_FALSE;
 	u8 *p2pie;
@@ -2340,7 +2340,7 @@ u32 process_probe_req_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pframe, uint l
 	//	6. Device ID attribute in P2P IE. (Todo)
 
 	p = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + _PROBEREQ_IE_OFFSET_, _SSID_IE_, (int *)&ssid_len,
-			len - WLAN_HDR_A3_LEN - _PROBEREQ_IE_OFFSET_);
+			len - WLAN_HDR_A3_LEN - _PROBEREQ_IE_OFFSET_);	
 
 	ssid_len &= 0xff;	//	Just last 1 byte is valid for ssid len of the probe request
 	if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_DEVICE) || rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
@@ -2353,8 +2353,8 @@ u32 process_probe_req_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pframe, uint l
 				//Check Requested Device Type attributes in WSC IE.
 				//Check Device ID attribute in P2P IE
 
-				ret = _TRUE;
-			}
+				ret = _TRUE;			
+			}		
 			else if ( (p != NULL) && ( ssid_len == 0 ) )
 			{
 				ret = _TRUE;
@@ -2364,12 +2364,12 @@ u32 process_probe_req_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pframe, uint l
 		{
 			//non -p2p device
 		}
+		
+	}	
 
-	}
-
-
+	
 	return ret;
-
+	
 }
 
 u32 process_assoc_req_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pframe, uint len, struct sta_info *psta)
@@ -2391,12 +2391,12 @@ u32 process_assoc_req_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pframe, uint l
 	if (frame_type == WIFI_ASSOCREQ)
 	{
 		ie_offset = _ASOCREQ_IE_OFFSET_;
-	}
+	}	
 	else // WIFI_REASSOCREQ
 	{
 		ie_offset = _REASOCREQ_IE_OFFSET_;
 	}
-
+	
 	ies = pframe + WLAN_HDR_A3_LEN + ie_offset;
 	ies_len = len - WLAN_HDR_A3_LEN - ie_offset;
 
@@ -2411,7 +2411,7 @@ u32 process_assoc_req_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pframe, uint l
 	{
 		DBG_8192C( "[%s] P2P IE Found!!\n", __FUNCTION__ );
 	}
-
+	
 	while ( p2p_ie )
 	{
 		//Check P2P Capability ATTR
@@ -2423,19 +2423,19 @@ u32 process_assoc_req_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pframe, uint l
 		}
 
 		//Check Extended Listen Timing ATTR
-
+	
 
 		//Check P2P Device Info ATTR
 		if(rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_DEVICE_INFO, NULL, (uint*)&attr_contentlen))
 		{
-			DBG_8192C( "[%s] Got P2P DEVICE INFO Attr!!\n", __FUNCTION__ );
+			DBG_8192C( "[%s] Got P2P DEVICE INFO Attr!!\n", __FUNCTION__ );		
 			pattr_content = pbuf = rtw_zmalloc(attr_contentlen);
 			if(pattr_content)
 			{
 				u8 num_of_secdev_type;
 				u16 dev_name_len;
-
-
+			
+		
 				rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_DEVICE_INFO , pattr_content, (uint*)&attr_contentlen);
 
 				_rtw_memcpy(psta->dev_addr, 	pattr_content, ETH_ALEN);//P2P Device Address
@@ -2467,7 +2467,7 @@ u32 process_assoc_req_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pframe, uint l
 					len = (sizeof(psta->secdev_types_list)<(num_of_secdev_type*8)) ? (sizeof(psta->secdev_types_list)) : (num_of_secdev_type*8);
 
 					_rtw_memcpy(psta->secdev_types_list, pattr_content, len);
-
+	
 					pattr_content += (num_of_secdev_type*8);
 				}
 
@@ -2475,7 +2475,7 @@ u32 process_assoc_req_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pframe, uint l
 				//dev_name_len = attr_contentlen - ETH_ALEN - 2 - 8 - 1 - (num_of_secdev_type*8);
 				psta->dev_name_len=0;
 				if(WPS_ATTR_DEVICE_NAME == be16_to_cpu(*(u16*)pattr_content))
-				{
+				{				
 					dev_name_len = be16_to_cpu(*(u16*)(pattr_content+2));
 
 					psta->dev_name_len = (sizeof(psta->dev_name)<dev_name_len) ? sizeof(psta->dev_name):dev_name_len;
@@ -2491,7 +2491,7 @@ u32 process_assoc_req_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pframe, uint l
 
 		//Get the next P2P IE
 		p2p_ie = rtw_get_p2p_ie(p2p_ie+p2p_ielen, ies_len -(p2p_ie -ies + p2p_ielen), NULL, &p2p_ielen);
-
+		
 	}
 
 	return status_code;
@@ -2506,39 +2506,39 @@ u32 process_p2p_devdisc_req(struct wifidirect_info *pwdinfo, u8 *pframe, uint le
 	_adapter *padapter = pwdinfo->padapter;
 	struct sta_priv *pstapriv = &padapter->stapriv;
 	u8 *p2p_ie;
-	u32	p2p_ielen = 0;
-
+	u32	p2p_ielen = 0;	
+	
 	frame_body = (unsigned char *)(pframe + sizeof(struct rtw_ieee80211_hdr_3addr));
 
 	dialogToken = frame_body[7];
 	status = P2P_STATUS_FAIL_UNKNOWN_P2PGROUP;
-
+		
 	if ( (p2p_ie=rtw_get_p2p_ie( frame_body + _PUBLIC_ACTION_IE_OFFSET_, len - _PUBLIC_ACTION_IE_OFFSET_, NULL, &p2p_ielen)) )
 	{
 		u8 groupid[ 38 ] = { 0x00 };
-		u8 dev_addr[ETH_ALEN] = { 0x00 };
+		u8 dev_addr[ETH_ALEN] = { 0x00 };		
 		u32	attr_contentlen = 0;
 
 		if(rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_GROUP_ID, groupid, &attr_contentlen))
 		{
-			if(_rtw_memcmp(pwdinfo->device_addr, groupid, ETH_ALEN) &&
+			if(_rtw_memcmp(pwdinfo->device_addr, groupid, ETH_ALEN) && 
 				_rtw_memcmp(pwdinfo->p2p_group_ssid, groupid+ETH_ALEN, pwdinfo->p2p_group_ssid_len))
 			{
 				attr_contentlen=0;
 				if(rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_DEVICE_ID, dev_addr, &attr_contentlen))
 				{
 					_irqL irqL;
-					_list	*phead, *plist;
+					_list	*phead, *plist;					
 
 					_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 					phead = &pstapriv->asoc_list;
 					plist = get_next(phead);
 
 					//look up sta asoc_queue
-					while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
-					{
+					while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)	
+					{		
 						psta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);
-
+		
 						plist = get_next(plist);
 
 						if(psta->is_p2p_device && (psta->dev_cap&P2P_DEVCAP_CLIENT_DISCOVERABILITY) &&
@@ -2549,19 +2549,19 @@ u32 process_p2p_devdisc_req(struct wifidirect_info *pwdinfo, u8 *pframe, uint le
 							//issue GO Discoverability Request
 							issue_group_disc_req(pwdinfo, psta->hwaddr);
 							//_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
-
+							
 							status = P2P_STATUS_SUCCESS;
-
+							
 							break;
 						}
 						else
 						{
 							status = P2P_STATUS_FAIL_INFO_UNAVAILABLE;
 						}
-
-					}
+		
+					}				
 					_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
-
+					
 				}
 				else
 				{
@@ -2573,18 +2573,18 @@ u32 process_p2p_devdisc_req(struct wifidirect_info *pwdinfo, u8 *pframe, uint le
 			{
 				status = P2P_STATUS_FAIL_INVALID_PARAM;
 			}
-
-		}
-
+			
+		}	
+		
 	}
 
-
+	
 	//issue Device Discoverability Response
 	issue_p2p_devdisc_resp(pwdinfo, GetAddr2Ptr(pframe), status, dialogToken);
-
-
+	
+	
 	return (status==P2P_STATUS_SUCCESS) ? _TRUE:_FALSE;
-
+	
 }
 
 u32 process_p2p_devdisc_resp(struct wifidirect_info *pwdinfo, u8 *pframe, uint len)
@@ -2598,7 +2598,7 @@ u8 process_p2p_provdisc_req(struct wifidirect_info *pwdinfo,  u8 *pframe, uint l
 	u8 *wpsie;
 	uint	wps_ielen = 0, attr_contentlen = 0;
 	u16	uconfig_method = 0;
-
+	
 
 	frame_body = (pframe + sizeof(struct rtw_ieee80211_hdr_3addr));
 
@@ -2635,9 +2635,9 @@ u8 process_p2p_provdisc_req(struct wifidirect_info *pwdinfo,  u8 *pframe, uint l
 	}
 	DBG_871X( "[%s] config method = %s\n", __FUNCTION__, pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req );
 	return _TRUE;
-
+	
 }
-
+	
 u8 process_p2p_provdisc_resp(struct wifidirect_info *pwdinfo,  u8 *pframe)
 {
 
@@ -2721,7 +2721,7 @@ u8 process_p2p_group_negotation_req( struct wifidirect_info *pwdinfo, u8 *pframe
 	u32	wfd_ielen = 0;
 #ifdef CONFIG_TDLS
 	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
-#endif // CONFIG_TDLS
+#endif // CONFIG_TDLS	
 #endif // CONFIG_WFD
 #ifdef CONFIG_CONCURRENT_MODE
 	_adapter				*pbuddy_adapter = pwdinfo->padapter->pbuddy_adapter;
@@ -2746,11 +2746,11 @@ u8 process_p2p_group_negotation_req( struct wifidirect_info *pwdinfo, u8 *pframe
 			}
 			else if ( wps_devicepassword_id == WPS_DPID_REGISTRAR_SPEC )
 			{
-				_rtw_memcpy( pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "pad", 3 );
+				_rtw_memcpy( pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "pad", 3 );	
 			}
 			else
 			{
-				_rtw_memcpy( pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "pbc", 3 );
+				_rtw_memcpy( pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "pbc", 3 );	
 			}
 		}
 	}
@@ -2771,7 +2771,7 @@ u8 process_p2p_group_negotation_req( struct wifidirect_info *pwdinfo, u8 *pframe
 
 	ies = pframe + _PUBLIC_ACTION_IE_OFFSET_;
 	ies_len = len - _PUBLIC_ACTION_IE_OFFSET_;
-
+					
 	p2p_ie = rtw_get_p2p_ie( ies, ies_len, NULL, &p2p_ielen );
 
 	if ( !p2p_ie )
@@ -2780,11 +2780,11 @@ u8 process_p2p_group_negotation_req( struct wifidirect_info *pwdinfo, u8 *pframe
 		result = P2P_STATUS_FAIL_INCOMPATIBLE_PARAM;
 		rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_FAIL);
 	}
-
+	
 	while ( p2p_ie )
 	{
 		u8	attr_content = 0x00;
-		u32	attr_contentlen = 0;
+		u32	attr_contentlen = 0;						
 		u8	ch_content[100] = { 0x00 };
 		uint	ch_cnt = 0;
 		u8	peer_ch_list[100] = { 0x00 };
@@ -2799,7 +2799,7 @@ u8 process_p2p_group_negotation_req( struct wifidirect_info *pwdinfo, u8 *pframe
 		if(rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8*)&cap_attr, (uint*)&attr_contentlen) )
 		{
 			cap_attr = le16_to_cpu(cap_attr);
-
+	
 #if defined(CONFIG_WFD) && defined(CONFIG_TDLS)
 			if(!(cap_attr & P2P_GRPCAP_INTRABSS) )
 				ptdlsinfo->ap_prohibited = _TRUE;
@@ -2829,7 +2829,7 @@ u8 process_p2p_group_negotation_req( struct wifidirect_info *pwdinfo, u8 *pframe
 					{
 						rtw_p2p_set_role(pwdinfo, P2P_ROLE_GO);
 					}
-				}
+				}							
 			}
 			else if ( pwdinfo->intent > ( pwdinfo->peer_intent >> 1 ) )
 			{
@@ -2844,11 +2844,11 @@ u8 process_p2p_group_negotation_req( struct wifidirect_info *pwdinfo, u8 *pframe
 			{
 				//	Store the group id information.
 				_rtw_memcpy( pwdinfo->groupid_info.go_device_addr, pwdinfo->device_addr, ETH_ALEN );
-				_rtw_memcpy( pwdinfo->groupid_info.ssid, pwdinfo->nego_ssid, pwdinfo->nego_ssidlen );
+				_rtw_memcpy( pwdinfo->groupid_info.ssid, pwdinfo->nego_ssid, pwdinfo->nego_ssidlen );		
 			}
 		}
 
-
+		
 		attr_contentlen = 0;
 		if ( rtw_get_p2p_attr_content( p2p_ie, p2p_ielen, P2P_ATTR_INTENTED_IF_ADDR, pwdinfo->p2p_peer_interface_addr, &attr_contentlen ) )
 		{
@@ -2873,7 +2873,7 @@ u8 process_p2p_group_negotation_req( struct wifidirect_info *pwdinfo, u8 *pframe
 
 			if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 			{
-				if ( !rtw_p2p_is_channel_list_ok( pwdinfo->operating_channel,
+				if ( !rtw_p2p_is_channel_list_ok( pwdinfo->operating_channel, 
 												ch_list_inclusioned, ch_num_inclusioned) )
 				{
 #ifdef CONFIG_CONCURRENT_MODE
@@ -2891,11 +2891,11 @@ u8 process_p2p_group_negotation_req( struct wifidirect_info *pwdinfo, u8 *pframe
 						attr_contentlen = 0;
 
 						if ( rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, operatingch_info, &attr_contentlen) )
-						{
+						{		
 							peer_operating_ch = operatingch_info[4];
 						}
 
-						if ( rtw_p2p_is_channel_list_ok( peer_operating_ch,
+						if ( rtw_p2p_is_channel_list_ok( peer_operating_ch, 
 														ch_list_inclusioned, ch_num_inclusioned) )
 						{
 							/**
@@ -2919,7 +2919,7 @@ u8 process_p2p_group_negotation_req( struct wifidirect_info *pwdinfo, u8 *pframe
 		//Get the next P2P IE
 		p2p_ie = rtw_get_p2p_ie(p2p_ie+p2p_ielen, ies_len -(p2p_ie -ies + p2p_ielen), NULL, &p2p_ielen);
 	}
-
+	
 #ifdef CONFIG_WFD
 	//	Added by Albert 20110823
 	//	Try to get the TCP port information when receiving the negotiation request.
@@ -2954,14 +2954,14 @@ u8 process_p2p_group_negotation_resp( struct wifidirect_info *pwdinfo, u8 *pfram
 	u32	wfd_ielen = 0;
 #ifdef CONFIG_TDLS
 	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
-#endif // CONFIG_TDLS
-#endif // CONFIG_WFD
+#endif // CONFIG_TDLS	
+#endif // CONFIG_WFD	
 
 	ies = pframe + _PUBLIC_ACTION_IE_OFFSET_;
 	ies_len = len - _PUBLIC_ACTION_IE_OFFSET_;
 
 	//	Be able to know which one is the P2P GO and which one is P2P client.
-
+					
 	if ( rtw_get_wps_ie( ies, ies_len, NULL, &wps_ielen) )
 	{
 
@@ -3010,7 +3010,7 @@ u8 process_p2p_group_negotation_resp( struct wifidirect_info *pwdinfo, u8 *pfram
 
 			rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_STATUS, &attr_content, &attr_contentlen);
 			if ( attr_contentlen == 1 )
-			{
+			{			
 				DBG_871X( "[%s] Status = %d\n", __FUNCTION__, attr_content );
 				if ( attr_content == P2P_STATUS_SUCCESS )
 				{
@@ -3038,7 +3038,7 @@ u8 process_p2p_group_negotation_resp( struct wifidirect_info *pwdinfo, u8 *pfram
 					_rtw_memset( pwdinfo->p2p_peer_interface_addr, 0x00, ETH_ALEN );
 				}
 			}
-
+			
 			//	Try to get the peer's intent and tie breaker value.
 			attr_content = 0x00;
 			attr_contentlen = 0;
@@ -3068,7 +3068,7 @@ u8 process_p2p_group_negotation_resp( struct wifidirect_info *pwdinfo, u8 *pfram
 						{
 							rtw_p2p_set_role(pwdinfo, P2P_ROLE_GO);
 						}
-					}
+					}							
 				}
 				else if ( pwdinfo->intent > ( pwdinfo->peer_intent >> 1 ) )
 				{
@@ -3088,19 +3088,19 @@ u8 process_p2p_group_negotation_resp( struct wifidirect_info *pwdinfo, u8 *pfram
 					//	Store the group id information.
 					_rtw_memcpy( pwdinfo->groupid_info.go_device_addr, pwdinfo->device_addr, ETH_ALEN );
 					_rtw_memcpy( pwdinfo->groupid_info.ssid, pwdinfo->nego_ssid, pwdinfo->nego_ssidlen );
-
+		
 				}
 			}
-
+			
 			//	Try to get the operation channel information
-
+					
 			attr_contentlen = 0;
 			if ( rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, operatingch_info, &attr_contentlen))
 			{
 				DBG_871X( "[%s] Peer's operating channel = %d\n", __FUNCTION__, operatingch_info[4] );
 				pwdinfo->peer_operating_ch = operatingch_info[4];
 			}
-
+			
 			//	Try to get the channel list information
 			if ( rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CH_LIST, pwdinfo->channel_list_attr, &pwdinfo->channel_list_attr_len ) )
 			{
@@ -3119,7 +3119,7 @@ u8 process_p2p_group_negotation_resp( struct wifidirect_info *pwdinfo, u8 *pfram
 
 				if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 				{
-					if ( !rtw_p2p_is_channel_list_ok( pwdinfo->operating_channel,
+					if ( !rtw_p2p_is_channel_list_ok( pwdinfo->operating_channel, 
 													ch_list_inclusioned, ch_num_inclusioned) )
 					{
 #ifdef CONFIG_CONCURRENT_MODE
@@ -3137,11 +3137,11 @@ u8 process_p2p_group_negotation_resp( struct wifidirect_info *pwdinfo, u8 *pfram
 							attr_contentlen = 0;
 
 							if ( rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, operatingch_info, &attr_contentlen) )
-							{
+							{		
 								peer_operating_ch = operatingch_info[4];
 							}
 
-							if ( rtw_p2p_is_channel_list_ok( peer_operating_ch,
+							if ( rtw_p2p_is_channel_list_ok( peer_operating_ch, 
 															ch_list_inclusioned, ch_num_inclusioned) )
 							{
 								/**
@@ -3175,11 +3175,11 @@ u8 process_p2p_group_negotation_resp( struct wifidirect_info *pwdinfo, u8 *pfram
 				_rtw_memcpy( pwdinfo->groupid_info.go_device_addr, &groupid[0], ETH_ALEN );
 				_rtw_memcpy( pwdinfo->groupid_info.ssid, &groupid[6], attr_contentlen - ETH_ALEN );
 			}
-
+			
 			//Get the next P2P IE
 			p2p_ie = rtw_get_p2p_ie(p2p_ie+p2p_ielen, ies_len -(p2p_ie -ies + p2p_ielen), NULL, &p2p_ielen);
 		}
-
+		
 	}
 
 #ifdef CONFIG_WFD
@@ -3231,7 +3231,7 @@ u8 process_p2p_group_negotation_confirm( struct wifidirect_info *pwdinfo, u8 *pf
 			if ( attr_content == P2P_STATUS_SUCCESS )
 			{
 				u8	bcancelled = 0;
-
+																
 				_cancel_timer( &pwdinfo->restore_p2p_state_timer, &bcancelled );
 
 				//	Commented by Albert 20100911
@@ -3257,15 +3257,15 @@ u8 process_p2p_group_negotation_confirm( struct wifidirect_info *pwdinfo, u8 *pf
 					{
 						rtw_p2p_set_role(pwdinfo, P2P_ROLE_GO);
 					}
-				}
-
+				}								
+				
 #ifdef CONFIG_CONCURRENT_MODE
 				if ( check_buddy_fwstate(pwdinfo->padapter , _FW_LINKED ) )
 				{
 					//	Switch back to the AP channel soon.
 					_set_timer( &pwdinfo->ap_p2p_switch_timer, 100 );
 				}
-#endif
+#endif				
 			}
 			else
 			{
@@ -3282,19 +3282,19 @@ u8 process_p2p_group_negotation_confirm( struct wifidirect_info *pwdinfo, u8 *pf
 		{
 			DBG_871X( "[%s] Ssid = %s, ssidlen = %d\n", __FUNCTION__, &groupid[ETH_ALEN], (u32)strlen(&groupid[ETH_ALEN]) );
 			_rtw_memcpy( pwdinfo->groupid_info.go_device_addr, &groupid[0], ETH_ALEN );
-			_rtw_memcpy( pwdinfo->groupid_info.ssid, &groupid[6], attr_contentlen - ETH_ALEN );
+			_rtw_memcpy( pwdinfo->groupid_info.ssid, &groupid[6], attr_contentlen - ETH_ALEN );			
 		}
 
 		attr_contentlen = 0;
 		if ( rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, operatingch_info, &attr_contentlen) )
-		{
+		{		
 			DBG_871X( "[%s] Peer's operating channel = %d\n", __FUNCTION__, operatingch_info[4] );
 			pwdinfo->peer_operating_ch = operatingch_info[4];
 		}
 
 		//Get the next P2P IE
 		p2p_ie = rtw_get_p2p_ie(p2p_ie+p2p_ielen, ies_len -(p2p_ie -ies + p2p_ielen), NULL, &p2p_ielen);
-
+		
 	}
 
 	return( result );
@@ -3302,10 +3302,10 @@ u8 process_p2p_group_negotation_confirm( struct wifidirect_info *pwdinfo, u8 *pf
 
 u8 process_p2p_presence_req(struct wifidirect_info *pwdinfo, u8 *pframe, uint len)
 {
-	u8 *frame_body;
+	u8 *frame_body;	
 	u8 dialogToken=0;
 	u8 status = P2P_STATUS_SUCCESS;
-
+	
 	frame_body = (unsigned char *)(pframe + sizeof(struct rtw_ieee80211_hdr_3addr));
 
 	dialogToken = frame_body[6];
@@ -3332,7 +3332,7 @@ void find_phase_handler( _adapter*	padapter )
 	ssid.SsidLength = P2P_WILDCARD_SSID_LEN;
 
 	rtw_p2p_set_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH);
-
+		
 	_enter_critical_bh(&pmlmepriv->lock, &irqL);
 	_status = rtw_sitesurvey_cmd(padapter, &ssid, 1, NULL, 0);
 	_exit_critical_bh(&pmlmepriv->lock, &irqL);
@@ -3360,19 +3360,19 @@ void restore_p2p_state_handler( _adapter*	padapter )
 	{
 		_adapter				*pbuddy_adapter = padapter->pbuddy_adapter;
 		struct mlme_priv		*pbuddy_mlmepriv = &pbuddy_adapter->mlmepriv;
-		struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
-
+		struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;	
+	
 		if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_PROVISION_DIS_REQ) || rtw_p2p_chk_state(pwdinfo, P2P_STATE_RX_PROVISION_DIS_RSP))
 		{
 			set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
-
+			
 			issue_nulldata(pbuddy_adapter, NULL, 0, 3, 500);
 		}
 	}
 #endif
 
 	rtw_p2p_set_state(pwdinfo, rtw_p2p_pre_state(pwdinfo));
-
+	
 	if(rtw_p2p_chk_role(pwdinfo, P2P_ROLE_DEVICE))
 	{
 #ifdef CONFIG_CONCURRENT_MODE
@@ -3393,10 +3393,10 @@ void pre_tx_invitereq_handler( _adapter*	padapter )
 _func_enter_;
 
 	set_channel_bwmode(padapter, pwdinfo->invitereq_info.peer_ch, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
-	rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
+	rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));	
 	issue_probereq_p2p(padapter, NULL);
 	_set_timer( &pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT );
-
+	
 _func_exit_;
 }
 
@@ -3410,7 +3410,7 @@ void pre_tx_provdisc_handler( _adapter*	padapter )
 	rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
 	issue_probereq_p2p(padapter, NULL);
 	_set_timer( &pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT );
-
+	
 _func_exit_;
 }
 
@@ -3421,10 +3421,10 @@ void pre_tx_negoreq_handler( _adapter*	padapter )
 _func_enter_;
 
 	set_channel_bwmode(padapter, pwdinfo->nego_req_info.peer_channel_num[0], HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
-	rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
+	rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));	
 	issue_probereq_p2p(padapter, NULL);
 	_set_timer( &pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT );
-
+	
 _func_exit_;
 }
 
@@ -3441,7 +3441,7 @@ void p2p_concurrent_handler( _adapter*	padapter )
 
 	if ( check_buddy_fwstate(padapter, _FW_LINKED ) )
 	{
-		PADAPTER pbuddy_adapter = padapter->pbuddy_adapter;
+		PADAPTER pbuddy_adapter = padapter->pbuddy_adapter;			
 		struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 
 		pwdinfo->operating_channel = pbuddy_mlmeext->cur_channel;
@@ -3451,7 +3451,7 @@ void p2p_concurrent_handler( _adapter*	padapter )
 			DBG_871X("%s, switch ch back to buddy's cur_channel=%d\n", __func__, pbuddy_mlmeext->cur_channel);
 
 			set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
-
+		
 			issue_nulldata(pbuddy_adapter, NULL, 0, 3, 500);
 		}
 		else if( pwdinfo->driver_interface == DRIVER_WEXT )
@@ -3479,7 +3479,7 @@ void p2p_concurrent_handler( _adapter*	padapter )
 					_set_timer( &pwdinfo->ap_p2p_switch_timer, pwdinfo->ext_listen_period );
 				}
 			}
-			else if ( rtw_p2p_chk_state(pwdinfo, P2P_STATE_LISTEN) ||
+			else if ( rtw_p2p_chk_state(pwdinfo, P2P_STATE_LISTEN) || 
 					rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_FAIL) ||
 					( rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING) && pwdinfo->nego_req_info.benable == _FALSE ) ||
 					rtw_p2p_chk_state(pwdinfo, P2P_STATE_RX_PROVISION_DIS_REQ) )
@@ -3526,7 +3526,7 @@ void p2p_concurrent_handler( _adapter*	padapter )
 				rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
 				issue_probereq_p2p(padapter, NULL);
 				_set_timer( &pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT );
-			}
+			}		
 			else if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_INVITE_REQ ) && pwdinfo->invitereq_info.benable == _TRUE)
 			{
 				/*
@@ -3538,12 +3538,12 @@ void p2p_concurrent_handler( _adapter*	padapter )
 				*/
 			}
 		}
-	}
+	}	
 	else
 	{
-		set_channel_bwmode( padapter, pwdinfo->listen_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
+		set_channel_bwmode( padapter, pwdinfo->listen_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);	
 	}
-
+	
 _func_exit_;
 }
 #endif
@@ -3590,8 +3590,8 @@ static void ro_ch_handler(_adapter *padapter)
 
 	DBG_871X("cfg80211_remain_on_channel_expired\n");
 
-	rtw_cfg80211_remain_on_channel_expired(padapter,
-		pcfg80211_wdinfo->remain_on_ch_cookie,
+	rtw_cfg80211_remain_on_channel_expired(padapter, 
+		pcfg80211_wdinfo->remain_on_ch_cookie, 
 		&pcfg80211_wdinfo->remain_on_ch_channel,
 		pcfg80211_wdinfo->remain_on_ch_type, GFP_KERNEL);
 
@@ -3604,7 +3604,7 @@ static void ro_ch_timer_process (void *FunctionContext)
 	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(adapter->rtw_wdev);
 
 	//printk("%s \n", __FUNCTION__);
-
+	
 #ifdef	CONFIG_CONCURRENT_MODE
 	ATOMIC_SET(&pwdev_priv->ro_ch_to, 1);
 #endif
@@ -3664,7 +3664,7 @@ static void rtw_change_p2pie_ch_list(_adapter *padapter, const u8 *frame_body, u
 			u8 *pattr_temp = pattr + 3 ;
 
 			attr_contentlen -= 3;
-
+			
 			while (attr_contentlen>0) {
 				num_of_ch = *(pattr_temp+1);
 
@@ -3773,19 +3773,19 @@ static void rtw_cfg80211_adjust_p2pie_channel(_adapter *padapter, const u8 *fram
 #ifdef CONFIG_CONCURRENT_MODE
 	u8 *ies, *p2p_ie;
 	u32 ies_len, p2p_ielen;
-	PADAPTER pbuddy_adapter = padapter->pbuddy_adapter;
+	PADAPTER pbuddy_adapter = padapter->pbuddy_adapter;			
 	struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 
 	ies = (u8*)(frame_body + _PUBLIC_ACTION_IE_OFFSET_);
 	ies_len = len - _PUBLIC_ACTION_IE_OFFSET_;
-
+					
 	p2p_ie = rtw_get_p2p_ie( ies, ies_len, NULL, &p2p_ielen );
 
 	while ( p2p_ie )
-	{
+	{	
 		u32	attr_contentlen = 0;
 		u8 *pattr = NULL;
-
+				
 		//Check P2P_ATTR_CH_LIST
 		if((pattr=rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CH_LIST, NULL, (uint*)&attr_contentlen))!=NULL)
 		{
@@ -3794,17 +3794,17 @@ static void rtw_cfg80211_adjust_p2pie_channel(_adapter *padapter, const u8 *fram
 			u8 *pattr_temp = pattr + 3 ;
 
 			attr_contentlen -= 3;
-
+			
 			while(attr_contentlen>0)
-			{
+			{				
 				num_of_ch = *(pattr_temp+1);
-
+								
 				for(i=0; i<num_of_ch; i++)
 					*(pattr_temp+2+i) = pbuddy_mlmeext->cur_channel;//forcing to the same channel
 
 				pattr_temp += (2+num_of_ch);
 				attr_contentlen -= (2+num_of_ch);
-			}
+			}	
 		}
 
 		//Check P2P_ATTR_OPERATING_CH
@@ -3812,12 +3812,12 @@ static void rtw_cfg80211_adjust_p2pie_channel(_adapter *padapter, const u8 *fram
 		pattr = NULL;
 		if((pattr = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, NULL, (uint*)&attr_contentlen))!=NULL)
 		{
-			*(pattr+4) = pbuddy_mlmeext->cur_channel;//forcing to the same channel
+			*(pattr+4) = pbuddy_mlmeext->cur_channel;//forcing to the same channel			
 		}
 
 		//Get the next P2P IE
 		p2p_ie = rtw_get_p2p_ie(p2p_ie+p2p_ielen, ies_len -(p2p_ie -ies + p2p_ielen), NULL, &p2p_ielen);
-
+		
 	}
 
 #endif
@@ -3830,8 +3830,8 @@ void rtw_append_wfd_ie(_adapter *padapter, u8 *buf, u32* len)
 	u8 category, action, OUI_Subtype, dialogToken=0;
 	u32	wfdielen = 0;
 	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(padapter->rtw_wdev);
-
-	frame_body = (unsigned char *)(buf + sizeof(struct rtw_ieee80211_hdr_3addr));
+	
+	frame_body = (unsigned char *)(buf + sizeof(struct rtw_ieee80211_hdr_3addr));	
 	category = frame_body[0];
 
 	if(category == RTW_WLAN_CATEGORY_PUBLIC)
@@ -3894,12 +3894,12 @@ void rtw_append_wfd_ie(_adapter *padapter, u8 *buf, u32* len)
 				}
 				default:
 
-					break;
+					break;	
 			}
 
 		}
-
-	}
+		
+	}	
 	else if(category == RTW_WLAN_CATEGORY_P2P)
 	{
 		OUI_Subtype = frame_body[5];
@@ -3914,26 +3914,26 @@ void rtw_append_wfd_ie(_adapter *padapter, u8 *buf, u32* len)
 		{
 			case P2P_NOTICE_OF_ABSENCE:
 
-				break;
+				break;			
 			case P2P_PRESENCE_REQUEST:
 
-				break;
+				break;			
 			case P2P_PRESENCE_RESPONSE:
 
-				break;
+				break;			
 			case P2P_GO_DISC_REQUEST:
 
-				break;
+				break;			
 			default:
 
-				break;
-		}
+				break;			
+		}	
 
-	}
-	else
+	}	
+	else 
 	{
 		DBG_871X("%s, action frame category=%d\n", __func__, category);
-		//is_p2p_frame = (-1);
+		//is_p2p_frame = (-1);		
 	}
 
 	return;
@@ -3960,7 +3960,7 @@ u8 *dump_p2p_attr_ch_list(u8 *p2p_ie, uint p2p_ielen, u8 *buf, u32 buf_len)
 
 		while (attr_contentlen>0) {
 			num_of_ch = *(pattr_temp+1);
-
+							
 			for(i=0; i<num_of_ch; i++) {
 				for (j=0;j<ch_cnt;j++) {
 					if (ch_list[j] == *(pattr_temp+2+i))
@@ -4016,8 +4016,8 @@ int rtw_p2p_check_frames(_adapter *padapter, const u8 *buf, u32 len, u8 tx)
 	int op_ch = -1;
 	int listen_ch = -1;
 	u8 intent = 0;
-
-	frame_body = (unsigned char *)(buf + sizeof(struct rtw_ieee80211_hdr_3addr));
+	
+	frame_body = (unsigned char *)(buf + sizeof(struct rtw_ieee80211_hdr_3addr));	
 	category = frame_body[0];
 	//just for check
 	if(category == RTW_WLAN_CATEGORY_PUBLIC)
@@ -4254,7 +4254,7 @@ int rtw_p2p_check_frames(_adapter *padapter, const u8 *buf, u32 len, u8 tx)
 						}
 #endif //CONFIG_P2P_INVITE_IOT
 						status = *cont;
-					}
+					}	
 					if ((cont = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, NULL, &cont_len)))
 						op_ch = *(cont+4);
 
@@ -4289,15 +4289,15 @@ int rtw_p2p_check_frames(_adapter *padapter, const u8 *buf, u32 len, u8 tx)
 					u8 *p2p_ie;
 					uint p2p_ielen = 0;
 					uint contentlen = 0;
-
+					
 					DBG_871X("RTW_%s:P2P_PROVISION_DISC_REQ, dialogToken=%d\n", (tx==_TRUE)?"Tx":"Rx", dialogToken);
 
 					//if(tx)
 					{
 						pwdev_priv->provdisc_req_issued = _FALSE;
-
+					
 						if( (p2p_ie=rtw_get_p2p_ie( frame_body + _PUBLIC_ACTION_IE_OFFSET_, frame_body_len - _PUBLIC_ACTION_IE_OFFSET_, NULL, &p2p_ielen)))
-						{
+						{	
 
 							if(rtw_get_p2p_attr_content( p2p_ie, p2p_ielen, P2P_ATTR_GROUP_ID, NULL, &contentlen))
 							{
@@ -4310,22 +4310,22 @@ int rtw_p2p_check_frames(_adapter *padapter, const u8 *buf, u32 len, u8 tx)
 								#endif //CONFIG_DEBUG_CFG80211
 								pwdev_priv->provdisc_req_issued = _TRUE;//case: p2p_devices connection before Nego req.
 							}
-
-						}
-					}
-				}
+												
+						}						
+					}				
+				}	
 					break;
 				case P2P_PROVISION_DISC_RESP:
 					DBG_871X("RTW_%s:P2P_PROVISION_DISC_RESP, dialogToken=%d\n", (tx==_TRUE)?"Tx":"Rx", dialogToken);
 					break;
 				default:
 					DBG_871X("RTW_%s:OUI_Subtype=%d, dialogToken=%d\n", (tx==_TRUE)?"Tx":"Rx", OUI_Subtype, dialogToken);
-					break;
+					break;	
 			}
 
 		}
-
-	}
+		
+	}	
 	else if(category == RTW_WLAN_CATEGORY_P2P)
 	{
 		OUI_Subtype = frame_body[5];
@@ -4342,22 +4342,22 @@ int rtw_p2p_check_frames(_adapter *padapter, const u8 *buf, u32 len, u8 tx)
 		{
 			case P2P_NOTICE_OF_ABSENCE:
 				DBG_871X("RTW_%s:P2P_NOTICE_OF_ABSENCE, dialogToken=%d\n", (tx==_TRUE)?"TX":"RX", dialogToken);
-				break;
+				break;			
 			case P2P_PRESENCE_REQUEST:
 				DBG_871X("RTW_%s:P2P_PRESENCE_REQUEST, dialogToken=%d\n", (tx==_TRUE)?"TX":"RX", dialogToken);
-				break;
+				break;			
 			case P2P_PRESENCE_RESPONSE:
 				DBG_871X("RTW_%s:P2P_PRESENCE_RESPONSE, dialogToken=%d\n", (tx==_TRUE)?"TX":"RX", dialogToken);
-				break;
+				break;			
 			case P2P_GO_DISC_REQUEST:
 				DBG_871X("RTW_%s:P2P_GO_DISC_REQUEST, dialogToken=%d\n", (tx==_TRUE)?"TX":"RX", dialogToken);
-				break;
+				break;			
 			default:
 				DBG_871X("RTW_%s:OUI_Subtype=%d, dialogToken=%d\n", (tx==_TRUE)?"TX":"RX", OUI_Subtype, dialogToken);
-				break;
-		}
+				break;			
+		}	
 
-	}
+	}	
 	else
 	{
 		DBG_871X("RTW_%s:action frame category=%d\n", (tx==_TRUE)?"TX":"RX", category);
@@ -4371,15 +4371,15 @@ void rtw_init_cfg80211_wifidirect_info( _adapter*	padapter)
 	struct cfg80211_wifidirect_info *pcfg80211_wdinfo = &padapter->cfg80211_wdinfo;
 
 	_rtw_memset(pcfg80211_wdinfo, 0x00, sizeof(struct cfg80211_wifidirect_info) );
-
+	
 	_init_timer( &pcfg80211_wdinfo->remain_on_ch_timer, padapter->pnetdev, ro_ch_timer_process, padapter );
 }
-#endif //CONFIG_IOCTL_CFG80211
+#endif //CONFIG_IOCTL_CFG80211	
 
 void p2p_protocol_wk_hdl(_adapter *padapter, int intCmdType)
 {
 	struct wifidirect_info	*pwdinfo= &(padapter->wdinfo);
-
+	
 _func_enter_;
 
 	switch(intCmdType)
@@ -4421,11 +4421,11 @@ void p2p_protocol_wk_hdl(_adapter *padapter, int intCmdType)
 			{
 				pre_tx_invitereq_handler( padapter );
 			}
-#else
+#else			
 			pre_tx_invitereq_handler( padapter );
 #endif
 			break;
-		}
+		}		
 		case P2P_PRE_TX_NEGOREQ_PROCESS_WK:
 		{
 #ifdef CONFIG_CONCURRENT_MODE
@@ -4437,7 +4437,7 @@ void p2p_protocol_wk_hdl(_adapter *padapter, int intCmdType)
 			{
 				pre_tx_negoreq_handler( padapter );
 			}
-#else
+#else			
 			pre_tx_negoreq_handler( padapter );
 #endif
 			break;
@@ -4448,7 +4448,7 @@ void p2p_protocol_wk_hdl(_adapter *padapter, int intCmdType)
 		{
 			p2p_concurrent_handler( padapter );
 			break;
-		}
+		}		
 #endif
 #endif
 #ifdef CONFIG_IOCTL_CFG80211
@@ -4456,11 +4456,11 @@ void p2p_protocol_wk_hdl(_adapter *padapter, int intCmdType)
 		{
 			ro_ch_handler( padapter );
 			break;
-		}
-#endif //CONFIG_IOCTL_CFG80211
+		}		
+#endif //CONFIG_IOCTL_CFG80211		
 
 	}
-
+	
 _func_exit_;
 }
 
@@ -4473,7 +4473,7 @@ void process_p2p_ps_ie(PADAPTER padapter, u8 *IEs, u32 IELength)
 	u32	p2p_ielen = 0;
 	u8	noa_attr[MAX_P2P_IE_LEN] = { 0x00 };// NoA length should be n*(13) + 2
 	u32	attr_contentlen = 0;
-
+	
 	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo );
 	u8	find_p2p = _FALSE, find_p2p_ps = _FALSE;
 	u8	noa_offset, noa_num, noa_index;
@@ -4484,19 +4484,19 @@ void process_p2p_ps_ie(PADAPTER padapter, u8 *IEs, u32 IELength)
 	{
 		return;
 	}
-
+	
 #ifdef CONFIG_CONCURRENT_MODE
-	if(padapter->iface_type != IFACE_PORT0)
+	if(padapter->iface_type != IFACE_PORT0) 
 		return;
 #endif
 	if(IELength <= _BEACON_IE_OFFSET_)
 		return;
-
+	
 	ies = IEs + _BEACON_IE_OFFSET_;
 	ies_len = IELength - _BEACON_IE_OFFSET_;
 
 	p2p_ie = rtw_get_p2p_ie( ies, ies_len, NULL, &p2p_ielen);
-
+	
 	while(p2p_ie)
 	{
 		find_p2p = _TRUE;
@@ -4581,14 +4581,14 @@ void p2p_ps_wk_hdl(_adapter *padapter, u8 p2p_ps_state)
 {
 	struct pwrctrl_priv		*pwrpriv = &padapter->pwrctrlpriv;
 	struct wifidirect_info	*pwdinfo= &(padapter->wdinfo);
-
+	
 _func_enter_;
 
 	switch(p2p_ps_state)
 	{
 		case P2P_PS_DISABLE:
 			pwdinfo->p2p_ps_state = p2p_ps_state;
-
+			
 			rtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_P2P_PS_OFFLOAD, (u8 *)(&p2p_ps_state));
 
 			pwdinfo->noa_index = 0;
@@ -4608,7 +4608,7 @@ void p2p_ps_wk_hdl(_adapter *padapter, u8 p2p_ps_state)
 		case P2P_PS_ENABLE:
 			if (pwdinfo->p2p_ps_mode > P2P_PS_NONE) {
 				pwdinfo->p2p_ps_state = p2p_ps_state;
-
+				
 				if( pwdinfo->ctwindow > 0 )
 				{
 					if(pwrpriv->smart_ps != 0)
@@ -4643,12 +4643,12 @@ u8 p2p_ps_wk_cmd(_adapter*padapter, u8 p2p_ps_state, u8 enqueue)
 	struct wifidirect_info	*pwdinfo= &(padapter->wdinfo);
 	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
 	u8	res = _SUCCESS;
-
+	
 _func_enter_;
 
-	if ( rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)
+	if ( rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) 
 #ifdef CONFIG_CONCURRENT_MODE
-		|| (padapter->iface_type != IFACE_PORT0)
+		|| (padapter->iface_type != IFACE_PORT0) 
 #endif
 		)
 	{
@@ -4657,13 +4657,13 @@ u8 p2p_ps_wk_cmd(_adapter*padapter, u8 p2p_ps_state, u8 enqueue)
 
 	if(enqueue)
 	{
-		ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
+		ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));	
 		if(ph2c==NULL){
 			res= _FAIL;
 			goto exit;
 		}
-
-		pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm));
+		
+		pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm)); 
 		if(pdrvextra_cmd_parm==NULL){
 			rtw_mfree((unsigned char *)ph2c, sizeof(struct cmd_obj));
 			res= _FAIL;
@@ -4682,9 +4682,9 @@ u8 p2p_ps_wk_cmd(_adapter*padapter, u8 p2p_ps_state, u8 enqueue)
 	{
 		p2p_ps_wk_hdl(padapter, p2p_ps_state);
 	}
-
+	
 exit:
-
+	
 _func_exit_;
 
 	return res;
@@ -4692,9 +4692,17 @@ u8 p2p_ps_wk_cmd(_adapter*padapter, u8 p2p_ps_state, u8 enqueue)
 }
 #endif // CONFIG_P2P_PS
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
 static void reset_ch_sitesurvey_timer_process (void *FunctionContext)
+#else
+static void reset_ch_sitesurvey_timer_process(struct timer_list *t)
+#endif
 {
-	_adapter *adapter = (_adapter *)FunctionContext;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+        _adapter *adapter = (_adapter *)FunctionContext;
+#else
+        _adapter *adapter = from_timer(adapter, t, wdinfo.reset_ch_sitesurvey);
+#endif
 	struct	wifidirect_info		*pwdinfo = &adapter->wdinfo;
 
 	if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
@@ -4707,13 +4715,21 @@ static void reset_ch_sitesurvey_timer_process (void *FunctionContext)
 	pwdinfo->rx_invitereq_info.operation_ch[1] = 0;
 	pwdinfo->rx_invitereq_info.operation_ch[2] = 0;
 	pwdinfo->rx_invitereq_info.operation_ch[3] = 0;
-#endif //P2P_OP_CHECK_SOCIAL_CH
+#endif //P2P_OP_CHECK_SOCIAL_CH 
 	pwdinfo->rx_invitereq_info.scan_op_ch_only = 0;
 }
 
-static void reset_ch_sitesurvey_timer_process2 (void *FunctionContext)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+static void reset_ch_sitesurvey_timer_process2(void *FunctionContext)
+#else
+static void reset_ch_sitesurvey_timer_process2(struct timer_list *t)
+#endif
 {
-	_adapter *adapter = (_adapter *)FunctionContext;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+        _adapter *adapter = (_adapter *)FunctionContext;
+#else
+        _adapter *adapter = from_timer(adapter, t, wdinfo.reset_ch_sitesurvey2);
+#endif
 	struct	wifidirect_info		*pwdinfo = &adapter->wdinfo;
 
 	if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
@@ -4730,20 +4746,36 @@ static void reset_ch_sitesurvey_timer_process2 (void *FunctionContext)
 	pwdinfo->p2p_info.scan_op_ch_only = 0;
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
 static void restore_p2p_state_timer_process (void *FunctionContext)
+#else
+static void restore_p2p_state_timer_process(struct timer_list *t)
+#endif
 {
-	_adapter *adapter = (_adapter *)FunctionContext;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+        _adapter *adapter = (_adapter *)FunctionContext;
+#else
+        _adapter *adapter = from_timer(adapter, t, wdinfo.restore_p2p_state_timer);
+#endif
 	struct	wifidirect_info		*pwdinfo = &adapter->wdinfo;
 
 	if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
-		return;
-
+		return; 
+	
 	p2p_protocol_wk_cmd( adapter, P2P_RESTORE_STATE_WK );
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
 static void pre_tx_scan_timer_process (void *FunctionContext)
+#else
+static void pre_tx_scan_timer_process(struct timer_list *t)
+#endif
 {
-	_adapter 							*adapter = (_adapter *) FunctionContext;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+        _adapter *adapter = (_adapter *) FunctionContext;
+#else
+        _adapter *adapter = from_timer(adapter, t, wdinfo.pre_tx_scan_timer);
+#endif
 	struct	wifidirect_info				*pwdinfo = &adapter->wdinfo;
 	_irqL							irqL;
 	struct mlme_priv					*pmlmepriv = &adapter->mlmepriv;
@@ -4751,17 +4783,17 @@ static void pre_tx_scan_timer_process (void *FunctionContext)
 
 	if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 		return;
-
+	
 	_enter_critical_bh(&pmlmepriv->lock, &irqL);
 
 	//	Commented by Albert 20110805
 	//	Todo: Use the issuing probe request directly instead of using the rtw_sitesurvey_cmd!!
-
+	
 	if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_PROVISION_DIS_REQ))
 	{
 		if ( _TRUE == pwdinfo->tx_prov_disc_info.benable )	//	the provision discovery request frame is trigger to send or not
 		{
-			p2p_protocol_wk_cmd( adapter, P2P_PRE_TX_PROVDISC_PROCESS_WK );
+			p2p_protocol_wk_cmd( adapter, P2P_PRE_TX_PROVDISC_PROCESS_WK );			
 			//issue_probereq_p2p(adapter, NULL);
 			//_set_timer( &pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT );
 		}
@@ -4786,13 +4818,21 @@ static void pre_tx_scan_timer_process (void *FunctionContext)
 	{
 		DBG_8192C( "[%s] p2p_state is %d, ignore!!\n", __FUNCTION__, rtw_p2p_state(pwdinfo) );
 	}
-
+	
 	_exit_critical_bh(&pmlmepriv->lock, &irqL);
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
 static void find_phase_timer_process (void *FunctionContext)
+#else
+static void find_phase_timer_process(struct timer_list *t)
+#endif
 {
-	_adapter *adapter = (_adapter *)FunctionContext;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+        _adapter *adapter = (_adapter *)FunctionContext;
+#else
+        _adapter *adapter = from_timer(adapter, t, wdinfo.find_phase_timer);
+#endif
 	struct	wifidirect_info		*pwdinfo = &adapter->wdinfo;
 
 	if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
@@ -4804,11 +4844,19 @@ static void find_phase_timer_process (void *FunctionContext)
 }
 
 #ifdef CONFIG_CONCURRENT_MODE
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
 void ap_p2p_switch_timer_process (void *FunctionContext)
+#else
+void ap_p2p_switch_timer_process(struct timer_list *t)
+#endif
 {
-	_adapter *adapter = (_adapter *)FunctionContext;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+        _adapter *adapter = (_adapter *)FunctionContext;
+#else
+        _adapter *adapter = from_timer(adapter, t, wdinfo.ap_p2p_switch_timer);
+#endif
 	struct	wifidirect_info		*pwdinfo = &adapter->wdinfo;
-#ifdef CONFIG_IOCTL_CFG80211
+#ifdef CONFIG_IOCTL_CFG80211	
 	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(adapter->rtw_wdev);
 #endif
 
@@ -4847,7 +4895,7 @@ int rtw_init_wifi_display_info(_adapter* padapter)
 	pwfd_info->wfd_device_type = WFD_DEVINFO_PSINK;
 	pwfd_info->scan_result_type = SCAN_RESULT_P2P_ONLY;
 
-	// Used in P2P
+	// Used in P2P	
 	pwfd_info->peer_session_avail = _TRUE;
 	pwfd_info->wfd_pc = _FALSE;
 
@@ -4863,6 +4911,7 @@ void rtw_init_wifidirect_timers(_adapter* padapter)
 {
 	struct wifidirect_info *pwdinfo = &padapter->wdinfo;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
 	_init_timer( &pwdinfo->find_phase_timer, padapter->pnetdev, find_phase_timer_process, padapter );
 	_init_timer( &pwdinfo->restore_p2p_state_timer, padapter->pnetdev, restore_p2p_state_timer_process, padapter );
 	_init_timer( &pwdinfo->pre_tx_scan_timer, padapter->pnetdev, pre_tx_scan_timer_process, padapter );
@@ -4871,6 +4920,16 @@ void rtw_init_wifidirect_timers(_adapter* padapter)
 #ifdef CONFIG_CONCURRENT_MODE
 	_init_timer( &pwdinfo->ap_p2p_switch_timer, padapter->pnetdev, ap_p2p_switch_timer_process, padapter );
 #endif
+#else
+        timer_setup(&pwdinfo->find_phase_timer, find_phase_timer_process, 0);
+        timer_setup(&pwdinfo->restore_p2p_state_timer, restore_p2p_state_timer_process, 0);
+        timer_setup(&pwdinfo->pre_tx_scan_timer, pre_tx_scan_timer_process, 0);
+        timer_setup(&pwdinfo->reset_ch_sitesurvey, reset_ch_sitesurvey_timer_process, 0);
+        timer_setup(&pwdinfo->reset_ch_sitesurvey2, reset_ch_sitesurvey_timer_process2, 0);
+#ifdef CONFIG_CONCURRENT_MODE
+        timer_setup(&pwdinfo->ap_p2p_switch_timer, ap_p2p_switch_timer_process, 0);
+#endif
+#endif
 }
 
 void rtw_init_wifidirect_addrs(_adapter* padapter, u8 *dev_addr, u8 *iface_addr)
@@ -4896,15 +4955,15 @@ void init_wifidirect_info( _adapter* padapter, enum P2P_ROLE role)
 #endif
 #ifdef CONFIG_CONCURRENT_MODE
 	_adapter				*pbuddy_adapter = padapter->pbuddy_adapter;
-	struct wifidirect_info	*pbuddy_wdinfo = NULL;
-	struct mlme_priv		*pbuddy_mlmepriv = NULL;
-	struct mlme_ext_priv	*pbuddy_mlmeext = NULL;
+	struct wifidirect_info	*pbuddy_wdinfo;
+	struct mlme_priv		*pbuddy_mlmepriv;
+	struct mlme_ext_priv	*pbuddy_mlmeext;
 #endif
 
 	pwdinfo = &padapter->wdinfo;
 
 	pwdinfo->padapter = padapter;
-
+	
 	//	1, 6, 11 are the social channel defined in the WiFi Direct specification.
 	pwdinfo->social_chan[0] = 1;
 	pwdinfo->social_chan[1] = 6;
@@ -4918,7 +4977,7 @@ void init_wifidirect_info( _adapter* padapter, enum P2P_ROLE role)
 		pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 	}
 
-	if ( ( check_buddy_fwstate(padapter, _FW_LINKED ) == _TRUE ) &&
+	if ( ( check_buddy_fwstate(padapter, _FW_LINKED ) == _TRUE ) && 
 	      ( ( pbuddy_mlmeext->cur_channel == 1) || ( pbuddy_mlmeext->cur_channel == 6 ) || ( pbuddy_mlmeext->cur_channel == 11 ) )
 	   )
 	{
@@ -4955,7 +5014,7 @@ void init_wifidirect_info( _adapter* padapter, enum P2P_ROLE role)
 		rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_OK);
 		pwdinfo->intent = 1;
 		rtw_p2p_set_pre_state(pwdinfo, P2P_STATE_GONEGO_OK);
-	}
+	}	
 	else if (role == P2P_ROLE_GO)
 	{
 		rtw_p2p_set_role(pwdinfo, P2P_ROLE_GO);
@@ -4964,7 +5023,7 @@ void init_wifidirect_info( _adapter* padapter, enum P2P_ROLE role)
 		rtw_p2p_set_pre_state(pwdinfo, P2P_STATE_GONEGO_OK);
 	}
 
-//	Use the OFDM rate in the P2P probe response frame. ( 6(B), 9(B), 12, 18, 24, 36, 48, 54 )
+//	Use the OFDM rate in the P2P probe response frame. ( 6(B), 9(B), 12, 18, 24, 36, 48, 54 )	
 	pwdinfo->support_rate[0] = 0x8c;	//	6(B)
 	pwdinfo->support_rate[1] = 0x92;	//	9(B)
 	pwdinfo->support_rate[2] = 0x18;	//	12
@@ -4981,7 +5040,7 @@ void init_wifidirect_info( _adapter* padapter, enum P2P_ROLE role)
 
 	_rtw_memset( &pwdinfo->invitereq_info, 0x00, sizeof( struct tx_invite_req_info ) );
 	pwdinfo->invitereq_info.token = 3;	//	Token used for P2P invitation request frame.
-
+	
 	_rtw_memset( &pwdinfo->inviteresp_info, 0x00, sizeof( struct tx_invite_resp_info ) );
 	pwdinfo->inviteresp_info.token = 0;
 
@@ -5158,7 +5217,7 @@ void dbg_rtw_p2p_set_state(struct wifidirect_info *wdinfo, enum P2P_STATE state,
 void dbg_rtw_p2p_set_pre_state(struct wifidirect_info *wdinfo, enum P2P_STATE state, const char *caller, int line)
 {
 	if(_rtw_p2p_pre_state(wdinfo) != state) {
-		enum P2P_STATE old_state = _rtw_p2p_pre_state(wdinfo);
+		enum P2P_STATE old_state = _rtw_p2p_pre_state(wdinfo); 
 		_rtw_p2p_set_pre_state(wdinfo, state);
 		DBG_871X("[CONFIG_DBG_P2P]%s:%d set_pre_state from %s to %s\n", caller, line
 			, rtw_p2p_state_txt(old_state), rtw_p2p_state_txt(_rtw_p2p_pre_state(wdinfo))
@@ -5180,7 +5239,7 @@ void dbg_rtw_p2p_restore_state(struct wifidirect_info *wdinfo, const char *calle
 	} else {
 		DBG_871X("[CONFIG_DBG_P2P]%s:%d restore no pre state, cur state %s\n", caller, line
 			, p2p_state_str[wdinfo->p2p_state]
-		);
+		);		
 	}
 }
 #endif
@@ -5230,7 +5289,7 @@ int rtw_p2p_enable(_adapter *padapter, enum P2P_ROLE role)
 			ret = _FAIL;
 			goto exit;
 		}
-
+		
 
 		//	Added by Albert 2011/03/22
 		//	In the P2P mode, the driver should not support the b mode.
@@ -5250,7 +5309,7 @@ int rtw_p2p_enable(_adapter *padapter, enum P2P_ROLE role)
 		if (_FAIL == rtw_pwr_wakeup(padapter)) {
 			ret = _FAIL;
 			goto exit;
-		}
+		}	
 
 		//Disable P2P function
 		if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
@@ -5260,9 +5319,14 @@ int rtw_p2p_enable(_adapter *padapter, enum P2P_ROLE role)
 			_cancel_timer_ex( &pwdinfo->pre_tx_scan_timer);
 			_cancel_timer_ex( &pwdinfo->reset_ch_sitesurvey);
 			_cancel_timer_ex( &pwdinfo->reset_ch_sitesurvey2);
-			reset_ch_sitesurvey_timer_process( padapter );
-			reset_ch_sitesurvey_timer_process2( padapter );
-			#ifdef CONFIG_CONCURRENT_MODE
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+                        reset_ch_sitesurvey_timer_process( padapter );
+                        reset_ch_sitesurvey_timer_process2( padapter );
+#else
+                        reset_ch_sitesurvey_timer_process(&padapter->wdinfo.reset_ch_sitesurvey);
+                        reset_ch_sitesurvey_timer_process(&padapter->wdinfo.reset_ch_sitesurvey2);
+#endif
+			#ifdef CONFIG_CONCURRENT_MODE			
 			_cancel_timer_ex( &pwdinfo->ap_p2p_switch_timer);
 			#endif
 			rtw_p2p_set_state(pwdinfo, P2P_STATE_NONE);
@@ -5286,8 +5350,9 @@ int rtw_p2p_enable(_adapter *padapter, enum P2P_ROLE role)
 
 	}
 
-exit:
+exit:	
 	return ret;
 }
 
 #endif //CONFIG_P2P
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_pwrctrl.c b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_pwrctrl.c
old mode 100644
new mode 100755
index 63f8655..e2329fb
--- a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_pwrctrl.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_pwrctrl.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -98,7 +98,7 @@ int ips_leave(_adapter * padapter)
 #endif /* CONFIG_IPS */
 
 #ifdef CONFIG_AUTOSUSPEND
-extern void autosuspend_enter(_adapter* padapter);
+extern void autosuspend_enter(_adapter* padapter);	
 extern int autoresume_enter(_adapter* padapter);
 #endif
 
@@ -143,7 +143,7 @@ bool rtw_pwr_unassociated_idle(_adapter *adapter)
 		struct mlme_priv *b_pmlmepriv = &(buddy->mlmepriv);
 		#ifdef CONFIG_P2P
 		struct wifidirect_info *b_pwdinfo = &(buddy->wdinfo);
-		#ifdef CONFIG_IOCTL_CFG80211
+		#ifdef CONFIG_IOCTL_CFG80211		
 		struct cfg80211_wifidirect_info *b_pcfg80211_wdinfo = &buddy->cfg80211_wdinfo;
 		#endif
 		#endif
@@ -191,9 +191,9 @@ void rtw_ps_processor(_adapter*padapter)
 #ifdef SUPPORT_HW_RFOFF_DETECTED
 	if(pwrpriv->bips_processing == _TRUE)
 		goto exit;
-
-	//DBG_871X("==> fw report state(0x%x)\n",rtw_read8(padapter,0x1ca));
-	if(padapter->pwrctrlpriv.bHWPwrPindetect)
+	
+	//DBG_871X("==> fw report state(0x%x)\n",rtw_read8(padapter,0x1ca));	
+	if(padapter->pwrctrlpriv.bHWPwrPindetect) 
 	{
 	#ifdef CONFIG_AUTOSUSPEND
 		if(padapter->registrypriv.usbss_enable)
@@ -210,14 +210,14 @@ void rtw_ps_processor(_adapter*padapter)
 					if(rfpwrstate == rf_off)
 					{
 						pwrpriv->change_rfpwrstate = rf_off;
-
-						pwrpriv->bkeepfwalive = _TRUE;
-						pwrpriv->brfoffbyhw = _TRUE;
-
-						autosuspend_enter(padapter);
+						
+						pwrpriv->bkeepfwalive = _TRUE;	
+						pwrpriv->brfoffbyhw = _TRUE;						
+						
+						autosuspend_enter(padapter);							
 					}
 				}
-			}
+			}			
 		}
 		else
 	#endif //CONFIG_AUTOSUSPEND
@@ -228,21 +228,21 @@ void rtw_ps_processor(_adapter*padapter)
 			if(rfpwrstate!= pwrpriv->rf_pwrstate)
 			{
 				if(rfpwrstate == rf_off)
-				{
-					pwrpriv->change_rfpwrstate = rf_off;
+				{	
+					pwrpriv->change_rfpwrstate = rf_off;														
 					pwrpriv->brfoffbyhw = _TRUE;
 					padapter->bCardDisableWOHSM = _TRUE;
-					rtw_hw_suspend(padapter );
+					rtw_hw_suspend(padapter );	
 				}
 				else
 				{
 					pwrpriv->change_rfpwrstate = rf_on;
-					rtw_hw_resume(padapter );
+					rtw_hw_resume(padapter );			
 				}
 				DBG_871X("current rf_pwrstate(%s)\n",(pwrpriv->rf_pwrstate == rf_off)?"rf_off":"rf_on");
 			}
 		}
-		pwrpriv->pwr_state_check_cnts ++;
+		pwrpriv->pwr_state_check_cnts ++;	
 	}
 #endif //SUPPORT_HW_RFOFF_DETECTED
 
@@ -263,24 +263,24 @@ void rtw_ps_processor(_adapter*padapter)
 
 		#ifdef CONFIG_AUTOSUSPEND
 		if(padapter->registrypriv.usbss_enable)
-		{
-			if(pwrpriv->bHWPwrPindetect)
+		{		
+			if(pwrpriv->bHWPwrPindetect) 
 				pwrpriv->bkeepfwalive = _TRUE;
-
+			
 			if(padapter->net_closed == _TRUE)
 				pwrpriv->ps_flag = _TRUE;
 
 			padapter->bCardDisableWOHSM = _TRUE;
 			autosuspend_enter(padapter);
-		}
+		}		
 		else if(pwrpriv->bHWPwrPindetect)
 		{
 		}
 		else
 		#endif //CONFIG_AUTOSUSPEND
 		{
-			#ifdef CONFIG_IPS
-			ips_enter(padapter);
+			#ifdef CONFIG_IPS	
+			ips_enter(padapter);			
 			#endif
 		}
 	}
@@ -290,11 +290,18 @@ void rtw_ps_processor(_adapter*padapter)
 	return;
 }
 
-void pwr_state_check_handler(void *FunctionContext);
-void pwr_state_check_handler(void *FunctionContext)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+void pwr_state_check_handler(RTW_TIMER_HDL_ARGS)
+#else
+void pwr_state_check_handler(struct timer_list *t)
+#endif
 {
-	_adapter *padapter = (_adapter *)FunctionContext;
-	rtw_ps_cmd(padapter);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+        _adapter *padapter = (_adapter *)FunctionContext;
+#else
+        _adapter *padapter = from_timer(padapter, t, pwrctrlpriv.pwr_state_check_timer);
+#endif
+        rtw_ps_cmd(padapter);
 }
 #endif
 
@@ -356,12 +363,12 @@ u8 PS_RDY_CHECK(_adapter * padapter)
 	struct pwrctrl_priv	*pwrpriv = &padapter->pwrctrlpriv;
 	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
 
-	curr_time = rtw_get_current_time();
+	curr_time = rtw_get_current_time();	
 
 	delta_time = curr_time -pwrpriv->DelayLPSLastTimeStamp;
 
 	if(delta_time < LPS_DELAY_TIME)
-	{
+	{		
 		return _FALSE;
 	}
 
@@ -375,7 +382,7 @@ u8 PS_RDY_CHECK(_adapter * padapter)
 
 	if(_TRUE == pwrpriv->bInSuspend )
 		return _FALSE;
-
+	
 	if( (padapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X) && (padapter->securitypriv.binstallGrpkey == _FALSE) )
 	{
 		DBG_871X("Group handshake still in progress !!!\n");
@@ -385,7 +392,7 @@ u8 PS_RDY_CHECK(_adapter * padapter)
 #ifdef CONFIG_IOCTL_CFG80211
 	if (!rtw_cfg80211_pwr_mgmt(padapter))
 		return _FALSE;
-#endif
+#endif	
 
 	return _TRUE;
 }
@@ -559,11 +566,11 @@ void LPS_Enter(PADAPTER padapter)
 		struct mlme_priv *b_pmlmepriv = &(buddy->mlmepriv);
 		#ifdef CONFIG_P2P
 		struct wifidirect_info *b_pwdinfo = &(buddy->wdinfo);
-		#ifdef CONFIG_IOCTL_CFG80211
+		#ifdef CONFIG_IOCTL_CFG80211		
 		struct cfg80211_wifidirect_info *b_pcfg80211_wdinfo = &buddy->cfg80211_wdinfo;
 		#endif
 		#endif
-
+		
 		if (check_fwstate(b_pmlmepriv, WIFI_ASOC_STATE|WIFI_SITE_MONITOR)
 			|| check_fwstate(b_pmlmepriv, WIFI_UNDER_LINKING|WIFI_UNDER_WPS)
 			|| check_fwstate(b_pmlmepriv, WIFI_AP_STATE)
@@ -594,16 +601,16 @@ void LPS_Enter(PADAPTER padapter)
 
 	if(_TRUE == pwrpriv->bInSuspend )
 		return ;
-
+	
 	if (pwrpriv->bLeisurePs)
 	{
 		// Idle for a while if we connect to AP a while ago.
-		if(pwrpriv->LpsIdleCount >= 2) //  4 Sec
+		if(pwrpriv->LpsIdleCount >= 2) //  4 Sec 
 		{
 			if(pwrpriv->pwr_mode == PS_MODE_ACTIVE)
 			{
 				rtw_set_ps_mode(padapter, pwrpriv->power_mgnt, 2);
-			}
+			}	
 		}
 		else
 			pwrpriv->LpsIdleCount++;
@@ -626,7 +633,7 @@ void LPS_Leave(PADAPTER padapter)
 	struct pwrctrl_priv	*pwrpriv = &padapter->pwrctrlpriv;
 	u32 start_time;
 	BOOLEAN bAwake = _FALSE;
-
+	
 _func_enter_;
 
 //	DBG_871X("+LeisurePSLeave\n");
@@ -637,21 +644,21 @@ void LPS_Leave(PADAPTER padapter)
 #endif
 
 	if (pwrpriv->bLeisurePs)
-	{
+	{	
 		if(pwrpriv->pwr_mode != PS_MODE_ACTIVE)
 		{
 			rtw_set_ps_mode(padapter, PS_MODE_ACTIVE, 0);
 
 			if(pwrpriv->pwr_mode == PS_MODE_ACTIVE)
 			{
-				start_time = rtw_get_current_time();
-				while(1)
+				start_time = rtw_get_current_time();		
+				while(1)			
 				{
 					rtw_hal_get_hwreg(padapter, HW_VAR_FWLPS_RF_ON, (u8 *)(&bAwake));
-
+						
 					if(bAwake || padapter->bSurpriseRemoved)
 						break;
-
+					
 					if(rtw_get_passing_time_ms(start_time)>LPS_LEAVE_TIMEOUT_MS)
 					{
 						DBG_871X("Wait for FW LPS leave more than %u ms!!!\n", LPS_LEAVE_TIMEOUT_MS);
@@ -673,7 +680,7 @@ void LPS_Leave(PADAPTER padapter)
 
 //
 // Description: Leave all power save mode: LPS, FwLPS, IPS if needed.
-// Move code to function by tynli. 2010.03.26.
+// Move code to function by tynli. 2010.03.26. 
 //
 void LeaveAllPowerSaveMode(IN PADAPTER Adapter)
 {
@@ -712,12 +719,12 @@ void LeaveAllPowerSaveMode(IN PADAPTER Adapter)
 				#ifdef CONFIG_IPS
 				if(_FALSE == ips_leave(Adapter))
 				{
-					DBG_871X("======> ips_leave fail.............\n");
+					DBG_871X("======> ips_leave fail.............\n");			
 				}
 				#endif
 			*/
-			}
-		}
+			}				
+		}	
 	}
 
 _func_exit_;
@@ -783,13 +790,13 @@ __inline static void unregister_task_alive(struct pwrctrl_priv *pwrctrl, u32 tag
 
 /*
  * Caller: rtw_xmit_thread
- *
+ * 
  * Check if the fw_pwrstate is okay for xmit.
  * If not (cpwm is less than S3), then the sub-routine
- * will raise the cpwm to be greater than or equal to S3.
+ * will raise the cpwm to be greater than or equal to S3. 
  *
  * Calling Context: Passive
- *
+ * 
  * Return Value:
  *	 _SUCCESS	rtw_xmit_thread can write fifo/txcmd afterwards.
  *	 _FAIL		rtw_xmit_thread can not do anything.
@@ -825,7 +832,7 @@ s32 rtw_register_tx_alive(PADAPTER padapter)
 
 _func_exit_;
 
-	return res;
+	return res;	
 }
 
 /*
@@ -1087,7 +1094,7 @@ void rtw_init_pwrctrl_priv(PADAPTER padapter)
 
 #ifdef CONFIG_AUTOSUSPEND
 #ifdef SUPPORT_HW_RFOFF_DETECTED
-	pwrctrlpriv->pwr_state_check_interval = (pwrctrlpriv->bHWPwrPindetect) ?1000:2000;
+	pwrctrlpriv->pwr_state_check_interval = (pwrctrlpriv->bHWPwrPindetect) ?1000:2000;		
 #endif
 #endif
 
@@ -1108,7 +1115,11 @@ void rtw_init_pwrctrl_priv(PADAPTER padapter)
 	pwrctrlpriv->tog = 0x80;
 
 #ifdef PLATFORM_LINUX
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
 	_init_timer(&(pwrctrlpriv->pwr_state_check_timer), padapter->pnetdev, pwr_state_check_handler, (u8 *)padapter);
+#else
+	timer_setup(&pwrctrlpriv->pwr_state_check_timer, pwr_state_check_handler, 0);
+#endif
 #endif
 
 	#ifdef CONFIG_RESUME_IN_WORKQUEUE
@@ -1137,7 +1148,7 @@ void rtw_free_pwrctrl_priv(PADAPTER adapter)
 
 
 	#ifdef CONFIG_RESUME_IN_WORKQUEUE
-	if (pwrctrlpriv->rtw_workqueue) {
+	if (pwrctrlpriv->rtw_workqueue) { 
 		flush_workqueue(pwrctrlpriv->rtw_workqueue);
 		destroy_workqueue(pwrctrlpriv->rtw_workqueue);
 	}
@@ -1167,16 +1178,16 @@ static void resume_workitem_callback(struct work_struct *work)
 	#if defined(CONFIG_USB_HCI) || defined(CONFIG_SDIO_HCI)
 	rtw_resume_process(adapter);
 	#endif
-
+	
 }
 
 void rtw_resume_in_workqueue(struct pwrctrl_priv *pwrpriv)
 {
 	// accquire system's suspend lock preventing from falliing asleep while resume in workqueue
 	rtw_lock_suspend();
-
+	
 	#if 1
-	queue_work(pwrpriv->rtw_workqueue, &pwrpriv->resume_work);
+	queue_work(pwrpriv->rtw_workqueue, &pwrpriv->resume_work);	
 	#else
 	_set_workitem(&pwrpriv->resume_work);
 	#endif
@@ -1233,7 +1244,7 @@ void rtw_register_early_suspend(struct pwrctrl_priv *pwrpriv)
 #if defined(CONFIG_CONCURRENT_MODE)
 	if (adapter->adapter_type != PRIMARY_ADAPTER)
 		return;
-#endif
+#endif	
 
 	DBG_871X("%s\n", __FUNCTION__);
 
@@ -1241,9 +1252,9 @@ void rtw_register_early_suspend(struct pwrctrl_priv *pwrpriv)
 	pwrpriv->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN - 20;
 	pwrpriv->early_suspend.suspend = rtw_early_suspend;
 	pwrpriv->early_suspend.resume = rtw_late_resume;
-	register_early_suspend(&pwrpriv->early_suspend);
-
+	register_early_suspend(&pwrpriv->early_suspend);	
 
+	
 }
 
 void rtw_unregister_early_suspend(struct pwrctrl_priv *pwrpriv)
@@ -1259,7 +1270,7 @@ void rtw_unregister_early_suspend(struct pwrctrl_priv *pwrpriv)
 
 	rtw_set_do_late_resume(pwrpriv, _FALSE);
 
-	if (pwrpriv->early_suspend.suspend)
+	if (pwrpriv->early_suspend.suspend) 
 		unregister_early_suspend(&pwrpriv->early_suspend);
 
 	pwrpriv->early_suspend.suspend = NULL;
@@ -1308,7 +1319,7 @@ void rtw_register_early_suspend(struct pwrctrl_priv *pwrpriv)
 	pwrpriv->early_suspend.level = ANDROID_EARLY_SUSPEND_LEVEL_BLANK_SCREEN - 20;
 	pwrpriv->early_suspend.suspend = rtw_early_suspend;
 	pwrpriv->early_suspend.resume = rtw_late_resume;
-	android_register_early_suspend(&pwrpriv->early_suspend);
+	android_register_early_suspend(&pwrpriv->early_suspend);	
 }
 
 void rtw_unregister_early_suspend(struct pwrctrl_priv *pwrpriv)
@@ -1324,7 +1335,7 @@ void rtw_unregister_early_suspend(struct pwrctrl_priv *pwrpriv)
 
 	rtw_set_do_late_resume(pwrpriv, _FALSE);
 
-	if (pwrpriv->early_suspend.suspend)
+	if (pwrpriv->early_suspend.suspend) 
 		android_unregister_early_suspend(&pwrpriv->early_suspend);
 
 	pwrpriv->early_suspend.suspend = NULL;
@@ -1357,7 +1368,7 @@ inline void rtw_set_ips_deny(_adapter *padapter, u32 ms)
 int _rtw_pwr_wakeup(_adapter *padapter, u32 ips_deffer_ms, const char *caller)
 {
 	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
-	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;	
 	int ret = _SUCCESS;
 	u32 start = rtw_get_current_time();
 
@@ -1399,7 +1410,7 @@ int _rtw_pwr_wakeup(_adapter *padapter, u32 ips_deffer_ms, const char *caller)
 
 	if (pwrpriv->bInternalAutoSuspend == _FALSE && pwrpriv->bInSuspend) {
 		DBG_871X("%s wait bInSuspend...\n", __func__);
-		while (pwrpriv->bInSuspend
+		while (pwrpriv->bInSuspend 
 			&& ((rtw_get_passing_time_ms(start) <= 3000 && !rtw_is_do_late_resume(pwrpriv))
 				|| (rtw_get_passing_time_ms(start) <= 500 && rtw_is_do_late_resume(pwrpriv)))
 		) {
@@ -1431,7 +1442,7 @@ int _rtw_pwr_wakeup(_adapter *padapter, u32 ips_deffer_ms, const char *caller)
 	}
 
 	if(rf_off == pwrpriv->rf_pwrstate )
-	{
+	{		
 #ifdef CONFIG_USB_HCI
 #ifdef CONFIG_AUTOSUSPEND
 		 if(pwrpriv->brfoffbyhw==_TRUE)
@@ -1448,7 +1459,7 @@ int _rtw_pwr_wakeup(_adapter *padapter, u32 ips_deffer_ms, const char *caller)
 				DBG_8192C("======> autoresume fail.............\n");
 				ret = _FAIL;
 				goto exit;
-			}
+			}	
 		}
 		else
 #endif
@@ -1473,9 +1484,9 @@ int _rtw_pwr_wakeup(_adapter *padapter, u32 ips_deffer_ms, const char *caller)
 	){
 		DBG_8192C("%s: bDriverStopped=%d, bup=%d, hw_init_completed=%u\n"
 			, caller
-			, padapter->bDriverStopped
-			, padapter->bup
-			, padapter->hw_init_completed);
+		   	, padapter->bDriverStopped
+		   	, padapter->bup
+		   	, padapter->hw_init_completed);
 		ret= _FALSE;
 		goto exit;
 	}
@@ -1489,9 +1500,9 @@ int _rtw_pwr_wakeup(_adapter *padapter, u32 ips_deffer_ms, const char *caller)
 
 int rtw_pm_set_lps(_adapter *padapter, u8 mode)
 {
-	int	ret = 0;
+	int	ret = 0;	
 	struct pwrctrl_priv *pwrctrlpriv = &padapter->pwrctrlpriv;
-
+	
 	if ( mode < PS_MODE_NUM )
 	{
 		if(pwrctrlpriv->power_mgnt !=mode)
@@ -1524,7 +1535,7 @@ int rtw_pm_set_ips(_adapter *padapter, u8 mode)
 		rtw_ips_mode_req(pwrctrlpriv, mode);
 		DBG_871X("%s %s\n", __FUNCTION__, mode == IPS_NORMAL?"IPS_NORMAL":"IPS_LEVEL_2");
 		return 0;
-	}
+	} 
 	else if(mode ==IPS_NONE){
 		rtw_ips_mode_req(pwrctrlpriv, mode);
 		DBG_871X("%s %s\n", __FUNCTION__, "IPS_NONE");
@@ -1536,3 +1547,5 @@ int rtw_pm_set_ips(_adapter *padapter, u8 mode)
 	}
 	return 0;
 }
+
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_recv.c b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_recv.c
old mode 100644
new mode 100755
index 1b14673..d6e8599
--- a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_recv.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_recv.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -41,7 +41,12 @@
 #include <circ_buf.h>
 
 #ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
 void rtw_signal_stat_timer_hdl(RTW_TIMER_HDL_ARGS);
+#else
+void rtw_signal_stat_timer_hdl(struct timer_list *t);
+#endif
+
 #endif //CONFIG_NEW_SIGNAL_STAT_PROCESS
 
 
@@ -90,7 +95,7 @@ sint _rtw_init_recv_priv(struct recv_priv *precvpriv, _adapter *padapter)
 	rtw_os_recv_resource_init(precvpriv, padapter);
 
 	precvpriv->pallocated_frame_buf = rtw_zvmalloc(NR_RECVFRAME * sizeof(union recv_frame) + RXFRAME_ALIGN_SZ);
-
+	
 	if(precvpriv->pallocated_frame_buf==NULL){
 		res= _FAIL;
 		goto exit;
@@ -134,7 +139,11 @@ sint _rtw_init_recv_priv(struct recv_priv *precvpriv, _adapter *padapter)
 
 #ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
 	#ifdef PLATFORM_LINUX
-	_init_timer(&precvpriv->signal_stat_timer, padapter->pnetdev, RTW_TIMER_HDL_NAME(signal_stat), padapter);
+		#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+			_init_timer(&precvpriv->signal_stat_timer, padapter->pnetdev, RTW_TIMER_HDL_NAME(signal_stat), padapter);
+		#else
+			timer_setup(&precvpriv->signal_stat_timer, RTW_TIMER_HDL_NAME(signal_stat), 0);
+		#endif
 	#elif defined(PLATFORM_OS_CE) || defined(PLATFORM_WINDOWS)
 	_init_timer(&precvpriv->signal_stat_timer, padapter->hndis_adapter, RTW_TIMER_HDL_NAME(signal_stat), padapter);
 	#endif
@@ -157,7 +166,7 @@ sint _rtw_init_recv_priv(struct recv_priv *precvpriv, _adapter *padapter)
 void rtw_mfree_recv_priv_lock(struct recv_priv *precvpriv)
 {
 	_rtw_spinlock_free(&precvpriv->lock);
-#ifdef CONFIG_RECV_THREAD_MODE
+#ifdef CONFIG_RECV_THREAD_MODE	
 	_rtw_free_sema(&precvpriv->recv_sema);
 	_rtw_free_sema(&precvpriv->terminate_recvthread_sema);
 #endif
@@ -234,7 +243,7 @@ union recv_frame *rtw_alloc_recvframe (_queue *pfree_recv_queue)
 {
 	_irqL irqL;
 	union recv_frame  *precvframe;
-
+	
 	_enter_critical_bh(&pfree_recv_queue->lock, &irqL);
 
 	precvframe = _rtw_alloc_recvframe(pfree_recv_queue);
@@ -266,8 +275,8 @@ int rtw_free_recvframe(union recv_frame *precvframe, _queue *pfree_recv_queue)
 		padapter = padapter->pbuddy_adapter;//get primary_padapter
 		precvpriv = &padapter->recvpriv;
 		pfree_recv_queue = &precvpriv->free_recv_queue;
-		precvframe->u.hdr.adapter = padapter;
-	}
+		precvframe->u.hdr.adapter = padapter;		
+	}	
 #endif
 
 
@@ -339,7 +348,7 @@ sint rtw_enqueue_recvframe(union recv_frame *precvframe, _queue *queue)
 {
 	sint ret;
 	_irqL irqL;
-
+	
 	//_spinlock(&pfree_recv_queue->lock);
 	_enter_critical_bh(&queue->lock, &irqL);
 	ret = _rtw_enqueue_recvframe(precvframe, queue);
@@ -425,26 +434,26 @@ sint rtw_enqueue_recvbuf_to_head(struct recv_buf *precvbuf, _queue *queue)
 
 sint rtw_enqueue_recvbuf(struct recv_buf *precvbuf, _queue *queue)
 {
-	_irqL irqL;
+	_irqL irqL;	
 
 	_enter_critical(&queue->lock, &irqL);
 
 	rtw_list_delete(&precvbuf->list);
 
 	rtw_list_insert_tail(&precvbuf->list, get_list_head(queue));
-
+	
 	_exit_critical(&queue->lock, &irqL);
 
 
 	return _SUCCESS;
-
+	
 }
 
 struct recv_buf *rtw_dequeue_recvbuf (_queue *queue)
 {
 	_irqL irqL;
 	struct recv_buf *precvbuf;
-	_list	*plist, *phead;
+	_list	*plist, *phead;	
 
 	_enter_critical(&queue->lock, &irqL);
 
@@ -461,7 +470,7 @@ struct recv_buf *rtw_dequeue_recvbuf (_queue *queue)
 		precvbuf = LIST_CONTAINOR(plist, struct recv_buf, list);
 
 		rtw_list_delete(&precvbuf->list);
-
+		
 	}
 
 	_exit_critical(&queue->lock, &irqL);
@@ -506,11 +515,11 @@ sint recvframe_chkmic(_adapter *adapter,  union recv_frame *precvframe){
 				//iv = precvframe->u.hdr.rx_data+prxattrib->hdrlen;
 				//rxdata_key_idx =( ((iv[3])>>6)&0x3) ;
 				mickey=&psecuritypriv->dot118021XGrprxmickey[prxattrib->key_index].skey[0];
-
+				
 				RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("\n recvframe_chkmic: bcmc key \n"));
 				//DBG_871X("\n recvframe_chkmic: bcmc key psecuritypriv->dot118021XGrpKeyid(%d),pmlmeinfo->key_index(%d) ,recv key_id(%d)\n",
 				//								psecuritypriv->dot118021XGrpKeyid,pmlmeinfo->key_index,rxdata_key_idx);
-
+				
 				if(psecuritypriv->binstallGrpkey==_FALSE)
 				{
 					res=_FAIL;
@@ -575,7 +584,7 @@ sint recvframe_chkmic(_adapter *adapter,  union recv_frame *precvframe){
 				// cannot compare with psecuritypriv->dot118021XGrpKeyid also cause timing issue
 				if((IS_MCAST(prxattrib->ra)==_TRUE)  && (prxattrib->key_index != pmlmeinfo->key_index ))
 					brpt_micerror = _FALSE;
-
+				
 				if(brpt_micerror == _TRUE)
 				{
 					rtw_handle_tkip_mic_err(adapter,(u8)IS_MCAST(prxattrib->ra));
@@ -639,13 +648,13 @@ union recv_frame * decryptor(_adapter *padapter,union recv_frame *precv_frame)
 				case _WEP104_:
 					prxattrib->key_index = psecuritypriv->dot11PrivacyKeyIndex;
 					break;
-				case _TKIP_:
-				case _AES_:
+				case _TKIP_:			
+				case _AES_:						
 				default:
 					prxattrib->key_index = psecuritypriv->dot118021XGrpKeyid;
 					break;
-			}
-		}
+			}	
+		}			
 	}
 
 	if((prxattrib->encrypt>0) && ((prxattrib->bdecrypted==0) ||(psecuritypriv->sw_decrypt==_TRUE)))
@@ -653,7 +662,7 @@ union recv_frame * decryptor(_adapter *padapter,union recv_frame *precv_frame)
 
 #ifdef CONFIG_CONCURRENT_MODE
 		if(!IS_MCAST(prxattrib->ra))//bc/mc packets use sw decryption for concurrent mode
-#endif
+#endif			
 		psecuritypriv->hw_decrypted=_FALSE;
 
 		#ifdef DBG_RX_DECRYPTOR
@@ -710,15 +719,15 @@ union recv_frame * decryptor(_adapter *padapter,union recv_frame *precv_frame)
 		, prxattrib->bdecrypted ,prxattrib->encrypt, psecuritypriv->hw_decrypted);
 		#endif
 	}
-
+	
 	if(res == _FAIL)
 	{
-		rtw_free_recvframe(return_packet,&padapter->recvpriv.free_recv_queue);
+		rtw_free_recvframe(return_packet,&padapter->recvpriv.free_recv_queue);			
 		return_packet = NULL;
-
+		
 	}
 	//recvframe_chkmic(adapter, precv_frame);   //move to recvframme_defrag function
-
+	
 _func_exit_;
 
 	return return_packet;
@@ -735,7 +744,7 @@ union recv_frame * portctrl(_adapter *adapter,union recv_frame * precv_frame)
 	struct sta_priv *pstapriv ;
 	union recv_frame * prtnframe;
 	u16	ether_type=0;
-	u16  eapol_type = 0x888e;//for Funia BD's WPA issue
+	u16  eapol_type = 0x888e;//for Funia BD's WPA issue  
 	struct rx_pkt_attrib *pattrib = & precv_frame->u.hdr.attrib;
 
 _func_enter_;
@@ -877,7 +886,7 @@ void process_pwrbit_data(_adapter *padapter, union recv_frame *precv_frame)
 			if(psta->state & WIFI_SLEEP_STATE)
 			{
 				//psta->state ^= WIFI_SLEEP_STATE;
-				//pstapriv->sta_dz_bitmap &= ~BIT(psta->aid);
+				//pstapriv->sta_dz_bitmap &= ~BIT(psta->aid);				
 
 				wakeup_sta_to_xmit(padapter, psta);
 
@@ -893,13 +902,13 @@ void process_pwrbit_data(_adapter *padapter, union recv_frame *precv_frame)
 void process_wmmps_data(_adapter *padapter, union recv_frame *precv_frame);
 void process_wmmps_data(_adapter *padapter, union recv_frame *precv_frame)
 {
-#ifdef CONFIG_AP_MODE
+#ifdef CONFIG_AP_MODE		
 	struct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;
 	struct sta_priv *pstapriv = &padapter->stapriv;
 	struct sta_info *psta=NULL;
 
 	psta = rtw_get_stainfo(pstapriv, pattrib->src);
-
+	
 	if(!psta) return;
 
 #ifdef CONFIG_TDLS
@@ -912,15 +921,15 @@ void process_wmmps_data(_adapter *padapter, union recv_frame *precv_frame)
 
 	if(!(psta->qos_info&0xf))
 		return;
-
+		
 #ifdef CONFIG_TDLS
 	}
-#endif //CONFIG_TDLS
+#endif //CONFIG_TDLS	
 
 	if(psta->state&WIFI_SLEEP_STATE)
 	{
-		u8 wmmps_ac=0;
-
+		u8 wmmps_ac=0;	
+		
 		switch(pattrib->priority)
 		{
 			case 1:
@@ -939,7 +948,7 @@ void process_wmmps_data(_adapter *padapter, union recv_frame *precv_frame)
 			case 3:
 			default:
 				wmmps_ac = psta->uapsd_be&BIT(1);
-				break;
+				break;	
 		}
 
 		if(wmmps_ac)
@@ -955,11 +964,11 @@ void process_wmmps_data(_adapter *padapter, union recv_frame *precv_frame)
 				issue_qos_nulldata(padapter, psta->hwaddr, (u16)pattrib->priority, 0, 0);
 			}
 		}
-
+				
 	}
 
-
-#endif
+	
+#endif	
 
 }
 
@@ -976,11 +985,11 @@ sint OnTDLS(_adapter *adapter, union recv_frame *precv_frame)
 	struct tdls_info *ptdlsinfo = &(adapter->tdlsinfo);
 
 	//point to action field
-	paction+=pattrib->hdrlen
-			+ pattrib->iv_len
-			+ SNAP_SIZE
-			+ ETH_TYPE_LEN
-			+ PAYLOAD_TYPE_LEN
+	paction+=pattrib->hdrlen 
+			+ pattrib->iv_len 
+			+ SNAP_SIZE 
+			+ ETH_TYPE_LEN 
+			+ PAYLOAD_TYPE_LEN 
 			+ category_field;
 
 	if(ptdlsinfo->enable == 0)
@@ -990,14 +999,14 @@ sint OnTDLS(_adapter *adapter, union recv_frame *precv_frame)
 		ret = _FAIL;
 		return ret;
 	}
-
+	
 	switch(*paction){
 		case TDLS_SETUP_REQUEST:
 			DBG_871X("recv tdls setup request frame\n");
 			ret=On_TDLS_Setup_Req(adapter, precv_frame);
 			break;
 		case TDLS_SETUP_RESPONSE:
-			DBG_871X("recv tdls setup response frame\n");
+			DBG_871X("recv tdls setup response frame\n");			
 			ret=On_TDLS_Setup_Rsp(adapter, precv_frame);
 			break;
 		case TDLS_SETUP_CONFIRM:
@@ -1024,7 +1033,7 @@ sint OnTDLS(_adapter *adapter, union recv_frame *precv_frame)
 			DBG_871X("recv tdls channel switch response frame\n");
 			ret=On_TDLS_Ch_Switch_Rsp(adapter, precv_frame);
 			break;
-#ifdef CONFIG_WFD
+#ifdef CONFIG_WFD			
 		case 0x50:	//First byte of WFA OUI
 			if( _rtw_memcmp(WFA_OUI, (paction), 3) )
 			{
@@ -1052,7 +1061,7 @@ sint OnTDLS(_adapter *adapter, union recv_frame *precv_frame)
 
 exit:
 	return ret;
-
+	
 }
 #endif //CONFIG_TDLS
 
@@ -1110,7 +1119,7 @@ sint sta2sta_data_frame(
 	u8 * sta_addr = NULL;
 	sint bmcast = IS_MCAST(pattrib->dst);
 
-#ifdef CONFIG_TDLS
+#ifdef CONFIG_TDLS	
 	struct tdls_info *ptdlsinfo = &adapter->tdlsinfo;
 	struct sta_info *ptdls_sta=NULL;
 	u8 *psnap_type=ptr+pattrib->hdrlen + pattrib->iv_len+SNAP_SIZE;
@@ -1220,12 +1229,12 @@ sint sta2sta_data_frame(
 					ret= OnTDLS(adapter, precv_frame);
 					goto exit;
 				}
-
+				
 			}
 
 			sta_addr = pattrib->src;
-
-		}
+			
+		}		
 		else
 #endif //CONFIG_TDLS
 		{
@@ -1327,7 +1336,7 @@ sint ap2sta_data_frame(
 _func_enter_;
 
 	if ((check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)
-		&& (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE
+		&& (check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE 
 			|| check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == _TRUE	)
 		)
 	{
@@ -1341,7 +1350,7 @@ sint ap2sta_data_frame(
 				pattrib->src[3], pattrib->src[4], pattrib->src[5],
 				*(myhwaddr), *(myhwaddr+1), *(myhwaddr+2),
 				*(myhwaddr+3), *(myhwaddr+4), *(myhwaddr+5));
-			#endif
+			#endif			
 			ret= _FAIL;
 			goto exit;
 		}
@@ -1447,11 +1456,11 @@ sint ap2sta_data_frame(
 			if (*psta == NULL)
 			{
 				DBG_871X("issue_deauth to the ap=" MAC_FMT " for the reason(7)\n", MAC_ARG(pattrib->bssid));
-
+		
 				issue_deauth(adapter, pattrib->bssid, WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA);
 			}
-		}
-
+		}	
+	
 		ret = _FAIL;
 		#ifdef DBG_RX_DROP_FRAME
 		DBG_871X("DBG_RX_DROP_FRAME %s fw_state:0x%x\n", __FUNCTION__, get_fwstate(pmlmepriv));
@@ -1479,7 +1488,7 @@ sint sta2ap_data_frame(
 	struct rx_pkt_attrib *pattrib = & precv_frame->u.hdr.attrib;
 	struct	sta_priv 		*pstapriv = &adapter->stapriv;
 	struct	mlme_priv	*pmlmepriv = &adapter->mlmepriv;
-	unsigned char *mybssid  = get_bssid(pmlmepriv);
+	unsigned char *mybssid  = get_bssid(pmlmepriv);	
 	sint ret=_SUCCESS;
 
 _func_enter_;
@@ -1546,11 +1555,11 @@ sint validate_recv_ctrl_frame(_adapter *padapter, union recv_frame *precv_frame)
 	struct sta_priv *pstapriv = &padapter->stapriv;
 	u8 *pframe = precv_frame->u.hdr.rx_data;
 	//uint len = precv_frame->u.hdr.len;
-
+		
 	//DBG_871X("+validate_recv_ctrl_frame\n");
 
 	if (GetFrameType(pframe) != WIFI_CTRL_TYPE)
-	{
+	{		
 		return _FAIL;
 	}
 
@@ -1564,12 +1573,12 @@ sint validate_recv_ctrl_frame(_adapter *padapter, union recv_frame *precv_frame)
 	if(GetFrameSubType(pframe) == WIFI_PSPOLL)
 	{
 		u16 aid;
-		u8 wmmps_ac=0;
+		u8 wmmps_ac=0;	
 		struct sta_info *psta=NULL;
-
+	
 		aid = GetAid(pframe);
 		psta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));
-
+		
 		if((psta==NULL) || (psta->aid!=aid))
 		{
 			return _FAIL;
@@ -1596,26 +1605,26 @@ sint validate_recv_ctrl_frame(_adapter *padapter, union recv_frame *precv_frame)
 			case 3:
 			default:
 				wmmps_ac = psta->uapsd_be&BIT(0);
-				break;
+				break;	
 		}
 
 		if(wmmps_ac)
 			return _FAIL;
 
 		if(psta->state & WIFI_STA_ALIVE_CHK_STATE)
-		{
+		{					
 			DBG_871X("%s alive check-rx ps-poll\n", __func__);
 			psta->expire_to = pstapriv->expire_to;
 			psta->state ^= WIFI_STA_ALIVE_CHK_STATE;
-		}
+		}	
 
 		if((psta->state&WIFI_SLEEP_STATE) && (pstapriv->sta_dz_bitmap&BIT(psta->aid)))
 		{
-			_irqL irqL;
+			_irqL irqL;	 
 			_list	*xmitframe_plist, *xmitframe_phead;
 			struct xmit_frame *pxmitframe=NULL;
 			struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
-
+		
 			//_enter_critical_bh(&psta->sleep_q.lock, &irqL);
 			_enter_critical_bh(&pxmitpriv->lock, &irqL);
 
@@ -1623,7 +1632,7 @@ sint validate_recv_ctrl_frame(_adapter *padapter, union recv_frame *precv_frame)
 			xmitframe_plist = get_next(xmitframe_phead);
 
 			if ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == _FALSE)
-			{
+			{			
 				pxmitframe = LIST_CONTAINOR(xmitframe_plist, struct xmit_frame, list);
 
 				xmitframe_plist = get_next(xmitframe_plist);
@@ -1642,12 +1651,12 @@ sint validate_recv_ctrl_frame(_adapter *padapter, union recv_frame *precv_frame)
 	                        //DBG_871X("handling ps-poll, q_len=%d, tim=%x\n", psta->sleepq_len, pstapriv->tim_bitmap);
 
 #if 0
-				_exit_critical_bh(&psta->sleep_q.lock, &irqL);
+				_exit_critical_bh(&psta->sleep_q.lock, &irqL);		
 				if(rtw_hal_xmit(padapter, pxmitframe) == _TRUE)
-				{
+				{		
 					rtw_os_xmit_complete(padapter, pxmitframe);
 				}
-				_enter_critical_bh(&psta->sleep_q.lock, &irqL);
+				_enter_critical_bh(&psta->sleep_q.lock, &irqL);	
 #endif
 				rtw_hal_xmitframe_enqueue(padapter, pxmitframe);
 
@@ -1658,19 +1667,19 @@ sint validate_recv_ctrl_frame(_adapter *padapter, union recv_frame *precv_frame)
 					//DBG_871X("after handling ps-poll, tim=%x\n", pstapriv->tim_bitmap);
 
 					//upate BCN for TIM IE
-					//update_BCNTIM(padapter);
+					//update_BCNTIM(padapter);		
 					update_beacon(padapter, _TIM_IE_, NULL, _FALSE);
 				}
-
+				
 				//_exit_critical_bh(&psta->sleep_q.lock, &irqL);
 				_exit_critical_bh(&pxmitpriv->lock, &irqL);
-
+				
 			}
 			else
 			{
 				//_exit_critical_bh(&psta->sleep_q.lock, &irqL);
 				_exit_critical_bh(&pxmitpriv->lock, &irqL);
-
+			
 				//DBG_871X("no buffered packets to xmit\n");
 				if(pstapriv->tim_bitmap&BIT(psta->aid))
 				{
@@ -1684,22 +1693,22 @@ sint validate_recv_ctrl_frame(_adapter *padapter, union recv_frame *precv_frame)
 					else
 					{
 						DBG_871X("error!psta->sleepq_len=%d\n", psta->sleepq_len);
-						psta->sleepq_len=0;
+						psta->sleepq_len=0;						
 					}
-
-					pstapriv->tim_bitmap &= ~BIT(psta->aid);
+				
+					pstapriv->tim_bitmap &= ~BIT(psta->aid);					
 
 					//upate BCN for TIM IE
 					//update_BCNTIM(padapter);
 					update_beacon(padapter, _TIM_IE_, NULL, _FALSE);
 				}
-
-			}
-
+				
+			}				
+			
 		}
-
+		
 	}
-
+	
 #endif
 
 	return _FAIL;
@@ -1750,7 +1759,7 @@ sint validate_recv_mgnt_frame(PADAPTER padapter, union recv_frame *precv_frame)
 				else if (is_broadcast_mac_addr(GetAddr1Ptr(precv_frame->u.hdr.rx_data))
 					|| is_multicast_mac_addr(GetAddr1Ptr(precv_frame->u.hdr.rx_data)))
 					psta->sta_stats.rx_probersp_bm_pkts++;
-				else
+				else 
 					psta->sta_stats.rx_probersp_uo_pkts++;
 			}
 		}
@@ -1762,7 +1771,7 @@ sint validate_recv_mgnt_frame(PADAPTER padapter, union recv_frame *precv_frame)
 		struct rx_pkt_attrib * pattrib=&precv_frame->u.hdr.attrib;
 		 struct recv_stat* prxstat=( struct recv_stat * )  precv_frame->u.hdr.rx_head ;
 		 u8 * pda,*psa,*pbssid,*ptr;
-		 ptr=precv_frame->u.hdr.rx_data;
+		 ptr=precv_frame->u.hdr.rx_data; 
 		pda = get_da(ptr);
 		psa = get_sa(ptr);
 		pbssid = get_hdr_bssid(ptr);
@@ -1799,7 +1808,7 @@ sint validate_recv_mgnt_frame(PADAPTER padapter, union recv_frame *precv_frame)
 		default:
 			break;
 
-		}
+		}	
 			pattrib->priority=0;
 			pattrib->hdrlen = pattrib->to_fr_ds==3 ? 30 : 24;
 
@@ -1820,7 +1829,7 @@ sint validate_recv_data_frame(_adapter *adapter, union recv_frame *precv_frame)
 	struct sta_info *psta = NULL;
 	u8 *ptr = precv_frame->u.hdr.rx_data;
 	struct rx_pkt_attrib	*pattrib = & precv_frame->u.hdr.attrib;
-	struct security_priv	*psecuritypriv = &adapter->securitypriv;
+	struct security_priv	*psecuritypriv = &adapter->securitypriv;	
 	sint ret = _SUCCESS;
 #ifdef CONFIG_TDLS
 	struct tdls_info *ptdlsinfo = &adapter->tdlsinfo;
@@ -1891,11 +1900,11 @@ sint validate_recv_data_frame(_adapter *adapter, union recv_frame *precv_frame)
 		ret= _FAIL;
 		goto exit;
 	}
-
+	
 	//psta->rssi = prxcmd->rssi;
 	//psta->signal_quality= prxcmd->sq;
 	precv_frame->u.hdr.psta = psta;
-
+		
 
 	pattrib->amsdu=0;
 	pattrib->ack_policy = 0;
@@ -1981,22 +1990,22 @@ static sint validate_80211w_mgmt(_adapter *adapter, union recv_frame *precv_fram
 	u8 *ptr = precv_frame->u.hdr.rx_data;
 	u8 type;
 	u8 subtype;
-
+			
 	type =  GetFrameType(ptr);
 	subtype = GetFrameSubType(ptr); //bit(7)~bit(2)
-
+			
 	//only support station mode
-	if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) && check_fwstate(pmlmepriv, _FW_LINKED)
+	if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) && check_fwstate(pmlmepriv, _FW_LINKED) 
 		&& adapter->securitypriv.binstallBIPkey == _TRUE)
 	{
 		//unicast management frame decrypt
-		if(pattrib->privacy && !(IS_MCAST(GetAddr1Ptr(ptr))) &&
+		if(pattrib->privacy && !(IS_MCAST(GetAddr1Ptr(ptr))) && 
 			(subtype == WIFI_DEAUTH || subtype == WIFI_DISASSOC || subtype == WIFI_ACTION))
 		{
 			u8 *ppp, *mgmt_DATA;
 			u32 data_len=0;
 			ppp = GetAddr2Ptr(ptr);
-
+			
 			pattrib->bdecrypted = 0;
 			pattrib->encrypt = _AES_;
 			pattrib->hdrlen = sizeof(struct rtw_ieee80211_hdr_3addr);
@@ -2020,7 +2029,7 @@ static sint validate_80211w_mgmt(_adapter *adapter, union recv_frame *precv_fram
 					printk(" %02x ", ptr[pp]);
 				printk("\n");
 			}*/
-
+			
 			precv_frame = decryptor(adapter, precv_frame);
 			//save actual management data frame body
 			_rtw_memcpy(mgmt_DATA, ptr+pattrib->hdrlen+pattrib->iv_len, data_len);
@@ -2087,10 +2096,10 @@ static sint validate_80211w_mgmt(_adapter *adapter, union recv_frame *precv_fram
 		}
 	}
 	return _SUCCESS;
-
+			
 validate_80211w_fail:
 	return _FAIL;
-
+	
 }
 #endif //CONFIG_IEEE80211W
 
@@ -2174,7 +2183,7 @@ sint validate_recv_frame(_adapter *adapter, union recv_frame *precv_frame)
 if(pHalData->bDumpRxPkt ==1){
 	int i;
 	DBG_871X("############################# \n");
-
+	
 	for(i=0; i<64;i=i+8)
 		DBG_871X("%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:\n", *(ptr+i),
 		*(ptr+i+1), *(ptr+i+2) ,*(ptr+i+3) ,*(ptr+i+4),*(ptr+i+5), *(ptr+i+6), *(ptr+i+7));
@@ -2195,7 +2204,7 @@ else if(pHalData->bDumpRxPkt ==3){
 	if(type== WIFI_DATA_TYPE){
 		int i;
 		DBG_871X("############################# \n");
-
+		
 		for(i=0; i<64;i=i+8)
 			DBG_871X("%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:\n", *(ptr+i),
 			*(ptr+i+1), *(ptr+i+2) ,*(ptr+i+3) ,*(ptr+i+4),*(ptr+i+5), *(ptr+i+6), *(ptr+i+7));
@@ -2214,7 +2223,7 @@ else if(pHalData->bDumpRxPkt ==3){
 				break;
 			}
 #endif //CONFIG_IEEE80211W
-
+			
 			retval = validate_recv_mgnt_frame(adapter, precv_frame);
 			if (retval == _FAIL)
 			{
@@ -2269,7 +2278,7 @@ sint wlanhdr_to_ethhdr ( union recv_frame *precvframe)
 	u8	bsnaphdr;
 	u8	*psnap_type;
 	struct ieee80211_snap_hdr	*psnap;
-
+	
 	sint ret=_SUCCESS;
 	_adapter			*adapter =precvframe->u.hdr.adapter;
 	struct mlme_priv	*pmlmepriv = &adapter->mlmepriv;
@@ -2280,7 +2289,7 @@ sint wlanhdr_to_ethhdr ( union recv_frame *precvframe)
 _func_enter_;
 
 	if(pattrib->encrypt){
-		recvframe_pull_tail(precvframe, pattrib->icv_len);
+		recvframe_pull_tail(precvframe, pattrib->icv_len);	
 	}
 
 	psnap=(struct ieee80211_snap_hdr	*)(ptr+pattrib->hdrlen + pattrib->iv_len);
@@ -2288,7 +2297,7 @@ sint wlanhdr_to_ethhdr ( union recv_frame *precvframe)
 	/* convert hdr + possible LLC headers into Ethernet header */
 	//eth_type = (psnap_type[0] << 8) | psnap_type[1];
 	if((_rtw_memcmp(psnap, rtw_rfc1042_header, SNAP_SIZE) &&
-		(_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_IPX, 2) == _FALSE) &&
+		(_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_IPX, 2) == _FALSE) && 
 		(_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_APPLETALK_AARP, 2)==_FALSE) )||
 		//eth_type != ETH_P_AARP && eth_type != ETH_P_IPX) ||
 		 _rtw_memcmp(psnap, rtw_bridge_tunnel_header, SNAP_SIZE)){
@@ -2309,9 +2318,9 @@ sint wlanhdr_to_ethhdr ( union recv_frame *precvframe)
 	eth_type= ntohs((unsigned short )eth_type); //pattrib->ether_type
 	pattrib->eth_type = eth_type;
 
-	if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE))
+	if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == _TRUE))	   	
 	{
-		ptr += rmv_len ;
+		ptr += rmv_len ;	
 		*ptr = 0x87;
 		*(ptr+1) = 0x12;
 
@@ -2333,7 +2342,7 @@ sint wlanhdr_to_ethhdr ( union recv_frame *precvframe)
 		_rtw_memcpy(ptr+12, &len, 2);
 	}
 
-_func_exit_;
+_func_exit_;	
 	return ret;
 
 }
@@ -2363,7 +2372,7 @@ sint wlanhdr_to_ethhdr ( union recv_frame *precvframe)
 	if (psnap->dsap==0xaa && psnap->ssap==0xaa && psnap->ctrl==0x03)
 	{
 		if (_rtw_memcmp(psnap->oui, oui_rfc1042, WLAN_IEEE_OUI_LEN))
-			bsnaphdr=_TRUE;//wlan_pkt_format = WLAN_PKT_FORMAT_SNAP_RFC1042;
+			bsnaphdr=_TRUE;//wlan_pkt_format = WLAN_PKT_FORMAT_SNAP_RFC1042;	
 		else if (_rtw_memcmp(psnap->oui, SNAP_HDR_APPLETALK_DDP, WLAN_IEEE_OUI_LEN) &&
 			_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_APPLETALK_DDP, 2) )
 			bsnaphdr=_TRUE;	//wlan_pkt_format = WLAN_PKT_FORMAT_APPLETALK;
@@ -2752,9 +2761,9 @@ union recv_frame* recvframe_chk_defrag(PADAPTER padapter, union recv_frame *prec
 int amsdu_to_msdu(_adapter *padapter, union recv_frame *prframe);
 int amsdu_to_msdu(_adapter *padapter, union recv_frame *prframe)
 {
-#if defined (PLATFORM_LINUX) || defined (PLATFORM_FREEBSD)  //for amsdu TP improvement,Creator: Thomas
+#if defined (PLATFORM_LINUX) || defined (PLATFORM_FREEBSD)  //for amsdu TP improvement,Creator: Thomas 
 	int	a_len, padding_len;
-	u16	eth_type, nSubframe_Length;
+	u16	eth_type, nSubframe_Length;	
 	u8	nr_subframes, i;
 	unsigned char *pdata;
 	struct rx_pkt_attrib *pattrib;
@@ -2766,7 +2775,7 @@ int amsdu_to_msdu(_adapter *padapter, union recv_frame *prframe)
 	_queue *pfree_recv_queue = &(precvpriv->free_recv_queue);
 	int	ret = _SUCCESS;
 #ifdef PLATFORM_FREEBSD
-	struct mbuf *sub_m=NULL, *subframes[MAX_SUBFRAME_COUNT];
+	struct mbuf *sub_m=NULL, *subframes[MAX_SUBFRAME_COUNT];	
 	u8 *ptr,offset;
 #endif //PLATFORM_FREEBSD
 	nr_subframes = 0;
@@ -2774,7 +2783,7 @@ int amsdu_to_msdu(_adapter *padapter, union recv_frame *prframe)
 	pattrib = &prframe->u.hdr.attrib;
 
 	recvframe_pull(prframe, prframe->u.hdr.attrib.hdrlen);
-
+	
 	if(prframe->u.hdr.attrib.iv_len >0)
 	{
 		recvframe_pull(prframe, prframe->u.hdr.attrib.iv_len);
@@ -2785,7 +2794,7 @@ int amsdu_to_msdu(_adapter *padapter, union recv_frame *prframe)
 	pdata = prframe->u.hdr.rx_data;
 
 	while(a_len > ETH_HLEN) {
-
+		
 		/* Offset 12 denote 2 mac address */
 #ifdef ENDIAN_FREE
 		//nSubframe_Length = ntohs(*((u16*)(pdata + 12)));
@@ -2836,13 +2845,13 @@ int amsdu_to_msdu(_adapter *padapter, union recv_frame *prframe)
 #else   // PLATFORM_FREEBSD
 
 		//PLATFORM_FREEBSD
-		//Allocate a mbuff,
+		//Allocate a mbuff,  
 		//sub_m =m_devget(pdata, nSubframe_Length+12, 12, padapter->pifp,NULL);
 		sub_m =m_devget(pdata, nSubframe_Length+ETH_HLEN, ETHER_ALIGN, padapter->pifp,NULL);
 
 		pdata += ETH_HLEN;
 		a_len -= ETH_HLEN;
-#endif	// PLATFORM_FREEBSD
+#endif	// PLATFORM_FREEBSD	
 
 #ifndef PLATFORM_FREEBSD
 		//sub_skb->dev = padapter->pnetdev;
@@ -2880,7 +2889,7 @@ int amsdu_to_msdu(_adapter *padapter, union recv_frame *prframe)
 #ifdef ENDIAN_FREE
 		//eth_type = ntohs(*(u16*)&sub_skb->data[6]);
 		eth_type = RTW_GET_BE16(&sub_skb->data[6]);
-#else // ENDIAN_FREE
+#else // ENDIAN_FREE		
 		eth_type = (sub_skb->data[6] << 8) | sub_skb->data[7];
 #endif // ENDIAN_FREE
 		if (sub_skb->len >= 8 &&
@@ -2925,14 +2934,14 @@ int amsdu_to_msdu(_adapter *padapter, union recv_frame *prframe)
 					//priv->ext_stats.rx_data_drops++;
 					//DEBUG_ERR("RX DROP: nat25_handle_frame fail!\n");
 					//return FAIL;
-
+					
 #if 1
 					// bypass this frame to upper layer!!
 #else
 					rtw_skb_free(sub_skb);
 					continue;
 #endif
-				}
+				}							
 			}
 #endif	// CONFIG_BR_EXT
 
@@ -3010,9 +3019,9 @@ int amsdu_to_msdu(_adapter *padapter, union recv_frame *prframe)
 				taskqueue_enqueue(taskqueue_thread, &precvpriv->rx_indicate_tasklet);
 			}
 #else	// CONFIG_RX_INDICATE_QUEUE
-			(*padapter->pifp->if_input)(padapter->pifp, sub_m);
+			(*padapter->pifp->if_input)(padapter->pifp, sub_m);	
 #endif	// CONFIG_RX_INDICATE_QUEUE
-		}
+		}		
 
 #endif //PLATFORM_FREEBSD
 	}
@@ -3021,9 +3030,9 @@ int amsdu_to_msdu(_adapter *padapter, union recv_frame *prframe)
 
 	prframe->u.hdr.len=0;
 	rtw_free_recvframe(prframe, pfree_recv_queue);//free this recv_frame
-
+	
 	return ret;
-#else  // || defined (PLATFORM_LINUX) || defined (PLATFORM_FREEBSD)
+#else  // || defined (PLATFORM_LINUX) || defined (PLATFORM_FREEBSD) 
 #ifdef PLATFORM_WINDOWS
 	_irqL irql;
 #endif //PLATFORM_WINDOWS
@@ -3258,7 +3267,7 @@ int amsdu_to_msdu(_adapter *padapter, union recv_frame *prframe)
 				{
 #ifdef PLATFORM_LINUX
 						_pkt *pskb = pnrframe->u.hdr.pkt;
-#endif //PLATFORM_LINUX
+#endif //PLATFORM_LINUX						
 						_rtw_init_listhead(&pnrframe_new->u.hdr.list);
 
 						pnrframe_new->u.hdr.len=0;
@@ -3308,7 +3317,7 @@ int amsdu_to_msdu(_adapter *padapter, union recv_frame *prframe)
 		}
 
 
-#endif // end defined (PLATFORM_LINUX) || defined (PLATFORM_FREEBSD)
+#endif // end defined (PLATFORM_LINUX) || defined (PLATFORM_FREEBSD) 
 
 	}while(pnrframe);
 
@@ -3345,7 +3354,7 @@ int check_indicate_seq(struct recv_reorder_ctrl *preorder_ctrl, u16 seq_num)
 		//DbgPrint("CheckRxTsIndicateSeq(): Packet Drop! IndicateSeq: %d, NewSeq: %d\n", precvpriv->indicate_seq, seq_num);
 
 		#ifdef DBG_RX_DROP_FRAME
-		DBG_871X("%s IndicateSeq: %d > NewSeq: %d\n", __FUNCTION__,
+		DBG_871X("%s IndicateSeq: %d > NewSeq: %d\n", __FUNCTION__, 
 			preorder_ctrl->indicate_seq, seq_num);
 		#endif
 
@@ -3486,10 +3495,10 @@ int recv_indicatepkts_in_order(_adapter *padapter, struct recv_reorder_ctrl *pre
 			//_rtw_spinunlock_ex(&ppending_recvframe_queue->lock);
 			return _TRUE;
 		}
-
+	
 		 prframe = LIST_CONTAINOR(plist, union recv_frame, u);
-	        pattrib = &prframe->u.hdr.attrib;
-		preorder_ctrl->indicate_seq = pattrib->seq_num;
+	        pattrib = &prframe->u.hdr.attrib;	
+		preorder_ctrl->indicate_seq = pattrib->seq_num;		
 		#ifdef DBG_RX_SEQ
 		DBG_871X("DBG_RX_SEQ %s:%d IndicateSeq: %d, NewSeq: %d\n", __FUNCTION__, __LINE__,
 			preorder_ctrl->indicate_seq, pattrib->seq_num);
@@ -3500,7 +3509,7 @@ int recv_indicatepkts_in_order(_adapter *padapter, struct recv_reorder_ctrl *pre
 	// Check if there is any packet need indicate.
 	while(!rtw_is_list_empty(phead))
 	{
-
+	
 		prframe = LIST_CONTAINOR(plist, union recv_frame, u);
 		pattrib = &prframe->u.hdr.attrib;
 
@@ -3562,9 +3571,9 @@ int recv_indicatepkts_in_order(_adapter *padapter, struct recv_reorder_ctrl *pre
 				if ((padapter->bDriverStopped == _FALSE) &&
 				    (padapter->bSurpriseRemoved == _FALSE))
 				{
-
+					
 					rtw_recv_indicatepkt(padapter, prframe);//indicate this recv_frame
-
+										
 				}
 			}
 			else if(pattrib->amsdu==1)
@@ -3646,34 +3655,34 @@ int recv_indicatepkt_reorder(_adapter *padapter, union recv_frame *prframe)
 				return _SUCCESS;
 
 			}
-
+			
 			#ifdef DBG_RX_DROP_FRAME
 			DBG_871X("DBG_RX_DROP_FRAME %s pattrib->qos !=1\n", __FUNCTION__);
 			#endif
-
+			
 			return _FAIL;
-
+		
 		}
 
 		if (preorder_ctrl->enable == _FALSE)
 		{
-			//indicate this recv_frame
+			//indicate this recv_frame			
 			preorder_ctrl->indicate_seq = pattrib->seq_num;
 			#ifdef DBG_RX_SEQ
 			DBG_871X("DBG_RX_SEQ %s:%d IndicateSeq: %d, NewSeq: %d\n", __FUNCTION__, __LINE__,
 				preorder_ctrl->indicate_seq, pattrib->seq_num);
 			#endif
-
-			rtw_recv_indicatepkt(padapter, prframe);
-
+			
+			rtw_recv_indicatepkt(padapter, prframe);		
+			
 			preorder_ctrl->indicate_seq = (preorder_ctrl->indicate_seq + 1)%4096;
 			#ifdef DBG_RX_SEQ
 			DBG_871X("DBG_RX_SEQ %s:%d IndicateSeq: %d, NewSeq: %d\n", __FUNCTION__, __LINE__,
 				preorder_ctrl->indicate_seq, pattrib->seq_num);
 			#endif
-
-			return _SUCCESS;
-		}
+			
+			return _SUCCESS;	
+		}			
 
 #ifndef CONFIG_RECV_REORDERING_CTRL
 		//indicate this recv_frame
@@ -3732,11 +3741,11 @@ int recv_indicatepkt_reorder(_adapter *padapter, union recv_frame *prframe)
 		#ifdef DBG_RX_DROP_FRAME
 		DBG_871X("DBG_RX_DROP_FRAME %s check_indicate_seq fail\n", __FUNCTION__);
 		#endif
-#if 0
+#if 0		
 		rtw_recv_indicatepkt(padapter, prframe);
 
 		_exit_critical_bh(&ppending_recvframe_queue->lock, &irql);
-
+		
 		goto _success_exit;
 #else
 		goto _err_exit;
@@ -3811,7 +3820,7 @@ void rtw_reordering_ctrl_timeout_handler(void *pcontext)
 
 	if(recv_indicatepkts_in_order(padapter, preorder_ctrl, _TRUE)==_TRUE)
 	{
-		_set_timer(&preorder_ctrl->reordering_ctrl_timer, REORDER_WAIT_TIME);
+		_set_timer(&preorder_ctrl->reordering_ctrl_timer, REORDER_WAIT_TIME);		
 	}
 
 	_exit_critical_bh(&ppending_recvframe_queue->lock, &irql);
@@ -3835,7 +3844,7 @@ int process_recv_indicatepkts(_adapter *padapter, union recv_frame *prframe)
 
 #ifdef CONFIG_TDLS
 	if( (phtpriv->ht_option==_TRUE) ||
-		((psta->tdls_sta_state & TDLS_LINKED_STATE) &&
+		((psta->tdls_sta_state & TDLS_LINKED_STATE) && 
 		 (psta->htpriv.ht_option==_TRUE) &&
 		 (psta->htpriv.ampdu_enable==_TRUE))) //B/G/N Mode
 #else
@@ -3849,7 +3858,7 @@ int process_recv_indicatepkts(_adapter *padapter, union recv_frame *prframe)
 			#ifdef DBG_RX_DROP_FRAME
 			DBG_871X("DBG_RX_DROP_FRAME %s recv_indicatepkt_reorder error!\n", __FUNCTION__);
 			#endif
-
+		
 			if ((padapter->bDriverStopped == _FALSE) &&
 			    (padapter->bSurpriseRemoved == _FALSE))
 			{
@@ -3894,13 +3903,13 @@ int process_recv_indicatepkts(_adapter *padapter, union recv_frame *prframe)
 
 }
 
-static int recv_func_prehandle(_adapter *padapter, union recv_frame *rframe)
+int recv_func_prehandle(_adapter *padapter, union recv_frame *rframe)
 {
 	int ret = _SUCCESS;
 	struct rx_pkt_attrib *pattrib = &rframe->u.hdr.attrib;
 	struct recv_priv *precvpriv = &padapter->recvpriv;
 	_queue *pfree_recv_queue = &padapter->recvpriv.free_recv_queue;
-
+	
 #ifdef CONFIG_MP_INCLUDED
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 #endif //CONFIG_MP_INCLUDED
@@ -3935,14 +3944,14 @@ static int recv_func_prehandle(_adapter *padapter, union recv_frame *rframe)
 	return ret;
 }
 
-static int recv_func_posthandle(_adapter *padapter, union recv_frame *prframe)
+int recv_func_posthandle(_adapter *padapter, union recv_frame *prframe)
 {
 	int ret = _SUCCESS;
 	union recv_frame *orig_prframe = prframe;
 	struct rx_pkt_attrib *pattrib = &prframe->u.hdr.attrib;
 	struct recv_priv *precvpriv = &padapter->recvpriv;
 	_queue *pfree_recv_queue = &padapter->recvpriv.free_recv_queue;
-
+	
 #ifdef CONFIG_MP_INCLUDED
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 #endif //CONFIG_MP_INCLUDED
@@ -4001,7 +4010,7 @@ static int recv_func_posthandle(_adapter *padapter, union recv_frame *prframe)
 		#ifdef DBG_RX_DROP_FRAME
 		DBG_871X("DBG_RX_DROP_FRAME %s recvframe_chk_defrag: drop pkt\n", __FUNCTION__);
 		#endif
-		goto _recv_data_drop;
+		goto _recv_data_drop;		
 	}
 
 	prframe=portctrl(padapter, prframe);
@@ -4056,7 +4065,7 @@ static int recv_func_posthandle(_adapter *padapter, union recv_frame *prframe)
 			//indicate this recv_frame
 			ret = rtw_recv_indicatepkt(padapter, prframe);
 			if (ret != _SUCCESS)
-			{
+			{	
 				#ifdef DBG_RX_DROP_FRAME
 				DBG_871X("DBG_RX_DROP_FRAME %s rtw_recv_indicatepkt fail!\n", __FUNCTION__);
 				#endif
@@ -4107,7 +4116,8 @@ static int recv_func_posthandle(_adapter *padapter, union recv_frame *prframe)
 }
 
 
-static int recv_func(_adapter *padapter, union recv_frame *rframe)
+int recv_func(_adapter *padapter, union recv_frame *rframe);
+int recv_func(_adapter *padapter, union recv_frame *rframe)
 {
 	int ret;
 	struct rx_pkt_attrib *prxattrib = &rframe->u.hdr.attrib;
@@ -4130,7 +4140,7 @@ static int recv_func(_adapter *padapter, union recv_frame *rframe)
 	ret = recv_func_prehandle(padapter, rframe);
 
 	if(ret == _SUCCESS) {
-
+		
 		/* check if need to enqueue into uc_swdec_pending_queue*/
 		if (check_fwstate(mlmepriv, WIFI_STATION_STATE) &&
 			!IS_MCAST(prxattrib->ra) && prxattrib->encrypt>0 &&
@@ -4141,7 +4151,7 @@ static int recv_func(_adapter *padapter, union recv_frame *rframe)
 			DBG_871X("%s: no key, enqueue uc_swdec_pending_queue\n", __func__);
 			goto exit;
 		}
-
+		
 		ret = recv_func_posthandle(padapter, rframe);
 	}
 
@@ -4192,10 +4202,19 @@ s32 rtw_recv_entry(union recv_frame *precvframe)
 }
 
 #ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
-void rtw_signal_stat_timer_hdl(RTW_TIMER_HDL_ARGS){
-	_adapter *adapter = (_adapter *)FunctionContext;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+void rtw_signal_stat_timer_hdl(RTW_TIMER_HDL_ARGS)
+#else
+void rtw_signal_stat_timer_hdl(struct timer_list *t)
+#endif
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+        _adapter *adapter = (_adapter *)FunctionContext;
+#else
+        _adapter *adapter = from_timer(adapter, t, recvpriv.signal_stat_timer);
+#endif
 	struct recv_priv *recvpriv = &adapter->recvpriv;
-
+	
 	u32 tmp_s, tmp_q;
 	u8 avg_signal_strength = 0;
 	u8 avg_signal_qual = 0;
@@ -4215,7 +4234,7 @@ void rtw_signal_stat_timer_hdl(RTW_TIMER_HDL_ARGS){
 			// after avg_vals are accquired, we can re-stat the signal values
 			recvpriv->signal_strength_data.update_req = 1;
 		}
-
+		
 		if(recvpriv->signal_qual_data.update_req == 0) {// update_req is clear, means we got rx
 			avg_signal_qual = recvpriv->signal_qual_data.avg_val;
 			num_signal_qual = recvpriv->signal_qual_data.total_num;
@@ -4233,7 +4252,7 @@ void rtw_signal_stat_timer_hdl(RTW_TIMER_HDL_ARGS){
 
 		if(check_fwstate(&adapter->mlmepriv, _FW_UNDER_SURVEY) == _TRUE
 			|| check_fwstate(&adapter->mlmepriv, _FW_LINKED) == _FALSE
-		) {
+		) { 
 			goto set_timer;
 		}
 
@@ -4280,6 +4299,9 @@ void rtw_signal_stat_timer_hdl(RTW_TIMER_HDL_ARGS){
 
 set_timer:
 	rtw_set_signal_stat_timer(recvpriv);
-
+	
 }
 #endif //CONFIG_NEW_SIGNAL_STAT_PROCESS
+
+
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_rf.c b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_rf.c
old mode 100644
new mode 100755
index 52234bd..7ae8635
--- a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_rf.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_rf.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -92,3 +92,4 @@ u32 rtw_freq2ch(u32 freq)
 
 	return ch;
 }
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_security.c b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_security.c
old mode 100644
new mode 100755
index 2df28ba..8fa8ed5
--- a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_security.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_security.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -26,7 +26,7 @@
 #include <osdep_intf.h>
 
 
-//=====WEP related=====
+//=====WEP related===== 
 
 #define CRC32_POLY 0x04c11db7
 
@@ -63,7 +63,7 @@ static void arcfour_init(struct arc4context 	*parc4ctx, u8 * key,u32	key_len)
 		if (++keyindex >= key_len)
 			keyindex = 0;
 	}
-_func_exit_;
+_func_exit_;	
 }
 static u32 arcfour_byte(	struct arc4context	*parc4ctx)
 {
@@ -81,21 +81,21 @@ static u32 arcfour_byte(	struct arc4context	*parc4ctx)
 	parc4ctx->y = y;
 	state[y] = (u8)sx;
 	state[x] = (u8)sy;
-_func_exit_;
+_func_exit_;	
 	return state[(sx + sy) & 0xff];
 }
-
-
-static void arcfour_encrypt(	struct arc4context	*parc4ctx,
+              
+           
+static void arcfour_encrypt(	struct arc4context	*parc4ctx, 
 	u8 * dest,
-	u8 * src,
+	u8 * src, 
 	u32 len)
 {
 	u32	i;
-_func_enter_;
+_func_enter_;	
 	for (i = 0; i < len; i++)
 		dest[i] = src[i] ^ (unsigned char)arcfour_byte(parc4ctx);
-_func_exit_;
+_func_exit_;		
 }
 
 static sint bcrc32initialized = 0;
@@ -109,8 +109,8 @@ static u8 crc32_reverseBit( u8 data)
 
 static void crc32_init(void)
 {
-_func_enter_;
-	if (bcrc32initialized == 1)
+_func_enter_;	
+	if (bcrc32initialized == 1) 
 		goto exit;
 	else{
 		sint i, j;
@@ -120,7 +120,7 @@ static void crc32_init(void)
 
 		c = 0x12340000;
 
-		for (i = 0; i < 256; ++i)
+		for (i = 0; i < 256; ++i) 
 		{
 			k = crc32_reverseBit((u8)i);
 			for (c = ((u32)k) << 24, j = 8; j > 0; --j){
@@ -135,24 +135,24 @@ static void crc32_init(void)
 		}
 		bcrc32initialized= 1;
 	}
-exit:
-_func_exit_;
+exit:	
+_func_exit_;			
 }
 
 static u32 getcrc32(u8 *buf, sint len)
 {
 	u8 *p;
 	u32  crc;
-_func_enter_;
+_func_enter_;	
 	if (bcrc32initialized == 0) crc32_init();
 
 	crc = 0xffffffff;       /* preload shift register, per CRC-32 spec */
 
-	for (p = buf; len > 0; ++p, --len)
+	for (p = buf; len > 0; ++p, --len) 
 	{
 		crc = crc32_table[ (crc ^ *p) & 0xff] ^ (crc >> 8);
 	}
-_func_exit_;
+_func_exit_;				
 	return ~crc;    /* transmit complement, per CRC-32 spec */
 }
 
@@ -162,7 +162,7 @@ static u32 getcrc32(u8 *buf, sint len)
 */
 void rtw_wep_encrypt(_adapter *padapter, u8 *pxmitframe)
 {																	// exclude ICV
-
+	
 	unsigned char	crc[4];
 	struct arc4context	 mycontext;
 
@@ -174,10 +174,10 @@ void rtw_wep_encrypt(_adapter *padapter, u8 *pxmitframe)
 	struct	pkt_attrib	 *pattrib = &((struct xmit_frame*)pxmitframe)->attrib;
 	struct 	security_priv	*psecuritypriv=&padapter->securitypriv;
 	struct	xmit_priv		*pxmitpriv=&padapter->xmitpriv;
+	
+_func_enter_;	
 
-_func_enter_;
-
-
+	
 	if(((struct xmit_frame*)pxmitframe)->buf_addr==NULL)
 		return;
 
@@ -187,7 +187,7 @@ void rtw_wep_encrypt(_adapter *padapter, u8 *pxmitframe)
 #else
 	pframe = ((struct xmit_frame*)pxmitframe)->buf_addr + TXDESC_OFFSET;
 #endif
-
+	
 	//start to encrypt each fragment
 	if((pattrib->encrypt==_WEP40_)||(pattrib->encrypt==_WEP104_))
 	{
@@ -202,9 +202,9 @@ void rtw_wep_encrypt(_adapter *padapter, u8 *pxmitframe)
 
 			if((curfragnum+1)==pattrib->nr_frags)
 			{	//the last fragment
-
+			
 				length=pattrib->last_txcmdsz-pattrib->hdrlen-pattrib->iv_len- pattrib->icv_len;
-
+			
 				*((u32 *)crc)=cpu_to_le32(getcrc32(payload,length));
 
 				arcfour_init(&mycontext, wepkey,3+keylength);
@@ -219,22 +219,22 @@ void rtw_wep_encrypt(_adapter *padapter, u8 *pxmitframe)
 				arcfour_init(&mycontext, wepkey,3+keylength);
 				arcfour_encrypt(&mycontext, payload, payload, length);
 				arcfour_encrypt(&mycontext, payload+length, crc, 4);
-
+	
 			pframe+=pxmitpriv->frag_len;
 			pframe=(u8 *)RND4((SIZE_PTR)(pframe));
 
 			}
-
-		}
-
+			
+		}		
+						
 	}
-
-_func_exit_;
+	
+_func_exit_;						
 
 }
 
 void rtw_wep_decrypt(_adapter  *padapter, u8 *precvframe)
-{
+{								
 	// exclude ICV
 	u8	crc[4];
 	struct arc4context	 mycontext;
@@ -245,10 +245,10 @@ void rtw_wep_decrypt(_adapter  *padapter, u8 *precvframe)
 	struct	rx_pkt_attrib	 *prxattrib = &(((union recv_frame*)precvframe)->u.hdr.attrib);
 	struct 	security_priv	*psecuritypriv=&padapter->securitypriv;
 
-_func_enter_;
+_func_enter_;	
 
 	pframe=(unsigned char *)((union recv_frame*)precvframe)->u.hdr.rx_data;
-
+	
 	//start to decrypt recvframe
 	if((prxattrib->encrypt==_WEP40_)||(prxattrib->encrypt==_WEP104_))
 	{
@@ -262,26 +262,26 @@ void rtw_wep_decrypt(_adapter  *padapter, u8 *precvframe)
 		length= ((union recv_frame *)precvframe)->u.hdr.len-prxattrib->hdrlen-prxattrib->iv_len;
 
 		payload=pframe+prxattrib->iv_len+prxattrib->hdrlen;
-
+		
 		//decrypt payload include icv
 		arcfour_init(&mycontext, wepkey,3+keylength);
 		arcfour_encrypt(&mycontext, payload, payload,  length);
-
+				
 		//calculate icv and compare the icv
 		*((u32 *)crc)=le32_to_cpu(getcrc32(payload,length-4));
-
+		
 		if(crc[3]!=payload[length-1] || crc[2]!=payload[length-2] || crc[1]!=payload[length-3] || crc[0]!=payload[length-4])
 		{
 			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_wep_decrypt:icv error crc[3](%x)!=payload[length-1](%x) || crc[2](%x)!=payload[length-2](%x) || crc[1](%x)!=payload[length-3](%x) || crc[0](%x)!=payload[length-4](%x)\n",
 						crc[3],payload[length-1],crc[2],payload[length-2],crc[1],payload[length-3],crc[0],payload[length-4]));
-		}
-
+		}	
+						
 	}
-
-_func_exit_;
+	
+_func_exit_;		
 
 	return;
-
+	
 }
 
 //3 		=====TKIP related=====
@@ -291,12 +291,12 @@ static u32 secmicgetuint32( u8 * p )
 {
 	s32 i;
 	u32 res = 0;
-_func_enter_;
+_func_enter_;		
 	for( i=0; i<4; i++ )
 	{
 		res |= ((u32)(*p++)) << (8*i);
 	}
-_func_exit_;
+_func_exit_;		
 	return res;
 }
 
@@ -304,40 +304,40 @@ static void secmicputuint32( u8 * p, u32 val )
 // Convert from Us4Byte32 to Byte[] in a portable way
 {
 	long i;
-_func_enter_;
+_func_enter_;			
 	for( i=0; i<4; i++ )
 	{
 		*p++ = (u8) (val & 0xff);
 		val >>= 8;
 	}
-_func_exit_;
+_func_exit_;		
 }
 
 static void secmicclear(struct mic_data *pmicdata)
 {
 // Reset the state to the empty message.
-_func_enter_;
+_func_enter_;	
 	pmicdata->L = pmicdata->K0;
 	pmicdata->R = pmicdata->K1;
 	pmicdata->nBytesInM = 0;
 	pmicdata->M = 0;
-_func_exit_;
+_func_exit_;	
 }
 
 void rtw_secmicsetkey(struct mic_data *pmicdata, u8 * key )
 {
 	// Set the key
-_func_enter_;
+_func_enter_;		
 	pmicdata->K0 = secmicgetuint32( key );
 	pmicdata->K1 = secmicgetuint32( key + 4 );
 	// and reset the message
 	secmicclear(pmicdata);
-_func_exit_;
+_func_exit_;		
 }
 
 void rtw_secmicappendbyte(struct mic_data *pmicdata, u8 b )
 {
-_func_enter_;
+_func_enter_;	
 	// Append the byte to our word-sized buffer
 	pmicdata->M |= ((unsigned long)b) << (8*pmicdata->nBytesInM);
 	pmicdata->nBytesInM++;
@@ -357,24 +357,24 @@ void rtw_secmicappendbyte(struct mic_data *pmicdata, u8 b )
 		pmicdata->M = 0;
 		pmicdata->nBytesInM = 0;
 	}
-_func_exit_;
+_func_exit_;			
 }
 
 void rtw_secmicappend(struct mic_data *pmicdata, u8 * src, u32 nbytes )
 {
-_func_enter_;
+_func_enter_;	
 	// This is simple
 	while( nbytes > 0 )
 	{
 		rtw_secmicappendbyte(pmicdata, *src++ );
 		nbytes--;
 	}
-_func_exit_;
+_func_exit_;			
 }
 
 void rtw_secgetmic(struct mic_data *pmicdata, u8 * dst )
 {
-_func_enter_;
+_func_enter_;	
 	// Append the minimum padding
 	rtw_secmicappendbyte(pmicdata, 0x5a );
 	rtw_secmicappendbyte(pmicdata, 0 );
@@ -391,7 +391,7 @@ void rtw_secgetmic(struct mic_data *pmicdata, u8 * dst )
 	secmicputuint32( dst+4, pmicdata->R );
 	// Reset to the empty message.
 	secmicclear(pmicdata);
-_func_exit_;
+_func_exit_;		
 }
 
 
@@ -400,18 +400,18 @@ void rtw_seccalctkipmic(u8 * key,u8 *header,u8 *data,u32 data_len,u8 *mic_code,
 
 	struct mic_data	micdata;
 	u8 priority[4]={0x0,0x0,0x0,0x0};
-_func_enter_;
+_func_enter_;		
 	rtw_secmicsetkey(&micdata, key);
 	priority[0]=pri;
-
+	
 	/* Michael MIC pseudo header: DA, SA, 3 x 0, Priority */
 	if(header[1]&1){   //ToDS==1
 			rtw_secmicappend(&micdata, &header[16], 6);  //DA
 		if(header[1]&2)  //From Ds==1
 			rtw_secmicappend(&micdata, &header[24], 6);
 		else
-			rtw_secmicappend(&micdata, &header[10], 6);
-	}
+			rtw_secmicappend(&micdata, &header[10], 6);		
+	}	
 	else{	//ToDS==0
 		rtw_secmicappend(&micdata, &header[4], 6);   //DA
 		if(header[1]&2)  //From Ds==1
@@ -422,11 +422,11 @@ void rtw_seccalctkipmic(u8 * key,u8 *header,u8 *data,u32 data_len,u8 *mic_code,
 	}
 	rtw_secmicappend(&micdata, &priority[0], 4);
 
-
+	
 	rtw_secmicappend(&micdata, data, data_len);
 
 	rtw_secgetmic(&micdata,mic_code);
-_func_exit_;
+_func_exit_;	
 }
 
 
@@ -490,7 +490,7 @@ void rtw_seccalctkipmic(u8 * key,u8 *header,u8 *data,u32 data_len,u8 *mic_code,
    0x038F,0x59F8,0x0980,0x1A17,0x65DA,0xD731,0x84C6,0xD0B8,
    0x82C3,0x29B0,0x5A77,0x1E11,0x7BCB,0xA8FC,0x6DD6,0x2C3A,
   },
-
+ 
 
   {  /* second half of table is unsigned char-reversed version of first! */
    0xA5C6,0x84F8,0x99EE,0x8DF6,0x0DFF,0xBDD6,0xB1DE,0x5491,
@@ -527,7 +527,7 @@ void rtw_seccalctkipmic(u8 * key,u8 *header,u8 *data,u32 data_len,u8 *mic_code,
    0xC382,0xB029,0x775A,0x111E,0xCB7B,0xFCA8,0xD66D,0x3A2C,
   }
 };
-
+ 
  /*
 **********************************************************************
 * Routine: Phase 1 -- generate P1K, given TA, TK, IV32
@@ -560,7 +560,7 @@ static void phase1(u16 *p1k,const u8 *tk,const u8 *ta,u32 iv32)
 	/* size on the 80-bit block P1K[], using the 128-bit key TK[] */
 	for (i=0; i < PHASE1_LOOP_CNT ;i++)
 	{                 /* Each add operation here is mod 2**16 */
-		p1k[0] += _S_(p1k[4] ^ TK16((i&1)+0));
+      		p1k[0] += _S_(p1k[4] ^ TK16((i&1)+0));
 		p1k[1] += _S_(p1k[0] ^ TK16((i&1)+2));
 		p1k[2] += _S_(p1k[1] ^ TK16((i&1)+4));
 		p1k[3] += _S_(p1k[2] ^ TK16((i&1)+6));
@@ -569,7 +569,7 @@ static void phase1(u16 *p1k,const u8 *tk,const u8 *ta,u32 iv32)
         }
 _func_exit_;
 }
-
+ 
 
 /*
 **********************************************************************
@@ -628,7 +628,7 @@ static void phase2(u8 *rc4key,const u8 *tk,const u16 *p1k,u16 iv16)
 	rc4key[1] =(Hi8(iv16) | 0x20) & 0x7F; /* Help avoid weak (FMS) keys  */
 	rc4key[2] = Lo8(iv16);
 	rc4key[3] = Lo8((PPK[5] ^ TK16(0)) >> 1);
-
+	 
 
 	/* Copy 96 bits of PPK[0..5] to RC4KEY[4..15]  (little-endian)       */
 	for (i=0;i<6;i++)
@@ -636,7 +636,7 @@ static void phase2(u8 *rc4key,const u8 *tk,const u16 *p1k,u16 iv16)
 		rc4key[4+2*i] = Lo8(PPK[i]);
 		rc4key[5+2*i] = Hi8(PPK[i]);
 	}
-_func_exit_;
+_func_exit_;	
 }
 
 
@@ -682,8 +682,8 @@ u32	rtw_tkip_encrypt(_adapter *padapter, u8 *pxmitframe)
 		{
 			DBG_871X("%s, call rtw_get_stainfo()\n", __func__);
 			stainfo=rtw_get_stainfo(&padapter->stapriv ,&pattrib->ra[0] );
-		}
-
+		}	
+		
 		if (stainfo!=NULL){
 
 			if(!(stainfo->state &_FW_LINKED))
@@ -691,7 +691,7 @@ u32	rtw_tkip_encrypt(_adapter *padapter, u8 *pxmitframe)
 				DBG_871X("%s, psta->state(0x%x) != _FW_LINKED\n", __func__, stainfo->state);
 				return _FAIL;
 			}
-
+			
 			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_tkip_encrypt: stainfo!=NULL!!!\n"));
 
 			if(IS_MCAST(pattrib->ra))
@@ -708,7 +708,7 @@ u32	rtw_tkip_encrypt(_adapter *padapter, u8 *pxmitframe)
 			for(curfragnum=0;curfragnum<pattrib->nr_frags;curfragnum++){
 				iv=pframe+pattrib->hdrlen;
 				payload=pframe+pattrib->iv_len+pattrib->hdrlen;
-
+				
 				GET_TKIP_PN(iv, dot11txpn);
 
 				pnl=(u16)(dot11txpn.val);
@@ -716,7 +716,7 @@ u32	rtw_tkip_encrypt(_adapter *padapter, u8 *pxmitframe)
 
 				phase1((u16 *)&ttkey[0],prwskey,&pattrib->ta[0],pnh);
 
-				phase2(&rc4key[0],prwskey,(u16 *)&ttkey[0],pnl);
+				phase2(&rc4key[0],prwskey,(u16 *)&ttkey[0],pnl);	
 
 				if((curfragnum+1)==pattrib->nr_frags){	//4 the last fragment
 					length=pattrib->last_txcmdsz-pattrib->hdrlen-pattrib->iv_len- pattrib->icv_len;
@@ -734,7 +734,7 @@ u32	rtw_tkip_encrypt(_adapter *padapter, u8 *pxmitframe)
 					arcfour_init(&mycontext,rc4key,16);
 					arcfour_encrypt(&mycontext, payload, payload, length);
 					arcfour_encrypt(&mycontext, payload+length, crc, 4);
-
+	
 				pframe+=pxmitpriv->frag_len;
 				pframe=(u8 *)RND4((SIZE_PTR)(pframe));
 
@@ -748,11 +748,11 @@ u32	rtw_tkip_encrypt(_adapter *padapter, u8 *pxmitframe)
                         DBG_871X("%s, psta==NUL\n", __func__);
 			res=_FAIL;
 		}
-
+						
 	}
-_func_exit_;
+_func_exit_;	
 	return res;
-
+				
 }
 
 
@@ -779,7 +779,7 @@ u32 rtw_tkip_decrypt(_adapter *padapter, u8 *precvframe)
 _func_enter_;
 
 	pframe=(unsigned char *)((union recv_frame*)precvframe)->u.hdr.rx_data;
-
+	
 	//4 start to decrypt recvframe
 	if(prxattrib->encrypt==_TKIP_){
 
@@ -835,21 +835,21 @@ u32 rtw_tkip_decrypt(_adapter *padapter, u8 *precvframe)
 				prwskey=&stainfo->dot118021x_UncstKey.skey[0];
 				prwskeylen=16;
 			}
-
+			
 			iv=pframe+prxattrib->hdrlen;
 			payload=pframe+prxattrib->iv_len+prxattrib->hdrlen;
 			length= ((union recv_frame *)precvframe)->u.hdr.len-prxattrib->hdrlen-prxattrib->iv_len;
-
+				
 			GET_TKIP_PN(iv, dot11txpn);
 
 			pnl=(u16)(dot11txpn.val);
 			pnh=(u32)(dot11txpn.val>>16);
 
 			phase1((u16 *)&ttkey[0],prwskey,&prxattrib->ta[0],pnh);
-			phase2(&rc4key[0],prwskey,(unsigned short *)&ttkey[0],pnl);
+			phase2(&rc4key[0],prwskey,(unsigned short *)&ttkey[0],pnl);	
 
 			//4 decrypt payload include icv
-
+					
 			arcfour_init(&mycontext, rc4key,16);
 			arcfour_encrypt(&mycontext, payload, payload, length);
 
@@ -861,19 +861,19 @@ u32 rtw_tkip_decrypt(_adapter *padapter, u8 *precvframe)
 						crc[3],payload[length-1],crc[2],payload[length-2],crc[1],payload[length-3],crc[0],payload[length-4]));
 				res=_FAIL;
 			}
-
-
+						
+		
 		}
 		else{
 			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_tkip_decrypt: stainfo==NULL!!!\n"));
 			res=_FAIL;
 		}
-
+						
 	}
-_func_exit_;
+_func_exit_;	
 exit:
 	return res;
-
+				
 }
 
 
@@ -960,7 +960,7 @@ static void construct_ctr_preload(
 static void byte_sub(u8 *in, u8 *out);
 static void shift_row(u8 *in, u8 *out);
 static void mix_column(u8 *in, u8 *out);
-#ifndef PLATFORM_FREEBSD
+#ifndef PLATFORM_FREEBSD 
 static void add_round_key( u8 *shiftrow_in,
                     u8 *mcol_in,
                     u8 *block_in,
@@ -978,24 +978,24 @@ static void add_round_key( u8 *shiftrow_in,
 static void xor_128(u8 *a, u8 *b, u8 *out)
 {
     sint i;
-_func_enter_;
+_func_enter_;	
     for (i=0;i<16; i++)
     {
         out[i] = a[i] ^ b[i];
     }
-_func_exit_;
+_func_exit_;		
 }
 
 
 static void xor_32(u8 *a, u8 *b, u8 *out)
 {
     sint i;
-_func_enter_;
+_func_enter_;		
     for (i=0;i<4; i++)
     {
         out[i] = a[i] ^ b[i];
     }
-_func_exit_;
+_func_exit_;		
 }
 
 
@@ -1014,7 +1014,7 @@ static void next_key(u8 *key, sint round)
         0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
         0x1b, 0x36, 0x36, 0x36
     };
-_func_enter_;
+_func_enter_;		
     sbox_key[0] = sbox(key[13]);
     sbox_key[1] = sbox(key[14]);
     sbox_key[2] = sbox(key[15]);
@@ -1028,25 +1028,25 @@ static void next_key(u8 *key, sint round)
     xor_32(&key[4], &key[0], &key[4]);
     xor_32(&key[8], &key[4], &key[8]);
     xor_32(&key[12], &key[8], &key[12]);
-_func_exit_;
+_func_exit_;		
 }
 
 
 static void byte_sub(u8 *in, u8 *out)
 {
     sint i;
-_func_enter_;
+_func_enter_;			
     for (i=0; i< 16; i++)
     {
         out[i] = sbox(in[i]);
     }
-_func_exit_;
+_func_exit_;	
 }
 
 
 static void shift_row(u8 *in, u8 *out)
 {
-_func_enter_;
+_func_enter_;	
     out[0] =  in[0];
     out[1] =  in[5];
     out[2] =  in[10];
@@ -1063,7 +1063,7 @@ static void shift_row(u8 *in, u8 *out)
     out[13] = in[1];
     out[14] = in[6];
     out[15] = in[11];
-_func_exit_;
+_func_exit_;		
 }
 
 
@@ -1078,7 +1078,7 @@ static void mix_column(u8 *in, u8 *out)
     u8 rotr[4];
     u8 temp[4];
     u8 tempb[4];
-_func_enter_;
+_func_enter_;	
     for (i=0 ; i<4; i++)
     {
         if ((in[i] & 0x80)== 0x80)
@@ -1126,7 +1126,7 @@ static void mix_column(u8 *in, u8 *out)
     xor_32(add1bf7, rotr, temp);
     xor_32(swap_halfs, rotl,tempb);
     xor_32(temp, tempb, out);
-_func_exit_;
+_func_exit_;		
 }
 
 
@@ -1137,7 +1137,7 @@ static void aes128k128d(u8 *key, u8 *data, u8 *ciphertext)
     u8 intermediatea[16];
     u8 intermediateb[16];
     u8 round_key[16];
-_func_enter_;
+_func_enter_;	
     for(i=0; i<16; i++) round_key[i] = key[i];
 
     for (round = 0; round < 11; round++)
@@ -1165,7 +1165,7 @@ static void aes128k128d(u8 *key, u8 *data, u8 *ciphertext)
             next_key(round_key, round);
         }
     }
-_func_exit_;
+_func_exit_;	
 }
 
 
@@ -1186,7 +1186,7 @@ static void construct_mic_iv(
                         )
 {
     sint i;
-_func_enter_;
+_func_enter_;	
     mic_iv[0] = 0x59;
     if (qc_exists && a4_exists) mic_iv[1] = mpdu[30] & 0x0f;    /* QoS_TC           */
     if (qc_exists && !a4_exists) mic_iv[1] = mpdu[24] & 0x0f;   /* mute bits 7-4    */
@@ -1207,7 +1207,7 @@ static void construct_mic_iv(
     #endif
     mic_iv[14] = (unsigned char) (payload_length / 256);
     mic_iv[15] = (unsigned char) (payload_length % 256);
-_func_exit_;
+_func_exit_;		
 }
 
 
@@ -1224,7 +1224,7 @@ static void construct_mic_header1(
                         uint frtype// add for CONFIG_IEEE80211W, none 11w also can use
                         )
 {
-_func_enter_;
+_func_enter_;	
     mic_header1[0] = (u8)((header_length - 2) / 256);
     mic_header1[1] = (u8)((header_length - 2) % 256);
 #ifdef CONFIG_IEEE80211W
@@ -1234,7 +1234,7 @@ static void construct_mic_header1(
 	else
 #endif //CONFIG_IEEE80211W
 		mic_header1[2] = mpdu[0] & 0xcf;    /* Mute CF poll & CF ack bits */
-
+    
     mic_header1[3] = mpdu[1] & 0xc7;    /* Mute retry, more data and pwr mgt bits */
     mic_header1[4] = mpdu[4];       /* A1 */
     mic_header1[5] = mpdu[5];
@@ -1248,7 +1248,7 @@ static void construct_mic_header1(
     mic_header1[13] = mpdu[13];
     mic_header1[14] = mpdu[14];
     mic_header1[15] = mpdu[15];
-_func_exit_;
+_func_exit_;	
 }
 
 
@@ -1265,7 +1265,7 @@ static void construct_mic_header2(
                 )
 {
     sint i;
-_func_enter_;
+_func_enter_;	
     for (i = 0; i<16; i++) mic_header2[i]=0x00;
 
     mic_header2[0] = mpdu[16];    /* A3 */
@@ -1300,7 +1300,7 @@ static void construct_mic_header2(
         mic_header2[15] = mpdu[31] & 0x00;
     }
 
-_func_exit_;
+_func_exit_;	
 }
 
 
@@ -1322,14 +1322,14 @@ static void construct_ctr_preload(
                         )
 {
     sint i = 0;
-_func_enter_;
+_func_enter_;		
     for (i=0; i<16; i++) ctr_preload[i] = 0x00;
     i = 0;
-
+	
     ctr_preload[0] = 0x01;                                  /* flag */
-    if (qc_exists && a4_exists)
+    if (qc_exists && a4_exists) 
 		ctr_preload[1] = mpdu[30] & 0x0f;   /* QoC_Control */
-    if (qc_exists && !a4_exists)
+    if (qc_exists && !a4_exists) 
 		ctr_preload[1] = mpdu[24] & 0x0f;
 #ifdef CONFIG_IEEE80211W
 	//802.11w management frame should set management bit(4)
@@ -1347,7 +1347,7 @@ static void construct_ctr_preload(
     #endif
     ctr_preload[14] =  (unsigned char) (c / 256); /* Ctr */
     ctr_preload[15] =  (unsigned char) (c % 256);
-_func_exit_;
+_func_exit_;		
 }
 
 
@@ -1358,12 +1358,12 @@ static void construct_ctr_preload(
 static void bitwise_xor(u8 *ina, u8 *inb, u8 *out)
 {
     sint i;
-_func_enter_;
+_func_enter_;		
     for (i=0; i<16; i++)
     {
         out[i] = ina[i] ^ inb[i];
     }
-_func_exit_;
+_func_exit_;		
 }
 
 
@@ -1388,8 +1388,8 @@ static sint aes_cipher(u8 *key, uint	hdrlen,
 //	uint	offset = 0;
 	uint	frtype  = GetFrameType(pframe);
 	uint	frsubtype  = GetFrameSubType(pframe);
-
-_func_enter_;
+	
+_func_enter_;		
 	frsubtype=frsubtype>>4;
 
 
@@ -1413,7 +1413,7 @@ static sint aes_cipher(u8 *key, uint	hdrlen,
 		{
 			qc_exists = 1;
 					if(hdrlen !=  WLAN_HDR_A3_QOS_LEN){
-
+				 
 					hdrlen += 2;
 			}
 		}
@@ -1425,7 +1425,7 @@ static sint aes_cipher(u8 *key, uint	hdrlen,
 		(frsubtype == 0x0b)))
 		{
 			if(hdrlen !=  WLAN_HDR_A3_QOS_LEN){
-
+				 
 					hdrlen += 2;
 			}
 			qc_exists = 1;
@@ -1439,7 +1439,7 @@ static sint aes_cipher(u8 *key, uint	hdrlen,
 	pn_vector[3]=pframe[hdrlen+5];
 	pn_vector[4]=pframe[hdrlen+6];
 	pn_vector[5]=pframe[hdrlen+7];
-
+	
 	construct_mic_iv(
                         mic_iv,
                         qc_exists,
@@ -1502,7 +1502,7 @@ static sint aes_cipher(u8 *key, uint	hdrlen,
 
     /* Insert MIC into payload */
     for (j = 0; j < 8; j++)
-	pframe[payload_index+j] = mic[j];	//message[payload_index+j] = mic[j];
+    	pframe[payload_index+j] = mic[j];	//message[payload_index+j] = mic[j];
 
 	payload_index = hdrlen + 8;
 	for (i=0; i< num_blocks; i++)
@@ -1560,7 +1560,7 @@ static sint aes_cipher(u8 *key, uint	hdrlen,
     aes128k128d(key, ctr_preload, aes_out);
     bitwise_xor(aes_out, padded_buffer, chain_buffer);
     for (j=0; j<8;j++) pframe[payload_index++] = chain_buffer[j];//for (j=0; j<8;j++) message[payload_index++] = chain_buffer[j];
-_func_exit_;
+_func_exit_;		
 	return _SUCCESS;
 }
 
@@ -1571,10 +1571,10 @@ u32	rtw_aes_encrypt(_adapter *padapter, u8 *pxmitframe)
 {	// exclude ICV
 
 
-	/*static*/
+	/*static*/ 
 //	unsigned char	message[MAX_MSG_SIZE];
 
-	/* Intermediate Buffers */
+    	/* Intermediate Buffers */
 	sint 	curfragnum,length;
 	u32	prwskeylen;
 	u8	*pframe,*prwskey;	//, *payload,*iv
@@ -1585,7 +1585,7 @@ u32	rtw_aes_encrypt(_adapter *padapter, u8 *pxmitframe)
 
 //	uint	offset = 0;
 	u32 res=_SUCCESS;
-_func_enter_;
+_func_enter_;		
 
 	if(((struct xmit_frame*)pxmitframe)->buf_addr==NULL)
 		return _FAIL;
@@ -1608,8 +1608,8 @@ u32	rtw_aes_encrypt(_adapter *padapter, u8 *pxmitframe)
 		{
 			DBG_871X("%s, call rtw_get_stainfo()\n", __func__);
 			stainfo=rtw_get_stainfo(&padapter->stapriv ,&pattrib->ra[0] );
-		}
-
+		}	
+		
 		if (stainfo!=NULL){
 
 			if(!(stainfo->state &_FW_LINKED))
@@ -1617,7 +1617,7 @@ u32	rtw_aes_encrypt(_adapter *padapter, u8 *pxmitframe)
 				DBG_871X("%s, psta->state(0x%x) != _FW_LINKED\n", __func__, stainfo->state);
 				return _FAIL;
 			}
-
+			
 			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_aes_encrypt: stainfo!=NULL!!!\n"));
 
 			if(IS_MCAST(pattrib->ra))
@@ -1642,17 +1642,17 @@ u32	rtw_aes_encrypt(_adapter *padapter, u8 *pxmitframe)
 #endif //CONFIG_TDLS
 
 			prwskeylen=16;
-
+	
 			for(curfragnum=0;curfragnum<pattrib->nr_frags;curfragnum++){
-
+			
 				if((curfragnum+1)==pattrib->nr_frags){	//4 the last fragment
 					length=pattrib->last_txcmdsz-pattrib->hdrlen-pattrib->iv_len- pattrib->icv_len;
-
+				
 					aes_cipher(prwskey,pattrib->hdrlen,pframe, length);
 				}
 				else{
 					length=pxmitpriv->frag_len-pattrib->hdrlen-pattrib->iv_len-pattrib->icv_len ;
-
+				
 					aes_cipher(prwskey,pattrib->hdrlen,pframe, length);
 				pframe+=pxmitpriv->frag_len;
 				pframe=(u8*)RND4((SIZE_PTR)(pframe));
@@ -1667,7 +1667,7 @@ u32	rtw_aes_encrypt(_adapter *padapter, u8 *pxmitframe)
                         DBG_871X("%s, psta==NUL\n", __func__);
 			res=_FAIL;
 		}
-
+						
 	}
 
 
@@ -1699,7 +1699,7 @@ static sint aes_decipher(u8 *key, uint	hdrlen,
 //	uint	offset = 0;
 	uint	frtype  = GetFrameType(pframe);
 	uint	frsubtype  = GetFrameSubType(pframe);
-_func_enter_;
+_func_enter_;			
 	frsubtype=frsubtype>>4;
 
 
@@ -1736,7 +1736,7 @@ static sint aes_decipher(u8 *key, uint	hdrlen,
 		{
 			qc_exists = 1;
 					if(hdrlen !=  WLAN_HDR_A3_QOS_LEN){
-
+				 
 					hdrlen += 2;
 			}
 		}//only for data packet . add for CONFIG_IEEE80211W, none 11w also can use
@@ -1747,7 +1747,7 @@ static sint aes_decipher(u8 *key, uint	hdrlen,
 		(frsubtype == 0x0b)))
 		{
 			if(hdrlen !=  WLAN_HDR_A3_QOS_LEN){
-
+				 
 					hdrlen += 2;
 			}
 			qc_exists = 1;
@@ -1759,7 +1759,7 @@ static sint aes_decipher(u8 *key, uint	hdrlen,
 	// now, decrypt pframe with hdrlen offset and plen long
 
 	payload_index = hdrlen + 8; // 8 is for extiv
-
+	
 	for (i=0; i< num_blocks; i++)
     {
         construct_ctr_preload(
@@ -1800,7 +1800,7 @@ static sint aes_decipher(u8 *key, uint	hdrlen,
         for (j=0; j<payload_remainder;j++) pframe[payload_index++] = chain_buffer[j];
     }
 
-	//start to calculate the mic
+	//start to calculate the mic	
 
 	_rtw_memcpy((void *)message, pframe, (hdrlen +plen+8)); //8 is for ext iv len
 
@@ -1813,7 +1813,7 @@ static sint aes_decipher(u8 *key, uint	hdrlen,
 	pn_vector[5]=pframe[hdrlen+7];
 
 
-
+	
 	construct_mic_iv(
                         mic_iv,
                         qc_exists,
@@ -1876,7 +1876,7 @@ static sint aes_decipher(u8 *key, uint	hdrlen,
 
     /* Insert MIC into payload */
     for (j = 0; j < 8; j++)
-	message[payload_index+j] = mic[j];
+    	message[payload_index+j] = mic[j];
 
 	payload_index = hdrlen + 8;
 	for (i=0; i< num_blocks; i++)
@@ -1955,7 +1955,7 @@ static sint aes_decipher(u8 *key, uint	hdrlen,
 		DBG_871X("error packet header \n");
 	}
 
-_func_exit_;
+_func_exit_;	
 	return res;
 }
 
@@ -1963,11 +1963,11 @@ u32	rtw_aes_decrypt(_adapter *padapter, u8 *precvframe)
 {	// exclude ICV
 
 
-	/*static*/
+	/*static*/ 
 //	unsigned char	message[MAX_MSG_SIZE];
 
 
-	/* Intermediate Buffers */
+    	/* Intermediate Buffers */
 
 
 	sint 		length;
@@ -1977,7 +1977,7 @@ u32	rtw_aes_decrypt(_adapter *padapter, u8 *precvframe)
 	struct 	security_priv	*psecuritypriv=&padapter->securitypriv;
 //	struct	recv_priv		*precvpriv=&padapter->recvpriv;
 	u32	res=_SUCCESS;
-_func_enter_;
+_func_enter_;	 
 	pframe=(unsigned char *)((union recv_frame*)precvframe)->u.hdr.rx_data;
 	//4 start to encrypt each fragment
 	if((prxattrib->encrypt==_AES_)){
@@ -1988,12 +1988,12 @@ u32	rtw_aes_decrypt(_adapter *padapter, u8 *precvframe)
 
 			if(IS_MCAST(prxattrib->ra))
 			{
-				//in concurrent we should use sw descrypt in group key, so we remove this message
+				//in concurrent we should use sw descrypt in group key, so we remove this message			
 				//DBG_871X("rx bc/mc packets, to perform sw rtw_aes_decrypt\n");
 				//prwskey = psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].skey;
 				if(psecuritypriv->binstallGrpkey==_FALSE)
 				{
-					res=_FAIL;
+					res=_FAIL;				
 					DBG_8192C("%s:rx bc/mc packets,but didn't install group key!!!!!!!!!!\n",__FUNCTION__);
 					goto exit;
 				}
@@ -2011,7 +2011,7 @@ u32	rtw_aes_decrypt(_adapter *padapter, u8 *precvframe)
 			{
 				prwskey=&stainfo->dot118021x_UncstKey.skey[0];
 			}
-
+	
 			length= ((union recv_frame *)precvframe)->u.hdr.len-prxattrib->hdrlen-prxattrib->iv_len;
 			/*// add for CONFIG_IEEE80211W, debug
 			if(0)
@@ -2042,9 +2042,9 @@ u32	rtw_aes_decrypt(_adapter *padapter, u8 *precvframe)
 			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_aes_encrypt: stainfo==NULL!!!\n"));
 			res=_FAIL;
 		}
-
+						
 	}
-_func_exit_;
+_func_exit_;	
 exit:
 	return res;
 }
@@ -2062,7 +2062,7 @@ u32	rtw_BIP_verify(_adapter *padapter, u8 *precvframe)
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	ori_len = pattrib->pkt_len-WLAN_HDR_A3_LEN+BIP_AAD_SIZE;
 	BIP_AAD = rtw_zmalloc(ori_len);
-
+	
 	if(BIP_AAD == NULL)
 	{
 		DBG_871X("BIP AAD allocate fail\n");
@@ -2100,7 +2100,7 @@ u32	rtw_BIP_verify(_adapter *padapter, u8 *precvframe)
 		}
 		//clear the MIC field of MME to zero
 		_rtw_memset(p+2+len-8, 0, 8);
-
+		
 		//conscruct AAD, copy frame control field
 		_rtw_memcpy(BIP_AAD, &pwlanhdr->frame_ctl, 2);
 		ClearRetry(BIP_AAD);
@@ -2108,11 +2108,11 @@ u32	rtw_BIP_verify(_adapter *padapter, u8 *precvframe)
 		ClearMData(BIP_AAD);
 		//conscruct AAD, copy address 1 to address 3
 		_rtw_memcpy(BIP_AAD+2, pwlanhdr->addr1, 18);
-
+		
 		if(omac1_aes_128(padapter->securitypriv.dot11wBIPKey[padapter->securitypriv.dot11wBIPKeyid].skey
 			, BIP_AAD, ori_len, mic))
 			goto BIP_exit;
-
+		
 		/*//management packet content
 		{
 			int pp;
@@ -2140,7 +2140,7 @@ u32	rtw_BIP_verify(_adapter *padapter, u8 *precvframe)
 		}
 		else
 			DBG_871X("BIP MIC error!\n");
-
+		
 	}
 	else
 		res = RTW_RX_HANDLED;
@@ -2172,7 +2172,7 @@ static int sha256_compress(struct sha256_state *md, unsigned char *buf)
 	for (i = 16; i < 64; i++) {
 		W[i] = Gamma1(W[i - 2]) + W[i - 7] + Gamma0(W[i - 15]) +
 			W[i - 16];
-	}
+	}        
 
 	/* Compress */
 #define RND(a,b,c,d,e,f,g,h,i)                          \
@@ -2183,7 +2183,7 @@ static int sha256_compress(struct sha256_state *md, unsigned char *buf)
 
 	for (i = 0; i < 64; ++i) {
 		RND(S[0], S[1], S[2], S[3], S[4], S[5], S[6], S[7], i);
-		t = S[7]; S[7] = S[6]; S[6] = S[5]; S[5] = S[4];
+		t = S[7]; S[7] = S[6]; S[6] = S[5]; S[5] = S[4]; 
 		S[4] = S[3]; S[3] = S[2]; S[2] = S[1]; S[1] = S[0]; S[0] = t;
 	}
 
@@ -2909,7 +2909,7 @@ void wpa_tdls_generate_tpk(_adapter *padapter, struct sta_info *psta)
 	}
 	_rtw_memcpy(data + 2 * ETH_ALEN, get_bssid(pmlmepriv), ETH_ALEN);
 
-	sha256_prf(key_input, SHA256_MAC_LEN, "TDLS PMK", data, sizeof(data), (u8 *) &psta->tpk, sizeof(psta->tpk));
+	sha256_prf(key_input, SHA256_MAC_LEN, "TDLS PMK", data, sizeof(data), (u8 *) &psta->tpk, sizeof(psta->tpk));	
 
 
 }
@@ -2925,7 +2925,7 @@ void wpa_tdls_generate_tpk(_adapter *padapter, struct sta_info *psta)
  *
  * Calculate MIC for TDLS frame.
  */
-int wpa_tdls_ftie_mic(u8 *kck, u8 trans_seq,
+int wpa_tdls_ftie_mic(u8 *kck, u8 trans_seq, 
 							u8 *lnkid, u8 *rsnie, u8 *timeoutie, u8 *ftie,
 							u8 *mic)
 {
@@ -2965,7 +2965,7 @@ int wpa_tdls_ftie_mic(u8 *kck, u8 trans_seq,
 	_ftie = (struct wpa_tdls_ftie *) pos;
 	_rtw_memset(_ftie->mic, 0, TDLS_MIC_LEN);
 	pos += 2 + ftie[1];
-
+ 
 	ret = omac1_aes_128(kck, buf, pos - buf, mic);
 	rtw_mfree(buf, len);
 	return ret;
@@ -2985,7 +2985,7 @@ int tdls_verify_mic(u8 *kck, u8 trans_seq,
 	    timeoutie == NULL || ftie == NULL){
 		return 0;
 	}
-
+	
 	len = 2 * ETH_ALEN + 1 + 2 + 18 + 2 + *(rsnie+1) + 2 + *(timeoutie+1) + 2 + *(ftie+1);
 
 	buf = rtw_zmalloc(len);
@@ -3053,10 +3053,10 @@ void rtw_use_tkipkey_handler(void *FunctionContext)
         _adapter *padapter = (_adapter *)FunctionContext;
 
 
-_func_enter_;
+_func_enter_;			
 
 	RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("^^^rtw_use_tkipkey_handler ^^^\n"));
-
+	
 /*
 	if(padapter->bDriverStopped ||padapter->bSurpriseRemoved){
 			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("^^^rtw_use_tkipkey_handler (padapter->bDriverStopped %d)(padapter->bSurpriseRemoved %d)^^^\n",padapter->bDriverStopped,padapter->bSurpriseRemoved));
@@ -3064,12 +3064,12 @@ void rtw_use_tkipkey_handler(void *FunctionContext)
 		return;
 	}
 	*/
-
+	
 	padapter->securitypriv.busetkipkey=_TRUE;
 
 	RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("^^^rtw_use_tkipkey_handler padapter->securitypriv.busetkipkey=%d^^^\n",padapter->securitypriv.busetkipkey));
 
-_func_exit_;
+_func_exit_;	
 
 }
 
@@ -3112,3 +3112,4 @@ u8 rtw_handle_tkip_countermeasure(_adapter* adapter, const char *caller)
 
 	return status;
 }
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_sreset.c b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_sreset.c
old mode 100644
new mode 100755
index 9d3dd7c..e08b1f7
--- a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_sreset.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_sreset.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -180,7 +180,7 @@ void sreset_restore_network_station(_adapter *padapter)
 	// reset related register of Beacon control
 
 	//set MSR to nolink
-	Set_MSR(padapter, _HW_STATE_NOLINK_);
+	Set_MSR(padapter, _HW_STATE_NOLINK_);		
 	// reject all data frame
 	rtw_write16(padapter, REG_RXFLTMAP2,0x00);
 	//reset TSF
@@ -192,7 +192,7 @@ void sreset_restore_network_station(_adapter *padapter)
 	//=======================================================
 	}
 	#endif
-
+	
 	rtw_setopmode_cmd(padapter, Ndis802_11Infrastructure);
 
 	{
@@ -201,7 +201,7 @@ void sreset_restore_network_station(_adapter *padapter)
 		// TH=1 => means that invalidate usb rx aggregation
 		// TH=0 => means that validate usb rx aggregation, use init value.
 		if(mlmepriv->htpriv.ht_option) {
-			if(padapter->registrypriv.wifi_spec==1)
+			if(padapter->registrypriv.wifi_spec==1)		
 				threshold = 1;
 			else
 				threshold = 0;
@@ -217,7 +217,7 @@ void sreset_restore_network_station(_adapter *padapter)
 
 	//disable dynamic functions, such as high power, DIG
 	//Switch_DM_Func(padapter, DYNAMIC_FUNC_DISABLE, _FALSE);
-
+	
 	rtw_hal_set_hwreg(padapter, HW_VAR_BSSID, pmlmeinfo->network.MacAddress);
 
 	{
@@ -349,3 +349,4 @@ void sreset_reset(_adapter *padapter)
 	DBG_871X("%s done in %d ms\n", __FUNCTION__, rtw_get_passing_time_ms(start));
 #endif
 }
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_sta_mgt.c b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_sta_mgt.c
old mode 100644
new mode 100755
index 23ccadf..f818a0c
--- a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_sta_mgt.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_sta_mgt.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -48,24 +48,24 @@ void _rtw_init_stainfo(struct sta_info *psta)
 	_rtw_init_listhead(&psta->hash_list);
 	//_rtw_init_listhead(&psta->asoc_list);
 	//_rtw_init_listhead(&psta->sleep_list);
-	//_rtw_init_listhead(&psta->wakeup_list);
+	//_rtw_init_listhead(&psta->wakeup_list);	
 
 	_rtw_init_queue(&psta->sleep_q);
 	psta->sleepq_len = 0;
 
 	_rtw_init_sta_xmit_priv(&psta->sta_xmitpriv);
 	_rtw_init_sta_recv_priv(&psta->sta_recvpriv);
-
+	
 #ifdef CONFIG_AP_MODE
 
 	_rtw_init_listhead(&psta->asoc_list);
 
 	_rtw_init_listhead(&psta->auth_list);
-
+	
 	psta->expire_to = 0;
-
+	
 	psta->flags = 0;
-
+	
 	psta->capability = 0;
 
 	psta->bpairwise_key_installed = _FALSE;
@@ -78,17 +78,17 @@ void _rtw_init_stainfo(struct sta_info *psta)
 	psta->no_ht_gf_set = 0;
 	psta->no_ht_set = 0;
 	psta->ht_20mhz_set = 0;
-#endif
+#endif	
 
 #ifdef CONFIG_TX_MCAST2UNI
 	psta->under_exist_checking = 0;
 #endif	// CONFIG_TX_MCAST2UNI
-
+	
 	psta->keep_alive_trycnt = 0;
 
-#endif	// CONFIG_AP_MODE
-
-_func_exit_;
+#endif	// CONFIG_AP_MODE	
+	
+_func_exit_;	
 
 }
 
@@ -97,20 +97,20 @@ u32	_rtw_init_sta_priv(struct	sta_priv *pstapriv)
 	struct sta_info *psta;
 	s32 i;
 
-_func_enter_;
+_func_enter_;	
 
 	pstapriv->pallocated_stainfo_buf = rtw_zvmalloc (sizeof(struct sta_info) * NUM_STA+ 4);
-
+	
 	if(!pstapriv->pallocated_stainfo_buf)
 		return _FAIL;
 
-	pstapriv->pstainfo_buf = pstapriv->pallocated_stainfo_buf + 4 -
+	pstapriv->pstainfo_buf = pstapriv->pallocated_stainfo_buf + 4 - 
 		((SIZE_PTR)(pstapriv->pallocated_stainfo_buf ) & 3);
 
 	_rtw_init_queue(&pstapriv->free_sta_queue);
 
 	_rtw_spinlock_init(&pstapriv->sta_hash_lock);
-
+	
 	//_rtw_init_queue(&pstapriv->asoc_q);
 	pstapriv->asoc_sta_count = 0;
 	_rtw_init_queue(&pstapriv->sleep_q);
@@ -118,7 +118,7 @@ u32	_rtw_init_sta_priv(struct	sta_priv *pstapriv)
 
 	psta = (struct sta_info *)(pstapriv->pstainfo_buf);
 
-
+		
 	for(i = 0; i < NUM_STA; i++)
 	{
 		_rtw_init_stainfo(psta);
@@ -130,7 +130,7 @@ u32	_rtw_init_sta_priv(struct	sta_priv *pstapriv)
 		psta++;
 	}
 
-
+	
 
 #ifdef CONFIG_AP_MODE
 
@@ -144,7 +144,7 @@ u32	_rtw_init_sta_priv(struct	sta_priv *pstapriv)
 	pstapriv->asoc_list_cnt = 0;
 	pstapriv->auth_list_cnt = 0;
 
-	pstapriv->auth_to = 3; // 3*2 = 6 sec
+	pstapriv->auth_to = 3; // 3*2 = 6 sec 
 	pstapriv->assoc_to = 3;
 	//pstapriv->expire_to = 900;// 900*2 = 1800 sec = 30 min, expire after no any traffic.
 	//pstapriv->expire_to = 30;// 30*2 = 60 sec = 1 min, expire after no any traffic.
@@ -152,15 +152,15 @@ u32	_rtw_init_sta_priv(struct	sta_priv *pstapriv)
 	pstapriv->expire_to = 3; // 3*2 = 6 sec
 #else
 	pstapriv->expire_to = 60;// 60*2 = 120 sec = 2 min, expire after no any traffic.
-#endif
+#endif	
 	pstapriv->max_num_sta = NUM_STA;
-
+		
 #endif
-
-_func_exit_;
+	
+_func_exit_;		
 
 	return _SUCCESS;
-
+	
 }
 
 inline int rtw_stainfo_offset(struct sta_priv *stapriv, struct sta_info *sta)
@@ -192,12 +192,12 @@ void	_rtw_free_sta_xmit_priv_lock(struct sta_xmit_priv *psta_xmitpriv)
 	_rtw_spinlock_free(&(psta_xmitpriv->bk_q.sta_pending.lock));
 	_rtw_spinlock_free(&(psta_xmitpriv->vi_q.sta_pending.lock));
 	_rtw_spinlock_free(&(psta_xmitpriv->vo_q.sta_pending.lock));
-_func_exit_;
+_func_exit_;	
 }
 
 static void	_rtw_free_sta_recv_priv_lock(struct sta_recv_priv *psta_recvpriv)
 {
-_func_enter_;
+_func_enter_;	
 
 	_rtw_spinlock_free(&psta_recvpriv->lock);
 
@@ -217,8 +217,8 @@ void rtw_mfree_stainfo(struct sta_info *psta)
 
 	_rtw_free_sta_xmit_priv_lock(&psta->sta_xmitpriv);
 	_rtw_free_sta_recv_priv_lock(&psta->sta_recvpriv);
-
-_func_exit_;
+	
+_func_exit_;	
 }
 
 
@@ -229,14 +229,14 @@ void rtw_mfree_all_stainfo(struct sta_priv *pstapriv )
 	_irqL	 irqL;
 	_list	*plist, *phead;
 	struct sta_info *psta = NULL;
-
-_func_enter_;
+	
+_func_enter_;	
 
 	_enter_critical_bh(&pstapriv->sta_hash_lock, &irqL);
 
 	phead = get_list_head(&pstapriv->free_sta_queue);
 	plist = get_next(phead);
-
+		
 	while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
 	{
 		psta = LIST_CONTAINOR(plist, struct sta_info ,list);
@@ -244,10 +244,10 @@ void rtw_mfree_all_stainfo(struct sta_priv *pstapriv )
 
 		rtw_mfree_stainfo(psta);
 	}
-
+	
 	_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);
 
-_func_exit_;
+_func_exit_;	
 
 }
 
@@ -285,44 +285,44 @@ u32	_rtw_free_sta_priv(struct	sta_priv *pstapriv)
 _func_enter_;
 	if(pstapriv){
 
-		/*	delete all reordering_ctrl_timer		*/
+		/*	delete all reordering_ctrl_timer		*/ 
 		_enter_critical_bh(&pstapriv->sta_hash_lock, &irqL);
 		for(index = 0; index < NUM_STA; index++)
 		{
 			phead = &(pstapriv->sta_hash[index]);
 			plist = get_next(phead);
-
+			
 			while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
 			{
-				int i;
+				int i;	
 				psta = LIST_CONTAINOR(plist, struct sta_info ,hash_list);
 				plist = get_next(plist);
 
 				for(i=0; i < 16 ; i++)
 				{
 					preorder_ctrl = &psta->recvreorder_ctrl[i];
-					_cancel_timer_ex(&preorder_ctrl->reordering_ctrl_timer);
+					_cancel_timer_ex(&preorder_ctrl->reordering_ctrl_timer);	
 				}
 			}
 		}
 		_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);
 		/*===============================*/
-
+		
 		rtw_mfree_sta_priv_lock(pstapriv);
 
 		if(pstapriv->pallocated_stainfo_buf) {
 			rtw_vmfree(pstapriv->pallocated_stainfo_buf, sizeof(struct sta_info)*NUM_STA+4);
 		}
 	}
-
+	
 _func_exit_;
 	return _SUCCESS;
 }
 
 
 //struct	sta_info *rtw_alloc_stainfo(_queue *pfree_sta_queue, unsigned char *hwaddr)
-struct	sta_info *rtw_alloc_stainfo(struct	sta_priv *pstapriv, u8 *hwaddr)
-{
+struct	sta_info *rtw_alloc_stainfo(struct	sta_priv *pstapriv, u8 *hwaddr) 
+{	
 	_irqL irqL, irqL2;
 	uint tmp_aid;
 	s32	index;
@@ -332,11 +332,11 @@ struct	sta_info *rtw_alloc_stainfo(struct	sta_priv *pstapriv, u8 *hwaddr)
 	struct recv_reorder_ctrl *preorder_ctrl;
 	int i = 0;
 	u16  wRxSeqInitialValue = 0xffff;
-
-_func_enter_;
+	
+_func_enter_;	
 
 	pfree_sta_queue = &pstapriv->free_sta_queue;
-
+	
 	//_enter_critical_bh(&(pfree_sta_queue->lock), &irqL);
 	_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL2);
 
@@ -349,13 +349,13 @@ struct	sta_info *rtw_alloc_stainfo(struct	sta_priv *pstapriv, u8 *hwaddr)
 	else
 	{
 		psta = LIST_CONTAINOR(get_next(&pfree_sta_queue->queue), struct sta_info, list);
-
+		
 		rtw_list_delete(&(psta->list));
 
 		//_exit_critical_bh(&(pfree_sta_queue->lock), &irqL);
-
-		tmp_aid = psta->aid;
-
+		
+		tmp_aid = psta->aid;	
+	
 		_rtw_init_stainfo(psta);
 
 		_rtw_memcpy(psta->hwaddr, hwaddr, ETH_ALEN);
@@ -366,7 +366,7 @@ struct	sta_info *rtw_alloc_stainfo(struct	sta_priv *pstapriv, u8 *hwaddr)
 
 		if(index >= NUM_STA){
 			RT_TRACE(_module_rtl871x_sta_mgt_c_,_drv_err_,("ERROR=> rtw_alloc_stainfo: index >= NUM_STA"));
-			psta= NULL;
+			psta= NULL;	
 			goto exit;
 		}
 		phash_list = &(pstapriv->sta_hash[index]);
@@ -389,7 +389,7 @@ struct	sta_info *rtw_alloc_stainfo(struct	sta_priv *pstapriv, u8 *hwaddr)
                      _rtw_memcpy( &psta->sta_recvpriv.rxcache.tid_rxseq[ i ], &wRxSeqInitialValue, 2 );
 		}
 
-		RT_TRACE(_module_rtl871x_sta_mgt_c_,_drv_info_,("alloc number_%d stainfo  with hwaddr = %x %x %x %x %x %x  \n",
+		RT_TRACE(_module_rtl871x_sta_mgt_c_,_drv_info_,("alloc number_%d stainfo  with hwaddr = %x %x %x %x %x %x  \n", 
 		pstapriv->asoc_sta_count , hwaddr[0], hwaddr[1], hwaddr[2],hwaddr[3],hwaddr[4],hwaddr[5]));
 
 		init_addba_retry_timer(pstapriv->padapter, psta);
@@ -410,15 +410,15 @@ struct	sta_info *rtw_alloc_stainfo(struct	sta_priv *pstapriv, u8 *hwaddr)
 			preorder_ctrl = &psta->recvreorder_ctrl[i];
 
 			preorder_ctrl->padapter = pstapriv->padapter;
-
+		
 			preorder_ctrl->enable = _FALSE;
-
+		
 			preorder_ctrl->indicate_seq = 0xffff;
 			#ifdef DBG_RX_SEQ
 			DBG_871X("DBG_RX_SEQ %s:%d IndicateSeq: %d\n", __FUNCTION__, __LINE__,
 				preorder_ctrl->indicate_seq);
 			#endif
-			preorder_ctrl->wend_b= 0xffff;
+			preorder_ctrl->wend_b= 0xffff;       
 			//preorder_ctrl->wsize_b = (NR_RECVBUFF-2);
 			preorder_ctrl->wsize_b = 64;//64;
 
@@ -431,11 +431,11 @@ struct	sta_info *rtw_alloc_stainfo(struct	sta_priv *pstapriv, u8 *hwaddr)
 		//init for DM
 		psta->rssi_stat.UndecoratedSmoothedPWDB = 0;
 		psta->rssi_stat.UndecoratedSmoothedCCK = (-1);
-
+		
 		/* init for the sequence number of received management frame */
 		psta->RxMgmtFrameSeqNum = 0xffff;
 	}
-
+	
 exit:
 
 	_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL2);
@@ -450,7 +450,7 @@ struct	sta_info *rtw_alloc_stainfo(struct	sta_priv *pstapriv, u8 *hwaddr)
 
 // using pstapriv->sta_hash_lock to protect
 u32	rtw_free_stainfo(_adapter *padapter , struct sta_info *psta)
-{
+{	
 	int i;
 	_irqL irqL0;
 	_queue *pfree_sta_queue;
@@ -459,10 +459,10 @@ u32	rtw_free_stainfo(_adapter *padapter , struct sta_info *psta)
 	struct	xmit_priv	*pxmitpriv= &padapter->xmitpriv;
 	struct	sta_priv *pstapriv = &padapter->stapriv;
 	struct hw_xmit *phwxmit;
+	
 
-
-_func_enter_;
-
+_func_enter_;	
+	
 	if (psta == NULL)
 		goto exit;
 
@@ -475,16 +475,16 @@ u32	rtw_free_stainfo(_adapter *padapter , struct sta_info *psta)
 
 
 	pstaxmitpriv = &psta->sta_xmitpriv;
-
+	
 	//rtw_list_delete(&psta->sleep_list);
-
+	
 	//rtw_list_delete(&psta->wakeup_list);
-
+	
 	_enter_critical_bh(&pxmitpriv->lock, &irqL0);
-
+	
 	rtw_free_xmitframe_queue(pxmitpriv, &psta->sleep_q);
 	psta->sleepq_len = 0;
-
+	
 	//vo
 	//_enter_critical_bh(&(pxmitpriv->vo_pending.lock), &irqL0);
 	rtw_free_xmitframe_queue( pxmitpriv, &pstaxmitpriv->vo_q.sta_pending);
@@ -511,7 +511,7 @@ u32	rtw_free_stainfo(_adapter *padapter , struct sta_info *psta)
 	phwxmit->accnt -= pstaxmitpriv->be_q.qcnt;
 	pstaxmitpriv->be_q.qcnt = 0;
 	//_exit_critical_bh(&(pxmitpriv->be_pending.lock), &irqL0);
-
+	
 	//bk
 	//_enter_critical_bh(&(pxmitpriv->bk_pending.lock), &irqL0);
 	rtw_free_xmitframe_queue( pxmitpriv, &pstaxmitpriv->bk_q.sta_pending);
@@ -520,14 +520,14 @@ u32	rtw_free_stainfo(_adapter *padapter , struct sta_info *psta)
 	phwxmit->accnt -= pstaxmitpriv->bk_q.qcnt;
 	pstaxmitpriv->bk_q.qcnt = 0;
 	//_exit_critical_bh(&(pxmitpriv->bk_pending.lock), &irqL0);
-
+	
 	_exit_critical_bh(&pxmitpriv->lock, &irqL0);
-
+	
 	rtw_list_delete(&psta->hash_list);
 	RT_TRACE(_module_rtl871x_sta_mgt_c_,_drv_err_,("\n free number_%d stainfo  with hwaddr = 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x  \n",pstapriv->asoc_sta_count , psta->hwaddr[0], psta->hwaddr[1], psta->hwaddr[2],psta->hwaddr[3],psta->hwaddr[4],psta->hwaddr[5]));
 	pstapriv->asoc_sta_count --;
-
-
+	
+	
 	// re-init sta_info; 20061114 // will be init in alloc_stainfo
 	//_rtw_init_sta_xmit_priv(&psta->sta_xmitpriv);
 	//_rtw_init_sta_recv_priv(&psta->sta_recvpriv);
@@ -551,32 +551,32 @@ u32	rtw_free_stainfo(_adapter *padapter , struct sta_info *psta)
 		union recv_frame *prframe;
 		_queue *ppending_recvframe_queue;
 		_queue *pfree_recv_queue = &padapter->recvpriv.free_recv_queue;
-
+	
 		preorder_ctrl = &psta->recvreorder_ctrl[i];
+		
+		_cancel_timer_ex(&preorder_ctrl->reordering_ctrl_timer);		
 
-		_cancel_timer_ex(&preorder_ctrl->reordering_ctrl_timer);
-
-
+		
 		ppending_recvframe_queue = &preorder_ctrl->pending_recvframe_queue;
 
 		_enter_critical_bh(&ppending_recvframe_queue->lock, &irqL);
 
 		phead = 	get_list_head(ppending_recvframe_queue);
 		plist = get_next(phead);
-
+		
 		while(!rtw_is_list_empty(phead))
-		{
+		{	
 			prframe = LIST_CONTAINOR(plist, union recv_frame, u);
-
+			
 			plist = get_next(plist);
-
+			
 			rtw_list_delete(&(prframe->u.hdr.list));
 
 			rtw_free_recvframe(prframe, pfree_recv_queue);
 		}
 
 		_exit_critical_bh(&ppending_recvframe_queue->lock, &irqL);
-
+		
 	}
 
 
@@ -584,7 +584,7 @@ u32	rtw_free_stainfo(_adapter *padapter , struct sta_info *psta)
 
 /*
 	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL0);
-	rtw_list_delete(&psta->asoc_list);
+	rtw_list_delete(&psta->asoc_list);	
 	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL0);
 */
 	_enter_critical_bh(&pstapriv->auth_list_lock, &irqL0);
@@ -593,9 +593,9 @@ u32	rtw_free_stainfo(_adapter *padapter , struct sta_info *psta)
 		pstapriv->auth_list_cnt--;
 	}
 	_exit_critical_bh(&pstapriv->auth_list_lock, &irqL0);
-
+	
 	psta->expire_to = 0;
-
+	
 	psta->sleepq_ac_len = 0;
 	psta->qos_info = 0;
 
@@ -608,9 +608,9 @@ u32	rtw_free_stainfo(_adapter *padapter , struct sta_info *psta)
 	psta->has_legacy_ac = 0;
 
 #ifdef CONFIG_NATIVEAP_MLME
-
+	
 	pstapriv->sta_dz_bitmap &=~BIT(psta->aid);
-	pstapriv->tim_bitmap &=~BIT(psta->aid);
+	pstapriv->tim_bitmap &=~BIT(psta->aid);	
 
 	//rtw_indicate_sta_disassoc_event(padapter, psta);
 
@@ -618,15 +618,15 @@ u32	rtw_free_stainfo(_adapter *padapter , struct sta_info *psta)
 	{
 		pstapriv->sta_aid[psta->aid - 1] = NULL;
 		psta->aid = 0;
-	}
+	}	
 
-#endif	// CONFIG_NATIVEAP_MLME
+#endif	// CONFIG_NATIVEAP_MLME	
 
 #ifdef CONFIG_TX_MCAST2UNI
 	psta->under_exist_checking = 0;
 #endif	// CONFIG_TX_MCAST2UNI
 
-#endif	// CONFIG_AP_MODE
+#endif	// CONFIG_AP_MODE	
 
 	 _rtw_spinlock_free(&psta->lock);
 
@@ -635,11 +635,11 @@ u32	rtw_free_stainfo(_adapter *padapter , struct sta_info *psta)
 	//_exit_critical_bh(&(pfree_sta_queue->lock), &irqL0);
 
 exit:
-
-_func_exit_;
+	
+_func_exit_;	
 
 	return _SUCCESS;
-
+	
 }
 
 // free all stainfo which in sta_hash[all]
@@ -651,8 +651,8 @@ void rtw_free_all_stainfo(_adapter *padapter)
 	struct sta_info *psta = NULL;
 	struct	sta_priv *pstapriv = &padapter->stapriv;
 	struct sta_info* pbcmc_stainfo =rtw_get_bcmc_stainfo( padapter);
-
-_func_enter_;
+	
+_func_enter_;	
 
 	if(pstapriv->asoc_sta_count==1)
 		goto exit;
@@ -663,29 +663,29 @@ void rtw_free_all_stainfo(_adapter *padapter)
 	{
 		phead = &(pstapriv->sta_hash[index]);
 		plist = get_next(phead);
-
+		
 		while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
 		{
 			psta = LIST_CONTAINOR(plist, struct sta_info ,hash_list);
 
 			plist = get_next(plist);
 
-			if(pbcmc_stainfo!=psta)
+			if(pbcmc_stainfo!=psta)					
 				rtw_free_stainfo(padapter , psta);
-
+			
 		}
 	}
-
+	
 	_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);
-
-exit:
-
-_func_exit_;
+	
+exit:	
+	
+_func_exit_;	
 
 }
 
 /* any station allocated can be searched by hash list */
-struct sta_info *rtw_get_stainfo(struct sta_priv *pstapriv, const u8 *hwaddr)
+struct sta_info *rtw_get_stainfo(struct sta_priv *pstapriv, u8 *hwaddr)
 {
 
 	_irqL	 irqL;
@@ -693,10 +693,10 @@ struct sta_info *rtw_get_stainfo(struct sta_priv *pstapriv, const u8 *hwaddr)
 	_list	*plist, *phead;
 
 	struct sta_info *psta = NULL;
-
+	
 	u32	index;
 
-	const u8 *addr;
+	u8 *addr;
 
 	u8 bc_addr[ETH_ALEN] = {0xff,0xff,0xff,0xff,0xff,0xff};
 
@@ -704,7 +704,7 @@ struct sta_info *rtw_get_stainfo(struct sta_priv *pstapriv, const u8 *hwaddr)
 
 	if(hwaddr==NULL)
 		return NULL;
-
+		
 	if(IS_MCAST(hwaddr))
 	{
 		addr = bc_addr;
@@ -717,17 +717,17 @@ struct sta_info *rtw_get_stainfo(struct sta_priv *pstapriv, const u8 *hwaddr)
 	index = wifi_mac_hash(addr);
 
 	_enter_critical_bh(&pstapriv->sta_hash_lock, &irqL);
-
+	
 	phead = &(pstapriv->sta_hash[index]);
 	plist = get_next(phead);
 
 
 	while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
 	{
-
+	
 		psta = LIST_CONTAINOR(plist, struct sta_info, hash_list);
-
-		if ((_rtw_memcmp(psta->hwaddr, addr, ETH_ALEN))== _TRUE)
+		
+		if ((_rtw_memcmp(psta->hwaddr, addr, ETH_ALEN))== _TRUE) 
 		{ // if found the matched address
 			break;
 		}
@@ -736,9 +736,9 @@ struct sta_info *rtw_get_stainfo(struct sta_priv *pstapriv, const u8 *hwaddr)
 	}
 
 	_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);
-_func_exit_;
+_func_exit_;	
 	return psta;
-
+	
 }
 
 u32 rtw_init_bcmc_stainfo(_adapter* padapter)
@@ -748,14 +748,14 @@ u32 rtw_init_bcmc_stainfo(_adapter* padapter)
 	struct tx_servq	*ptxservq;
 	u32 res=_SUCCESS;
 	NDIS_802_11_MAC_ADDRESS	bcast_addr= {0xff,0xff,0xff,0xff,0xff,0xff};
-
+	
 	struct	sta_priv *pstapriv = &padapter->stapriv;
-	//_queue	*pstapending = &padapter->xmitpriv.bm_pending;
-
+	//_queue	*pstapending = &padapter->xmitpriv.bm_pending; 
+	
 _func_enter_;
 
 	psta = rtw_alloc_stainfo(pstapriv, bcast_addr);
-
+	
 	if(psta==NULL){
 		res=_FAIL;
 		RT_TRACE(_module_rtl871x_sta_mgt_c_,_drv_err_,("rtw_alloc_stainfo fail"));
@@ -775,9 +775,9 @@ u32 rtw_init_bcmc_stainfo(_adapter* padapter)
 
 	_exit_critical(&pstapending->lock, &irqL0);
 */
-
+	
 exit:
-_func_exit_;
+_func_exit_;		
 	return _SUCCESS;
 
 }
@@ -790,7 +790,7 @@ struct sta_info* rtw_get_bcmc_stainfo(_adapter* padapter)
 	u8 bc_addr[ETH_ALEN] = {0xff,0xff,0xff,0xff,0xff,0xff};
 _func_enter_;
 	 psta = rtw_get_stainfo(pstapriv, bc_addr);
-_func_exit_;
+_func_exit_;		 
 	return psta;
 
 }
@@ -806,10 +806,10 @@ u8 rtw_access_ctrl(_adapter *padapter, u8 *mac_addr)
 	struct sta_priv *pstapriv = &padapter->stapriv;
 	struct wlan_acl_pool *pacl_list = &pstapriv->acl_list;
 	_queue	*pacl_node_q =&pacl_list->acl_node_q;
-
+	
 	_enter_critical_bh(&(pacl_node_q->lock), &irqL);
 	phead = get_list_head(pacl_node_q);
-	plist = get_next(phead);
+	plist = get_next(phead);		
 	while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
 	{
 		paclnode = LIST_CONTAINOR(plist, struct rtw_wlan_acl_node, list);
@@ -822,15 +822,15 @@ u8 rtw_access_ctrl(_adapter *padapter, u8 *mac_addr)
 				match = _TRUE;
 				break;
 			}
-		}
-	}
+		}		
+	}	
 	_exit_critical_bh(&(pacl_node_q->lock), &irqL);
-
+	
 
 	if(pacl_list->mode == 1)//accept unless in deny list
 	{
 		res = (match == _TRUE) ?  _FALSE:_TRUE;
-	}
+	}	
 	else if(pacl_list->mode == 2)//deny unless in accept list
 	{
 		res = (match == _TRUE) ?  _TRUE:_FALSE;
@@ -838,10 +838,11 @@ u8 rtw_access_ctrl(_adapter *padapter, u8 *mac_addr)
 	else
 	{
 		 res = _TRUE;
-	}
-
+	}		
+	
 #endif
 
 	return res;
 
 }
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_tdls.c b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_tdls.c
old mode 100644
new mode 100755
index c99fc01..e8c4d4c
--- a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_tdls.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_tdls.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -141,15 +141,15 @@ s32 update_tdls_attrib(_adapter *padapter, struct pkt_attrib *pattrib)
 	sint bmcast;
 
 	bmcast = IS_MCAST(pattrib->ra);
-
+	
 	psta = rtw_get_stainfo(pstapriv, pattrib->ra);
-	if (psta == NULL)	{
+	if (psta == NULL)	{ 
 		res =_FAIL;
 		goto exit;
 	}
 
 	pattrib->mac_id = psta->mac_id;
-
+				
 	pattrib->psta = psta;
 
 	pattrib->ack_policy = 0;
@@ -162,7 +162,7 @@ s32 update_tdls_attrib(_adapter *padapter, struct pkt_attrib *pattrib)
 		pattrib->subtype = WIFI_QOS_DATA_TYPE;
 	} else {
 		pattrib->hdrlen = WLAN_HDR_A3_LEN;
-		pattrib->subtype = WIFI_DATA_TYPE;
+		pattrib->subtype = WIFI_DATA_TYPE;	
 		pattrib->priority = 0;
 	}
 
@@ -178,7 +178,7 @@ s32 update_tdls_attrib(_adapter *padapter, struct pkt_attrib *pattrib)
 		{
 			case dot11AuthAlgrthm_Open:
 			case dot11AuthAlgrthm_Shared:
-			case dot11AuthAlgrthm_Auto:
+			case dot11AuthAlgrthm_Auto:				
 				pattrib->key_idx = (u8)psecuritypriv->dot11PrivacyKeyIndex;
 				break;
 			case dot11AuthAlgrthm_8021X:
@@ -205,7 +205,7 @@ s32 update_tdls_attrib(_adapter *padapter, struct pkt_attrib *pattrib)
 				res =_FAIL;
 				goto exit;
 			}
-			break;
+			break;			
 		case _AES_:
 			pattrib->iv_len = 8;
 			pattrib->icv_len = 8;
@@ -232,12 +232,12 @@ s32 update_tdls_attrib(_adapter *padapter, struct pkt_attrib *pattrib)
 	pattrib->ch_offset = psta->htpriv.ch_offset;
 	pattrib->sgi= psta->htpriv.sgi;
 	pattrib->ampdu_en = _FALSE;
-
+	
 	//if(pattrib->ht_en && psta->htpriv.ampdu_enable)
 	//{
 	//	if(psta->htpriv.agg_enable_bitmap & BIT(pattrib->priority))
 	//		pattrib->ampdu_en = _TRUE;
-	//}
+	//}	
 
 exit:
 
@@ -247,9 +247,9 @@ s32 update_tdls_attrib(_adapter *padapter, struct pkt_attrib *pattrib)
 void free_tdls_sta(_adapter *padapter, struct sta_info *ptdls_sta)
 {
 	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
-	struct sta_priv *pstapriv = &padapter->stapriv;
+   	struct sta_priv *pstapriv = &padapter->stapriv;
 	_irqL irqL;
-
+	
 	//free peer sta_info
 	_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
 	if(ptdlsinfo->sta_cnt != 0)
@@ -274,7 +274,7 @@ void free_tdls_sta(_adapter *padapter, struct sta_info *ptdls_sta)
 		DBG_871X("Remain tdls sta:%02x\n", ptdlsinfo->sta_cnt);
 
 	rtw_free_stainfo(padapter,  ptdls_sta);
-
+	
 }
 
 // cam entry will be the same as mac_id
@@ -305,11 +305,11 @@ void rtw_tdls_process_ht_cap(_adapter *adapter, struct sta_info *ptdls_sta, u8 *
 	if (data && Length >= sizeof(struct rtw_ieee80211_ht_cap) )
 	{
 		ptdls_sta->flags |= WLAN_STA_HT;
-
+		
 		ptdls_sta->flags |= WLAN_STA_WME;
-
-		_rtw_memcpy(&ptdls_sta->htpriv.ht_cap, data, sizeof(struct rtw_ieee80211_ht_cap));
-
+		
+		_rtw_memcpy(&ptdls_sta->htpriv.ht_cap, data, sizeof(struct rtw_ieee80211_ht_cap));			
+		
 	} else
 		ptdls_sta->flags &= ~WLAN_STA_HT;
 
@@ -366,7 +366,7 @@ u8 *rtw_tdls_set_ht_cap(_adapter *padapter, u8 *pframe, struct pkt_attrib *pattr
 		if(max_recvbuf_sz-rx_packet_offset>(8191-256))
 			ht_capie.cap_info = ht_capie.cap_info |IEEE80211_HT_CAP_MAX_AMSDU;
 	}
-
+	
 	ht_capie.ampdu_params_info = (IEEE80211_HT_CAP_AMPDU_FACTOR&0x03);
 
 	rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
@@ -384,8 +384,8 @@ u8 *rtw_tdls_set_ht_cap(_adapter *padapter, u8 *pframe, struct pkt_attrib *pattr
 			_rtw_memcpy(ht_capie.supp_mcs_set, MCS_rate_2R, 16);
 			break;
 	}
-
-	return(rtw_set_ie(pframe, _HT_CAPABILITY_IE_,
+			
+	return(rtw_set_ie(pframe, _HT_CAPABILITY_IE_, 
 						sizeof(struct rtw_ieee80211_ht_cap), (unsigned char*)&ht_capie, &(pattrib->pktlen)));
 }
 
@@ -403,7 +403,7 @@ u8 *rtw_tdls_set_sup_ch(struct mlme_ext_priv *pmlmeext, u8 *pframe, struct pkt_a
 			sup_ch[idx_5g++] = pmlmeext->channel_set[sup_ch_idx].ChannelNum;
 			sup_ch[idx_5g++] = 1;
 		}
-
+		
 		sup_ch_idx++;
 	}
 	while( pmlmeext->channel_set[sup_ch_idx].ChannelNum != 0 );
@@ -441,7 +441,7 @@ void rtw_tdls_process_wfd_ie(struct tdls_info *ptdlsinfo, u8 *ptr, u8 length)
 		if ( attr_contentlen )
 		{
 			_rtw_memcpy(ptdlsinfo->wfd_info->peer_ip_address, ( attr_content + 1 ), 4);
-			DBG_871X( "[%s] Peer IP = %02u.%02u.%02u.%02u \n", __FUNCTION__,
+			DBG_871X( "[%s] Peer IP = %02u.%02u.%02u.%02u \n", __FUNCTION__, 
 				ptdlsinfo->wfd_info->peer_ip_address[0], ptdlsinfo->wfd_info->peer_ip_address[1],
 				ptdlsinfo->wfd_info->peer_ip_address[2], ptdlsinfo->wfd_info->peer_ip_address[3]
 				);
@@ -456,15 +456,15 @@ void issue_tunneled_probe_req(_adapter *padapter)
 	struct pkt_attrib			*pattrib;
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
-	u8 baddr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+	u8 baddr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff}; 
 
 	DBG_871X("[%s]\n", __FUNCTION__);
-
+	
 	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
 	{
 		return;
 	}
-
+	
 	//update attribute
 	pattrib = &pmgntframe->attrib;
 
@@ -473,7 +473,7 @@ void issue_tunneled_probe_req(_adapter *padapter)
 	pattrib->pctrl =0;
 
 	_rtw_memcpy(pattrib->dst, baddr, ETH_ALEN);
-
+	
 	_rtw_memcpy(pattrib->src, myid(&(padapter->eeprompriv)), ETH_ALEN);
 
 	_rtw_memcpy(pattrib->ra, get_bssid(pmlmepriv), ETH_ALEN);
@@ -502,12 +502,12 @@ void issue_tunneled_probe_rsp(_adapter *padapter, union recv_frame *precv_frame)
 	struct rx_pkt_attrib	*rx_pkt_pattrib = &precv_frame->u.hdr.attrib;
 
 	DBG_871X("[%s]\n", __FUNCTION__);
-
+	
 	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
 	{
 		return;
 	}
-
+	
 	//update attribute
 	pattrib = &pmgntframe->attrib;
 
@@ -516,7 +516,7 @@ void issue_tunneled_probe_rsp(_adapter *padapter, union recv_frame *precv_frame)
 	pattrib->pctrl =0;
 
 	_rtw_memcpy(pattrib->dst, rx_pkt_pattrib->src, ETH_ALEN);
-
+	
 	_rtw_memcpy(pattrib->src, myid(&(padapter->eeprompriv)), ETH_ALEN);
 
 	_rtw_memcpy(pattrib->ra, get_bssid(pmlmepriv), ETH_ALEN);
@@ -544,7 +544,7 @@ void issue_tdls_setup_req(_adapter *padapter, u8 *mac_addr)
 	struct pkt_attrib			*pattrib;
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
-	struct sta_priv *pstapriv = &padapter->stapriv;
+   	struct sta_priv *pstapriv = &padapter->stapriv;
 	struct sta_info *ptdls_sta= NULL;
 	_irqL irqL;
 	static u8 dialogtoken = 0;
@@ -557,13 +557,13 @@ void issue_tdls_setup_req(_adapter *padapter, u8 *mac_addr)
 	{
 		return;
 	}
-
+	
 	//update attribute
 	pattrib = &pmgntframe->attrib;
 
 	pmgntframe->frame_tag = DATA_FRAMETAG;
 	pattrib->ether_type = 0x890d;
-	pattrib->pctrl =0;
+	pattrib->pctrl =0;		
 
 	_rtw_memcpy(pattrib->dst, mac_addr, ETH_ALEN);
 	_rtw_memcpy(pattrib->src, myid(&(padapter->eeprompriv)), ETH_ALEN);
@@ -580,10 +580,10 @@ void issue_tdls_setup_req(_adapter *padapter, u8 *mac_addr)
 		ptdls_sta = rtw_alloc_stainfo(pstapriv, mac_addr);
 		if(ptdls_sta)
 		{
-			_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+			_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);	
 			if(!(ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE))
 				ptdlsinfo->sta_cnt++;
-			_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+			_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);	
 			if( ptdlsinfo->sta_cnt == (NUM_STA - 2) )	// -2: AP + BC/MC sta
 			{
 				ptdlsinfo->sta_maximum  = _TRUE;
@@ -596,8 +596,8 @@ void issue_tdls_setup_req(_adapter *padapter, u8 *mac_addr)
 			goto exit;
 		}
 	}
-
-	if(ptdls_sta){
+	
+	if(ptdls_sta){	
 		ptdls_sta->tdls_sta_state |= TDLS_RESPONDER_STATE;
 		//for tdls; ptdls_sta->aid is used to fill dialogtoken
 		ptdls_sta->dialog = dialogtoken;
@@ -641,7 +641,7 @@ void issue_tdls_teardown(_adapter *padapter, u8 *mac_addr)
 	{
 		return;
 	}
-
+	
 	//update attribute
 	pattrib = &pmgntframe->attrib;
 
@@ -667,7 +667,7 @@ void issue_tdls_teardown(_adapter *padapter, u8 *mac_addr)
 	if(ptdls_sta->tdls_sta_state & TDLS_CH_SWITCH_ON_STATE){
 		rtw_tdls_cmd(padapter, ptdls_sta->hwaddr, TDLS_CS_OFF);
 	}
-
+	
 	if( ptdls_sta->timer_flag == 1 )
 	{
 		_enter_critical_bh(&(padapter->tdlsinfo.hdl_lock), &irqL);
@@ -689,13 +689,13 @@ void issue_tdls_dis_req(_adapter *padapter, u8 *mac_addr)
 	struct pkt_attrib			*pattrib;
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
-	u8 baddr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
-
+	u8 baddr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff}; 
+	
 	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
 	{
 		return;
 	}
-
+	
 	//update attribute
 	pattrib = &pmgntframe->attrib;
 
@@ -707,7 +707,7 @@ void issue_tdls_dis_req(_adapter *padapter, u8 *mac_addr)
 		_rtw_memcpy(pattrib->dst, baddr, ETH_ALEN);
 	else
 		_rtw_memcpy(pattrib->dst, mac_addr, ETH_ALEN);
-
+	
 	_rtw_memcpy(pattrib->src, myid(&(padapter->eeprompriv)), ETH_ALEN);
 
 	_rtw_memcpy(pattrib->ra, get_bssid(pmlmepriv), ETH_ALEN);
@@ -742,7 +742,7 @@ void issue_tdls_setup_rsp(_adapter *padapter, union recv_frame *precv_frame)
 	{
 		return;
 	}
-
+	
 	//update attribute
 	pattrib = &pmgntframe->attrib;
 
@@ -781,12 +781,12 @@ void issue_tdls_setup_cfm(_adapter *padapter, union recv_frame *precv_frame)
 	_irqL irqL;
 
 	struct rx_pkt_attrib	*rx_pkt_pattrib = & precv_frame->u.hdr.attrib;
-
+	
 	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
 	{
 		return;
 	}
-
+	
 	//update attribute
 	pattrib = &pmgntframe->attrib;
 
@@ -805,7 +805,7 @@ void issue_tdls_setup_cfm(_adapter *padapter, union recv_frame *precv_frame)
 	if (rtw_xmit_tdls_coalesce(padapter, pmgntframe, TDLS_SETUP_CONFIRM) != _SUCCESS) {
 		rtw_free_xmitbuf(pxmitpriv, pmgntframe->pxmitbuf);
 		rtw_free_xmitframe(pxmitpriv, pmgntframe);
-		goto exit;
+		goto exit;		
 	}
 
 	rtw_dump_xframe(padapter, pmgntframe);
@@ -849,20 +849,20 @@ void issue_tdls_dis_rsp(_adapter *padapter, union recv_frame *precv_frame, u8 di
 	//	unicast probe request frame
 	_rtw_memcpy(pwlanhdr->addr1, rx_pkt_pattrib->src, ETH_ALEN);
 	_rtw_memcpy(pattrib->dst, pwlanhdr->addr1, ETH_ALEN);
-
+	
 	_rtw_memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);
 	_rtw_memcpy(pattrib->src, pwlanhdr->addr2, ETH_ALEN);
 
 	_rtw_memcpy(pwlanhdr->addr3, rx_pkt_pattrib->bssid, ETH_ALEN);
 	_rtw_memcpy(pattrib->ra, pwlanhdr->addr3, ETH_ALEN);
-
+	
 	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
 	pmlmeext->mgnt_seq++;
 	SetFrameSubType(pframe, WIFI_ACTION);
 
 	pframe += sizeof (struct rtw_ieee80211_hdr_3addr);
 	pattrib->pktlen = sizeof (struct rtw_ieee80211_hdr_3addr);
-
+	
 	rtw_build_tdls_dis_rsp_ies(padapter, pmgntframe, pframe, dialog);
 
 	pattrib->nr_frags = 1;
@@ -881,12 +881,12 @@ void issue_tdls_peer_traffic_indication(_adapter *padapter, struct sta_info *ptd
 	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
 
 	static u8 dialogtoken=0;
-
+	
 	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
 	{
 		return;
 	}
-
+	
 	//update attribute
 	pattrib = &pmgntframe->attrib;
 
@@ -904,7 +904,7 @@ void issue_tdls_peer_traffic_indication(_adapter *padapter, struct sta_info *ptd
 	ptdls_sta->dialog = dialogtoken;
 	dialogtoken = (dialogtoken+1)%256;
 	//PTI frame's priority should be AC_VO
-	pattrib->priority = 7;
+	pattrib->priority = 7; 
 
 	update_tdls_attrib(padapter, pattrib);
 	pattrib->qsel=pattrib->priority;
@@ -914,7 +914,7 @@ void issue_tdls_peer_traffic_indication(_adapter *padapter, struct sta_info *ptd
 		goto exit;
 	}
 	rtw_dump_xframe(padapter, pmgntframe);
-
+	
 exit:
 
 	return;
@@ -931,13 +931,13 @@ void issue_tdls_ch_switch_req(_adapter *padapter, u8 *mac_addr)
 	{
 		return;
 	}
-
+	
 	//update attribute
 	pattrib = &pmgntframe->attrib;
 
 	pmgntframe->frame_tag = DATA_FRAMETAG;
 	pattrib->ether_type = 0x890d;
-	pattrib->pctrl =0;
+	pattrib->pctrl =0;		
 
 	_rtw_memcpy(pattrib->dst, mac_addr, ETH_ALEN);
 	_rtw_memcpy(pattrib->src, myid(&(padapter->eeprompriv)), ETH_ALEN);
@@ -967,19 +967,19 @@ void issue_tdls_ch_switch_rsp(_adapter *padapter, u8 *mac_addr)
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 	struct xmit_priv	*pxmitpriv = &(padapter->xmitpriv);
 
-        _irqL irqL;
-
+        _irqL irqL;	
+		
 	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
 	{
 		return;
 	}
-
+	
 	//update attribute
 	pattrib = &pmgntframe->attrib;
 
 	pmgntframe->frame_tag = DATA_FRAMETAG;
 	pattrib->ether_type = 0x890d;
-	pattrib->pctrl =0;
+	pattrib->pctrl =0;		
 
 	_rtw_memcpy(pattrib->dst, mac_addr, ETH_ALEN);
 	_rtw_memcpy(pattrib->src, myid(&(padapter->eeprompriv)), ETH_ALEN);
@@ -1000,7 +1000,7 @@ void issue_tdls_ch_switch_rsp(_adapter *padapter, u8 *mac_addr)
 	if(rtw_xmit_tdls_coalesce(padapter, pmgntframe, TDLS_CHANNEL_SWITCH_RESPONSE) !=_SUCCESS ){
 		rtw_free_xmitbuf(pxmitpriv,pmgntframe->pxmitbuf);
 		rtw_free_xmitframe(pxmitpriv, pmgntframe);
-		goto exit;
+		goto exit;	
 	}
 	rtw_dump_xframe(padapter, pmgntframe);
 
@@ -1018,12 +1018,12 @@ sint On_TDLS_Dis_Rsp(_adapter *adapter, union recv_frame *precv_frame)
 	struct tdls_info *ptdlsinfo = &(adapter->tdlsinfo);
 	u8 empty_addr[ETH_ALEN] = { 0x00 };
 	int UndecoratedSmoothedPWDB;
-
+	
 
 	//WFDTDLS: for sigma test, not to setup direct link automatically
 	ptdlsinfo->dev_discovered = 1;
-
-#ifdef CONFIG_TDLS_AUTOSETUP
+	
+#ifdef CONFIG_TDLS_AUTOSETUP	
 	psa = get_sa(ptr);
 	ptdls_sta = rtw_get_stainfo(&(adapter->stapriv), psa);
 
@@ -1090,7 +1090,7 @@ sint On_TDLS_Setup_Req(_adapter *adapter, union recv_frame *precv_frame)
 	struct tdls_info *ptdlsinfo = &adapter->tdlsinfo;
 	u8 *psa, *pmyid;
 	struct sta_info *ptdls_sta= NULL;
-	struct sta_priv *pstapriv = &adapter->stapriv;
+   	struct sta_priv *pstapriv = &adapter->stapriv;
 	u8 *ptr = precv_frame->u.hdr.rx_data;
 	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
 	struct security_priv *psecuritypriv = &adapter->securitypriv;
@@ -1157,7 +1157,7 @@ sint On_TDLS_Setup_Req(_adapter *adapter, union recv_frame *precv_frame)
 		}
 	}
 
-	if(ptdls_sta)
+	if(ptdls_sta) 
 	{
 		ptdls_sta->dialog = *(ptr+2);	//copy dialog token
 		ptdls_sta->stat_code = 0;
@@ -1232,10 +1232,10 @@ sint On_TDLS_Setup_Req(_adapter *adapter, union recv_frame *precv_frame)
 			}
 
 			j += (pIE->Length + 2);
-
+			
 		}
 
-		//update station supportRate
+		//update station supportRate	
 		ptdls_sta->bssratelen = supportRateNum;
 		_rtw_memcpy(ptdls_sta->bssrateset, supportRate, supportRateNum);
 
@@ -1269,10 +1269,10 @@ sint On_TDLS_Setup_Req(_adapter *adapter, union recv_frame *precv_frame)
 			_rtw_memcpy(ptdls_sta->SNonce, SNonce, 32);
 			_rtw_memcpy(&(ptdls_sta->TDLS_PeerKey_Lifetime), timeout_interval, 4);
 		}
-		_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+		_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);		
 		if(!(ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE))
 			ptdlsinfo->sta_cnt++;
-		_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
+		_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);	
 		if( ptdlsinfo->sta_cnt == (NUM_STA - 2) )	// -2: AP + BC/MC sta
 		{
 			ptdlsinfo->sta_maximum = _TRUE;
@@ -1288,7 +1288,7 @@ sint On_TDLS_Setup_Req(_adapter *adapter, union recv_frame *precv_frame)
 		goto exit;
 	}
 
-	issue_tdls_setup_rsp(adapter, precv_frame);
+ 	issue_tdls_setup_rsp(adapter, precv_frame);
 
 	if(ptdls_sta->stat_code==0)
 	{
@@ -1298,9 +1298,9 @@ sint On_TDLS_Setup_Req(_adapter *adapter, union recv_frame *precv_frame)
 	{
 		free_tdls_sta(adapter, ptdls_sta);
 	}
-
+		
 exit:
-
+	
 	return _FAIL;
 }
 
@@ -1308,7 +1308,7 @@ sint On_TDLS_Setup_Rsp(_adapter *adapter, union recv_frame *precv_frame)
 {
 	struct tdls_info *ptdlsinfo = &adapter->tdlsinfo;
 	struct sta_info *ptdls_sta= NULL;
-	struct sta_priv *pstapriv = &adapter->stapriv;
+   	struct sta_priv *pstapriv = &adapter->stapriv;
 	u8 *ptr = precv_frame->u.hdr.rx_data;
 	_irqL irqL;
 	struct rx_pkt_attrib	*prx_pkt_attrib = &precv_frame->u.hdr.attrib;
@@ -1342,7 +1342,7 @@ sint On_TDLS_Setup_Rsp(_adapter *adapter, union recv_frame *precv_frame)
 			-FIXED_IE;
 
 	_rtw_memcpy(&stat_code, ptr+2, 2);
-
+	
 	if(stat_code!=0)
 	{
 		DBG_871X( "[%s] status_code = %d, free_tdls_sta\n", __FUNCTION__, stat_code );
@@ -1409,10 +1409,10 @@ sint On_TDLS_Setup_Rsp(_adapter *adapter, union recv_frame *precv_frame)
 		}
 
 		j += (pIE->Length + 2);
-
+		
 	}
 
-	//update station supportRate
+	//update station supportRate	
 	ptdls_sta->bssratelen = supportRateNum;
 	_rtw_memcpy(ptdls_sta->bssrateset, supportRate, supportRateNum);
 
@@ -1483,11 +1483,11 @@ sint On_TDLS_Setup_Cfm(_adapter *adapter, union recv_frame *precv_frame)
 {
 	struct tdls_info *ptdlsinfo = &adapter->tdlsinfo;
 	struct sta_info *ptdls_sta= NULL;
-	struct sta_priv *pstapriv = &adapter->stapriv;
+   	struct sta_priv *pstapriv = &adapter->stapriv;
 	u8 *ptr = precv_frame->u.hdr.rx_data;
 	_irqL irqL;
 	struct rx_pkt_attrib	*prx_pkt_attrib = &precv_frame->u.hdr.attrib;
-	u8 *psa;
+	u8 *psa; 
 	u16 stat_code;
 	sint parsing_length;
 	PNDIS_802_11_VARIABLE_IEs	pIE;
@@ -1528,7 +1528,7 @@ sint On_TDLS_Setup_Cfm(_adapter *adapter, union recv_frame *precv_frame)
 					break;
 				case _VENDOR_SPECIFIC_IE_:
 					break;
-				case _FTIE_:
+	 			case _FTIE_:
 					pftie=(u8*)pIE;
 					break;
 				case _TIMEOUT_ITVL_IE_:
@@ -1536,7 +1536,7 @@ sint On_TDLS_Setup_Cfm(_adapter *adapter, union recv_frame *precv_frame)
 					break;
 				case _HT_EXTRA_INFO_IE_:
 					break;
-				case _LINK_ID_IE_:
+	 			case _LINK_ID_IE_:
 					plinkid_ie=(u8*)pIE;
 					break;
 				default:
@@ -1544,7 +1544,7 @@ sint On_TDLS_Setup_Cfm(_adapter *adapter, union recv_frame *precv_frame)
 			}
 
 			j += (pIE->Length + 2);
-
+			
 		}
 
 		//verify mic in FTIE MIC field
@@ -1569,7 +1569,7 @@ sint On_TDLS_Setup_Cfm(_adapter *adapter, union recv_frame *precv_frame)
 	rtw_tdls_set_key(adapter, prx_pkt_attrib, ptdls_sta);
 
 	rtw_tdls_cmd(adapter, ptdls_sta->hwaddr, TDLS_WRCR);
-
+	
 	return _FAIL;
 
 }
@@ -1621,7 +1621,7 @@ sint On_TDLS_Dis_Req(_adapter *adapter, union recv_frame *precv_frame)
 		}
 
 		j += (pIE->Length + 2);
-
+		
 	}
 
 	//check frame contents
@@ -1631,7 +1631,7 @@ sint On_TDLS_Dis_Req(_adapter *adapter, union recv_frame *precv_frame)
 exit:
 
 	return _FAIL;
-
+	
 }
 
 sint On_TDLS_Teardown(_adapter *adapter, union recv_frame *precv_frame)
@@ -1639,7 +1639,7 @@ sint On_TDLS_Teardown(_adapter *adapter, union recv_frame *precv_frame)
 	u8 *psa;
 	u8 *ptr = precv_frame->u.hdr.rx_data;
 	struct rx_pkt_attrib	*prx_pkt_attrib = &precv_frame->u.hdr.attrib;
-	struct mlme_ext_priv	*pmlmeext = &(adapter->mlmeextpriv);
+	struct mlme_ext_priv	*pmlmeext = &(adapter->mlmeextpriv);	
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct sta_priv 	*pstapriv = &adapter->stapriv;
 	struct sta_info *ptdls_sta= NULL;
@@ -1654,9 +1654,9 @@ sint On_TDLS_Teardown(_adapter *adapter, union recv_frame *precv_frame)
 		}
 		free_tdls_sta(adapter, ptdls_sta);
 	}
-
+		
 	return _FAIL;
-
+	
 }
 
 u8 TDLS_check_ch_state(uint state){
@@ -1683,7 +1683,7 @@ sint On_TDLS_Peer_Traffic_Rsp(_adapter *adapter, union recv_frame *precv_frame)
 	struct sta_info *ptdls_sta = rtw_get_stainfo(pstapriv, pattrib->src);
 	u8 wmmps_ac=0, state=TDLS_check_ch_state(ptdls_sta->tdls_sta_state);
 	int i;
-
+	
 	ptdls_sta->sta_stats.rx_data_pkts++;
 
 	//receive peer traffic response frame, sleeping STA wakes up
@@ -1706,18 +1706,18 @@ sint On_TDLS_Peer_Traffic_Rsp(_adapter *adapter, union recv_frame *precv_frame)
 	if(ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE){
 		if(wmmps_ac && state)
 		{
-			_irqL irqL;
+			_irqL irqL;	 
 			_list	*xmitframe_plist, *xmitframe_phead;
 			struct xmit_frame *pxmitframe=NULL;
-
-			_enter_critical_bh(&ptdls_sta->sleep_q.lock, &irqL);
+		
+			_enter_critical_bh(&ptdls_sta->sleep_q.lock, &irqL);	
 
 			xmitframe_phead = get_list_head(&ptdls_sta->sleep_q);
 			xmitframe_plist = get_next(xmitframe_phead);
 
 			//transmit buffered frames
 			while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == _FALSE)
-			{
+			{			
 				pxmitframe = LIST_CONTAINOR(xmitframe_plist, struct xmit_frame, list);
 				xmitframe_plist = get_next(xmitframe_plist);
 				rtw_list_delete(&pxmitframe->list);
@@ -1732,7 +1732,7 @@ sint On_TDLS_Peer_Traffic_Rsp(_adapter *adapter, union recv_frame *precv_frame)
 				}
 				//pxmitframe->attrib.triggered = 1;	//maybe doesn't need in TDLS
 				if(rtw_hal_xmit(adapter, pxmitframe) == _TRUE)
-				{
+				{		
 					rtw_os_xmit_complete(adapter, pxmitframe);
 				}
 
@@ -1751,16 +1751,16 @@ sint On_TDLS_Peer_Traffic_Rsp(_adapter *adapter, union recv_frame *precv_frame)
 						issue_tdls_ch_switch_req(adapter, pattrib->src);
 						DBG_871X("issue tdls ch switch req back to base channel\n");
 				}
-
+				
 			}
 			else
 			{
 				DBG_871X("error!psta->sleepq_len=%d\n", ptdls_sta->sleepq_len);
-				ptdls_sta->sleepq_len=0;
+				ptdls_sta->sleepq_len=0;						
 			}
 
-			_exit_critical_bh(&ptdls_sta->sleep_q.lock, &irqL);
-
+			_exit_critical_bh(&ptdls_sta->sleep_q.lock, &irqL);			
+		
 		}
 
 	}
@@ -1771,10 +1771,10 @@ sint On_TDLS_Peer_Traffic_Rsp(_adapter *adapter, union recv_frame *precv_frame)
 sint On_TDLS_Ch_Switch_Req(_adapter *adapter, union recv_frame *precv_frame)
 {
 	struct sta_info *ptdls_sta= NULL;
-	struct sta_priv *pstapriv = &adapter->stapriv;
+   	struct sta_priv *pstapriv = &adapter->stapriv;
 	u8 *ptr = precv_frame->u.hdr.rx_data;
 	struct rx_pkt_attrib	*prx_pkt_attrib = &precv_frame->u.hdr.attrib;
-	u8 *psa;
+	u8 *psa; 
 	sint parsing_length;
 	PNDIS_802_11_VARIABLE_IEs	pIE;
 	u8 FIXED_IE =3;
@@ -1783,7 +1783,7 @@ sint On_TDLS_Ch_Switch_Req(_adapter *adapter, union recv_frame *precv_frame)
 
 	psa = get_sa(ptr);
 	ptdls_sta = rtw_get_stainfo(pstapriv, psa);
-
+	
 	ptr +=prx_pkt_attrib->hdrlen + prx_pkt_attrib->iv_len+LLC_HEADER_SIZE+TYPE_LENGTH_FIELD_SIZE+1;
 	parsing_length= ((union recv_frame *)precv_frame)->u.hdr.len
 			-prx_pkt_attrib->hdrlen
@@ -1795,7 +1795,7 @@ sint On_TDLS_Ch_Switch_Req(_adapter *adapter, union recv_frame *precv_frame)
 			-FIXED_IE;
 
 	ptdls_sta->off_ch = *(ptr+2);
-
+	
 	//parsing information element
 	for(j=FIXED_IE; j<parsing_length;){
 
@@ -1807,7 +1807,7 @@ sint On_TDLS_Ch_Switch_Req(_adapter *adapter, union recv_frame *precv_frame)
 				break;
 			case _CH_SWTICH_ANNOUNCE_:
 				break;
-			case _LINK_ID_IE_:
+ 			case _LINK_ID_IE_:
 				break;
 			case _CH_SWITCH_TIMING_:
 				_rtw_memcpy(&ptdls_sta->ch_switch_time, pIE->data, 2);
@@ -1817,7 +1817,7 @@ sint On_TDLS_Ch_Switch_Req(_adapter *adapter, union recv_frame *precv_frame)
 		}
 
 		j += (pIE->Length + 2);
-
+		
 	}
 
 	//todo: check status
@@ -1834,7 +1834,7 @@ sint On_TDLS_Ch_Switch_Req(_adapter *adapter, union recv_frame *precv_frame)
 		DBG_871X("back to base channel %x\n", pmlmeext->cur_channel);
 		ptdls_sta->option=7;
 		rtw_tdls_cmd(adapter, ptdls_sta->hwaddr, TDLS_BASE_CH);
-	}else{
+	}else{		
 		ptdls_sta->option=6;
 		rtw_tdls_cmd(adapter, ptdls_sta->hwaddr, TDLS_OFF_CH);
 	}
@@ -1844,10 +1844,10 @@ sint On_TDLS_Ch_Switch_Req(_adapter *adapter, union recv_frame *precv_frame)
 sint On_TDLS_Ch_Switch_Rsp(_adapter *adapter, union recv_frame *precv_frame)
 {
 	struct sta_info *ptdls_sta= NULL;
-	struct sta_priv *pstapriv = &adapter->stapriv;
+   	struct sta_priv *pstapriv = &adapter->stapriv;
 	u8 *ptr = precv_frame->u.hdr.rx_data;
 	struct rx_pkt_attrib	*prx_pkt_attrib = &precv_frame->u.hdr.attrib;
-	u8 *psa;
+	u8 *psa; 
 	sint parsing_length;
 	PNDIS_802_11_VARIABLE_IEs	pIE;
 	u8 FIXED_IE =4;
@@ -1874,7 +1874,7 @@ sint On_TDLS_Ch_Switch_Rsp(_adapter *adapter, union recv_frame *precv_frame)
 	//avoiding duplicated or unconditional ch. switch. rsp
 	if((ptdls_sta->tdls_sta_state & TDLS_CH_SW_INITIATOR_STATE) != TDLS_CH_SW_INITIATOR_STATE)
 		return _FAIL;
-
+	
 	ptr +=prx_pkt_attrib->hdrlen + prx_pkt_attrib->iv_len+LLC_HEADER_SIZE+TYPE_LENGTH_FIELD_SIZE+1;
 	parsing_length= ((union recv_frame *)precv_frame)->u.hdr.len
 			-prx_pkt_attrib->hdrlen
@@ -1890,7 +1890,7 @@ sint On_TDLS_Ch_Switch_Rsp(_adapter *adapter, union recv_frame *precv_frame)
 	if(stat_code!=0){
 		return _FAIL;
 	}
-
+	
 	//parsing information element
 	for(j=FIXED_IE; j<parsing_length;){
 
@@ -1898,7 +1898,7 @@ sint On_TDLS_Ch_Switch_Rsp(_adapter *adapter, union recv_frame *precv_frame)
 
 		switch (pIE->ElementID)
 		{
-			case _LINK_ID_IE_:
+ 			case _LINK_ID_IE_:
 				break;
 			case _CH_SWITCH_TIMING_:
 				_rtw_memcpy(&switch_time, pIE->data, 2);
@@ -1914,7 +1914,7 @@ sint On_TDLS_Ch_Switch_Rsp(_adapter *adapter, union recv_frame *precv_frame)
 		}
 
 		j += (pIE->Length + 2);
-
+		
 	}
 
 	ptdls_sta->tdls_sta_state &= ~(TDLS_CH_SW_INITIATOR_STATE);
@@ -1924,7 +1924,7 @@ sint On_TDLS_Ch_Switch_Rsp(_adapter *adapter, union recv_frame *precv_frame)
 	ptdls_sta->option=6;
 	rtw_tdls_cmd(adapter, ptdls_sta->hwaddr, TDLS_OFF_CH);
 
-	return _FAIL;
+	return _FAIL;	
 }
 
 #ifdef CONFIG_WFD
@@ -1960,7 +1960,7 @@ void wfd_ie_tdls(_adapter * padapter, u8 *pframe, u32 *pktlen )
 	//	Value1:
 	//	WFD device information
 	//	available for WFD session + Preferred TDLS + WSD ( WFD Service Discovery )
-	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_SESSION_AVAIL
+	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_SESSION_AVAIL 
 								| WFD_DEVINFO_PC_TDLS | WFD_DEVINFO_WSD);
 	wfdielen += 2;
 
@@ -2006,14 +2006,14 @@ void wfd_ie_tdls(_adapter * padapter, u8 *pframe, u32 *pktlen )
 
 	//	Version:
 	//	0x01: Version1;IPv4
-	wfdie[ wfdielen++ ] = 0x01;
+	wfdie[ wfdielen++ ] = 0x01;	
 
 	//	IPv4 Address
 	_rtw_memcpy( wfdie + wfdielen, pwfd_info->ip_address, 4 );
 	wfdielen += 4;
-
+	
 	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *) wfdie, pktlen);
-
+	
 }
 #endif //CONFIG_WFD
 
@@ -2029,7 +2029,7 @@ void rtw_build_tdls_setup_req_ies(_adapter * padapter, struct xmit_frame * pxmit
 	u8 category = RTW_WLAN_CATEGORY_TDLS;
 	u8 action = TDLS_SETUP_REQUEST;
 	u8 bssrate[NDIS_802_11_LENGTH_RATES_EX]; //Use NDIS_802_11_LENGTH_RATES_EX in order to call func.rtw_set_supported_rate
-	int	bssrate_len = 0, i = 0 ;
+ 	int	bssrate_len = 0, i = 0 ;
 	u8 more_supportedrates = 0;
 	unsigned int ie_len;
 	u8 *p;
@@ -2040,7 +2040,7 @@ void rtw_build_tdls_setup_req_ies(_adapter * padapter, struct xmit_frame * pxmit
 	u8 timeout_itvl[5];	//set timeout interval to maximum value
 	u32 time;
 
-	//SNonce
+	//SNonce	
 	if(pattrib->encrypt){
 		for(i=0;i<8;i++){
 			time=rtw_get_current_time();
@@ -2085,14 +2085,14 @@ void rtw_build_tdls_setup_req_ies(_adapter * padapter, struct xmit_frame * pxmit
 
 	//supported channels
 	pframe = rtw_tdls_set_sup_ch(pmlmeext, pframe, pattrib);
-
+	
 	//	SRC IE
 	pframe = rtw_set_ie( pframe, _SRC_IE_, 16, TDLS_SRC, &(pattrib->pktlen));
-
+	
 	//RSNIE
 	if(pattrib->encrypt)
 		pframe = rtw_set_ie(pframe, _RSN_IE_2_, 20, TDLS_RSNIE, &(pattrib->pktlen));
-
+	
 	//extended capabilities
 	pframe = rtw_set_ie(pframe, _EXT_CAP_IE_ , 5, TDLS_EXT_CAPIE, &(pattrib->pktlen));
 
@@ -2123,7 +2123,7 @@ void rtw_build_tdls_setup_req_ies(_adapter * padapter, struct xmit_frame * pxmit
 	if(pmlmepriv->num_FortyMHzIntolerant>0)
 		iedata |= BIT(2);//20 MHz BSS Width Request
 	pframe = rtw_set_ie(pframe, EID_BSSCoexistence,  1, &iedata, &(pattrib->pktlen));
-
+	
 	//Link identifier
 	_rtw_memcpy(link_id_addr, pattrib->ra, 6);
 	_rtw_memcpy((link_id_addr+6), pattrib->src, 6);
@@ -2144,10 +2144,10 @@ void rtw_build_tdls_setup_rsp_ies(_adapter * padapter, struct xmit_frame * pxmit
 	struct sta_info *ptdls_sta;
 	struct registry_priv	*pregistrypriv = &padapter->registrypriv;
 
-	u8 payload_type = 0x02;
+	u8 payload_type = 0x02;	
 	unsigned char category = RTW_WLAN_CATEGORY_TDLS;
 	unsigned char action = TDLS_SETUP_RESPONSE;
-	unsigned char	bssrate[NDIS_802_11_LENGTH_RATES_EX];
+	unsigned char	bssrate[NDIS_802_11_LENGTH_RATES_EX];	
 	int	bssrate_len = 0;
 	u8 more_supportedrates = 0;
 	unsigned int ie_len;
@@ -2177,7 +2177,7 @@ void rtw_build_tdls_setup_rsp_ies(_adapter * padapter, struct xmit_frame * pxmit
 	}
 
 	//payload type
-	pframe = rtw_set_fixed_ie(pframe, 1, &(payload_type), &(pattrib->pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 1, &(payload_type), &(pattrib->pktlen));	
 	//category, action, status code
 	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
@@ -2185,10 +2185,10 @@ void rtw_build_tdls_setup_rsp_ies(_adapter * padapter, struct xmit_frame * pxmit
 
 	if(ptdls_sta->stat_code!=0)	//invalid setup request
 	{
-		DBG_871X("ptdls_sta->stat_code:%04x \n", ptdls_sta->stat_code);
+		DBG_871X("ptdls_sta->stat_code:%04x \n", ptdls_sta->stat_code);		
 		return;
 	}
-
+	
 	//dialog token
 	pframe = rtw_set_fixed_ie(pframe, 1, &(ptdls_sta->dialog), &(pattrib->pktlen));
 
@@ -2222,7 +2222,7 @@ void rtw_build_tdls_setup_rsp_ies(_adapter * padapter, struct xmit_frame * pxmit
 
 	//supported channels
 	pframe = rtw_tdls_set_sup_ch(pmlmeext, pframe, pattrib);
-
+	
 	// SRC IE
 	pframe = rtw_set_ie(pframe, _SRC_IE_ , 16, TDLS_SRC, &(pattrib->pktlen));
 
@@ -2293,7 +2293,7 @@ void rtw_build_tdls_setup_cfm_ies(_adapter * padapter, struct xmit_frame * pxmit
 	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
 	struct sta_info *ptdls_sta=rtw_get_stainfo( (&padapter->stapriv) , pattrib->dst);
 
-	u8 payload_type = 0x02;
+	u8 payload_type = 0x02;	
 	unsigned char category = RTW_WLAN_CATEGORY_TDLS;
 	unsigned char action = TDLS_SETUP_CONFIRM;
 	u8 more_supportedrates = 0;
@@ -2314,13 +2314,13 @@ void rtw_build_tdls_setup_cfm_ies(_adapter * padapter, struct xmit_frame * pxmit
 
 	if(ptdls_sta->stat_code!=0)	//invalid setup request
 		return;
-
+	
 	//RSNIE
 	if(pattrib->encrypt){
 		prsnie = pframe;
 		pframe = rtw_set_ie(pframe, _RSN_IE_2_, 20, TDLS_RSNIE, &(pattrib->pktlen));
 	}
-
+	
 	//EDCA param set; WMM param ele.
 	if(pattrib->encrypt){
 		//FTIE
@@ -2365,19 +2365,19 @@ void rtw_build_tdls_teardown_ies(_adapter * padapter, struct xmit_frame * pxmitf
 	unsigned char category = RTW_WLAN_CATEGORY_TDLS;
 	unsigned char action = TDLS_TEARDOWN;
 	u8	link_id_addr[18] = {0};
-
+	
 	struct sta_info *ptdls_sta = rtw_get_stainfo( &(padapter->stapriv) , pattrib->dst);
 	struct sta_priv 	*pstapriv = &padapter->stapriv;
 
 	//payload type
-	pframe = rtw_set_fixed_ie(pframe, 1, &(payload_type), &(pattrib->pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 1, &(payload_type), &(pattrib->pktlen));	
 	//category, action, reason code
 	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, (u8 *)&ptdls_sta->stat_code, &(pattrib->pktlen));
 
 	//Link identifier
-	if(ptdls_sta->tdls_sta_state & TDLS_INITIATOR_STATE){
+	if(ptdls_sta->tdls_sta_state & TDLS_INITIATOR_STATE){	
 		_rtw_memcpy(link_id_addr, pattrib->ra, 6);
 		_rtw_memcpy((link_id_addr+6), pattrib->src, 6);
 		_rtw_memcpy((link_id_addr+12), pattrib->dst, 6);
@@ -2387,7 +2387,7 @@ void rtw_build_tdls_teardown_ies(_adapter * padapter, struct xmit_frame * pxmitf
 		_rtw_memcpy((link_id_addr+12), pattrib->src, 6);
 	}
 	pframe = rtw_set_ie(pframe, _LINK_ID_IE_,  18, link_id_addr, &(pattrib->pktlen));
-
+	
 }
 
 void rtw_build_tdls_dis_req_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe)
@@ -2401,7 +2401,7 @@ void rtw_build_tdls_dis_req_ies(_adapter * padapter, struct xmit_frame * pxmitfr
 	static u8 dialogtoken=0;
 
 	//payload type
-	pframe = rtw_set_fixed_ie(pframe, 1, &(payload_type), &(pattrib->pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 1, &(payload_type), &(pattrib->pktlen));		
 	//category, action, reason code
 	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
@@ -2413,7 +2413,7 @@ void rtw_build_tdls_dis_req_ies(_adapter * padapter, struct xmit_frame * pxmitfr
 	_rtw_memcpy((link_id_addr+6), pattrib->src, 6);
 	_rtw_memcpy((link_id_addr+12), pattrib->dst, 6);
 	pframe = rtw_set_ie(pframe, _LINK_ID_IE_,  18, link_id_addr, &(pattrib->pktlen));
-
+	
 }
 
 void rtw_build_tdls_dis_rsp_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe, u8 dialog)
@@ -2426,7 +2426,7 @@ void rtw_build_tdls_dis_rsp_ies(_adapter * padapter, struct xmit_frame * pxmitfr
 	u8 category = RTW_WLAN_CATEGORY_PUBLIC;
 	u8 action = TDLS_DISCOVERY_RESPONSE;
 	u8 bssrate[NDIS_802_11_LENGTH_RATES_EX];
-	int bssrate_len = 0;
+ 	int bssrate_len = 0;
 	u8 more_supportedrates = 0;
 	u8 *p;
 	struct mlme_priv 		*pmlmepriv = &padapter->mlmepriv;
@@ -2434,7 +2434,7 @@ void rtw_build_tdls_dis_rsp_ies(_adapter * padapter, struct xmit_frame * pxmitfr
 	u8 iedata=0;
 	u8 timeout_itvl[5];	//set timeout interval to maximum value
 	u32 timeout_interval= TPK_RESEND_COUNT * 1000;
-
+	
 	//category, action, dialog token
 	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
@@ -2473,7 +2473,7 @@ void rtw_build_tdls_dis_rsp_ies(_adapter * padapter, struct xmit_frame * pxmitfr
 	//RSNIE
 	if(pattrib->encrypt)
 		pframe = rtw_set_ie(pframe, _RSN_IE_2_, 20, TDLS_RSNIE, &(pattrib->pktlen));
-
+	
 	//extended capability
 	pframe = rtw_set_ie(pframe, _EXT_CAP_IE_ , 5, TDLS_EXT_CAPIE, &(pattrib->pktlen));
 
@@ -2505,7 +2505,7 @@ void rtw_build_tdls_dis_rsp_ies(_adapter * padapter, struct xmit_frame * pxmitfr
 	_rtw_memcpy((link_id_addr+6), pattrib->dst, 6);
 	_rtw_memcpy((link_id_addr+12), pattrib->src, 6);
 	pframe = rtw_set_ie(pframe, _LINK_ID_IE_, 18, link_id_addr, &(pattrib->pktlen));
-
+	
 }
 
 void rtw_build_tdls_peer_traffic_indication_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe)
@@ -2518,11 +2518,11 @@ void rtw_build_tdls_peer_traffic_indication_ies(_adapter * padapter, struct xmit
 
 	u8	link_id_addr[18] = {0};
 	u8 AC_queue=0;
-	struct sta_priv 	*pstapriv = &padapter->stapriv;
+	struct sta_priv 	*pstapriv = &padapter->stapriv;	
 	struct sta_info *ptdls_sta = rtw_get_stainfo(pstapriv, pattrib->dst);
 
 	//payload type
-	pframe = rtw_set_fixed_ie(pframe, 1, &(payload_type), &(pattrib->pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 1, &(payload_type), &(pattrib->pktlen));	
 	//category, action, reason code
 	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
@@ -2545,7 +2545,7 @@ void rtw_build_tdls_peer_traffic_indication_ies(_adapter * padapter, struct xmit
 	if(ptdls_sta->uapsd_vo&BIT(1))
 		AC_queue=BIT(3);
 	pframe = rtw_set_ie(pframe, _PTI_BUFFER_STATUS_, 1, &AC_queue, &(pattrib->pktlen));
-
+	
 }
 
 void rtw_build_tdls_ch_switch_req_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe)
@@ -2557,13 +2557,13 @@ void rtw_build_tdls_ch_switch_req_ies(_adapter * padapter, struct xmit_frame * p
 	unsigned char category = RTW_WLAN_CATEGORY_TDLS;
 	unsigned char action = TDLS_CHANNEL_SWITCH_REQUEST;
 	u8	link_id_addr[18] = {0};
-	struct sta_priv 	*pstapriv = &padapter->stapriv;
+	struct sta_priv 	*pstapriv = &padapter->stapriv;	
 	struct sta_info *ptdls_sta = rtw_get_stainfo(pstapriv, pattrib->dst);
 	u8 ch_switch_timing[4] = {0};
-	u16 switch_time= CH_SWITCH_TIME, switch_timeout=CH_SWITCH_TIMEOUT;
+	u16 switch_time= CH_SWITCH_TIME, switch_timeout=CH_SWITCH_TIMEOUT;	
 
 	//payload type
-	pframe = rtw_set_fixed_ie(pframe, 1, &(payload_type), &(pattrib->pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 1, &(payload_type), &(pattrib->pktlen));	
 	//category, action, target_ch
 	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
@@ -2595,14 +2595,14 @@ void rtw_build_tdls_ch_switch_rsp_ies(_adapter * padapter, struct xmit_frame * p
 	unsigned char category = RTW_WLAN_CATEGORY_TDLS;
 	unsigned char action = TDLS_CHANNEL_SWITCH_RESPONSE;
 	u8	link_id_addr[18] = {0};
-	struct sta_priv 	*pstapriv = &padapter->stapriv;
+	struct sta_priv 	*pstapriv = &padapter->stapriv;	
 	struct sta_info *ptdls_sta = rtw_get_stainfo(pstapriv, pattrib->dst);
 	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;
 	u8 ch_switch_timing[4] = {0};
 
 	//payload type
-	pframe = rtw_set_fixed_ie(pframe, 1, &(payload_type), &(pattrib->pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 1, &(payload_type), &(pattrib->pktlen));	
 	//category, action, status_code
 	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
@@ -2635,7 +2635,7 @@ void rtw_build_tunneled_probe_req_ies(_adapter * padapter, struct xmit_frame * p
 	u8 wfdielen = 0;
 
 	//payload type
-	pframe = rtw_set_fixed_ie(pframe, 1, &(payload_type), &(pattrib->pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 1, &(payload_type), &(pattrib->pktlen));		
 	//category, OUI, frame_body_type
 	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 3, WFA_OUI, &(pattrib->pktlen));
@@ -2653,7 +2653,7 @@ void rtw_build_tunneled_probe_req_ies(_adapter * padapter, struct xmit_frame * p
 		pframe += wfdielen;
 		pattrib->pktlen += wfdielen;
 	}
-
+	
 }
 
 void rtw_build_tunneled_probe_rsp_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe)
@@ -2669,7 +2669,7 @@ void rtw_build_tunneled_probe_rsp_ies(_adapter * padapter, struct xmit_frame * p
 	u8 wfdielen = 0;
 
 	//payload type
-	pframe = rtw_set_fixed_ie(pframe, 1, &(payload_type), &(pattrib->pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 1, &(payload_type), &(pattrib->pktlen));		
 	//category, OUI, frame_body_type
 	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 3, WFA_OUI, &(pattrib->pktlen));
@@ -2702,7 +2702,7 @@ void _TPK_timer_hdl(void *FunctionContext)
 		ptdls_sta->TPK_count=0;
 		issue_tdls_setup_req(ptdls_sta->padapter, ptdls_sta->hwaddr);
 	}
-
+	
 	_set_timer(&ptdls_sta->TPK_timer, ptdls_sta->TDLS_PeerKey_Lifetime/TPK_RESEND_COUNT);
 }
 
@@ -2721,7 +2721,7 @@ void _ch_switch_timer_hdl(void *FunctionContext)
 
 	struct sta_info *ptdls_sta = (struct sta_info *)FunctionContext;
 	_adapter *padapter = ptdls_sta->padapter;
-
+	
 	if( ptdls_sta->option == TDLS_DONE_CH_SEN ){
 		rtw_tdls_cmd(padapter, ptdls_sta->hwaddr, TDLS_DONE_CH_SEN);
 	}else if( ptdls_sta->option == TDLS_OFF_CH ){
@@ -2755,7 +2755,7 @@ void _off_ch_timer_hdl(void *FunctionContext)
 	struct sta_info *ptdls_sta = (struct sta_info *)FunctionContext;
 	rtw_tdls_cmd(ptdls_sta->padapter, ptdls_sta->hwaddr, TDLS_P_BASE_CH );
 }
-
+	
 void init_off_ch_timer(_adapter *padapter, struct sta_info *psta)
 {
 	psta->padapter=padapter;
@@ -2789,7 +2789,7 @@ void _tdls_alive_timer_phase1_hdl(void *FunctionContext)
 	struct sta_info *ptdls_sta = (struct sta_info *)FunctionContext;
 	_adapter *padapter = ptdls_sta->padapter;
 	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
-
+	
 	_enter_critical_bh(&ptdlsinfo->hdl_lock, &irqL);
 	ptdls_sta->timer_flag = 1;
 	_exit_critical_bh(&ptdlsinfo->hdl_lock, &irqL);
@@ -2802,7 +2802,7 @@ void _tdls_alive_timer_phase1_hdl(void *FunctionContext)
 	sta_update_last_rx_pkts(ptdls_sta);
 
 	if (	ptdls_sta->timer_flag == 2 )
-		rtw_tdls_cmd(padapter, ptdls_sta->hwaddr, TDLS_FREE_STA);
+		rtw_tdls_cmd(padapter, ptdls_sta->hwaddr, TDLS_FREE_STA);		
 	else
 	{
 		_enter_critical_bh(&ptdlsinfo->hdl_lock, &irqL);
@@ -2818,12 +2818,12 @@ void _tdls_alive_timer_phase2_hdl(void *FunctionContext)
 	struct sta_info *ptdls_sta = (struct sta_info *)FunctionContext;
 	_adapter *padapter = ptdls_sta->padapter;
 	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
-
+	
 	_enter_critical_bh(&(ptdlsinfo->hdl_lock), &irqL);
 	ptdls_sta->timer_flag = 1;
 	_exit_critical_bh(&ptdlsinfo->hdl_lock, &irqL);
 
-	if( (ptdls_sta->tdls_sta_state & TDLS_ALIVE_STATE) &&
+	if( (ptdls_sta->tdls_sta_state & TDLS_ALIVE_STATE) && 
 		(sta_last_rx_pkts(ptdls_sta) + 3 <= sta_rx_pkts(ptdls_sta)) )
 	{
 		DBG_871X("TDLS STA ALIVE, ptdls_sta->sta_stats.last_rx_pkts:%llu, ptdls_sta->sta_stats.rx_pkts:%llu\n",
@@ -2853,7 +2853,7 @@ void _tdls_alive_timer_phase2_hdl(void *FunctionContext)
 	}
 
 	if (	ptdls_sta->timer_flag == 2 )
-		rtw_tdls_cmd(padapter, ptdls_sta->hwaddr, TDLS_FREE_STA);
+		rtw_tdls_cmd(padapter, ptdls_sta->hwaddr, TDLS_FREE_STA);		
 	else
 	{
 		_enter_critical_bh(&(ptdlsinfo->hdl_lock), &irqL);
@@ -2888,14 +2888,14 @@ u32 update_mask_tdls(_adapter *padapter, struct sta_info *psta)
 	int i;
 	u8 rf_type, id;
 	unsigned char sta_band = 0;
-	unsigned char limit;
+	unsigned char limit;	
 	unsigned int tx_ra_bitmap=0;
 	struct ht_priv	*psta_ht = NULL;
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	WLAN_BSSID_EX *pcur_network = (WLAN_BSSID_EX *)&pmlmepriv->cur_network.network;
 
 	psta_ht = &psta->htpriv;
-	//b/g mode ra_bitmap
+	//b/g mode ra_bitmap  
 	for (i=0; i<sizeof(psta->bssrateset); i++)
 	{
 		if (psta->bssrateset[i])
@@ -2903,7 +2903,7 @@ u32 update_mask_tdls(_adapter *padapter, struct sta_info *psta)
 	}
 
 	//n mode ra_bitmap
-	if(psta_ht->ht_option)
+	if(psta_ht->ht_option) 
 	{
 		rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
 		if(rf_type == RF_2T2R)
@@ -2938,3 +2938,4 @@ u32 update_mask_tdls(_adapter *padapter, struct sta_info *psta)
 }
 
 #endif //CONFIG_TDLS
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_wlan_util.c b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_wlan_util.c
old mode 100644
new mode 100755
index c977cd1..56dac60d
--- a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_wlan_util.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_wlan_util.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -76,12 +76,12 @@
 int cckrates_included(unsigned char *rate, int ratelen)
 {
 	int	i;
-
+	
 	for(i = 0; i < ratelen; i++)
 	{
 		if  (  (((rate[i]) & 0x7f) == 2)	|| (((rate[i]) & 0x7f) == 4) ||
 			   (((rate[i]) & 0x7f) == 11)  || (((rate[i]) & 0x7f) == 22) )
-		return _TRUE;
+		return _TRUE;	
 	}
 
 	return _FALSE;
@@ -91,14 +91,14 @@ int cckrates_included(unsigned char *rate, int ratelen)
 int cckratesonly_included(unsigned char *rate, int ratelen)
 {
 	int	i;
-
+	
 	for(i = 0; i < ratelen; i++)
 	{
 		if  ( (((rate[i]) & 0x7f) != 2) && (((rate[i]) & 0x7f) != 4) &&
 			   (((rate[i]) & 0x7f) != 11)  && (((rate[i]) & 0x7f) != 22) )
-		return _FALSE;
+		return _FALSE;	
 	}
-
+	
 	return _TRUE;
 }
 
@@ -131,12 +131,12 @@ unsigned char networktype_to_raid(unsigned char network_type)
 			break;
 		default:
 			raid = 4;
-			break;
+			break;	
 
 	}
 
 	return raid;
-
+	
 }
 
 int judge_network_type(_adapter *padapter, unsigned char *rate, int ratelen)
@@ -144,7 +144,7 @@ int judge_network_type(_adapter *padapter, unsigned char *rate, int ratelen)
 	int network_type = 0;
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-
+	
 
 	if(pmlmeext->cur_channel > 14)
 	{
@@ -152,7 +152,7 @@ int judge_network_type(_adapter *padapter, unsigned char *rate, int ratelen)
 		{
 			network_type = WIRELESS_11_5N;
 		}
-
+	
 		network_type |= WIRELESS_11A;
 	}
 	else
@@ -175,7 +175,7 @@ int judge_network_type(_adapter *padapter, unsigned char *rate, int ratelen)
 			network_type |= WIRELESS_11G;
 		}
 	}
-
+		
 	return 	network_type;
 }
 
@@ -184,7 +184,7 @@ unsigned char ratetbl_val_2wifirate(unsigned char rate)
 {
 	unsigned char val = 0;
 
-	switch (rate & 0x7f)
+	switch (rate & 0x7f) 
 	{
 		case 0:
 			val = IEEE80211_CCK_RATE_1MB;
@@ -201,7 +201,7 @@ unsigned char ratetbl_val_2wifirate(unsigned char rate)
 		case 3:
 			val = IEEE80211_CCK_RATE_11MB;
 			break;
-
+			
 		case 4:
 			val = IEEE80211_OFDM_RATE_6MB;
 			break;
@@ -213,7 +213,7 @@ unsigned char ratetbl_val_2wifirate(unsigned char rate)
 		case 6:
 			val = IEEE80211_OFDM_RATE_12MB;
 			break;
-
+			
 		case 7:
 			val = IEEE80211_OFDM_RATE_18MB;
 			break;
@@ -221,7 +221,7 @@ unsigned char ratetbl_val_2wifirate(unsigned char rate)
 		case 8:
 			val = IEEE80211_OFDM_RATE_24MB;
 			break;
-
+			
 		case 9:
 			val = IEEE80211_OFDM_RATE_36MB;
 			break;
@@ -229,7 +229,7 @@ unsigned char ratetbl_val_2wifirate(unsigned char rate)
 		case 10:
 			val = IEEE80211_OFDM_RATE_48MB;
 			break;
-
+		
 		case 11:
 			val = IEEE80211_OFDM_RATE_54MB;
 			break;
@@ -246,7 +246,7 @@ int is_basicrate(_adapter *padapter, unsigned char rate)
 	int i;
 	unsigned char val;
 	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
-
+	
 	for(i = 0; i < NumRates; i++)
 	{
 		val = pmlmeext->basicrate[i];
@@ -259,7 +259,7 @@ int is_basicrate(_adapter *padapter, unsigned char rate)
 			}
 		}
 	}
-
+	
 	return _FALSE;
 }
 
@@ -279,10 +279,10 @@ unsigned int ratetbl2rateset(_adapter *padapter, unsigned char *rateset)
 		{
 			case 0xff:
 				return len;
-
+				
 			case 0xfe:
 				continue;
-
+				
 			default:
 				rate = ratetbl_val_2wifirate(rate);
 
@@ -290,7 +290,7 @@ unsigned int ratetbl2rateset(_adapter *padapter, unsigned char *rateset)
 				{
 					rate |= IEEE80211_BASIC_RATE_MASK;
 				}
-
+				
 				rateset[len] = rate;
 				len++;
 				break;
@@ -362,7 +362,7 @@ void Save_DM_Func_Flag(_adapter *padapter)
 {
 	u8	bSaveFlag = _TRUE;
 
-#ifdef CONFIG_CONCURRENT_MODE
+#ifdef CONFIG_CONCURRENT_MODE	
 	_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
 	if(pbuddy_adapter)
 	rtw_hal_set_hwreg(pbuddy_adapter, HW_VAR_DM_FUNC_OP, (u8 *)(&bSaveFlag));
@@ -375,7 +375,7 @@ void Save_DM_Func_Flag(_adapter *padapter)
 void Restore_DM_Func_Flag(_adapter *padapter)
 {
 	u8	bSaveFlag = _FALSE;
-#ifdef CONFIG_CONCURRENT_MODE
+#ifdef CONFIG_CONCURRENT_MODE	
 	_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
 	if(pbuddy_adapter)
 	rtw_hal_set_hwreg(pbuddy_adapter, HW_VAR_DM_FUNC_OP, (u8 *)(&bSaveFlag));
@@ -385,7 +385,7 @@ void Restore_DM_Func_Flag(_adapter *padapter)
 
 void Switch_DM_Func(_adapter *padapter, u8 mode, u8 enable)
 {
-#ifdef CONFIG_CONCURRENT_MODE
+#ifdef CONFIG_CONCURRENT_MODE	
 	_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
 #endif
 
@@ -495,7 +495,7 @@ inline u32 rtw_get_on_cur_ch_time(_adapter *adapter)
 
 void SelectChannel(_adapter *padapter, unsigned char channel)
 {
-	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;	
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	//saved channel info
@@ -504,12 +504,12 @@ void SelectChannel(_adapter *padapter, unsigned char channel)
 #else //CONFIG_DUALMAC_CONCURRENT
 
 	_enter_critical_mutex(&(adapter_to_dvobj(padapter)->setch_mutex), NULL);
-
+	
 	//saved channel info
 	rtw_set_oper_ch(padapter, channel);
 
 	rtw_hal_set_chan(padapter, channel);
-
+	
 	_exit_critical_mutex(&(adapter_to_dvobj(padapter)->setch_mutex), NULL);
 
 #endif // CONFIG_DUALMAC_CONCURRENT
@@ -554,7 +554,7 @@ void set_channel_bwmode(_adapter *padapter, unsigned char channel, unsigned char
 		//SelectChannel(padapter, channel);
 		center_ch = channel;
 	}
-	else
+	else		
 	{
 		//switch to the proper channel
 		if (channel_offset == HAL_PRIME_CHNL_OFFSET_LOWER)
@@ -567,7 +567,7 @@ void set_channel_bwmode(_adapter *padapter, unsigned char channel, unsigned char
 			//SelectChannel(padapter, channel - 2);
 			center_ch = channel - 2;
 		}
-	}
+	}	
 
 	//set Channel , must be independant for correct co_ch value/
 #ifdef CONFIG_DUALMAC_CONCURRENT
@@ -577,9 +577,9 @@ void set_channel_bwmode(_adapter *padapter, unsigned char channel, unsigned char
 	rtw_set_oper_choffset(padapter, channel_offset);
 	dc_SelectChannel(padapter, center_ch);// set center channel
 #else //CONFIG_DUALMAC_CONCURRENT
-
+	
 	_enter_critical_mutex(&(adapter_to_dvobj(padapter)->setch_mutex), NULL);
-
+	
 	//saved channel/bw info
 	rtw_set_oper_ch(padapter, channel);
 	rtw_set_oper_bw(padapter, bwmode);
@@ -594,7 +594,7 @@ void set_channel_bwmode(_adapter *padapter, unsigned char channel, unsigned char
 
 	//set BandWidth
 	SetBWMode(padapter, bwmode, channel_offset);
-
+	
 }
 
 int get_bsstype(unsigned short capability)
@@ -609,13 +609,13 @@ int get_bsstype(unsigned short capability)
 	}
 	else
 	{
-		return 0;
+		return 0;		
 	}
 }
 
 __inline u8 *get_my_bssid(WLAN_BSSID_EX *pnetwork)
-{
-	return (pnetwork->MacAddress);
+{	
+	return (pnetwork->MacAddress); 
 }
 
 u16 get_beacon_interval(WLAN_BSSID_EX *bss)
@@ -623,7 +623,7 @@ u16 get_beacon_interval(WLAN_BSSID_EX *bss)
 	unsigned short val;
 	_rtw_memcpy((unsigned char *)&val, rtw_get_beacon_interval_from_ie(bss->IEs), 2);
 
-	return le16_to_cpu(val);
+	return le16_to_cpu(val);	
 
 }
 
@@ -637,7 +637,7 @@ int is_client_associated_to_ap(_adapter *padapter)
 
 	pmlmeext = &padapter->mlmeextpriv;
 	pmlmeinfo = &(pmlmeext->mlmext_info);
-
+	
 	if ((pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS) && ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE))
 	{
 		return _TRUE;
@@ -652,7 +652,7 @@ int is_client_associated_to_ibss(_adapter *padapter)
 {
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-
+	
 	if ((pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS) && ((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE))
 	{
 		return _TRUE;
@@ -668,7 +668,7 @@ int is_IBSS_empty(_adapter *padapter)
 	unsigned int i;
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-
+	
 	for (i = IBSS_START_MAC_ID; i < NUM_STA; i++)
 	{
 		if (pmlmeinfo->FW_sta_info[i].status == 1)
@@ -676,9 +676,9 @@ int is_IBSS_empty(_adapter *padapter)
 			return _FAIL;
 		}
 	}
-
+	
 	return _TRUE;
-
+	
 }
 
 unsigned int decide_wait_for_beacon_timeout(unsigned int bcn_interval)
@@ -686,11 +686,11 @@ unsigned int decide_wait_for_beacon_timeout(unsigned int bcn_interval)
 	if ((bcn_interval << 2) < WAIT_FOR_BCN_TO_MIN)
 	{
 		return WAIT_FOR_BCN_TO_MIN;
-	}
+	} 
 	else if ((bcn_interval << 2) > WAIT_FOR_BCN_TO_MAX)
 	{
 		return WAIT_FOR_BCN_TO_MAX;
-	}
+	}	
 	else
 	{
 		return ((bcn_interval << 2));
@@ -698,7 +698,7 @@ unsigned int decide_wait_for_beacon_timeout(unsigned int bcn_interval)
 }
 
 void CAM_empty_entry(
-	PADAPTER     	Adapter,
+	PADAPTER     	Adapter,	
 	u8 			ucIndex
 )
 {
@@ -720,9 +720,9 @@ static u32 _ReadCAM(_adapter *padapter ,u32 addr)
 		if(0 == (rtw_read32(padapter,REG_CAMCMD) & CAM_POLLINIG)){
 			break;
 		}
-	}while(count++ < 100);
+	}while(count++ < 100);		
 
-	return rtw_read32(padapter,REG_CAMREAD);
+	return rtw_read32(padapter,REG_CAMREAD);	
 }
 void read_cam(_adapter *padapter ,u8 entry)
 {
@@ -731,7 +731,7 @@ void read_cam(_adapter *padapter ,u8 entry)
 
 	printk("********* DUMP CAM Entry_#%02d***************\n",entry);
 	for (j = 0; j < 6; j++)
-	{
+	{	
 		cmd = _ReadCAM(padapter ,addr+j);
 		printk("offset:0x%02x => 0x%08x \n",addr+j,cmd);
 	}
@@ -749,48 +749,48 @@ void write_cam(_adapter *padapter, u8 entry, u16 ctrl, u8 *mac, u8 *key)
 	addr = entry << 3;
 
 	for (j = 5; j >= 0; j--)
-	{
+	{	
 		switch (j)
 		{
 			case 0:
 				val = (ctrl | (mac[0] << 16) | (mac[1] << 24) );
 				break;
-
+				
 			case 1:
 				val = (mac[2] | ( mac[3] << 8) | (mac[4] << 16) | (mac[5] << 24));
 				break;
-
+			
 			default:
 				i = (j - 2) << 2;
 				val = (key[i] | (key[i+1] << 8) | (key[i+2] << 16) | (key[i+3] << 24));
 				break;
-
+				
 		}
 
 		cam_val[0] = val;
 		cam_val[1] = addr + (unsigned int)j;
 
 		rtw_hal_set_hwreg(padapter, HW_VAR_CAM_WRITE, (u8 *)cam_val);
-
+		
 		//rtw_write32(padapter, WCAMI, val);
-
+		
 		//cmd = CAM_POLLINIG | CAM_WRITE | (addr + j);
 		//rtw_write32(padapter, RWCAM, cmd);
-
+		
 		//DBG_871X("%s=> cam write: %x, %x\n",__FUNCTION__, cmd, val);
-
+		
 	}
 
 }
 
 void clear_cam_entry(_adapter *padapter, u8 entry)
-{
+{	
 #if 0
 	u32	addr, val=0;
 	u32	cam_val[2];
 
 	addr = entry << 3;
-
+	
 
 	cam_val[0] = val;
 	cam_val[1] = addr + (unsigned int)0;
@@ -819,7 +819,7 @@ int allocate_fw_sta_entry(_adapter *padapter)
 	unsigned int mac_id;
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-
+	
 	for (mac_id = IBSS_START_MAC_ID; mac_id < NUM_STA; mac_id++)
 	{
 		if (pmlmeinfo->FW_sta_info[mac_id].status == 0)
@@ -829,7 +829,7 @@ int allocate_fw_sta_entry(_adapter *padapter)
 			break;
 		}
 	}
-
+	
 	return mac_id;
 }
 
@@ -842,10 +842,10 @@ void flush_all_cam_entry(_adapter *padapter)
 
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 
-	//if(check_buddy_mlmeinfo_state(padapter, _HW_STATE_NOLINK_))
+	//if(check_buddy_mlmeinfo_state(padapter, _HW_STATE_NOLINK_))	
 	if(check_buddy_fwstate(padapter, _FW_LINKED) == _FALSE)
 	{
-		rtw_hal_set_hwreg(padapter, HW_VAR_CAM_INVALID_ALL, 0);
+		rtw_hal_set_hwreg(padapter, HW_VAR_CAM_INVALID_ALL, 0);		
 	}
 	else
 	{
@@ -853,12 +853,12 @@ void flush_all_cam_entry(_adapter *padapter)
 		{
 			struct sta_priv	*pstapriv = &padapter->stapriv;
 			struct sta_info	*psta;
-			u8 cam_id=0;//cam_entry
+			u8 cam_id;//cam_entry
 
 			psta = rtw_get_stainfo(pstapriv, pmlmeinfo->network.MacAddress);
 			if(psta) {
 				if(psta->state & WIFI_AP_STATE)
-				{}   //clear cam when ap free per sta_info
+				{}   //clear cam when ap free per sta_info        
 				else {
 					if(psta->mac_id==2)
 						cam_id = 5;
@@ -871,12 +871,12 @@ void flush_all_cam_entry(_adapter *padapter)
 		}
 		else if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
 		{
-			//clear cam when ap free per sta_info
-		}
+			//clear cam when ap free per sta_info 
+		}			
 	}
 #else //CONFIG_CONCURRENT_MODE
 
-	rtw_hal_set_hwreg(padapter, HW_VAR_CAM_INVALID_ALL, 0);
+	rtw_hal_set_hwreg(padapter, HW_VAR_CAM_INVALID_ALL, 0);	
 
 #endif //CONFIG_CONCURRENT_MODE
 
@@ -891,7 +891,7 @@ int WFD_info_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs	pIE)
 	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-	struct wifidirect_info	*pwdinfo;
+	struct wifidirect_info	*pwdinfo;	
 	u8	wfd_ie[ 128 ] = { 0x00 };
 	u32	wfd_ielen = 0;
 
@@ -901,7 +901,7 @@ int WFD_info_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs	pIE)
 	{
 		u8	attr_content[ 10 ] = { 0x00 };
 		u32	attr_contentlen = 0;
-
+			
 		printk( "[%s] Found WFD IE\n", __FUNCTION__ );
 		rtw_get_wfd_attr_content( wfd_ie, wfd_ielen, WFD_ATTR_DEVICE_INFO, attr_content, &attr_contentlen);
 		if ( attr_contentlen )
@@ -909,7 +909,7 @@ int WFD_info_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs	pIE)
 			pwdinfo->wfd_info->peer_rtsp_ctrlport = RTW_GET_BE16( attr_content + 2 );
 			DBG_8192C( "[%s] Peer PORT NUM = %d\n", __FUNCTION__, pwdinfo->wfd_info->peer_rtsp_ctrlport );
 			return( _TRUE );
-		}
+		}		
 	}
 	else
 	{
@@ -925,13 +925,13 @@ int WMM_param_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs	pIE)
 	//struct registry_priv	*pregpriv = &padapter->registrypriv;
 	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
-	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);	
+	
 	if(pmlmepriv->qospriv.qos_option==0)
 	{
 		pmlmeinfo->WMM_enable = 0;
 		return _FAIL;
-	}
+	}	
 
 	pmlmeinfo->WMM_enable = 1;
 	_rtw_memcpy(&(pmlmeinfo->WMM_param), (pIE->data + 6), sizeof(struct WMM_para_element));
@@ -956,7 +956,7 @@ int WMM_param_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs	pIE)
 		pmlmeinfo->WMM_enable = 0;
 		return _FAIL;
 	}*/
-
+	
 }
 
 void WMMOnAssocRsp(_adapter *padapter)
@@ -981,7 +981,7 @@ void WMMOnAssocRsp(_adapter *padapter)
 	else
 		aSifsTime = 16;
 
-	for (i = 0; i < 4; i++)
+	for (i = 0; i < 4; i++)  
 	{
 		ACI = (pmlmeinfo->WMM_param.ac_param[i].ACI_AIFSN >> 5) & 0x03;
 		ACM = (pmlmeinfo->WMM_param.ac_param[i].ACI_AIFSN >> 4) & 0x01;
@@ -1015,7 +1015,7 @@ void WMMOnAssocRsp(_adapter *padapter)
 			case 0x3:
 				rtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_VO, (u8 *)(&acParm));
 				acm_mask |= (ACM? BIT(3):0);
-				break;
+				break;							
 		}
 
 		DBG_871X("WMM(%x): %x, %x\n", ACI, ACM, acParm);
@@ -1026,7 +1026,7 @@ void WMMOnAssocRsp(_adapter *padapter)
 	else
 		padapter->mlmepriv.acm_mask = acm_mask;
 
-	return;
+	return;	
 }
 
 static void bwmode_update_check(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE)
@@ -1048,7 +1048,7 @@ static void bwmode_update_check(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pI
 
 	if(pIE->Length > sizeof(struct HT_info_element))
 		return;
-
+	
 	pHT_info = (struct HT_info_element *)pIE->data;
 
 	if (pmlmeext->cur_channel > 14) {
@@ -1058,7 +1058,7 @@ static void bwmode_update_check(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pI
 		if (pregistrypriv->cbw40_enable & BIT(0))
 			cbw40_enable = 1;
 	}
-
+	
 	if((pHT_info->infos[0] & BIT(2)) && cbw40_enable )
 	{
 		new_bwmode = HT_CHANNEL_WIDTH_40;
@@ -1068,11 +1068,11 @@ static void bwmode_update_check(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pI
 			case 1:
 				new_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;
 				break;
-
+			
 			case 3:
 				new_ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER;
 				break;
-
+				
 			default:
 				new_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
 				break;
@@ -1082,13 +1082,13 @@ static void bwmode_update_check(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pI
 	{
 		new_bwmode = HT_CHANNEL_WIDTH_20;
 		new_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
-	}
-
+	}	
 
+	
 	if((new_bwmode!= pmlmeext->cur_bwmode) || (new_ch_offset!=pmlmeext->cur_ch_offset))
 	{
 		pmlmeinfo->bwmode_updated = _TRUE;
-
+		
 		pmlmeext->cur_bwmode = new_bwmode;
 		pmlmeext->cur_ch_offset = new_ch_offset;
 
@@ -1099,40 +1099,40 @@ static void bwmode_update_check(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pI
 	{
 		pmlmeinfo->bwmode_updated = _FALSE;
 	}
-
+		
 
 	if(_TRUE == pmlmeinfo->bwmode_updated)
 	{
 		struct sta_info *psta;
 		WLAN_BSSID_EX 	*cur_network = &(pmlmeinfo->network);
 		struct sta_priv	*pstapriv = &padapter->stapriv;
-
+	
 		//set_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
 
-
+		
 		//update ap's stainfo
 		psta = rtw_get_stainfo(pstapriv, cur_network->MacAddress);
 		if(psta)
 		{
 			struct ht_priv	*phtpriv_sta = &psta->htpriv;
-
+			
 			if(phtpriv_sta->ht_option)
-			{
-				// bwmode
+			{				
+				// bwmode				
 				phtpriv_sta->bwmode = pmlmeext->cur_bwmode;
-				phtpriv_sta->ch_offset = pmlmeext->cur_ch_offset;
+				phtpriv_sta->ch_offset = pmlmeext->cur_ch_offset;		
 			}
 			else
 			{
 				phtpriv_sta->bwmode = HT_CHANNEL_WIDTH_20;
 				phtpriv_sta->ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
 			}
-
+			
 		}
 
 		//pmlmeinfo->bwmode_updated = _FALSE;//bwmode_updated done, reset it!
-
-	}
+		
+	}	
 
 }
 
@@ -1143,16 +1143,16 @@ void HT_caps_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE)
 	u8	max_AMPDU_len, min_MPDU_spacing;
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-	struct mlme_priv 		*pmlmepriv = &padapter->mlmepriv;
+	struct mlme_priv 		*pmlmepriv = &padapter->mlmepriv;	
 	struct ht_priv			*phtpriv = &pmlmepriv->htpriv;
 	struct registry_priv 	*pregistrypriv = &padapter->registrypriv;
-
+	
 	if(pIE==NULL) return;
-
+	
 	if(phtpriv->ht_option == _FALSE)	return;
 
 	pmlmeinfo->HT_caps_enable = 1;
-
+	
 	for (i = 0; i < (pIE->Length); i++)
 	{
 		if (i != 2)
@@ -1172,7 +1172,7 @@ void HT_caps_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE)
 			{
 				max_AMPDU_len = (pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x3);
 			}
-
+			
 			if ((pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x1c) > (pIE->data[i] & 0x1c))
 			{
 				min_MPDU_spacing = (pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x1c);
@@ -1188,7 +1188,7 @@ void HT_caps_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE)
 
 	//	Commented by Albert 2010/07/12
 	//	Have to handle the endian issue after copying.
-	//	HT_ext_caps didn't be used yet.
+	//	HT_ext_caps didn't be used yet.	
 	pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info = le16_to_cpu( pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info );
 	pmlmeinfo->HT_caps.u.HT_cap_element.HT_ext_caps = le16_to_cpu( pmlmeinfo->HT_caps.u.HT_cap_element.HT_ext_caps );
 
@@ -1222,7 +1222,7 @@ void HT_caps_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE)
 			pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_1R[i];
 
 	}
-
+	
 	return;
 }
 
@@ -1230,7 +1230,7 @@ void HT_info_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE)
 {
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-	struct mlme_priv 		*pmlmepriv = &padapter->mlmepriv;
+	struct mlme_priv 		*pmlmepriv = &padapter->mlmepriv;	
 	struct ht_priv			*phtpriv = &pmlmepriv->htpriv;
 
 	if(pIE==NULL) return;
@@ -1240,10 +1240,10 @@ void HT_info_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE)
 
 	if(pIE->Length > sizeof(struct HT_info_element))
 		return;
-
+	
 	pmlmeinfo->HT_info_enable = 1;
 	_rtw_memcpy(&(pmlmeinfo->HT_info), pIE->data, pIE->Length);
-
+	
 	return;
 }
 
@@ -1254,7 +1254,7 @@ void HTOnAssocRsp(_adapter *padapter)
 	//struct registry_priv	 *pregpriv = &padapter->registrypriv;
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-
+	
 	DBG_871X("%s\n", __FUNCTION__);
 
 	if ((pmlmeinfo->HT_info_enable) && (pmlmeinfo->HT_caps_enable))
@@ -1267,15 +1267,15 @@ void HTOnAssocRsp(_adapter *padapter)
 		//set_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
 		return;
 	}
-
+	
 	//handle A-MPDU parameter field
-	/*
+	/* 	
 		AMPDU_para [1:0]:Max AMPDU Len => 0:8k , 1:16k, 2:32k, 3:64k
-		AMPDU_para [4:2]:Min MPDU Start Spacing
+		AMPDU_para [4:2]:Min MPDU Start Spacing	
 	*/
-	max_AMPDU_len = pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x03;
-
-	min_MPDU_spacing = (pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x1c) >> 2;
+	max_AMPDU_len = pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x03;	
+	
+	min_MPDU_spacing = (pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x1c) >> 2;	
 
 	rtw_hal_set_hwreg(padapter, HW_VAR_AMPDU_MIN_SPACE, (u8 *)(&min_MPDU_spacing));
 
@@ -1283,7 +1283,7 @@ void HTOnAssocRsp(_adapter *padapter)
 
 #if 0 //move to rtw_update_ht_cap()
 	if ((pregpriv->cbw40_enable) &&
-		(pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info & BIT(1)) &&
+		(pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info & BIT(1)) && 
 		(pmlmeinfo->HT_info.infos[0] & BIT(2)))
 	{
 		//switch to the 40M Hz mode accoring to the AP
@@ -1293,16 +1293,16 @@ void HTOnAssocRsp(_adapter *padapter)
 			case HT_EXTCHNL_OFFSET_UPPER:
 				pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;
 				break;
-
+			
 			case HT_EXTCHNL_OFFSET_LOWER:
 				pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER;
 				break;
-
+				
 			default:
 				pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
 				break;
 		}
-
+		
 		//SelectChannel(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset);
 	}
 #endif
@@ -1330,7 +1330,7 @@ void HTOnAssocRsp(_adapter *padapter)
 	//
 	pmlmeinfo->HT_protection = pmlmeinfo->HT_info.infos[1] & 0x3;
 #endif
-
+	
 }
 
 void ERP_IE_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE)
@@ -1340,7 +1340,7 @@ void ERP_IE_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE)
 
 	if(pIE->Length>1)
 		return;
-
+	
 	pmlmeinfo->ERP_enable = 1;
 	_rtw_memcpy(&(pmlmeinfo->ERP_IE), pIE->data, pIE->Length);
 }
@@ -1357,7 +1357,7 @@ void VCS_update(_adapter *padapter, struct sta_info *psta)
 			psta->rtsen = 0;
 			psta->cts2self = 0;
 			break;
-
+			
 		case 1: //on
 			if (pregpriv->vcs_type == 1) /* 1:RTS/CTS 2:CTS to self */
 			{
@@ -1370,7 +1370,7 @@ void VCS_update(_adapter *padapter, struct sta_info *psta)
 				psta->cts2self = 1;
 			}
 			break;
-
+			
 		case 2: //auto
 		default:
 			if ((pmlmeinfo->ERP_enable) && (pmlmeinfo->ERP_IE & BIT(1)))
@@ -1390,7 +1390,7 @@ void VCS_update(_adapter *padapter, struct sta_info *psta)
 			{
 				psta->rtsen = 0;
 				psta->cts2self = 0;
-			}
+			}	
 			break;
 	}
 }
@@ -1418,7 +1418,7 @@ void update_beacon_info(_adapter *padapter, u8 *pframe, uint pkt_len, struct sta
 	unsigned int i;
 	unsigned int len;
 	PNDIS_802_11_VARIABLE_IEs	pIE;
-
+		
 #ifdef CONFIG_TDLS
 	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
 	u8 tdls_prohibited[] = { 0x00, 0x00, 0x00, 0x00, 0x10 }; //bit(38): TDLS_prohibited
@@ -1429,20 +1429,20 @@ void update_beacon_info(_adapter *padapter, u8 *pframe, uint pkt_len, struct sta
 	for (i = 0; i < len;)
 	{
 		pIE = (PNDIS_802_11_VARIABLE_IEs)(pframe + (_BEACON_IE_OFFSET_ + WLAN_HDR_A3_LEN) + i);
-
+		
 		switch (pIE->ElementID)
 		{
-#if 0
-			case _VENDOR_SPECIFIC_IE_:
-				//todo: to update WMM paramter set while receiving beacon
+#if 0			
+			case _VENDOR_SPECIFIC_IE_:		
+				//todo: to update WMM paramter set while receiving beacon			
 				if (_rtw_memcmp(pIE->data, WMM_PARA_OUI, 6))	//WMM
 				{
 					(WMM_param_handler(padapter, pIE))? WMMOnAssocRsp(padapter): 0;
-				}
+				}				
 				break;
 #endif
 
-			case _HT_EXTRA_INFO_IE_:	//HT info
+			case _HT_EXTRA_INFO_IE_:	//HT info				
 				//HT_info_handler(padapter, pIE);
 				bwmode_update_check(padapter, pIE);
 				break;
@@ -1451,7 +1451,7 @@ void update_beacon_info(_adapter *padapter, u8 *pframe, uint pkt_len, struct sta
 				ERP_IE_handler(padapter, pIE);
 				VCS_update(padapter, psta);
 				break;
-
+				
 #ifdef CONFIG_TDLS
 			case _EXT_CAP_IE_:
 				if( check_ap_tdls_prohibited(pIE->data, pIE->Length) == _TRUE )
@@ -1461,7 +1461,7 @@ void update_beacon_info(_adapter *padapter, u8 *pframe, uint pkt_len, struct sta
 			default:
 				break;
 		}
-
+		
 		i += (pIE->Length + 2);
 	}
 }
@@ -1472,14 +1472,14 @@ void process_csa_ie(_adapter *padapter, u8 *pframe, uint pkt_len)
 	unsigned int i;
 	unsigned int len;
 	PNDIS_802_11_VARIABLE_IEs	pIE;
-	u8 new_ch_no = 0;
-
+	u8 new_ch_no = 0; 
+		
 	len = pkt_len - (_BEACON_IE_OFFSET_ + WLAN_HDR_A3_LEN);
 
 	for (i = 0; i < len;)
 	{
 		pIE = (PNDIS_802_11_VARIABLE_IEs)(pframe + (_BEACON_IE_OFFSET_ + WLAN_HDR_A3_LEN) + i);
-
+		
 		switch (pIE->ElementID)
 		{
 			case _CH_SWTICH_ANNOUNCE_:
@@ -1490,7 +1490,7 @@ void process_csa_ie(_adapter *padapter, u8 *pframe, uint pkt_len)
 			default:
 				break;
 		}
-
+		
 		i += (pIE->Length + 2);
 	}
 }
@@ -1509,36 +1509,36 @@ unsigned int is_ap_in_tkip(_adapter *padapter)
 		for (i = sizeof(NDIS_802_11_FIXED_IEs); i < pmlmeinfo->network.IELength;)
 		{
 			pIE = (PNDIS_802_11_VARIABLE_IEs)(pmlmeinfo->network.IEs + i);
-
+		
 			switch (pIE->ElementID)
 			{
 				case _VENDOR_SPECIFIC_IE_:
-					if ((_rtw_memcmp(pIE->data, RTW_WPA_OUI, 4)) && (_rtw_memcmp((pIE->data + 12), WPA_TKIP_CIPHER, 4)))
+					if ((_rtw_memcmp(pIE->data, RTW_WPA_OUI, 4)) && (_rtw_memcmp((pIE->data + 12), WPA_TKIP_CIPHER, 4))) 
 					{
 						return _TRUE;
 					}
 					break;
-
+				
 				case _RSN_IE_2_:
-					if (_rtw_memcmp((pIE->data + 8), RSN_TKIP_CIPHER, 4))
+					if (_rtw_memcmp((pIE->data + 8), RSN_TKIP_CIPHER, 4)) 
 					{
 						return _TRUE;
 					}
-
+					
 				default:
 					break;
 			}
-
+		
 			i += (pIE->Length + 2);
 		}
-
+		
 		return _FALSE;
 	}
 	else
 	{
 		return _FALSE;
 	}
-
+	
 }
 
 int wifirate2_ratetbl_inx(unsigned char rate);
@@ -1547,7 +1547,7 @@ int wifirate2_ratetbl_inx(unsigned char rate)
 	int	inx = 0;
 	rate = rate & 0x7f;
 
-	switch (rate)
+	switch (rate) 
 	{
 		case 54*2:
 			inx = 11;
@@ -1564,7 +1564,7 @@ int wifirate2_ratetbl_inx(unsigned char rate)
 		case 24*2:
 			inx = 8;
 			break;
-
+			
 		case 18*2:
 			inx = 7;
 			break;
@@ -1576,7 +1576,7 @@ int wifirate2_ratetbl_inx(unsigned char rate)
 		case 9*2:
 			inx = 5;
 			break;
-
+			
 		case 6*2:
 			inx = 4;
 			break;
@@ -1591,22 +1591,22 @@ int wifirate2_ratetbl_inx(unsigned char rate)
 		case 2*2:
 			inx = 1;
 			break;
-
+		
 		case 1*2:
 			inx = 0;
 			break;
 
 	}
-	return inx;
+	return inx;	
 }
 
 unsigned int update_basic_rate(unsigned char *ptn, unsigned int ptn_sz)
 {
 	unsigned int i, num_of_rate;
 	unsigned int mask = 0;
-
+	
 	num_of_rate = (ptn_sz > NumRates)? NumRates: ptn_sz;
-
+		
 	for (i = 0; i < num_of_rate; i++)
 	{
 		if ((*(ptn + i)) & 0x80)
@@ -1621,9 +1621,9 @@ unsigned int update_supported_rate(unsigned char *ptn, unsigned int ptn_sz)
 {
 	unsigned int i, num_of_rate;
 	unsigned int mask = 0;
-
+	
 	num_of_rate = (ptn_sz > NumRates)? NumRates: ptn_sz;
-
+		
 	for (i = 0; i < num_of_rate; i++)
 	{
 		mask |= 0x1 << wifirate2_ratetbl_inx(*(ptn + i));
@@ -1635,9 +1635,9 @@ unsigned int update_supported_rate(unsigned char *ptn, unsigned int ptn_sz)
 unsigned int update_MSC_rate(struct HT_caps_element *pHT_caps)
 {
 	unsigned int mask = 0;
-
+	
 	mask = ((pHT_caps->u.HT_cap_element.MCS_rate[0] << 12) | (pHT_caps->u.HT_cap_element.MCS_rate[1] << 20));
-
+						
 	return mask;
 }
 
@@ -1646,15 +1646,15 @@ int support_short_GI(_adapter *padapter, struct HT_caps_element *pHT_caps)
 	unsigned char					bit_offset;
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-
+	
 	if (!(pmlmeinfo->HT_enable))
 		return _FAIL;
-
+	
 	if ((pmlmeinfo->assoc_AP_vendor == ralinkAP))
 		return _FAIL;
-
+		
 	bit_offset = (pmlmeext->cur_bwmode & HT_CHANNEL_WIDTH_40)? 6: 5;
-
+	
 	if (pHT_caps->u.HT_cap_element.HT_caps_info & (0x1 << bit_offset))
 	{
 		return _SUCCESS;
@@ -1662,7 +1662,7 @@ int support_short_GI(_adapter *padapter, struct HT_caps_element *pHT_caps)
 	else
 	{
 		return _FAIL;
-	}
+	}		
 }
 
 unsigned char get_highest_rate_idx(u32 mask)
@@ -1686,9 +1686,9 @@ unsigned char get_highest_rate_idx(u32 mask)
 unsigned char get_highest_mcs_rate(struct HT_caps_element *pHT_caps)
 {
 	int i, mcs_rate;
-
+	
 	mcs_rate = (pHT_caps->u.HT_cap_element.MCS_rate[0] | (pHT_caps->u.HT_cap_element.MCS_rate[1] << 8));
-
+	
 	for (i = 15; i >= 0; i--)
 	{
 		if (mcs_rate & (0x1 << i))
@@ -1696,7 +1696,7 @@ unsigned char get_highest_mcs_rate(struct HT_caps_element *pHT_caps)
 			break;
 		}
 	}
-
+	
 	return i;
 }
 
@@ -1713,7 +1713,7 @@ void enable_rate_adaptive(_adapter *padapter, u32 mac_id)
 
 void set_sta_rate(_adapter *padapter, struct sta_info *psta)
 {
-	//rate adaptive
+	//rate adaptive	
 	enable_rate_adaptive(padapter, psta->mac_id);
 }
 
@@ -1766,7 +1766,7 @@ unsigned char check_assoc_AP(u8 *pframe, uint len)
 	for (i = sizeof(NDIS_802_11_FIXED_IEs); i < len;)
 	{
 		pIE = (PNDIS_802_11_VARIABLE_IEs)(pframe + i);
-
+		
 		switch (pIE->ElementID)
 		{
 			case _VENDOR_SPECIFIC_IE_:
@@ -1811,14 +1811,14 @@ unsigned char check_assoc_AP(u8 *pframe, uint len)
 				{
 					break;
 				}
-
+						
 			default:
 				break;
 		}
-
+				
 		i += (pIE->Length + 2);
 	}
-
+	
 	DBG_871X("link to new AP\n");
 	return unknownAP;
 }
@@ -1827,32 +1827,32 @@ void update_IOT_info(_adapter *padapter)
 {
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-
+	
 	switch (pmlmeinfo->assoc_AP_vendor)
 	{
 		case marvellAP:
 			pmlmeinfo->turboMode_cts2self = 1;
 			pmlmeinfo->turboMode_rtsen = 0;
 			break;
-
+		
 		case ralinkAP:
 			pmlmeinfo->turboMode_cts2self = 0;
 			pmlmeinfo->turboMode_rtsen = 1;
-			//disable high power
+			//disable high power			
 			Switch_DM_Func(padapter, (~DYNAMIC_FUNC_HP), _FALSE);
 			break;
 		case realtekAP:
 			//rtw_write16(padapter, 0x4cc, 0xffff);
 			//rtw_write16(padapter, 0x546, 0x01c0);
-			//disable high power
+			//disable high power			
 			Switch_DM_Func(padapter, (~DYNAMIC_FUNC_HP), _FALSE);
 			break;
 		default:
 			pmlmeinfo->turboMode_cts2self = 0;
 			pmlmeinfo->turboMode_rtsen = 1;
-			break;
+			break;	
 	}
-
+	
 }
 
 void update_capinfo(PADAPTER Adapter, u16 updateCap)
@@ -1865,7 +1865,7 @@ void update_capinfo(PADAPTER Adapter, u16 updateCap)
 	// Mark to update preamble value forever, 2008.03.18 by lanhsin
 	//if( pMgntInfo->RegPreambleMode == PREAMBLE_AUTO )
 	{
-
+			
 		if(updateCap & cShortPreamble)
 		{ // Short Preamble
 			if(pmlmeinfo->preamble_mode != PREAMBLE_SHORT) // PREAMBLE_LONG or PREAMBLE_AUTO
@@ -1919,8 +1919,8 @@ void update_capinfo(PADAPTER Adapter, u16 updateCap)
 			//B Mode
 			pmlmeinfo->slotTime = NON_SHORT_SLOT_TIME;
 		}
-	}
-
+ 	}
+ 
 	rtw_hal_set_hwreg( Adapter, HW_VAR_SLOT_TIME, &pmlmeinfo->slotTime );
 
 }
@@ -1960,7 +1960,7 @@ void update_wireless_mode(_adapter *padapter)
 		{
 			network_type = WIRELESS_11_24N;
 		}
-
+	
 		if ((cckratesonly_included(rate, ratelen)) == _TRUE)
 		{
 			network_type |= WIRELESS_11B;
@@ -1982,7 +1982,7 @@ void update_wireless_mode(_adapter *padapter)
 	mask = update_supported_rate(cur_network->SupportedRates, ratelen);
 	init_rate = get_highest_rate_idx(mask)&0x3f;
 	rtw_hal_set_hwreg( padapter, HW_VAR_INIT_DATA_RATE,  (u8 *)&init_rate);
-
+	
 /*
 	if((pmlmeext->cur_wireless_mode==WIRELESS_11G) ||
 		(pmlmeext->cur_wireless_mode==WIRELESS_11BG))//WIRELESS_MODE_G)
@@ -1990,10 +1990,10 @@ void update_wireless_mode(_adapter *padapter)
 	else
 		SIFS_Timer = 0x0e0e;//pHalData->SifsTime; //OFDM
 */
-
+	
 	SIFS_Timer = 0x0a0a0808; //0x0808 -> for CCK, 0x0a0a -> for OFDM
                              //change this value if having IOT issues.
-
+		
 	rtw_hal_set_hwreg( padapter, HW_VAR_RESP_SIFS,  (u8 *)&SIFS_Timer);
 
 	if (pmlmeext->cur_wireless_mode & WIRELESS_11B)
@@ -2019,21 +2019,21 @@ void fire_write_MAC_cmd(_adapter *padapter, unsigned int addr, unsigned int valu
 	if ((ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj))) == NULL)
 	{
 		return;
-	}
+	}	
 
-	if ((pwriteMacPara = (struct reg_rw_parm*)rtw_malloc(sizeof(struct reg_rw_parm))) == NULL)
-	{
+	if ((pwriteMacPara = (struct reg_rw_parm*)rtw_malloc(sizeof(struct reg_rw_parm))) == NULL) 
+	{		
 		rtw_mfree((unsigned char *)ph2c, sizeof(struct cmd_obj));
 		return;
 	}
-
+	
 	pwriteMacPara->rw = 1;
 	pwriteMacPara->addr = addr;
 	pwriteMacPara->value = value;
-
+	
 	init_h2fwcmd_w_parm_no_rsp(ph2c, pwriteMacPara, GEN_CMD_CODE(_Write_MACREG));
 	rtw_enqueue_cmd(pcmdpriv, ph2c);
-#endif
+#endif	
 }
 
 void update_bmc_sta_support_rate(_adapter *padapter, u32 mac_id)
@@ -2059,16 +2059,16 @@ int update_sta_support_rate(_adapter *padapter, u8* pvar_ie, uint var_ie_len, in
 	int	supportRateNum = 0;
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-
+	
 	pIE = (PNDIS_802_11_VARIABLE_IEs)rtw_get_ie(pvar_ie, _SUPPORTEDRATES_IE_, &ie_len, var_ie_len);
 	if (pIE == NULL)
 	{
 		return _FAIL;
 	}
-
+	
 	_rtw_memcpy(pmlmeinfo->FW_sta_info[cam_idx].SupportedRates, pIE->data, ie_len);
 	supportRateNum = ie_len;
-
+				
 	pIE = (PNDIS_802_11_VARIABLE_IEs)rtw_get_ie(pvar_ie, _EXT_SUPPORTEDRATES_IE_, &ie_len, var_ie_len);
 	if (pIE)
 	{
@@ -2076,15 +2076,15 @@ int update_sta_support_rate(_adapter *padapter, u8* pvar_ie, uint var_ie_len, in
 	}
 
 	return _SUCCESS;
-
+	
 }
 
 void process_addba_req(_adapter *padapter, u8 *paddba_req, u8 *addr)
 {
 	struct sta_info *psta;
-	u16 tid, start_seq, param;
+	u16 tid, start_seq, param;	
 	struct recv_reorder_ctrl *preorder_ctrl;
-	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct sta_priv *pstapriv = &padapter->stapriv;	
 	struct ADDBA_request	*preq = (struct ADDBA_request*)paddba_req;
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
@@ -2094,10 +2094,10 @@ void process_addba_req(_adapter *padapter, u8 *paddba_req, u8 *addr)
 	if(psta)
 	{
 		start_seq = le16_to_cpu(preq->BA_starting_seqctrl) >> 4;
-
+			
 		param = le16_to_cpu(preq->BA_para_set);
 		tid = (param>>2)&0x0f;
-
+		
 		preorder_ctrl = &psta->recvreorder_ctrl[tid];
 
 		#ifdef CONFIG_UPDATE_INDICATE_SEQ_WHILE_PROCESS_ADDBA_REQ
@@ -2109,22 +2109,22 @@ void process_addba_req(_adapter *padapter, u8 *paddba_req, u8 *addr)
 		#else
 		preorder_ctrl->indicate_seq = 0xffff;
 		#endif
-
+		
 		preorder_ctrl->enable =(pmlmeinfo->bAcceptAddbaReq == _TRUE)? _TRUE :_FALSE;
 	}
 
 }
 
 void update_TSF(struct mlme_ext_priv *pmlmeext, u8 *pframe, uint len)
-{
+{	
 	u8* pIE;
 	u32 *pbuf;
-
+		
 	pIE = pframe + sizeof(struct rtw_ieee80211_hdr_3addr);
 	pbuf = (u32*)pIE;
 
 	pmlmeext->TSFValue = le32_to_cpu(*(pbuf+1));
-
+	
 	pmlmeext->TSFValue = pmlmeext->TSFValue << 32;
 
 	pmlmeext->TSFValue |= le32_to_cpu(*pbuf);
@@ -2154,23 +2154,23 @@ unsigned int setup_beacon_frame(_adapter *padapter, unsigned char *beacon_frame)
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	WLAN_BSSID_EX 		*cur_network = &(pmlmeinfo->network);
 	u8	bc_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
-
+	
 	_rtw_memset(beacon_frame, 0, 256);
-
+	
 	pframe = beacon_frame + TXDESC_SIZE;
-
-	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
-
+	
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;	
+	
 	fctrl = &(pwlanhdr->frame_ctl);
 	*(fctrl) = 0;
-
+	
 	_rtw_memcpy(pwlanhdr->addr1, bc_addr, ETH_ALEN);
 	_rtw_memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);
 	_rtw_memcpy(pwlanhdr->addr3, get_my_bssid(cur_network), ETH_ALEN);
-
+	
 	SetFrameSubType(pframe, WIFI_BEACON);
-
-	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);
+	
+	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);	
 	len = sizeof(struct rtw_ieee80211_hdr_3addr);
 
 	//timestamp will be inserted by hardware
@@ -2178,7 +2178,7 @@ unsigned int setup_beacon_frame(_adapter *padapter, unsigned char *beacon_frame)
 	len += 8;
 
 	// beacon interval: 2 bytes
-	_rtw_memcpy(pframe, (unsigned char *)(rtw_get_beacon_interval_from_ie(cur_network->IEs)), 2);
+	_rtw_memcpy(pframe, (unsigned char *)(rtw_get_beacon_interval_from_ie(cur_network->IEs)), 2); 
 
 	pframe += 2;
 	len += 2;
@@ -2205,7 +2205,7 @@ unsigned int setup_beacon_frame(_adapter *padapter, unsigned char *beacon_frame)
 	pframe = rtw_set_ie(pframe, _IBSS_PARA_IE_, 2, (unsigned char *)(&ATIMWindow), &len);
 
 	//todo: ERP IE
-
+	
 	// EXTERNDED SUPPORTED RATE
 	if (rate_len > 8)
 	{
@@ -2220,24 +2220,24 @@ unsigned int setup_beacon_frame(_adapter *padapter, unsigned char *beacon_frame)
 
 	//fill the tx descriptor
 	ptxdesc = (struct tx_desc *)beacon_frame;
-
-	//offset 0
-	ptxdesc->txdw0 |= cpu_to_le32(len & 0x0000ffff);
+	
+	//offset 0	
+	ptxdesc->txdw0 |= cpu_to_le32(len & 0x0000ffff); 
 	ptxdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE + OFFSET_SZ) << OFFSET_SHT) & 0x00ff0000); //default = 32 bytes for TX Desc
-
-	//offset 4
+	
+	//offset 4	
 	ptxdesc->txdw1 |= cpu_to_le32((0x10 << QSEL_SHT) & 0x00001f00);
-
-	//offset 8
+	
+	//offset 8		
 	ptxdesc->txdw2 |= cpu_to_le32(BMC);
 	ptxdesc->txdw2 |= cpu_to_le32(BK);
 
-	//offset 16
+	//offset 16		
 	ptxdesc->txdw4 = 0x80000000;
-
+	
 	//offset 20
-	ptxdesc->txdw5 = 0x00000000; //1M
-
+	ptxdesc->txdw5 = 0x00000000; //1M	
+	
 	return (len + TXDESC_SIZE);
 }
 #endif
@@ -2258,7 +2258,7 @@ int rtw_handle_dualmac(_adapter *adapter, bool init)
 			// temply disable IPS For 92D-VC
 			adapter->registrypriv.ips_mode = IPS_NONE;
 		}
-
+		
 		/* For SMSP on 92DU-VC, driver do not probe another Interface. */
 		if ((dvobj->DualMacMode != _TRUE) && (dvobj->InterfaceNumber != 0)) {
 			DBG_871X("%s(): Do not init another Interface because SMSP\n",__FUNCTION__);
@@ -2302,3 +2302,4 @@ int rtw_handle_dualmac(_adapter *adapter, bool init)
 exit:
 	return status;
 }
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_xmit.c b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_xmit.c
old mode 100644
new mode 100755
index c069543..18f1fdb
--- a/drivers/net/wireless/realtek/rtl8192cu/core/rtw_xmit.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/core/rtw_xmit.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -50,19 +50,19 @@ static void _init_txservq(struct tx_servq *ptxservq)
 	_rtw_init_listhead(&ptxservq->tx_pending);
 	_rtw_init_queue(&ptxservq->sta_pending);
 	ptxservq->qcnt = 0;
-_func_exit_;
+_func_exit_;		
 }
 
 
 void	_rtw_init_sta_xmit_priv(struct sta_xmit_priv *psta_xmitpriv)
-{
-
+{	
+	
 _func_enter_;
 
 	_rtw_memset((unsigned char *)psta_xmitpriv, 0, sizeof (struct sta_xmit_priv));
 
 	_rtw_spinlock_init(&psta_xmitpriv->lock);
-
+	
 	//for(i = 0 ; i < MAX_NUMBLKS; i++)
 	//	_init_txservq(&(psta_xmitpriv->blk_q[i]));
 
@@ -72,8 +72,8 @@ void	_rtw_init_sta_xmit_priv(struct sta_xmit_priv *psta_xmitpriv)
 	_init_txservq(&psta_xmitpriv->vo_q);
 	_rtw_init_listhead(&psta_xmitpriv->legacy_dz);
 	_rtw_init_listhead(&psta_xmitpriv->apsd);
-
-_func_exit_;
+	
+_func_exit_;	
 
 }
 
@@ -82,27 +82,27 @@ s32	_rtw_init_xmit_priv(struct xmit_priv *pxmitpriv, _adapter *padapter)
 	int i;
 	struct xmit_buf *pxmitbuf;
 	struct xmit_frame *pxframe;
-	sint	res=_SUCCESS;
+	sint	res=_SUCCESS;   
 
-_func_enter_;
+_func_enter_;   	
 
 	// We don't need to memset padapter->XXX to zero, because adapter is allocated by rtw_zvmalloc().
 	//_rtw_memset((unsigned char *)pxmitpriv, 0, sizeof(struct xmit_priv));
-
+	
 	_rtw_spinlock_init(&pxmitpriv->lock);
 	_rtw_spinlock_init(&pxmitpriv->lock_sctx);
 	_rtw_init_sema(&pxmitpriv->xmit_sema, 0);
 	_rtw_init_sema(&pxmitpriv->terminate_xmitthread_sema, 0);
 
-	/*
+	/* 
 	Please insert all the queue initializaiton using _rtw_init_queue below
 	*/
 
 	pxmitpriv->adapter = padapter;
-
+	
 	//for(i = 0 ; i < MAX_NUMBLKS; i++)
 	//	_rtw_init_queue(&pxmitpriv->blk_strms[i]);
-
+	
 	_rtw_init_queue(&pxmitpriv->be_pending);
 	_rtw_init_queue(&pxmitpriv->bk_pending);
 	_rtw_init_queue(&pxmitpriv->vi_pending);
@@ -114,17 +114,17 @@ s32	_rtw_init_xmit_priv(struct xmit_priv *pxmitpriv, _adapter *padapter)
 
 	_rtw_init_queue(&pxmitpriv->free_xmit_queue);
 
-	/*
-	Please allocate memory with the sz = (struct xmit_frame) * NR_XMITFRAME,
+	/*	
+	Please allocate memory with the sz = (struct xmit_frame) * NR_XMITFRAME, 
 	and initialize free_xmit_frame below.
 	Please also apply  free_txobj to link_up all the xmit_frames...
 	*/
 
 	pxmitpriv->pallocated_frame_buf = rtw_zvmalloc(NR_XMITFRAME * sizeof(struct xmit_frame) + 4);
-
+	
 	if (pxmitpriv->pallocated_frame_buf  == NULL){
 		pxmitpriv->pxmit_frame_buf =NULL;
-		RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("alloc xmit_frame fail!\n"));
+		RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("alloc xmit_frame fail!\n"));	
 		res= _FAIL;
 		goto exit;
 	}
@@ -141,11 +141,11 @@ s32	_rtw_init_xmit_priv(struct xmit_priv *pxmitpriv, _adapter *padapter)
 		pxframe->padapter = padapter;
 		pxframe->frame_tag = NULL_FRAMETAG;
 
-		pxframe->pkt = NULL;
+		pxframe->pkt = NULL;		
 
 		pxframe->buf_addr = NULL;
 		pxframe->pxmitbuf = NULL;
-
+ 
 		rtw_list_insert_tail(&(pxframe->list), &(pxmitpriv->free_xmit_queue.queue));
 
 		pxframe++;
@@ -161,7 +161,7 @@ s32	_rtw_init_xmit_priv(struct xmit_priv *pxmitpriv, _adapter *padapter)
 	_rtw_init_queue(&pxmitpriv->pending_xmitbuf_queue);
 
 	pxmitpriv->pallocated_xmitbuf = rtw_zvmalloc(NR_XMITBUFF * sizeof(struct xmit_buf) + 4);
-
+	
 	if (pxmitpriv->pallocated_xmitbuf  == NULL){
 		RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("alloc xmit_buf fail!\n"));
 		res= _FAIL;
@@ -207,26 +207,26 @@ s32	_rtw_init_xmit_priv(struct xmit_priv *pxmitpriv, _adapter *padapter)
 #endif
 
 		pxmitbuf->flags = XMIT_VO_QUEUE;
-
+		
 		rtw_list_insert_tail(&pxmitbuf->list, &(pxmitpriv->free_xmitbuf_queue.queue));
 		#ifdef DBG_XMIT_BUF
 		pxmitbuf->no=i;
 		#endif
 
 		pxmitbuf++;
-
+		
 	}
 
 	pxmitpriv->free_xmitbuf_cnt = NR_XMITBUFF;
 
 	/* init xframe_ext queue,  the same count as extbuf  */
 	_rtw_init_queue(&pxmitpriv->free_xframe_ext_queue);
-
+	
 	pxmitpriv->xframe_ext_alloc_addr = rtw_zvmalloc(NR_XMIT_EXTBUFF * sizeof(struct xmit_frame) + 4);
-
+	
 	if (pxmitpriv->xframe_ext_alloc_addr  == NULL){
 		pxmitpriv->xframe_ext = NULL;
-		RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("alloc xframe_ext fail!\n"));
+		RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("alloc xframe_ext fail!\n"));	
 		res= _FAIL;
 		goto exit;
 	}
@@ -239,13 +239,13 @@ s32	_rtw_init_xmit_priv(struct xmit_priv *pxmitpriv, _adapter *padapter)
 		pxframe->padapter = padapter;
 		pxframe->frame_tag = NULL_FRAMETAG;
 
-		pxframe->pkt = NULL;
+		pxframe->pkt = NULL;		
 
 		pxframe->buf_addr = NULL;
 		pxframe->pxmitbuf = NULL;
-
+		
 		pxframe->ext_tag = 1;
-
+ 
 		rtw_list_insert_tail(&(pxframe->list), &(pxmitpriv->free_xframe_ext_queue.queue));
 
 		pxframe++;
@@ -256,7 +256,7 @@ s32	_rtw_init_xmit_priv(struct xmit_priv *pxmitpriv, _adapter *padapter)
 	_rtw_init_queue(&pxmitpriv->free_xmit_extbuf_queue);
 
 	pxmitpriv->pallocated_xmit_extbuf = rtw_zvmalloc(NR_XMIT_EXTBUFF * sizeof(struct xmit_buf) + 4);
-
+	
 	if (pxmitpriv->pallocated_xmit_extbuf  == NULL){
 		RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("alloc xmit_extbuf fail!\n"));
 		res= _FAIL;
@@ -284,13 +284,13 @@ s32	_rtw_init_xmit_priv(struct xmit_priv *pxmitpriv, _adapter *padapter)
 		}
 
 		pxmitbuf->pbuf = (u8 *)N_BYTE_ALIGMENT((SIZE_PTR)(pxmitbuf->pallocated_buf), 4);
-*/
+*/		
 
 		if((res=rtw_os_xmit_resource_alloc(padapter, pxmitbuf,MAX_XMIT_EXTBUF_SZ + XMITBUF_ALIGN_SZ)) == _FAIL) {
 			res= _FAIL;
 			goto exit;
 		}
-
+		
 #ifdef CONFIG_SDIO_HCI
 		pxmitbuf->phead = pxmitbuf->pbuf;
 		pxmitbuf->pend = pxmitbuf->pbuf + MAX_XMIT_EXTBUF_SZ;
@@ -303,7 +303,7 @@ s32	_rtw_init_xmit_priv(struct xmit_priv *pxmitpriv, _adapter *padapter)
 		pxmitbuf->no=i;
 		#endif
 		pxmitbuf++;
-
+		
 	}
 
 	pxmitpriv->free_xmit_extbuf_cnt = NR_XMIT_EXTBUFF;
@@ -327,14 +327,14 @@ s32	_rtw_init_xmit_priv(struct xmit_priv *pxmitpriv, _adapter *padapter)
 #ifdef CONFIG_XMIT_ACK
 	pxmitpriv->ack_tx = _FALSE;
 	_rtw_mutex_init(&pxmitpriv->ack_tx_mutex);
-	rtw_sctx_init(&pxmitpriv->ack_tx_ops, 0);
+	rtw_sctx_init(&pxmitpriv->ack_tx_ops, 0);	
 #endif
 
 	rtw_hal_init_xmit_priv(padapter);
 
 exit:
 
-_func_exit_;
+_func_exit_;	
 
 	return res;
 }
@@ -368,36 +368,36 @@ void _rtw_free_xmit_priv (struct xmit_priv *pxmitpriv)
 	struct xmit_frame	*pxmitframe = (struct xmit_frame*) pxmitpriv->pxmit_frame_buf;
 	struct xmit_buf *pxmitbuf = (struct xmit_buf *)pxmitpriv->pxmitbuf;
 
- _func_enter_;
+ _func_enter_;   
 
 	rtw_hal_free_xmit_priv(padapter);
-
+ 
 	rtw_mfree_xmit_priv_lock(pxmitpriv);
-
-	if(pxmitpriv->pxmit_frame_buf==NULL)
+ 
+ 	if(pxmitpriv->pxmit_frame_buf==NULL)
 		goto out;
-
+	
 	for(i=0; i<NR_XMITFRAME; i++)
-	{
+	{	
 		rtw_os_xmit_complete(padapter, pxmitframe);
 
 		pxmitframe++;
-	}
-
+	}		
+	
 	for(i=0; i<NR_XMITBUFF; i++)
 	{
 		rtw_os_xmit_resource_free(padapter, pxmitbuf,(MAX_XMITBUF_SZ + XMITBUF_ALIGN_SZ));
 
 		//if(pxmitbuf->pallocated_buf)
 		//	rtw_mfree(pxmitbuf->pallocated_buf, MAX_XMITBUF_SZ + XMITBUF_ALIGN_SZ);
-
+		
 		pxmitbuf++;
 	}
 
 	if(pxmitpriv->pallocated_frame_buf) {
 		rtw_vmfree(pxmitpriv->pallocated_frame_buf, NR_XMITFRAME * sizeof(struct xmit_frame) + 4);
 	}
-
+	
 
 	if(pxmitpriv->pallocated_xmitbuf) {
 		rtw_vmfree(pxmitpriv->pallocated_xmitbuf, NR_XMITBUFF * sizeof(struct xmit_buf) + 4);
@@ -424,23 +424,23 @@ void _rtw_free_xmit_priv (struct xmit_priv *pxmitpriv)
 
 		//if(pxmitbuf->pallocated_buf)
 		//	rtw_mfree(pxmitbuf->pallocated_buf, MAX_XMIT_EXTBUF_SZ);
-
+		
 		pxmitbuf++;
 	}
 
 	if(pxmitpriv->pallocated_xmit_extbuf) {
-		rtw_vmfree(pxmitpriv->pallocated_xmit_extbuf, NR_XMIT_EXTBUFF * sizeof(struct xmit_buf) + 4);
+		rtw_vmfree(pxmitpriv->pallocated_xmit_extbuf, NR_XMIT_EXTBUFF * sizeof(struct xmit_buf) + 4);	
 	}
 
 	rtw_free_hwxmits(padapter);
 
-#ifdef CONFIG_XMIT_ACK
-	_rtw_mutex_free(&pxmitpriv->ack_tx_mutex);
-#endif
+#ifdef CONFIG_XMIT_ACK	
+	_rtw_mutex_free(&pxmitpriv->ack_tx_mutex);	
+#endif	
 
-out:
+out:	
 
-_func_exit_;
+_func_exit_;		
 
 }
 
@@ -529,8 +529,8 @@ static void update_attrib_vcs_info(_adapter *padapter, struct xmit_frame *pxmitf
 			{
 				pattrib->vcs_mode = CTS_TO_SELF;
 				break;
-			}
-
+			}	
+			
 
 			//check ERP protection
 			if(psta->rtsen || psta->cts2self)
@@ -579,17 +579,17 @@ static void update_attrib_vcs_info(_adapter *padapter, struct xmit_frame *pxmitf
 
 static void update_attrib_phy_info(struct pkt_attrib *pattrib, struct sta_info *psta)
 {
-	/*if(psta->rtsen)
-		pattrib->vcs_mode = RTS_CTS;
-	else if(psta->cts2self)
-		pattrib->vcs_mode = CTS_TO_SELF;
+	/*if(psta->rtsen)	
+		pattrib->vcs_mode = RTS_CTS;	
+	else if(psta->cts2self)	
+		pattrib->vcs_mode = CTS_TO_SELF;	
 	else
 		pattrib->vcs_mode = NONE_VCS;*/
-
+	
 	pattrib->mdata = 0;
 	pattrib->eosp = 0;
 	pattrib->triggered=0;
-
+	
 	//qos_en, ht_en, init rate, ,bw, ch_offset, sgi
 	pattrib->qos_en = psta->qos_option;
 	pattrib->ht_en = psta->htpriv.ht_option;
@@ -603,7 +603,7 @@ static void update_attrib_phy_info(struct pkt_attrib *pattrib, struct sta_info *
 	//{
 	//	if(psta->htpriv.agg_enable_bitmap & BIT(pattrib->priority))
 	//		pattrib->ampdu_en = _TRUE;
-	//}
+	//}	
 
 
 	pattrib->retry_ctrl = _FALSE;
@@ -713,7 +713,7 @@ static s32 update_attrib(_adapter *padapter, _pkt *pkt, struct pkt_attrib *pattr
 
 	if (ETH_P_IP == pattrib->ether_type)
 	{
-		// The following is for DHCP and ARP packet, we use cck1M to tx these packets and let LPS awake some time
+		// The following is for DHCP and ARP packet, we use cck1M to tx these packets and let LPS awake some time 
 		// to prevent DHCP protocol fail
 		u8 tmp[24];
 		_rtw_pktfile_read(&pktfile, &tmp[0], 24);
@@ -726,14 +726,14 @@ static s32 update_attrib(_adapter *padapter, _pkt *pkt, struct pkt_attrib *pattr
 					// 67 : UDP BOOTP server
 					RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("======================update_attrib: get DHCP Packet \n"));
 					// Use low rate to send DHCP packet.
-					//if(pMgntInfo->IOTAction & HT_IOT_ACT_WA_IOT_Broadcom)
+					//if(pMgntInfo->IOTAction & HT_IOT_ACT_WA_IOT_Broadcom) 
 					//{
 					//	tcb_desc->DataRate = MgntQuery_TxRateExcludeCCKRates(ieee);//0xc;//ofdm 6m
 					//	tcb_desc->bTxDisableRateFallBack = false;
 					//}
 					//else
-					//	pTcb->DataRate = Adapter->MgntInfo.LowestBasicRate;
-					//RTPRINT(FDM, WA_IOT, ("DHCP TranslateHeader(), pTcb->DataRate = 0x%x\n", pTcb->DataRate));
+					//	pTcb->DataRate = Adapter->MgntInfo.LowestBasicRate; 
+					//RTPRINT(FDM, WA_IOT, ("DHCP TranslateHeader(), pTcb->DataRate = 0x%x\n", pTcb->DataRate)); 
 					pattrib->dhcp_pkt = 1;
 				}
 			}
@@ -754,7 +754,7 @@ static s32 update_attrib(_adapter *padapter, _pkt *pkt, struct pkt_attrib *pattr
 #endif
 
 	bmcast = IS_MCAST(pattrib->ra);
-
+	
 	// get sta_info
 	if (bmcast) {
 		psta = rtw_get_bcmc_stainfo(padapter);
@@ -796,9 +796,9 @@ static s32 update_attrib(_adapter *padapter, _pkt *pkt, struct pkt_attrib *pattr
 	pattrib->pkt_hdrlen = ETH_HLEN;//(pattrib->ether_type == 0x8100) ? (14 + 4 ): 14; //vlan tag
 
 	pattrib->hdrlen = WLAN_HDR_A3_LEN;
-	pattrib->subtype = WIFI_DATA_TYPE;
+	pattrib->subtype = WIFI_DATA_TYPE;	
 	pattrib->priority = 0;
-
+	
 	if (check_fwstate(pmlmepriv, WIFI_AP_STATE|WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE))
 	{
 		if(psta->qos_option)
@@ -843,12 +843,12 @@ static s32 update_attrib(_adapter *padapter, _pkt *pkt, struct pkt_attrib *pattr
 		{
 			case dot11AuthAlgrthm_Open:
 			case dot11AuthAlgrthm_Shared:
-			case dot11AuthAlgrthm_Auto:
+			case dot11AuthAlgrthm_Auto:				
 				pattrib->key_idx = (u8)psecuritypriv->dot11PrivacyKeyIndex;
 				break;
 			case dot11AuthAlgrthm_8021X:
-				if(bmcast)
-					pattrib->key_idx = (u8)psecuritypriv->dot118021XGrpKeyid;
+				if(bmcast)					
+					pattrib->key_idx = (u8)psecuritypriv->dot118021XGrpKeyid;	
 				else
 					pattrib->key_idx = 0;
 				break;
@@ -856,8 +856,8 @@ static s32 update_attrib(_adapter *padapter, _pkt *pkt, struct pkt_attrib *pattr
 				pattrib->key_idx = 0;
 				break;
 		}
-
-
+		
+			
 	}
 
 	switch (pattrib->encrypt)
@@ -871,7 +871,7 @@ static s32 update_attrib(_adapter *padapter, _pkt *pkt, struct pkt_attrib *pattr
 		case _TKIP_:
 			pattrib->iv_len = 8;
 			pattrib->icv_len = 4;
-
+			
 			if(padapter->securitypriv.busetkipkey==_FAIL)
 			{
 				RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("\npadapter->securitypriv.busetkipkey(%d)==_FAIL drop packet\n", padapter->securitypriv.busetkipkey));
@@ -881,14 +881,14 @@ static s32 update_attrib(_adapter *padapter, _pkt *pkt, struct pkt_attrib *pattr
 				res =_FAIL;
 				goto exit;
 			}
-
-			break;
+					
+			break;			
 		case _AES_:
 			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("\n pattrib->encrypt=%d  (_AES_)\n",pattrib->encrypt));
 			pattrib->iv_len = 8;
 			pattrib->icv_len = 8;
 			break;
-
+			
 		default:
 			pattrib->iv_len = 0;
 			pattrib->icv_len = 0;
@@ -934,7 +934,7 @@ static s32 xmitframe_addmic(_adapter *padapter, struct xmit_frame *pxmitframe){
 	u8	*pframe, *payload,mic[8];
 	struct	mic_data		micdata;
 	struct	sta_info		*stainfo;
-	struct	qos_priv   *pqospriv= &(padapter->mlmepriv.qospriv);
+	struct	qos_priv   *pqospriv= &(padapter->mlmepriv.qospriv);	
 	struct	pkt_attrib	 *pattrib = &pxmitframe->attrib;
 	struct 	security_priv	*psecuritypriv=&padapter->securitypriv;
 	struct	xmit_priv		*pxmitpriv=&padapter->xmitpriv;
@@ -949,14 +949,14 @@ static s32 xmitframe_addmic(_adapter *padapter, struct xmit_frame *pxmitframe){
 	{
 		DBG_871X("%s, call rtw_get_stainfo()\n", __func__);
 		stainfo=rtw_get_stainfo(&padapter->stapriv ,&pattrib->ra[0]);
-	}
+	}	
 
 	if(stainfo==NULL)
 	{
 		DBG_871X("%s, psta==NUL\n", __func__);
 		return _FAIL;
 	}
-
+	
 	if(!(stainfo->state &_FW_LINKED))
 	{
 		DBG_871X("%s, psta->state(0x%x) != _FW_LINKED\n", __func__, stainfo->state);
@@ -965,7 +965,7 @@ static s32 xmitframe_addmic(_adapter *padapter, struct xmit_frame *pxmitframe){
 
 _func_enter_;
 
-	if(pattrib->encrypt ==_TKIP_)//if(psecuritypriv->dot11PrivacyAlgrthm==_TKIP_PRIVACY_)
+	if(pattrib->encrypt ==_TKIP_)//if(psecuritypriv->dot11PrivacyAlgrthm==_TKIP_PRIVACY_) 
 	{
 		//encode mic code
 		if(stainfo!= NULL){
@@ -976,14 +976,14 @@ static s32 xmitframe_addmic(_adapter *padapter, struct xmit_frame *pxmitframe){
 #else
 			pframe = pxmitframe->buf_addr + TXDESC_OFFSET;
 #endif
-
+			
 			if(bmcst)
 			{
 				if(_rtw_memcmp(psecuritypriv->dot118021XGrptxmickey[psecuritypriv->dot118021XGrpKeyid].skey, null_key, 16)==_TRUE){
 					//DbgPrint("\nxmitframe_addmic:stainfo->dot11tkiptxmickey==0\n");
 					//rtw_msleep_os(10);
 					return _FAIL;
-				}
+				}				
 				//start to calculate the mic code
 				rtw_secmicsetkey(&micdata, psecuritypriv->dot118021XGrptxmickey[psecuritypriv->dot118021XGrpKeyid].skey);
 			}
@@ -997,14 +997,14 @@ static s32 xmitframe_addmic(_adapter *padapter, struct xmit_frame *pxmitframe){
 				//start to calculate the mic code
 				rtw_secmicsetkey(&micdata, &stainfo->dot11tkiptxmickey.skey[0]);
 			}
-
+			
 			if(pframe[1]&1){   //ToDS==1
 				rtw_secmicappend(&micdata, &pframe[16], 6);  //DA
 				if(pframe[1]&2)  //From Ds==1
 					rtw_secmicappend(&micdata, &pframe[24], 6);
 				else
-				rtw_secmicappend(&micdata, &pframe[10], 6);
-			}
+				rtw_secmicappend(&micdata, &pframe[10], 6);		
+			}	
 			else{	//ToDS==0
 				rtw_secmicappend(&micdata, &pframe[4], 6);   //DA
 				if(pframe[1]&2)  //From Ds==1
@@ -1018,9 +1018,9 @@ static s32 xmitframe_addmic(_adapter *padapter, struct xmit_frame *pxmitframe){
                     if(pattrib->qos_en)
 				priority[0]=(u8)pxmitframe->attrib.priority;
 
-
+			
 			rtw_secmicappend(&micdata, &priority[0], 4);
-
+	
 			payload=pframe;
 
 			for(curfragnum=0;curfragnum<pattrib->nr_frags;curfragnum++){
@@ -1052,7 +1052,7 @@ static s32 xmitframe_addmic(_adapter *padapter, struct xmit_frame *pxmitframe){
 
 			_rtw_memcpy(payload, &(mic[0]),8);
 			pattrib->last_txcmdsz+=8;
-
+			
 			RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("\n ========last pkt========\n"));
 			payload=payload-pattrib->last_txcmdsz+8;
 			for(curfragnum=0;curfragnum<pattrib->last_txcmdsz;curfragnum=curfragnum+8)
@@ -1064,7 +1064,7 @@ static s32 xmitframe_addmic(_adapter *padapter, struct xmit_frame *pxmitframe){
 				RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("xmitframe_addmic: rtw_get_stainfo==NULL!!!\n"));
 			}
 	}
-
+	
 _func_exit_;
 
 	return _SUCCESS;
@@ -1074,10 +1074,10 @@ static s32 xmitframe_swencrypt(_adapter *padapter, struct xmit_frame *pxmitframe
 
 	struct	pkt_attrib	 *pattrib = &pxmitframe->attrib;
 	//struct 	security_priv	*psecuritypriv=&padapter->securitypriv;
-
+	
 _func_enter_;
 
-	//if((psecuritypriv->sw_encrypt)||(pattrib->bswenc))
+	//if((psecuritypriv->sw_encrypt)||(pattrib->bswenc))	
 	if(pattrib->bswenc)
 	{
 		//DBG_871X("start xmitframe_swencrypt\n");
@@ -1173,20 +1173,20 @@ s32 rtw_make_wlanhdr (_adapter *padapter , u8 *hdr, struct pkt_attrib *pattrib)
 				}else{
 					// 1.Data transfer to AP
 					// 2.Arp pkt will relayed by AP
-					SetToDs(fctrl);
+					SetToDs(fctrl);							
 					_rtw_memcpy(pwlanhdr->addr1, get_bssid(pmlmepriv), ETH_ALEN);
 					_rtw_memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
 					_rtw_memcpy(pwlanhdr->addr3, pattrib->dst, ETH_ALEN);
-				}
+				} 
 			}else
 #endif //CONFIG_TDLS
 			{
 				//Data transfer to AP
-				SetToDs(fctrl);
+				SetToDs(fctrl);							
 				_rtw_memcpy(pwlanhdr->addr1, get_bssid(pmlmepriv), ETH_ALEN);
 				_rtw_memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
 				_rtw_memcpy(pwlanhdr->addr3, pattrib->dst, ETH_ALEN);
-			}
+			} 
 
 			if (pqospriv->qos_option)
 				qos_option = _TRUE;
@@ -1199,7 +1199,7 @@ s32 rtw_make_wlanhdr (_adapter *padapter , u8 *hdr, struct pkt_attrib *pattrib)
 			_rtw_memcpy(pwlanhdr->addr2, get_bssid(pmlmepriv), ETH_ALEN);
 			_rtw_memcpy(pwlanhdr->addr3, pattrib->src, ETH_ALEN);
 
-			if(psta->qos_option)
+			if(psta->qos_option)			
 				qos_option = _TRUE;
 		}
 		else if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE) ||
@@ -1208,7 +1208,7 @@ s32 rtw_make_wlanhdr (_adapter *padapter , u8 *hdr, struct pkt_attrib *pattrib)
 			_rtw_memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
 			_rtw_memcpy(pwlanhdr->addr3, get_bssid(pmlmepriv), ETH_ALEN);
 
-			if(psta->qos_option)
+			if(psta->qos_option)			
 				qos_option = _TRUE;
 		}
 		else {
@@ -1265,11 +1265,11 @@ s32 rtw_make_wlanhdr (_adapter *padapter , u8 *hdr, struct pkt_attrib *pattrib)
 
 				//re-check if enable ampdu by BA_starting_seqctrl
 				if(pattrib->ampdu_en == _TRUE)
-				{
+				{					
 					u16 tx_seq;
 
 					tx_seq = psta->BA_starting_seqctrl[pattrib->priority & 0x0f];
-
+		
 					//check BA_starting_seqctrl
 					if(SN_LESS(pattrib->seqnum, tx_seq))
 					{
@@ -1277,9 +1277,9 @@ s32 rtw_make_wlanhdr (_adapter *padapter , u8 *hdr, struct pkt_attrib *pattrib)
 						pattrib->ampdu_en = _FALSE;//AGG BK
 					}
 					else if(SN_EQUAL(pattrib->seqnum, tx_seq))
-					{
+					{					
 						psta->BA_starting_seqctrl[pattrib->priority & 0x0f] = (tx_seq+1)&0xfff;
-
+					
 						pattrib->ampdu_en = _TRUE;//AGG EN
 					}
 					else
@@ -1316,7 +1316,7 @@ s32 rtw_make_wlanhdr (_adapter *padapter , u8 *hdr, struct pkt_attrib *pattrib)
 
 			}
 		}
-
+		
 	}
 	else
 	{
@@ -1334,14 +1334,14 @@ s32 rtw_txframes_pending(_adapter *padapter)
 {
 	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
 
-	return ((_rtw_queue_empty(&pxmitpriv->be_pending) == _FALSE) ||
-			 (_rtw_queue_empty(&pxmitpriv->bk_pending) == _FALSE) ||
+	return ((_rtw_queue_empty(&pxmitpriv->be_pending) == _FALSE) || 
+			 (_rtw_queue_empty(&pxmitpriv->bk_pending) == _FALSE) || 
 			 (_rtw_queue_empty(&pxmitpriv->vi_pending) == _FALSE) ||
 			 (_rtw_queue_empty(&pxmitpriv->vo_pending) == _FALSE));
 }
 
 s32 rtw_txframes_sta_ac_pending(_adapter *padapter, struct pkt_attrib *pattrib)
-{
+{	
 	struct sta_info *psta;
 	struct tx_servq *ptxservq;
 	int priority = pattrib->priority;
@@ -1354,7 +1354,7 @@ s32 rtw_txframes_sta_ac_pending(_adapter *padapter, struct pkt_attrib *pattrib)
 	{
 		DBG_871X("%s, call rtw_get_stainfo()\n", __func__);
 		psta=rtw_get_stainfo(&padapter->stapriv ,&pattrib->ra[0]);
-	}
+	}	
 
 	if(psta==NULL)
 	{
@@ -1367,30 +1367,30 @@ s32 rtw_txframes_sta_ac_pending(_adapter *padapter, struct pkt_attrib *pattrib)
 		DBG_871X("%s, psta->state(0x%x) != _FW_LINKED\n", __func__, psta->state);
 		return 0;
 	}
-
-	switch(priority)
+	
+	switch(priority) 
 	{
 			case 1:
 			case 2:
-				ptxservq = &(psta->sta_xmitpriv.bk_q);
+				ptxservq = &(psta->sta_xmitpriv.bk_q);				
 				break;
 			case 4:
 			case 5:
-				ptxservq = &(psta->sta_xmitpriv.vi_q);
+				ptxservq = &(psta->sta_xmitpriv.vi_q);				
 				break;
 			case 6:
 			case 7:
-				ptxservq = &(psta->sta_xmitpriv.vo_q);
+				ptxservq = &(psta->sta_xmitpriv.vo_q);							
 				break;
 			case 0:
 			case 3:
 			default:
-				ptxservq = &(psta->sta_xmitpriv.be_q);
+				ptxservq = &(psta->sta_xmitpriv.be_q);							
 			break;
+	
+	}	
 
-	}
-
-	return ptxservq->qcnt;
+	return ptxservq->qcnt;	
 }
 
 #ifdef CONFIG_TDLS
@@ -1414,7 +1414,7 @@ int rtw_build_tdls_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *
 			break;
 		case TDLS_DISCOVERY_REQUEST:
 			rtw_build_tdls_dis_req_ies(padapter, pxmitframe, pframe);
-			break;
+			break;			
 		case TDLS_PEER_TRAFFIC_INDICATION:
 			rtw_build_tdls_peer_traffic_indication_ies(padapter, pxmitframe, pframe);
 			break;
@@ -1424,7 +1424,7 @@ int rtw_build_tdls_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *
 		case TDLS_CHANNEL_SWITCH_RESPONSE:
 			rtw_build_tdls_ch_switch_rsp_ies(padapter, pxmitframe, pframe);
 			break;
-#ifdef CONFIG_WFD
+#ifdef CONFIG_WFD			
 		case TUNNELED_PROBE_REQ:
 			rtw_build_tunneled_probe_req_ies(padapter, pxmitframe, pframe);
 			break;
@@ -1467,8 +1467,8 @@ s32 rtw_make_tdls_wlanhdr (_adapter *padapter , u8 *hdr, struct pkt_attrib *patt
 		case TDLS_PEER_TRAFFIC_INDICATION:
 		case TDLS_PEER_PSM_REQUEST:	//directly to peer STA or via AP
 		case TUNNELED_PROBE_REQ:
-		case TUNNELED_PROBE_RSP:
-			SetToDs(fctrl);
+		case TUNNELED_PROBE_RSP:		
+			SetToDs(fctrl);							
 			_rtw_memcpy(pwlanhdr->addr1, get_bssid(pmlmepriv), ETH_ALEN);
 			_rtw_memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
 			_rtw_memcpy(pwlanhdr->addr3, pattrib->dst, ETH_ALEN);
@@ -1485,7 +1485,7 @@ s32 rtw_make_tdls_wlanhdr (_adapter *padapter , u8 *hdr, struct pkt_attrib *patt
 		case TDLS_DISCOVERY_REQUEST:	//unicast: directly to peer sta, Bcast: via AP
 			if(_rtw_memcmp(pattrib->dst, baddr, ETH_ALEN) )
 			{
-				SetToDs(fctrl);
+				SetToDs(fctrl);							
 				_rtw_memcpy(pwlanhdr->addr1, get_bssid(pmlmepriv), ETH_ALEN);
 				_rtw_memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
 				_rtw_memcpy(pwlanhdr->addr3, pattrib->dst, ETH_ALEN);
@@ -1512,7 +1512,7 @@ s32 rtw_make_tdls_wlanhdr (_adapter *padapter , u8 *hdr, struct pkt_attrib *patt
 	}
 
 	psta = pattrib->psta;
-
+ 
 	//  1. update seq_num per link by sta_info
 	//  2. rewrite encrypt to _AES_, also rewrite iv_len, icv_len
 	if(tdls_seq==1){
@@ -1560,12 +1560,12 @@ s32 rtw_xmit_tdls_coalesce(_adapter * padapter, struct xmit_frame * pxmitframe,
 	u8 *pbuf_start;
 	s32 bmcst = IS_MCAST(pattrib->ra);
 	s32 res = _SUCCESS;
-
+	
 _func_enter_;
 
 	if (pattrib->psta) {
 		psta = pattrib->psta;
-	} else {
+	} else {	
 		if(bmcst) {
 			psta = rtw_get_bcmc_stainfo(padapter);
 		} else {
@@ -1599,14 +1599,14 @@ s32 rtw_xmit_tdls_coalesce(_adapter * padapter, struct xmit_frame * pxmitframe,
 			{
 				case _WEP40_:
 				case _WEP104_:
-						WEP_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);
+						WEP_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);	
 					break;
-				case _TKIP_:
+				case _TKIP_:			
 					if(bmcst)
 						TKIP_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);
 					else
 						TKIP_IV(pattrib->iv, psta->dot11txpn, 0);
-					break;
+					break;			
 				case _AES_:
 					if(bmcst)
 						AES_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);
@@ -1631,26 +1631,26 @@ s32 rtw_xmit_tdls_coalesce(_adapter * padapter, struct xmit_frame * pxmitframe,
 
 	if ((pattrib->icv_len >0 )&& (pattrib->bswenc)) {
 		pframe += pattrib->pktlen;
-		_rtw_memcpy(pframe, pattrib->icv, pattrib->icv_len);
+		_rtw_memcpy(pframe, pattrib->icv, pattrib->icv_len); 
 		pframe += pattrib->icv_len;
 	}
 
 	pattrib->nr_frags = 1;
-	pattrib->last_txcmdsz = pattrib->hdrlen + pattrib->iv_len + llc_sz +
+	pattrib->last_txcmdsz = pattrib->hdrlen + pattrib->iv_len + llc_sz + 
 			((pattrib->bswenc) ? pattrib->icv_len : 0) + pattrib->pktlen;
-
+	
 	if (xmitframe_addmic(padapter, pxmitframe) == _FAIL)
 	{
 		goto exit;
 	}
 
 	xmitframe_swencrypt(padapter, pxmitframe);
-
+	
 	update_attrib_vcs_info(padapter, pxmitframe);
-
-exit:
-
-_func_exit_;
+	
+exit:	
+	
+_func_exit_;	
 
 	return res;
 }
@@ -1682,7 +1682,7 @@ u32 rtw_calculate_wlan_pkt_size_by_attribue(struct pkt_attrib *pattrib)
 3. append sta's iv/ext-iv
 4. append LLC
 5. move frag chunk from pframe to pxmitframe->mem
-6. apply sw-encrypt, if necessary.
+6. apply sw-encrypt, if necessary. 
 
 */
 s32 rtw_xmitframe_coalesce(_adapter *padapter, _pkt *pkt, struct xmit_frame *pxmitframe)
@@ -1713,14 +1713,14 @@ s32 rtw_xmitframe_coalesce(_adapter *padapter, _pkt *pkt, struct xmit_frame *pxm
 	{
 		psta = pattrib->psta;
 	} else
-	{
+	{	
 		DBG_871X("%s, call rtw_get_stainfo()\n", __func__);
 		psta = rtw_get_stainfo(&padapter->stapriv, pattrib->ra);
 	}
 
 	if(psta==NULL)
         {
-
+		
 		DBG_871X("%s, psta==NUL\n", __func__);
 		return _FAIL;
 	}
@@ -1784,14 +1784,14 @@ s32 rtw_xmitframe_coalesce(_adapter *padapter, _pkt *pkt, struct xmit_frame *pxm
 				{
 					case _WEP40_:
 					case _WEP104_:
-							WEP_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);
+							WEP_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);	
 						break;
-					case _TKIP_:
+					case _TKIP_:			
 						if(bmcst)
 							TKIP_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);
 						else
 							TKIP_IV(pattrib->iv, psta->dot11txpn, 0);
-						break;
+						break;			
 					case _AES_:
 						if(bmcst)
 							AES_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);
@@ -1833,7 +1833,7 @@ s32 rtw_xmitframe_coalesce(_adapter *padapter, _pkt *pkt, struct xmit_frame *pxm
 		pframe += mem_sz;
 
 		if ((pattrib->icv_len >0 )&& (pattrib->bswenc)) {
-			_rtw_memcpy(pframe, pattrib->icv, pattrib->icv_len);
+			_rtw_memcpy(pframe, pattrib->icv, pattrib->icv_len); 
 			pframe += pattrib->icv_len;
 		}
 
@@ -1843,9 +1843,9 @@ s32 rtw_xmitframe_coalesce(_adapter *padapter, _pkt *pkt, struct xmit_frame *pxm
 		{
 			pattrib->nr_frags = frg_inx;
 
-			pattrib->last_txcmdsz = pattrib->hdrlen + pattrib->iv_len + ((pattrib->nr_frags==1)? llc_sz:0) +
+			pattrib->last_txcmdsz = pattrib->hdrlen + pattrib->iv_len + ((pattrib->nr_frags==1)? llc_sz:0) + 
 					((pattrib->bswenc) ? pattrib->icv_len : 0) + mem_sz;
-
+			
 			ClearMFrag(mem_start);
 
 			break;
@@ -1854,9 +1854,9 @@ s32 rtw_xmitframe_coalesce(_adapter *padapter, _pkt *pkt, struct xmit_frame *pxm
 		}
 
 		addr = (SIZE_PTR)(pframe);
-
+		
 		mem_start = (unsigned char *)RND4(addr) + TXDESC_OFFSET;
-		_rtw_memcpy(mem_start, pbuf_start + TXDESC_OFFSET, pattrib->hdrlen);
+		_rtw_memcpy(mem_start, pbuf_start + TXDESC_OFFSET, pattrib->hdrlen);		
 	}
 
 	if (xmitframe_addmic(padapter, pxmitframe) == _FAIL)
@@ -1873,9 +1873,9 @@ s32 rtw_xmitframe_coalesce(_adapter *padapter, _pkt *pkt, struct xmit_frame *pxm
 	else
 		pattrib->vcs_mode = NONE_VCS;
 
-exit:
-
-_func_exit_;
+exit:	
+	
+_func_exit_;	
 
 	return res;
 }
@@ -1897,31 +1897,31 @@ s32 rtw_mgmt_xmitframe_coalesce(_adapter *padapter, _pkt *pkt, struct xmit_frame
 	s32 res = _FAIL;
 	u8 *BIP_AAD=NULL;
 	u8 *MGMT_body=NULL;
-
+	
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 	struct rtw_ieee80211_hdr	*pwlanhdr;
 	u8 MME[_MME_IE_LENGTH_];
-
+	
 	_irqL irqL;
 	u32	ori_len;
 	mem_start = pframe = (u8 *)(pxmitframe->buf_addr) + TXDESC_OFFSET;
 	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
-
+	
 _func_enter_;
 	ori_len = BIP_AAD_SIZE+pattrib->pktlen;
 	tmp_buf = BIP_AAD = rtw_zmalloc(ori_len);
 	subtype = GetFrameSubType(pframe); //bit(7)~bit(2)
-
+	
 	if(BIP_AAD == NULL)
 		return _FAIL;
-
+			
 	_enter_critical_bh(&padapter->security_key_mutex, &irqL);
-
+	
 	//only support station mode
 	if(!check_fwstate(pmlmepriv, WIFI_STATION_STATE) || !check_fwstate(pmlmepriv, _FW_LINKED))
 		goto xmitframe_coalesce_success;
-
+	
 	//IGTK key is not install, it may not support 802.11w
 	if(padapter->securitypriv.binstallBIPkey != _TRUE)
 	{
@@ -1933,29 +1933,29 @@ s32 rtw_mgmt_xmitframe_coalesce(_adapter *padapter, _pkt *pkt, struct xmit_frame
 	{
 		int frame_body_len;
 		u8 mic[16];
-
+		
 		_rtw_memset(MME, 0, 18);
-
+				
 		//other types doesn't need the BIP
 		if(GetFrameSubType(pframe) != WIFI_DEAUTH && GetFrameSubType(pframe) != WIFI_DISASSOC)
 			goto xmitframe_coalesce_fail;
-
+		
 		MGMT_body = pframe + sizeof(struct rtw_ieee80211_hdr_3addr);
 		pframe += pattrib->pktlen;
-
+		
 		//octent 0 and 1 is key index ,BIP keyid is 4 or 5, LSB only need octent 0
 		MME[0]=padapter->securitypriv.dot11wBIPKeyid;
 		//copy packet number
 		_rtw_memcpy(&MME[2], &pmlmeext->mgnt_80211w_IPN, 6);
 		//increase the packet number
 		pmlmeext->mgnt_80211w_IPN++;
-
+		
 		//add MME IE with MIC all zero, MME string doesn't include element id and length
 		pframe = rtw_set_ie(pframe, _MME_IE_ , 16 , MME, &(pattrib->pktlen));
 		pattrib->last_txcmdsz = pattrib->pktlen;
 		// total frame length - header length
 		frame_body_len = pattrib->pktlen - sizeof(struct rtw_ieee80211_hdr_3addr);
-
+		
 		//conscruct AAD, copy frame control field
 		_rtw_memcpy(BIP_AAD, &pwlanhdr->frame_ctl, 2);
 		ClearRetry(BIP_AAD);
@@ -1977,7 +1977,7 @@ s32 rtw_mgmt_xmitframe_coalesce(_adapter *padapter, _pkt *pkt, struct xmit_frame
 		if(omac1_aes_128(padapter->securitypriv.dot11wBIPKey[padapter->securitypriv.dot11wBIPKeyid].skey
 			, BIP_AAD, BIP_AAD_SIZE+frame_body_len, mic))
 			goto xmitframe_coalesce_fail;
-
+		
 		/*//dump calculated mic result
 		{
 			int i;
@@ -2009,23 +2009,23 @@ s32 rtw_mgmt_xmitframe_coalesce(_adapter *padapter, _pkt *pkt, struct xmit_frame
 			{
 				psta = rtw_get_stainfo(&padapter->stapriv, pattrib->ra);
 			}
-
+		
 			if(psta==NULL)
 			{
-
+				
 				DBG_871X("%s, psta==NUL\n", __func__);
 				goto xmitframe_coalesce_fail;
 			}
-
+		
 			if(!(psta->state & _FW_LINKED) || pxmitframe->buf_addr==NULL)
 			{
 				DBG_871X("%s, not _FW_LINKED or addr null\n", __func__);
 				goto xmitframe_coalesce_fail;
 			}
-
+			
 			//DBG_871X("%s, action frame category=%d \n", __func__, pframe[WLAN_HDR_A3_LEN]);
 			//according 802.11-2012 standard, these five types are not robust types
-			if(subtype == WIFI_ACTION &&
+			if(subtype == WIFI_ACTION && 
 			(pframe[WLAN_HDR_A3_LEN] == RTW_WLAN_CATEGORY_PUBLIC ||
 			pframe[WLAN_HDR_A3_LEN] == RTW_WLAN_CATEGORY_HT ||
 			pframe[WLAN_HDR_A3_LEN] == RTW_WLAN_CATEGORY_UNPROTECTED_WNM ||
@@ -2046,12 +2046,12 @@ s32 rtw_mgmt_xmitframe_coalesce(_adapter *padapter, _pkt *pkt, struct xmit_frame
 			_rtw_memcpy(tmp_buf, pframe, pattrib->pktlen);
 			//move to data portion
 			pframe += pattrib->hdrlen;
-
+			
 			//802.11w unicast management packet must be _AES_
 			pattrib->iv_len = 8;
 			//it's MIC of AES
 			pattrib->icv_len = 8;
-
+			
 			switch(pattrib->encrypt)
 			{
 				case _AES_:
@@ -2078,16 +2078,16 @@ s32 rtw_mgmt_xmitframe_coalesce(_adapter *padapter, _pkt *pkt, struct xmit_frame
 				//printk(" %02x ", mem_start[i]);
 				printk("@@@@@@@@@@@@@\n");
 			}*/
-
+			
 			if ((pattrib->icv_len >0 )&& (pattrib->bswenc)) {
-				_rtw_memcpy(pframe, pattrib->icv, pattrib->icv_len);
+				_rtw_memcpy(pframe, pattrib->icv, pattrib->icv_len); 
 				pframe += pattrib->icv_len;
 			}
 			//add 8 bytes MIC
 			pattrib->pktlen += pattrib->icv_len;
 			//set final tx command size
 			pattrib->last_txcmdsz = pattrib->pktlen;
-
+	
 			//set protected bit must be beofre SW encrypt
 			SetPrivacy(mem_start);
 			/*//dump management packet include AES header
@@ -2108,7 +2108,7 @@ s32 rtw_mgmt_xmitframe_coalesce(_adapter *padapter, _pkt *pkt, struct xmit_frame
 	rtw_mfree(BIP_AAD, ori_len);
 _func_exit_;
 	return _SUCCESS;
-
+	
 xmitframe_coalesce_fail:
 	_exit_critical_bh(&padapter->security_key_mutex, &irqL);
 	rtw_mfree(BIP_AAD, ori_len);
@@ -2141,7 +2141,7 @@ s32 rtw_put_snap(u8 *data, u16 h_proto)
 		oui = P802_1H_OUI;
 	else
 		oui = RFC1042_OUI;
-
+	
 	snap->oui[0] = oui[0];
 	snap->oui[1] = oui[1];
 	snap->oui[2] = oui[2];
@@ -2161,18 +2161,18 @@ void rtw_update_protection(_adapter *padapter, u8 *ie, uint ie_len)
 	sint	 erp_len;
 	struct	xmit_priv *pxmitpriv = &padapter->xmitpriv;
 	struct	registry_priv *pregistrypriv = &padapter->registrypriv;
-
+	
 _func_enter_;
-
+	
 	switch(pxmitpriv->vcs_setting)
 	{
 		case DISABLE_VCS:
 			pxmitpriv->vcs = NONE_VCS;
 			break;
-
+	
 		case ENABLE_VCS:
 			break;
-
+	
 		case AUTO_VCS:
 		default:
 			perp = rtw_get_ie(ie, _ERPINFO_IE_, &erp_len, ie_len);
@@ -2194,8 +2194,8 @@ void rtw_update_protection(_adapter *padapter, u8 *ie, uint ie_len)
 					pxmitpriv->vcs = NONE_VCS;
 			}
 
-			break;
-
+			break;			
+	
 	}
 
 _func_exit_;
@@ -2231,7 +2231,7 @@ void rtw_count_tx_stats(_adapter *padapter, struct xmit_frame *pxmitframe, int s
 			pstats->tx_bytes += sz;
 		}
 	}
-
+	
 }
 
 struct xmit_buf *rtw_alloc_xmitbuf_ext(struct xmit_priv *pxmitpriv)
@@ -2264,8 +2264,8 @@ struct xmit_buf *rtw_alloc_xmitbuf_ext(struct xmit_priv *pxmitpriv)
 		#ifdef DBG_XMIT_BUF
 		DBG_871X("DBG_XMIT_BUF ALLOC no=%d,  free_xmit_extbuf_cnt=%d\n",pxmitbuf->no, pxmitpriv->free_xmit_extbuf_cnt);
 		#endif
-
-
+		
+	
 		pxmitbuf->priv_data = NULL;
 
 #ifdef CONFIG_SDIO_HCI
@@ -2317,7 +2317,7 @@ s32 rtw_free_xmitbuf_ext(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf)
 _func_exit_;
 
 	return _SUCCESS;
-}
+} 
 
 struct xmit_buf *rtw_alloc_xmitbuf(struct xmit_priv *pxmitpriv)
 {
@@ -2409,7 +2409,7 @@ s32 rtw_free_xmitbuf(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf)
 	{
 		_enter_critical(&pfree_xmitbuf_queue->lock, &irqL);
 
-		rtw_list_delete(&pxmitbuf->list);
+		rtw_list_delete(&pxmitbuf->list);	
 
 		rtw_list_insert_tail(&(pxmitbuf->list), get_list_head(pfree_xmitbuf_queue));
 
@@ -2421,10 +2421,10 @@ s32 rtw_free_xmitbuf(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf)
 		_exit_critical(&pfree_xmitbuf_queue->lock, &irqL);
 	}
 
-_func_exit_;
+_func_exit_;	 
 
-	return _SUCCESS;
-}
+	return _SUCCESS;	
+} 
 
 void rtw_init_xmitframe(struct xmit_frame *pxframe)
 {
@@ -2475,7 +2475,7 @@ struct xmit_frame *rtw_alloc_xmitframe(struct xmit_priv *pxmitpriv)//(_queue *pf
 {
 	/*
 		Please remember to use all the osdep_service api,
-		and lock/unlock or _enter/_exit critical to protect
+		and lock/unlock or _enter/_exit critical to protect 
 		pfree_xmit_queue
 	*/
 
@@ -2564,10 +2564,10 @@ struct xmit_frame *rtw_alloc_xmitframe_once(struct xmit_priv *pxmitpriv)
 	u8 *alloc_addr;
 
 	alloc_addr = rtw_zmalloc(sizeof(struct xmit_frame) + 4);
-
+	
 	if (alloc_addr == NULL)
 		goto exit;
-
+		
 	pxframe = (struct xmit_frame *)N_BYTE_ALIGMENT((SIZE_PTR)(alloc_addr), 4);
 	pxframe->alloc_addr = alloc_addr;
 
@@ -2588,13 +2588,13 @@ struct xmit_frame *rtw_alloc_xmitframe_once(struct xmit_priv *pxmitpriv)
 }
 
 s32 rtw_free_xmitframe(struct xmit_priv *pxmitpriv, struct xmit_frame *pxmitframe)
-{
+{	
 	_irqL irqL;
-	_queue *queue = NULL;
+	_queue *queue;
 	_adapter *padapter = pxmitpriv->adapter;
 	_pkt *pndis_pkt = NULL;
 
-_func_enter_;
+_func_enter_;	
 
 	if (pxmitframe == NULL) {
 		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("======rtw_free_xmitframe():pxmitframe==NULL!!!!!!!!!!\n"));
@@ -2621,7 +2621,7 @@ s32 rtw_free_xmitframe(struct xmit_priv *pxmitpriv, struct xmit_frame *pxmitfram
 
 	_enter_critical_bh(&queue->lock, &irqL);
 
-	rtw_list_delete(&pxmitframe->list);
+	rtw_list_delete(&pxmitframe->list);	
 	rtw_list_insert_tail(&pxmitframe->list, get_list_head(queue));
 	if (pxmitframe->ext_tag == 0) {
 		pxmitpriv->free_xmitframe_cnt++;
@@ -2652,22 +2652,22 @@ void rtw_free_xmitframe_queue(struct xmit_priv *pxmitpriv, _queue *pframequeue)
 	_list	*plist, *phead;
 	struct	xmit_frame 	*pxmitframe;
 
-_func_enter_;
+_func_enter_;	
 
 	_enter_critical_bh(&(pframequeue->lock), &irqL);
 
 	phead = get_list_head(pframequeue);
 	plist = get_next(phead);
-
+	
 	while (rtw_end_of_queue_search(phead, plist) == _FALSE)
 	{
-
+			
 		pxmitframe = LIST_CONTAINOR(plist, struct xmit_frame, list);
 
-		plist = get_next(plist);
-
+		plist = get_next(plist); 
+		
 		rtw_free_xmitframe(pxmitpriv,pxmitframe);
-
+			
 	}
 	_exit_critical_bh(&(pframequeue->lock), &irqL);
 
@@ -2755,8 +2755,8 @@ struct xmit_frame* rtw_dequeue_xframe(struct xmit_priv *pxmitpriv, struct hw_xmi
 			inx[flags] = 0;
 			inx[0] = flags;
 		}
-#endif
-
+#endif	
+	
 #ifdef CONFIG_USB_HCI
 		//entry indx: 0->vo, 1->vi, 2->be, 3->bk.
 		acirp_cnt[0] = pxmitpriv->voq_cnt;
@@ -2785,7 +2785,7 @@ struct xmit_frame* rtw_dequeue_xframe(struct xmit_priv *pxmitpriv, struct hw_xmi
 
 	_enter_critical_bh(&pxmitpriv->lock, &irqL0);
 
-	for(i = 0; i < entry; i++)
+	for(i = 0; i < entry; i++) 
 	{
 		phwxmit = phwxmit_i + inx[i];
 
@@ -2837,10 +2837,10 @@ struct xmit_frame* rtw_dequeue_xframe(struct xmit_priv *pxmitpriv, struct hw_xmi
 struct tx_servq *rtw_get_sta_pending(_adapter *padapter, struct sta_info *psta, sint up, u8 *ac)
 {
 	struct tx_servq *ptxservq=NULL;
+	
+_func_enter_;	
 
-_func_enter_;
-
-	switch (up)
+	switch (up) 
 	{
 		case 1:
 		case 2:
@@ -2860,7 +2860,7 @@ struct tx_servq *rtw_get_sta_pending(_adapter *padapter, struct sta_info *psta,
 		case 7:
 			ptxservq = &(psta->sta_xmitpriv.vo_q);
 			*(ac) = 0;
-			RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("rtw_get_sta_pending : VO \n"));
+			RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("rtw_get_sta_pending : VO \n"));			
 			break;
 
 		case 0:
@@ -2868,14 +2868,14 @@ struct tx_servq *rtw_get_sta_pending(_adapter *padapter, struct sta_info *psta,
 		default:
 			ptxservq = &(psta->sta_xmitpriv.be_q);
 			*(ac) = 2;
-			RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("rtw_get_sta_pending : BE \n"));
+			RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("rtw_get_sta_pending : BE \n"));				
 		break;
-
+		
 	}
 
 _func_exit_;
 
-	return ptxservq;
+	return ptxservq;			
 }
 #else
 __inline static struct tx_servq *rtw_get_sta_pending
@@ -2883,20 +2883,20 @@ struct tx_servq *rtw_get_sta_pending(_adapter *padapter, struct sta_info *psta,
 {
 	struct tx_servq *ptxservq;
 	struct hw_xmit *phwxmits =  padapter->xmitpriv.hwxmits;
-
-_func_enter_;
+	
+_func_enter_;	
 
 #ifdef CONFIG_RTL8711
 
 	if(IS_MCAST(psta->hwaddr))
 	{
 		ptxservq = &(psta->sta_xmitpriv.be_q); // we will use be_q to queue bc/mc frames in BCMC_stainfo
-		*ppstapending = &padapter->xmitpriv.bm_pending;
+		*ppstapending = &padapter->xmitpriv.bm_pending; 
 	}
 	else
-#endif
+#endif		
 	{
-		switch (up)
+		switch (up) 
 		{
 			case 1:
 			case 2:
@@ -2919,7 +2919,7 @@ struct tx_servq *rtw_get_sta_pending(_adapter *padapter, struct sta_info *psta,
 				ptxservq = &(psta->sta_xmitpriv.vo_q);
 				*ppstapending = &padapter->xmitpriv.vo_pending;
 				(phwxmits+0)->accnt++;
-				RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("rtw_get_sta_pending : VO \n"));
+				RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("rtw_get_sta_pending : VO \n"));			
 				break;
 
 			case 0:
@@ -2928,16 +2928,16 @@ struct tx_servq *rtw_get_sta_pending(_adapter *padapter, struct sta_info *psta,
 				ptxservq = &(psta->sta_xmitpriv.be_q);
 				*ppstapending = &padapter->xmitpriv.be_pending;
 				(phwxmits+2)->accnt++;
-				RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("rtw_get_sta_pending : BE \n"));
+				RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("rtw_get_sta_pending : BE \n"));				
 			break;
-
+			
 		}
 
 	}
 
 _func_exit_;
 
-	return ptxservq;
+	return ptxservq;			
 }
 #endif
 
@@ -2959,7 +2959,7 @@ s32 rtw_xmit_classifier(_adapter *padapter, struct xmit_frame *pxmitframe)
 _func_enter_;
 
 	if (pattrib->psta) {
-		psta = pattrib->psta;
+		psta = pattrib->psta;		
 	} else {
 		DBG_871X("%s, call rtw_get_stainfo()\n", __func__);
 		psta = rtw_get_stainfo(pstapriv, pattrib->ra);
@@ -3010,8 +3010,8 @@ void rtw_alloc_hwxmits(_adapter *padapter)
 
 	pxmitpriv->hwxmit_entry = HWXMIT_ENTRY;
 
-	pxmitpriv->hwxmits = (struct hw_xmit *)rtw_zmalloc(sizeof (struct hw_xmit) * pxmitpriv->hwxmit_entry);
-
+	pxmitpriv->hwxmits = (struct hw_xmit *)rtw_zmalloc(sizeof (struct hw_xmit) * pxmitpriv->hwxmit_entry);	
+	
 	hwxmits = pxmitpriv->hwxmits;
 
 	if(pxmitpriv->hwxmit_entry == 5)
@@ -3019,7 +3019,7 @@ void rtw_alloc_hwxmits(_adapter *padapter)
 		//pxmitpriv->bmc_txqueue.head = 0;
 		//hwxmits[0] .phwtxqueue = &pxmitpriv->bmc_txqueue;
 		hwxmits[0] .sta_queue = &pxmitpriv->bm_pending;
-
+	
 		//pxmitpriv->vo_txqueue.head = 0;
 		//hwxmits[1] .phwtxqueue = &pxmitpriv->vo_txqueue;
 		hwxmits[1] .sta_queue = &pxmitpriv->vo_pending;
@@ -3027,16 +3027,16 @@ void rtw_alloc_hwxmits(_adapter *padapter)
 		//pxmitpriv->vi_txqueue.head = 0;
 		//hwxmits[2] .phwtxqueue = &pxmitpriv->vi_txqueue;
 		hwxmits[2] .sta_queue = &pxmitpriv->vi_pending;
-
+	
 		//pxmitpriv->bk_txqueue.head = 0;
 		//hwxmits[3] .phwtxqueue = &pxmitpriv->bk_txqueue;
 		hwxmits[3] .sta_queue = &pxmitpriv->bk_pending;
 
-		//pxmitpriv->be_txqueue.head = 0;
+      		//pxmitpriv->be_txqueue.head = 0;
 		//hwxmits[4] .phwtxqueue = &pxmitpriv->be_txqueue;
 		hwxmits[4] .sta_queue = &pxmitpriv->be_pending;
-
-	}
+		
+	}	
 	else if(pxmitpriv->hwxmit_entry == 4)
 	{
 
@@ -3051,17 +3051,17 @@ void rtw_alloc_hwxmits(_adapter *padapter)
 		//pxmitpriv->be_txqueue.head = 0;
 		//hwxmits[2] .phwtxqueue = &pxmitpriv->be_txqueue;
 		hwxmits[2] .sta_queue = &pxmitpriv->be_pending;
-
+	
 		//pxmitpriv->bk_txqueue.head = 0;
 		//hwxmits[3] .phwtxqueue = &pxmitpriv->bk_txqueue;
 		hwxmits[3] .sta_queue = &pxmitpriv->bk_pending;
 	}
 	else
 	{
-
+		
 
 	}
-
+	
 
 }
 
@@ -3078,15 +3078,15 @@ void rtw_free_hwxmits(_adapter *padapter)
 void rtw_init_hwxmits(struct hw_xmit *phwxmit, sint entry)
 {
 	sint i;
-_func_enter_;
+_func_enter_;	
 	for(i = 0; i < entry; i++, phwxmit++)
 	{
 		//_rtw_spinlock_init(&phwxmit->xmit_lock);
-		//_rtw_init_listhead(&phwxmit->pending);
+		//_rtw_init_listhead(&phwxmit->pending);		
 		//phwxmit->txcmdcnt = 0;
 		phwxmit->accnt = 0;
 	}
-_func_exit_;
+_func_exit_;	
 }
 
 #ifdef CONFIG_BR_EXT
@@ -3123,7 +3123,7 @@ int rtw_br_client_tx(_adapter *padapter, struct sk_buff **pskb)
 			_exit_critical_bh(&padapter->br_ext_lock, &irqL);
 		}
 		else
-		//if (!priv->pmib->ethBrExtInfo.nat25_disable)
+		//if (!priv->pmib->ethBrExtInfo.nat25_disable) 		
 		{
 //			if (priv->dev->br_port &&
 //				 !memcmp(skb->data+MACADDRLEN, priv->br_mac, MACADDRLEN)) {
@@ -3143,7 +3143,7 @@ int rtw_br_client_tx(_adapter *padapter, struct sk_buff **pskb)
 			if (*((unsigned short *)(skb->data+MACADDRLEN*2)) == __constant_htons(ETH_P_IP)) {
 				if (memcmp(padapter->scdb_mac, skb->data+MACADDRLEN, MACADDRLEN)) {
 					void *scdb_findEntry(_adapter *priv, unsigned char *macAddr, unsigned char *ipAddr);
-
+					
 					if ((padapter->scdb_entry = (struct nat25_network_db_entry *)scdb_findEntry(padapter,
 								skb->data+MACADDRLEN, skb->data+WLAN_ETHHDR_LEN+12)) != NULL) {
 						memcpy(padapter->scdb_mac, skb->data+MACADDRLEN, MACADDRLEN);
@@ -3199,19 +3199,19 @@ int rtw_br_client_tx(_adapter *padapter, struct sk_buff **pskb)
 
 				if (skb_is_nonlinear(skb))
 					DEBUG_ERR("%s(): skb_is_nonlinear!!\n", __FUNCTION__);
-
+					
 
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18))
 				res = skb_linearize(skb, GFP_ATOMIC);
 #else	// (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18))
 				res = skb_linearize(skb);
 #endif	// (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18))
-				if (res < 0) {
+				if (res < 0) {				
 						DEBUG_ERR("TX DROP: skb_linearize fail!\n");
 						//goto free_and_stop;
 						return -1;
 				}
-
+				
 				res = nat25_db_handle(padapter, skb, NAT25_INSERT);
 				if (res < 0) {
 					if (res == -2) {
@@ -3240,12 +3240,12 @@ int rtw_br_client_tx(_adapter *padapter, struct sk_buff **pskb)
 				*((unsigned short *)(skb->data+MACADDRLEN*2+2)) = vlan_hdr;
 			}
 		}
-#if 0
+#if 0		
 		else{
 			if (*((unsigned short *)(skb->data+MACADDRLEN*2)) == __constant_htons(ETH_P_8021Q)) {
 				is_vlan_tag = 1;
 			}
-
+				
 			if(is_vlan_tag){
 				if(ICMPV6_MCAST_MAC(skb->data) && ICMPV6_PROTO1A_VALN(skb->data)){
                                         memcpy(skb->data+MACADDRLEN, GET_MY_HWADDR(padapter), MACADDRLEN);
@@ -3255,7 +3255,7 @@ int rtw_br_client_tx(_adapter *padapter, struct sk_buff **pskb)
 				if(ICMPV6_MCAST_MAC(skb->data) && ICMPV6_PROTO1A(skb->data)){
                                         memcpy(skb->data+MACADDRLEN, GET_MY_HWADDR(padapter), MACADDRLEN);
 				}
-			}
+			}	
 		}
 #endif	// 0
 
@@ -3275,15 +3275,15 @@ int rtw_br_client_tx(_adapter *padapter, struct sk_buff **pskb)
 static void do_queue_select(_adapter	*padapter, struct pkt_attrib *pattrib)
 {
 	u8 qsel;
-
+		
 	qsel = pattrib->priority;
 	RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("### do_queue_select priority=%d ,qsel = %d\n",pattrib->priority ,qsel));
 
-#ifdef CONFIG_CONCURRENT_MODE
+#ifdef CONFIG_CONCURRENT_MODE	
 //	if (check_fwstate(&padapter->mlmepriv, WIFI_AP_STATE) == _TRUE)
 //		qsel = 7;//
 #endif
-
+	
 	pattrib->qsel = qsel;
 }
 
@@ -3347,7 +3347,7 @@ s32 rtw_xmit(_adapter *padapter, _pkt **ppkt)
 			rtw_free_xmitframe(pxmitpriv, pxmitframe);
 			return -1;
 		}
-	}
+	}	
 
 #endif	// CONFIG_BR_EXT
 
@@ -3371,7 +3371,7 @@ s32 rtw_xmit(_adapter *padapter, _pkt **ppkt)
 	if(xmitframe_enqueue_for_sleeping_sta(padapter, pxmitframe) == _TRUE)
 	{
 		_exit_critical_bh(&pxmitpriv->lock, &irqL0);
-		return 1;
+		return 1;		
 	}
 	_exit_critical_bh(&pxmitpriv->lock, &irqL0);
 #endif
@@ -3393,7 +3393,7 @@ sint xmitframe_enqueue_for_tdls_sleeping_sta(_adapter *padapter, struct xmit_fra
 	struct pkt_attrib *pattrib = &pxmitframe->attrib;
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	int i;
-
+	
 	ptdls_sta=rtw_get_stainfo(pstapriv, pattrib->dst);
 	if(ptdls_sta==NULL){
 		return ret;
@@ -3405,16 +3405,16 @@ sint xmitframe_enqueue_for_tdls_sleeping_sta(_adapter *padapter, struct xmit_fra
 			return ret;
 			}
 
-		_enter_critical_bh(&ptdls_sta->sleep_q.lock, &irqL);
-
+		_enter_critical_bh(&ptdls_sta->sleep_q.lock, &irqL);	
+		
 		if(ptdls_sta->state&WIFI_SLEEP_STATE)
 		{
 			rtw_list_delete(&pxmitframe->list);
-
-			//_enter_critical_bh(&psta->sleep_q.lock, &irqL);
-
+		
+			//_enter_critical_bh(&psta->sleep_q.lock, &irqL);	
+			
 			rtw_list_insert_tail(&pxmitframe->list, get_list_head(&ptdls_sta->sleep_q));
-
+			
 			ptdls_sta->sleepq_len++;
 			ptdls_sta->sleepq_ac_len++;
 
@@ -3449,11 +3449,11 @@ sint xmitframe_enqueue_for_tdls_sleeping_sta(_adapter *padapter, struct xmit_fra
 
 		}
 
-		_exit_critical_bh(&ptdls_sta->sleep_q.lock, &irqL);
+		_exit_critical_bh(&ptdls_sta->sleep_q.lock, &irqL);	
 	}
 
 	return ret;
-
+	
 }
 #endif //CONFIG_TDLS
 
@@ -3511,7 +3511,7 @@ sint xmitframe_enqueue_for_sleeping_sta(_adapter *padapter, struct xmit_frame *p
 
 		if(bmcst)
 			pattrib->qsel = 0x11;//HIQ
-
+		
 
 		return ret;
 	}
@@ -3519,54 +3519,54 @@ sint xmitframe_enqueue_for_sleeping_sta(_adapter *padapter, struct xmit_frame *p
 
 	if(bmcst)
 	{
-		_enter_critical_bh(&psta->sleep_q.lock, &irqL);
-
+		_enter_critical_bh(&psta->sleep_q.lock, &irqL);	
+	
 		if(pstapriv->sta_dz_bitmap)//if anyone sta is in ps mode
 		{
 			//pattrib->qsel = 0x11;//HIQ
-
+			
 			rtw_list_delete(&pxmitframe->list);
-
-			//_enter_critical_bh(&psta->sleep_q.lock, &irqL);
-
+			
+			//_enter_critical_bh(&psta->sleep_q.lock, &irqL);	
+			
 			rtw_list_insert_tail(&pxmitframe->list, get_list_head(&psta->sleep_q));
-
+			
 			psta->sleepq_len++;
 
 			pstapriv->tim_bitmap |= BIT(0);//
 			pstapriv->sta_dz_bitmap |= BIT(0);
-
+			
 			//DBG_871X("enqueue, sq_len=%d, tim=%x\n", psta->sleepq_len, pstapriv->tim_bitmap);
 
 			update_beacon(padapter, _TIM_IE_, NULL, _FALSE);//tx bc/mc packets after upate bcn
-
-			//_exit_critical_bh(&psta->sleep_q.lock, &irqL);
-
-			ret = _TRUE;
-
+			
+			//_exit_critical_bh(&psta->sleep_q.lock, &irqL);				
+			
+			ret = _TRUE;			
+			
 		}
-
-		_exit_critical_bh(&psta->sleep_q.lock, &irqL);
-
+		
+		_exit_critical_bh(&psta->sleep_q.lock, &irqL);	
+		
 		return ret;
-
+		
 	}
+	
 
-
-	_enter_critical_bh(&psta->sleep_q.lock, &irqL);
-
+	_enter_critical_bh(&psta->sleep_q.lock, &irqL);	
+	
 	if(psta->state&WIFI_SLEEP_STATE)
 	{
 		u8 wmmps_ac=0;
-
-		if(pstapriv->sta_dz_bitmap&BIT(psta->aid))
-		{
+	
+		if(pstapriv->sta_dz_bitmap&BIT(psta->aid))	
+		{			
 			rtw_list_delete(&pxmitframe->list);
-
-			//_enter_critical_bh(&psta->sleep_q.lock, &irqL);
-
+		
+			//_enter_critical_bh(&psta->sleep_q.lock, &irqL);	
+			
 			rtw_list_insert_tail(&pxmitframe->list, get_list_head(&psta->sleep_q));
-
+			
 			psta->sleepq_len++;
 
 			switch(pattrib->priority)
@@ -3607,12 +3607,12 @@ sint xmitframe_enqueue_for_sleeping_sta(_adapter *padapter, struct xmit_frame *p
 				}
 			}
 
-			//_exit_critical_bh(&psta->sleep_q.lock, &irqL);
+			//_exit_critical_bh(&psta->sleep_q.lock, &irqL);			
 
 			//if(psta->sleepq_len > (NR_XMITFRAME>>3))
 			//{
 			//	wakeup_sta_to_xmit(padapter, psta);
-			//}
+			//}	
 
 			ret = _TRUE;
 
@@ -3620,10 +3620,10 @@ sint xmitframe_enqueue_for_sleeping_sta(_adapter *padapter, struct xmit_frame *p
 
 	}
 
-	_exit_critical_bh(&psta->sleep_q.lock, &irqL);
+	_exit_critical_bh(&psta->sleep_q.lock, &irqL);	
 
 	return ret;
-
+	
 }
 
 static void dequeue_xmitframes_to_sleeping_queue(_adapter *padapter, struct sta_info *psta, _queue *pframequeue)
@@ -3635,17 +3635,17 @@ static void dequeue_xmitframes_to_sleeping_queue(_adapter *padapter, struct sta_
 	struct pkt_attrib	*pattrib;
 	struct xmit_frame 	*pxmitframe;
 	struct hw_xmit *phwxmits =  padapter->xmitpriv.hwxmits;
-
+	
 	phead = get_list_head(pframequeue);
 	plist = get_next(phead);
-
+	
 	while (rtw_end_of_queue_search(phead, plist) == _FALSE)
-	{
+	{			
 		pxmitframe = LIST_CONTAINOR(plist, struct xmit_frame, list);
 
-		plist = get_next(plist);
-
-		ret = xmitframe_enqueue_for_sleeping_sta(padapter, pxmitframe);
+		plist = get_next(plist);	
+		
+		ret = xmitframe_enqueue_for_sleeping_sta(padapter, pxmitframe);	
 
 		if(_TRUE == ret)
 		{
@@ -3654,41 +3654,41 @@ static void dequeue_xmitframes_to_sleeping_queue(_adapter *padapter, struct sta_
 		ptxservq = rtw_get_sta_pending(padapter, psta, pattrib->priority, (u8 *)(&ac_index));
 
 		ptxservq->qcnt--;
-		phwxmits[ac_index].accnt--;
+		phwxmits[ac_index].accnt--;		
 	}
 		else
 		{
 			//DBG_871X("xmitframe_enqueue_for_sleeping_sta return _FALSE\n");
 		}
-
+		
 	}
-
+	
 }
 
 void stop_sta_xmit(_adapter *padapter, struct sta_info *psta)
-{
-	_irqL irqL0;
+{	
+	_irqL irqL0;	
 	struct sta_info *psta_bmc;
 	struct sta_xmit_priv *pstaxmitpriv;
-	struct sta_priv *pstapriv = &padapter->stapriv;
-	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
-
+	struct sta_priv *pstapriv = &padapter->stapriv;	
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;	
+	
 	pstaxmitpriv = &psta->sta_xmitpriv;
 
 	//for BC/MC Frames
 	psta_bmc = rtw_get_bcmc_stainfo(padapter);
-
-
+	
+			
 	_enter_critical_bh(&pxmitpriv->lock, &irqL0);
 
 	psta->state |= WIFI_SLEEP_STATE;
-
+	
 #ifdef CONFIG_TDLS
 	if( !(psta->tdls_sta_state & TDLS_LINKED_STATE) )
-#endif //CONFIG_TDLS
+#endif //CONFIG_TDLS	
 	pstapriv->sta_dz_bitmap |= BIT(psta->aid);
-
-
+	
+	
 
 	dequeue_xmitframes_to_sleeping_queue(padapter, psta, &pstaxmitpriv->vo_q.sta_pending);
 	rtw_list_delete(&(pstaxmitpriv->vo_q.tx_pending));
@@ -3700,7 +3700,7 @@ void stop_sta_xmit(_adapter *padapter, struct sta_info *psta)
 
 	dequeue_xmitframes_to_sleeping_queue(padapter, psta, &pstaxmitpriv->be_q.sta_pending);
 	rtw_list_delete(&(pstaxmitpriv->be_q.tx_pending));
-
+	
 
 	dequeue_xmitframes_to_sleeping_queue(padapter, psta, &pstaxmitpriv->bk_q.sta_pending);
 	rtw_list_delete(&(pstaxmitpriv->bk_q.tx_pending));
@@ -3717,20 +3717,20 @@ void stop_sta_xmit(_adapter *padapter, struct sta_info *psta)
 	pstaxmitpriv = &psta_bmc->sta_xmitpriv;
 	dequeue_xmitframes_to_sleeping_queue(padapter, psta_bmc, &pstaxmitpriv->be_q.sta_pending);
 	rtw_list_delete(&(pstaxmitpriv->be_q.tx_pending));
+	
 
-
-#ifdef CONFIG_TDLS
+#ifdef CONFIG_TDLS	
 		}
 	}
-#endif //CONFIG_TDLS
+#endif //CONFIG_TDLS	
 	_exit_critical_bh(&pxmitpriv->lock, &irqL0);
+	
 
-
-}
+}	
 
 void wakeup_sta_to_xmit(_adapter *padapter, struct sta_info *psta)
-{
-	_irqL irqL;
+{	 
+	_irqL irqL;	 
 	u8 update_mask=0, wmmps_ac=0;
 	struct sta_info *psta_bmc;
 	_list	*xmitframe_plist, *xmitframe_phead;
@@ -3739,7 +3739,7 @@ void wakeup_sta_to_xmit(_adapter *padapter, struct sta_info *psta)
 	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
 
 	psta_bmc = rtw_get_bcmc_stainfo(padapter);
-
+	
 
 	//_enter_critical_bh(&psta->sleep_q.lock, &irqL);
 	_enter_critical_bh(&pxmitpriv->lock, &irqL);
@@ -3748,10 +3748,10 @@ void wakeup_sta_to_xmit(_adapter *padapter, struct sta_info *psta)
 	xmitframe_plist = get_next(xmitframe_phead);
 
 	while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == _FALSE)
-	{
+	{			
 		pxmitframe = LIST_CONTAINOR(xmitframe_plist, struct xmit_frame, list);
 
-		xmitframe_plist = get_next(xmitframe_plist);
+		xmitframe_plist = get_next(xmitframe_plist);            
 
 		rtw_list_delete(&pxmitframe->list);
 
@@ -3773,7 +3773,7 @@ void wakeup_sta_to_xmit(_adapter *padapter, struct sta_info *psta)
 			case 3:
 			default:
 				wmmps_ac = psta->uapsd_be&BIT(1);
-				break;
+				break;	
 		}
 
 		psta->sleepq_len--;
@@ -3796,22 +3796,22 @@ void wakeup_sta_to_xmit(_adapter *padapter, struct sta_info *psta)
 				pxmitframe->attrib.eosp = 1;
 			}
 		}
-
+		
 		pxmitframe->attrib.triggered = 1;
 
 /*
-		_exit_critical_bh(&psta->sleep_q.lock, &irqL);
+		_exit_critical_bh(&psta->sleep_q.lock, &irqL);	
 		if(rtw_hal_xmit(padapter, pxmitframe) == _TRUE)
-		{
+		{		
 			rtw_os_xmit_complete(padapter, pxmitframe);
-		}
+		}		
 		_enter_critical_bh(&psta->sleep_q.lock, &irqL);
 */
 		rtw_hal_xmitframe_enqueue(padapter, pxmitframe);
 
-
-	}
-
+		
+	}	
+	
 	//for BC/MC Frames
 	if(!psta_bmc)
 		goto _exit;
@@ -3822,7 +3822,7 @@ void wakeup_sta_to_xmit(_adapter *padapter, struct sta_info *psta)
 		xmitframe_plist = get_next(xmitframe_phead);
 
 		while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == _FALSE)
-		{
+		{			
 			pxmitframe = LIST_CONTAINOR(xmitframe_plist, struct xmit_frame, list);
 
 			xmitframe_plist = get_next(xmitframe_plist);
@@ -3834,22 +3834,22 @@ void wakeup_sta_to_xmit(_adapter *padapter, struct sta_info *psta)
 				pxmitframe->attrib.mdata = 1;
 			else
 				pxmitframe->attrib.mdata = 0;
-
+			
 
 			pxmitframe->attrib.triggered = 1;
 /*
-			_exit_critical_bh(&psta_bmc->sleep_q.lock, &irqL);
+			_exit_critical_bh(&psta_bmc->sleep_q.lock, &irqL);	
 			if(rtw_hal_xmit(padapter, pxmitframe) == _TRUE)
-			{
+			{		
 				rtw_os_xmit_complete(padapter, pxmitframe);
 			}
-			_enter_critical_bh(&psta_bmc->sleep_q.lock, &irqL);
+			_enter_critical_bh(&psta_bmc->sleep_q.lock, &irqL);	
 
 */
 			rtw_hal_xmitframe_enqueue(padapter, pxmitframe);
 
-		}
-
+		}	
+	
 		if(psta_bmc->sleepq_len==0)
 		{
 			pstapriv->tim_bitmap &= ~BIT(0);
@@ -3859,9 +3859,9 @@ void wakeup_sta_to_xmit(_adapter *padapter, struct sta_info *psta)
 			//upate BCN for TIM IE
 			//update_BCNTIM(padapter);
 			update_mask |= BIT(1);
-		}
-
-	}
+		}		
+	
+	}	
 
 	if(psta->sleepq_len==0)
 	{
@@ -3872,7 +3872,7 @@ void wakeup_sta_to_xmit(_adapter *padapter, struct sta_info *psta)
 				psta->state ^= WIFI_SLEEP_STATE;
 
 			goto _exit;
-	}
+	}	
 #endif //CONFIG_TDLS
 		pstapriv->tim_bitmap &= ~BIT(psta->aid);
 
@@ -3895,16 +3895,16 @@ void wakeup_sta_to_xmit(_adapter *padapter, struct sta_info *psta)
 
 _exit:
 
-	//_exit_critical_bh(&psta_bmc->sleep_q.lock, &irqL);
+	//_exit_critical_bh(&psta_bmc->sleep_q.lock, &irqL);	
 	_exit_critical_bh(&pxmitpriv->lock, &irqL);
-
+	
 	if(update_mask)
 	{
 		//update_BCNTIM(padapter);
 		//printk("%s => call update_beacon\n",__FUNCTION__);
 		update_beacon(padapter, _TIM_IE_, NULL, _FALSE);
-	}
-
+	}	
+	
 }
 
 void xmit_delivery_enabled_frames(_adapter *padapter, struct sta_info *psta)
@@ -3924,7 +3924,7 @@ void xmit_delivery_enabled_frames(_adapter *padapter, struct sta_info *psta)
 	xmitframe_plist = get_next(xmitframe_phead);
 
 	while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == _FALSE)
-	{
+	{			
 		pxmitframe = LIST_CONTAINOR(xmitframe_plist, struct xmit_frame, list);
 
 		xmitframe_plist = get_next(xmitframe_plist);
@@ -3947,9 +3947,9 @@ void xmit_delivery_enabled_frames(_adapter *padapter, struct sta_info *psta)
 			case 3:
 			default:
 				wmmps_ac = psta->uapsd_be&BIT(1);
-				break;
+				break;	
 		}
-
+		
 		if(!wmmps_ac)
 			continue;
 
@@ -3973,7 +3973,7 @@ void xmit_delivery_enabled_frames(_adapter *padapter, struct sta_info *psta)
 
 /*
 		if(rtw_hal_xmit(padapter, pxmitframe) == _TRUE)
-		{
+		{		
 			rtw_os_xmit_complete(padapter, pxmitframe);
 		}
 */
@@ -3997,10 +3997,10 @@ void xmit_delivery_enabled_frames(_adapter *padapter, struct sta_info *psta)
 			update_beacon(padapter, _TIM_IE_, NULL, _FALSE);
 			//update_mask = BIT(0);
 		}
-
+	
 	}
-
-	//_exit_critical_bh(&psta->sleep_q.lock, &irqL);
+	
+	//_exit_critical_bh(&psta->sleep_q.lock, &irqL);	
 	_exit_critical_bh(&pxmitpriv->lock, &irqL);
 
 }
@@ -4020,7 +4020,7 @@ void rtw_sctx_init(struct submit_ctx *sctx, int timeout_ms)
 int rtw_sctx_wait(struct submit_ctx *sctx)
 {
 	int ret = _FAIL;
-	unsigned long expire;
+	unsigned long expire; 
 	int status = 0;
 
 #ifdef PLATFORM_LINUX
@@ -4028,7 +4028,7 @@ int rtw_sctx_wait(struct submit_ctx *sctx)
 	if (!wait_for_completion_timeout(&sctx->done, expire)) {
 		/* timeout, do something?? */
 		status = RTW_SCTX_DONE_TIMEOUT;
-		DBG_871X("%s timeout\n", __func__);
+		DBG_871X("%s timeout\n", __func__);	
 	} else {
 		status = sctx->status;
 	}
@@ -4111,7 +4111,7 @@ int rtw_ack_tx_polling(struct xmit_priv *pxmitpriv, u32 timeout_ms)
 			pack_tx_ops->status = RTW_SCTX_DONE_DEV_REMOVE;
 			break;
 		}
-
+		
 		rtw_msleep_os(10);
 	} while (rtw_get_passing_time_ms(pack_tx_ops->submit_time) < timeout_ms);
 
@@ -4145,7 +4145,7 @@ int rtw_ack_tx_wait(struct xmit_priv *pxmitpriv, u32 timeout_ms)
 void rtw_ack_tx_done(struct xmit_priv *pxmitpriv, int status)
 {
 	struct submit_ctx *pack_tx_ops = &pxmitpriv->ack_tx_ops;
-
+	
 	if (pxmitpriv->ack_tx) {
 		rtw_sctx_done_err(&pack_tx_ops, status);
 	} else {
@@ -4153,3 +4153,4 @@ void rtw_ack_tx_done(struct xmit_priv *pxmitpriv, int status)
 	}
 }
 #endif //CONFIG_XMIT_ACK
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/hal/HalPwrSeqCmd.c b/drivers/net/wireless/realtek/rtl8192cu/hal/HalPwrSeqCmd.c
old mode 100644
new mode 100755
index 4ecf229..c59bb66
--- a/drivers/net/wireless/realtek/rtl8192cu/hal/HalPwrSeqCmd.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/hal/HalPwrSeqCmd.c
@@ -173,3 +173,5 @@ u8 HalPwrSeqCmdParsing(
 
 	return _TRUE;
 }
+
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/hal/dm.c b/drivers/net/wireless/realtek/rtl8192cu/hal/dm.c
old mode 100644
new mode 100755
index 807dfd1..465ca82
--- a/drivers/net/wireless/realtek/rtl8192cu/hal/dm.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/hal/dm.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2013 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -37,7 +37,7 @@ bool rtw_adapter_linked(_adapter *adapter)
 
 	if(	(check_fwstate(mlmepriv, WIFI_AP_STATE) == _TRUE) ||
 		(check_fwstate(mlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE) == _TRUE))
-	{
+	{				
 		if(adapter->stapriv.asoc_sta_count > 2)
 			linked = _TRUE;
 	}
@@ -78,8 +78,8 @@ void dm_enable_EDCCA(_adapter *adapter)
 	{
 		rtw_write8(adapter,rOFDM0_ECCAThreshold,0x00);
 		rtw_write8(adapter,rOFDM0_ECCAThreshold+2,0xFD);
-
-	}
+		
+	}	
 	else*/
 	{
 		rtw_write8(adapter,rOFDM0_ECCAThreshold,0x03);
@@ -88,7 +88,7 @@ void dm_enable_EDCCA(_adapter *adapter)
 }
 
 void dm_disable_EDCCA(_adapter *adapter)
-{
+{	
 	// Disable EDCCA..
 	rtw_write8(adapter, rOFDM0_ECCAThreshold, 0x7f);
 	rtw_write8(adapter, rOFDM0_ECCAThreshold+2, 0x7f);
@@ -104,22 +104,22 @@ void dm_dynamic_EDCCA(_adapter *pAdapter)
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
 	struct dm_priv *dmpriv = &pHalData->dmpriv;
 	u8 RegC50, RegC58;
-
+	
 	RegC50 = (u8)PHY_QueryBBReg(pAdapter, rOFDM0_XAAGCCore1, bMaskByte0);
 	RegC58 = (u8)PHY_QueryBBReg(pAdapter, rOFDM0_XBAGCCore1, bMaskByte0);
 
 
-	if((RegC50 > 0x28 && RegC58 > 0x28)
-		/*|| ((pDM_Odm->SupportICType == ODM_RTL8723A && IS_WIRELESS_MODE_G(pAdapter) && RegC50>0x26))
-		|| (pDM_Odm->SupportICType == ODM_RTL8188E && RegC50 > 0x28)*/
-	)
+ 	if((RegC50 > 0x28 && RegC58 > 0x28)
+  		/*|| ((pDM_Odm->SupportICType == ODM_RTL8723A && IS_WIRELESS_MODE_G(pAdapter) && RegC50>0x26))
+  		|| (pDM_Odm->SupportICType == ODM_RTL8188E && RegC50 > 0x28)*/
+  	)
 	{
 		if(!dmpriv->bPreEdccaEnable)
 		{
 			dm_enable_EDCCA(pAdapter);
 			dmpriv->bPreEdccaEnable = _TRUE;
 		}
-
+		
 	}
 	else if((RegC50 < 0x25 && RegC58 < 0x25)
 		/*|| (pDM_Odm->SupportICType == ODM_RTL8188E && RegC50 < 0x25)*/
@@ -224,7 +224,7 @@ void dm_adaptivity(_adapter *pAdapter)
 	if (!(dmpriv->DMFlag & DYNAMIC_FUNC_ADAPTIVITY))
 	{
 		LOG_LEVEL(_drv_info_, "Go to odm_DynamicEDCCA() \n");
-		// Add by Neil Chen to enable edcca to MP Platform
+		// Add by Neil Chen to enable edcca to MP Platform 
 		// Adjust EDCCA.
 		/*if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)
 			dm_dynamic_EDCCA(pAdapter);
@@ -233,13 +233,13 @@ void dm_adaptivity(_adapter *pAdapter)
 	}
 	LOG_LEVEL(_drv_info_, "odm_Adaptivity() =====> \n");
 
-	LOG_LEVEL(_drv_info_, "ForceEDCCA=%d, IGI_Base=0x%x, TH_L2H_ini = %d, TH_EDCCA_HL_diff = %d, AdapEn_RSSI = %d\n",
+	LOG_LEVEL(_drv_info_, "ForceEDCCA=%d, IGI_Base=0x%x, TH_L2H_ini = %d, TH_EDCCA_HL_diff = %d, AdapEn_RSSI = %d\n", 
 		dmpriv->ForceEDCCA, dmpriv->IGI_Base, dmpriv->TH_L2H_ini, dmpriv->TH_EDCCA_HL_diff, dmpriv->AdapEn_RSSI);
 
 	/*if(pDM_Odm->SupportICType & ODM_IC_11AC_SERIES)
 		PHY_SetBBReg(0x800, BIT10, 0); //ADC_mask enable
 	*/
-
+	
 	if(!dm_linked(pAdapter) || pHalData->CurrentChannel > 149) /* Band4 doesn't need adaptivity */
 	{
 		/*if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)*/
@@ -296,7 +296,7 @@ void dm_adaptivity(_adapter *pAdapter)
 		TH_H2L_dmc = 0x7f;
 	}
 
-	LOG_LEVEL(_drv_info_, "IGI=0x%x, TH_L2H_dmc = %d, TH_H2L_dmc = %d\n",
+	LOG_LEVEL(_drv_info_, "IGI=0x%x, TH_L2H_dmc = %d, TH_H2L_dmc = %d\n", 
 		IGI, TH_L2H_dmc, TH_H2L_dmc);
 
 	/*if(pDM_Odm->SupportICType & ODM_IC_11N_SERIES)*/
@@ -311,3 +311,4 @@ void dm_adaptivity(_adapter *pAdapter)
 	return;
 #endif /* CONFIG_DM_ADAPTIVITY */
 }
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/hal/dm.h b/drivers/net/wireless/realtek/rtl8192cu/hal/dm.h
old mode 100644
new mode 100755
index cacd58f..dd9a57d
--- a/drivers/net/wireless/realtek/rtl8192cu/hal/dm.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/hal/dm.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2013 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
diff --git a/drivers/net/wireless/realtek/rtl8192cu/hal/hal_com.c b/drivers/net/wireless/realtek/rtl8192cu/hal/hal_com.c
old mode 100644
new mode 100755
index b9e4dad..4dcafd6
--- a/drivers/net/wireless/realtek/rtl8192cu/hal/hal_com.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/hal/hal_com.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -76,11 +76,11 @@
 	0x11000044, // 35, -11.5dB
 	0x10000040, // 36, -12.0dB
 	0x0f00003c,// 37, -12.5dB
-	0x0e400039,// 38, -13.0dB
+	0x0e400039,// 38, -13.0dB    
 	0x0d800036,// 39, -13.5dB
 	0x0cc00033,// 40, -14.0dB
 	0x0c000030,// 41, -14.5dB
-	0x0b40002d,// 42, -15.0dB
+	0x0b40002d,// 42, -15.0dB	
 };
 
 
@@ -89,21 +89,21 @@
 	{0x33, 0x32, 0x2b, 0x23, 0x1a, 0x11, 0x08, 0x04},	// 1, -0.5dB
 	{0x30, 0x2f, 0x29, 0x21, 0x19, 0x10, 0x08, 0x03},	// 2, -1.0dB
 	{0x2d, 0x2d, 0x27, 0x1f, 0x18, 0x0f, 0x08, 0x03},	// 3, -1.5dB
-	{0x2b, 0x2a, 0x25, 0x1e, 0x16, 0x0e, 0x07, 0x03},	// 4, -2.0dB
+	{0x2b, 0x2a, 0x25, 0x1e, 0x16, 0x0e, 0x07, 0x03},	// 4, -2.0dB 
 	{0x28, 0x28, 0x22, 0x1c, 0x15, 0x0d, 0x07, 0x03},	// 5, -2.5dB
 	{0x26, 0x25, 0x21, 0x1b, 0x14, 0x0d, 0x06, 0x03},	// 6, -3.0dB
 	{0x24, 0x23, 0x1f, 0x19, 0x13, 0x0c, 0x06, 0x03},	// 7, -3.5dB
-	{0x22, 0x21, 0x1d, 0x18, 0x11, 0x0b, 0x06, 0x02},	// 8, -4.0dB
+	{0x22, 0x21, 0x1d, 0x18, 0x11, 0x0b, 0x06, 0x02},	// 8, -4.0dB 
 	{0x20, 0x20, 0x1b, 0x16, 0x11, 0x08, 0x05, 0x02},	// 9, -4.5dB
-	{0x1f, 0x1e, 0x1a, 0x15, 0x10, 0x0a, 0x05, 0x02},	// 10, -5.0dB
+	{0x1f, 0x1e, 0x1a, 0x15, 0x10, 0x0a, 0x05, 0x02},	// 10, -5.0dB 
 	{0x1d, 0x1c, 0x18, 0x14, 0x0f, 0x0a, 0x05, 0x02},	// 11, -5.5dB
-	{0x1b, 0x1a, 0x17, 0x13, 0x0e, 0x09, 0x04, 0x02},	// 12, -6.0dB
+	{0x1b, 0x1a, 0x17, 0x13, 0x0e, 0x09, 0x04, 0x02},	// 12, -6.0dB 
 	{0x1a, 0x19, 0x16, 0x12, 0x0d, 0x09, 0x04, 0x02},	// 13, -6.5dB
-	{0x18, 0x17, 0x15, 0x11, 0x0c, 0x08, 0x04, 0x02},	// 14, -7.0dB
+	{0x18, 0x17, 0x15, 0x11, 0x0c, 0x08, 0x04, 0x02},	// 14, -7.0dB 
 	{0x17, 0x16, 0x13, 0x10, 0x0c, 0x08, 0x04, 0x02},	// 15, -7.5dB
-	{0x16, 0x15, 0x12, 0x0f, 0x0b, 0x07, 0x04, 0x01},	// 16, -8.0dB
+	{0x16, 0x15, 0x12, 0x0f, 0x0b, 0x07, 0x04, 0x01},	// 16, -8.0dB 
 	{0x14, 0x14, 0x11, 0x0e, 0x0b, 0x07, 0x03, 0x02},	// 17, -8.5dB
-	{0x13, 0x13, 0x10, 0x0d, 0x0a, 0x06, 0x03, 0x01},	// 18, -9.0dB
+	{0x13, 0x13, 0x10, 0x0d, 0x0a, 0x06, 0x03, 0x01},	// 18, -9.0dB 
 	{0x12, 0x12, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},	// 19, -9.5dB
 	{0x11, 0x11, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},	// 20, -10.0dB
 	{0x10, 0x10, 0x0e, 0x0b, 0x08, 0x05, 0x03, 0x01},	// 21, -10.5dB
@@ -122,25 +122,25 @@
 
 
 u8 CCKSwingTable_Ch14 [CCK_TABLE_SIZE][8]= {
-	{0x36, 0x35, 0x2e, 0x1b, 0x00, 0x00, 0x00, 0x00},	// 0, +0dB
-	{0x33, 0x32, 0x2b, 0x19, 0x00, 0x00, 0x00, 0x00},	// 1, -0.5dB
-	{0x30, 0x2f, 0x29, 0x18, 0x00, 0x00, 0x00, 0x00},	// 2, -1.0dB
+	{0x36, 0x35, 0x2e, 0x1b, 0x00, 0x00, 0x00, 0x00},	// 0, +0dB	
+	{0x33, 0x32, 0x2b, 0x19, 0x00, 0x00, 0x00, 0x00},	// 1, -0.5dB 
+	{0x30, 0x2f, 0x29, 0x18, 0x00, 0x00, 0x00, 0x00},	// 2, -1.0dB  
 	{0x2d, 0x2d, 0x17, 0x17, 0x00, 0x00, 0x00, 0x00},	// 3, -1.5dB
-	{0x2b, 0x2a, 0x25, 0x15, 0x00, 0x00, 0x00, 0x00},	// 4, -2.0dB
+	{0x2b, 0x2a, 0x25, 0x15, 0x00, 0x00, 0x00, 0x00},	// 4, -2.0dB  
 	{0x28, 0x28, 0x24, 0x14, 0x00, 0x00, 0x00, 0x00},	// 5, -2.5dB
-	{0x26, 0x25, 0x21, 0x13, 0x00, 0x00, 0x00, 0x00},	// 6, -3.0dB
-	{0x24, 0x23, 0x1f, 0x12, 0x00, 0x00, 0x00, 0x00},	// 7, -3.5dB
-	{0x22, 0x21, 0x1d, 0x11, 0x00, 0x00, 0x00, 0x00},	// 8, -4.0dB
+	{0x26, 0x25, 0x21, 0x13, 0x00, 0x00, 0x00, 0x00},	// 6, -3.0dB  
+	{0x24, 0x23, 0x1f, 0x12, 0x00, 0x00, 0x00, 0x00},	// 7, -3.5dB  
+	{0x22, 0x21, 0x1d, 0x11, 0x00, 0x00, 0x00, 0x00},	// 8, -4.0dB  
 	{0x20, 0x20, 0x1b, 0x10, 0x00, 0x00, 0x00, 0x00},	// 9, -4.5dB
-	{0x1f, 0x1e, 0x1a, 0x0f, 0x00, 0x00, 0x00, 0x00},	// 10, -5.0dB
+	{0x1f, 0x1e, 0x1a, 0x0f, 0x00, 0x00, 0x00, 0x00},	// 10, -5.0dB  
 	{0x1d, 0x1c, 0x18, 0x0e, 0x00, 0x00, 0x00, 0x00},	// 11, -5.5dB
-	{0x1b, 0x1a, 0x17, 0x0e, 0x00, 0x00, 0x00, 0x00},	// 12, -6.0dB
-	{0x1a, 0x19, 0x16, 0x0d, 0x00, 0x00, 0x00, 0x00},	// 13, -6.5dB
-	{0x18, 0x17, 0x15, 0x0c, 0x00, 0x00, 0x00, 0x00},	// 14, -7.0dB
+	{0x1b, 0x1a, 0x17, 0x0e, 0x00, 0x00, 0x00, 0x00},	// 12, -6.0dB  
+	{0x1a, 0x19, 0x16, 0x0d, 0x00, 0x00, 0x00, 0x00},	// 13, -6.5dB 
+	{0x18, 0x17, 0x15, 0x0c, 0x00, 0x00, 0x00, 0x00},	// 14, -7.0dB  
 	{0x17, 0x16, 0x13, 0x0b, 0x00, 0x00, 0x00, 0x00},	// 15, -7.5dB
-	{0x16, 0x15, 0x12, 0x0b, 0x00, 0x00, 0x00, 0x00},	// 16, -8.0dB
+	{0x16, 0x15, 0x12, 0x0b, 0x00, 0x00, 0x00, 0x00},	// 16, -8.0dB  
 	{0x14, 0x14, 0x11, 0x0a, 0x00, 0x00, 0x00, 0x00},	// 17, -8.5dB
-	{0x13, 0x13, 0x10, 0x0a, 0x00, 0x00, 0x00, 0x00},	// 18, -9.0dB
+	{0x13, 0x13, 0x10, 0x0a, 0x00, 0x00, 0x00, 0x00},	// 18, -9.0dB  
 	{0x12, 0x12, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},	// 19, -9.5dB
 	{0x11, 0x11, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},	// 20, -10.0dB
 	{0x10, 0x10, 0x0e, 0x08, 0x00, 0x00, 0x00, 0x00},	// 21, -10.5dB
@@ -155,7 +155,7 @@
 	{0x0a, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},	// 30, -15.0dB
 	{0x09, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},	// 31, -15.5dB
 	{0x09, 0x08, 0x07, 0x04, 0x00, 0x00, 0x00, 0x00}	// 32, -16.0dB
-};
+};	
 
 
 #ifdef CONFIG_CHIP_VER_INTEGRATION
@@ -174,22 +174,22 @@ void dump_chip_info(HAL_VERSION	ChipVersion)
 		DBG_871X("Chip Version Info: CHIP_8188E_");
 	}
 
-	DBG_871X("%s_",IS_NORMAL_CHIP(ChipVersion)?"Normal_Chip":"Test_Chip");
+	DBG_871X("%s_",IS_NORMAL_CHIP(ChipVersion)?"Normal_Chip":"Test_Chip");	
 	DBG_871X("%s_",IS_CHIP_VENDOR_TSMC(ChipVersion)?"TSMC":"UMC");
-	if(IS_A_CUT(ChipVersion)) DBG_871X("A_CUT_");
-	else if(IS_B_CUT(ChipVersion)) DBG_871X("B_CUT_");
-	else if(IS_C_CUT(ChipVersion)) DBG_871X("C_CUT_");
-	else if(IS_D_CUT(ChipVersion)) DBG_871X("D_CUT_");
-	else if(IS_E_CUT(ChipVersion)) DBG_871X("E_CUT_");
+	if(IS_A_CUT(ChipVersion)) DBG_871X("A_CUT_");	
+	else if(IS_B_CUT(ChipVersion)) DBG_871X("B_CUT_");	
+	else if(IS_C_CUT(ChipVersion)) DBG_871X("C_CUT_");	
+	else if(IS_D_CUT(ChipVersion)) DBG_871X("D_CUT_");	
+	else if(IS_E_CUT(ChipVersion)) DBG_871X("E_CUT_");	
 	else DBG_871X("UNKNOWN_CUT(%d)_",ChipVersion.CUTVersion);
-
-	if(IS_1T1R(ChipVersion))	DBG_871X("1T1R_");
-	else if(IS_1T2R(ChipVersion))	DBG_871X("1T2R_");
+	
+	if(IS_1T1R(ChipVersion))	DBG_871X("1T1R_");	
+	else if(IS_1T2R(ChipVersion))	DBG_871X("1T2R_");	
 	else if(IS_2T2R(ChipVersion))	DBG_871X("2T2R_");
 	else DBG_871X("UNKNOWN_RFTYPE(%d)_",ChipVersion.RFType);
 
-
-	DBG_871X("RomVer(%d)\n",ChipVersion.ROMVer);
+	
+	DBG_871X("RomVer(%d)\n",ChipVersion.ROMVer);	
 }
 
 #endif
@@ -231,7 +231,7 @@ void dump_chip_info(HAL_VERSION	ChipVersion)
 u8	MRateToHwRate(u8 rate)
 {
 	u8	ret = DESC_RATE1M;
-
+		
 	switch(rate)
 	{
 		// CCK and OFDM non-HT rates
@@ -275,9 +275,9 @@ void	HalSetBrateCfg(
 	{
 		is_brate = mBratesOS[i] & IEEE80211_BASIC_RATE_MASK;
 		brate = mBratesOS[i] & 0x7f;
-
+		
 		if( is_brate )
-		{
+		{		
 			switch(brate)
 			{
 				case IEEE80211_CCK_RATE_1MB:	*pBrateCfg |= RATE_1M;	break;
@@ -306,7 +306,7 @@ void hal_init_macaddr(_adapter *adapter)
 #endif
 }
 
-/*
+/* 
 * C2H event format:
 * Field	 TRIGGER		CONTENT	   CMD_SEQ 	CMD_LEN		 CMD_ID
 * BITS	 [127:120]	[119:16]      [15:8]		  [7:4]	 	   [3:0]
@@ -340,7 +340,7 @@ s32 c2h_evt_read(_adapter *adapter, u8 *buf)
 	_rtw_memset(c2h_evt, 0, 16);
 
 	*buf = rtw_read8(adapter, REG_C2HEVT_MSG_NORMAL);
-	*(buf+1) = rtw_read8(adapter, REG_C2HEVT_MSG_NORMAL + 1);
+	*(buf+1) = rtw_read8(adapter, REG_C2HEVT_MSG_NORMAL + 1);	
 
 	RT_PRINT_DATA(_module_hal_init_c_, _drv_info_, "c2h_evt_read(): ",
 		&c2h_evt , sizeof(c2h_evt));
@@ -360,7 +360,7 @@ s32 c2h_evt_read(_adapter *adapter, u8 *buf)
 	ret = _SUCCESS;
 
 clear_evt:
-	/*
+	/* 
 	* Clear event to notify FW we have read the command.
 	* If this field isn't clear, the FW won't update the next command message.
 	*/
@@ -368,3 +368,4 @@ s32 c2h_evt_read(_adapter *adapter, u8 *buf)
 exit:
 	return ret;
 }
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/hal/hal_intf.c b/drivers/net/wireless/realtek/rtl8192cu/hal/hal_intf.c
old mode 100644
new mode 100755
index fd1e888..6c56e72
--- a/drivers/net/wireless/realtek/rtl8192cu/hal/hal_intf.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/hal/hal_intf.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -74,7 +74,7 @@ void rtw_hal_dm_deinit(_adapter *padapter)
 {
 	// cancel dm  timer
 	if(padapter->HalFunc.dm_deinit)
-		padapter->HalFunc.dm_deinit(padapter);
+		padapter->HalFunc.dm_deinit(padapter);	
 }
 
 void rtw_hal_sw_led_init(_adapter *padapter)
@@ -89,7 +89,7 @@ void rtw_hal_sw_led_deinit(_adapter *padapter)
 		padapter->HalFunc.DeInitSwLeds(padapter);
 }
 
-uint	 rtw_hal_init(_adapter *padapter)
+uint	 rtw_hal_init(_adapter *padapter) 
 {
 	uint	status = _SUCCESS;
 
@@ -105,7 +105,7 @@ uint	 rtw_hal_init(_adapter *padapter)
 		goto fail;
 	}
 #endif
-
+	
 #ifdef CONFIG_DUALMAC_CONCURRENT
 	// before init mac0, driver must init mac1 first to avoid usb rx error.
 	if((padapter->pbuddy_adapter != NULL) && (padapter->DualMacConcurrent == _TRUE)
@@ -129,7 +129,7 @@ uint	 rtw_hal_init(_adapter *padapter)
 				padapter->pbuddy_adapter->hw_init_completed = _TRUE;
 			}
 			else{
-				padapter->pbuddy_adapter->hw_init_completed = _FALSE;
+			 	padapter->pbuddy_adapter->hw_init_completed = _FALSE;
 				RT_TRACE(_module_hal_init_c_,_drv_err_,("rtw_hal_init: hal__init fail(pbuddy_adapter)\n"));
 				goto fail;
 			}
@@ -169,7 +169,7 @@ uint	 rtw_hal_init(_adapter *padapter)
 		padapter->hw_init_completed = _TRUE;
 	}
 	else{
-		padapter->hw_init_completed = _FALSE;
+	 	padapter->hw_init_completed = _FALSE;
 		RT_TRACE(_module_hal_init_c_,_drv_err_,("rtw_hal_init: hal__init fail\n"));
 		goto fail;
 	}
@@ -190,12 +190,12 @@ uint	 rtw_hal_init(_adapter *padapter)
 	RT_TRACE(_module_hal_init_c_,_drv_err_,("-rtl871x_hal_init:status=0x%x\n",status));
 
 	return status;
-}
+}	
 
 uint rtw_hal_deinit(_adapter *padapter)
 {
 	uint	status = _SUCCESS;
-
+	
 _func_enter_;
 
 	status = padapter->HalFunc.hal_deinit(padapter);
@@ -207,9 +207,9 @@ uint rtw_hal_deinit(_adapter *padapter)
 	{
 		RT_TRACE(_module_hal_init_c_,_drv_err_,("\n rtw_hal_deinit: hal_init fail\n"));
 	}
-
+	
 _func_exit_;
-
+	
 	return status;
 }
 
@@ -226,54 +226,54 @@ void rtw_hal_get_hwreg(_adapter *padapter, u8 variable, u8 *val)
 }
 
 u8 rtw_hal_set_def_var(_adapter *padapter, HAL_DEF_VARIABLE eVariable, PVOID pValue)
-{
+{	
 	if(padapter->HalFunc.SetHalDefVarHandler)
 		return padapter->HalFunc.SetHalDefVarHandler(padapter,eVariable,pValue);
 	return _FAIL;
 }
 
 u8 rtw_hal_get_def_var(_adapter *padapter, HAL_DEF_VARIABLE eVariable, PVOID pValue)
-{
+{	
 	if(padapter->HalFunc.GetHalDefVarHandler)
 		return padapter->HalFunc.GetHalDefVarHandler(padapter,eVariable,pValue);
-	return _FAIL;
+	return _FAIL;	
 }
 
 void rtw_hal_enable_interrupt(_adapter *padapter)
 {
 	if (padapter->HalFunc.enable_interrupt)
 		padapter->HalFunc.enable_interrupt(padapter);
-	else
+	else 
 		DBG_871X("%s: HalFunc.enable_interrupt is NULL!\n", __FUNCTION__);
-
+	
 }
 void rtw_hal_disable_interrupt(_adapter *padapter)
 {
 	if (padapter->HalFunc.disable_interrupt)
 		padapter->HalFunc.disable_interrupt(padapter);
-	else
+	else 
 		DBG_871X("%s: HalFunc.disable_interrupt is NULL!\n", __FUNCTION__);
-
+	
 }
 
 u32	rtw_hal_inirp_init(_adapter *padapter)
 {
 	u32 rst = _FAIL;
-	if(padapter->HalFunc.inirp_init)
-		rst = padapter->HalFunc.inirp_init(padapter);
-	else
-		DBG_871X(" %s HalFunc.inirp_init is NULL!!!\n",__FUNCTION__);
+	if(padapter->HalFunc.inirp_init)	
+		rst = padapter->HalFunc.inirp_init(padapter);	
+	else		
+		DBG_871X(" %s HalFunc.inirp_init is NULL!!!\n",__FUNCTION__);		
 	return rst;
 }
-
+	
 u32	rtw_hal_inirp_deinit(_adapter *padapter)
 {
-
+	
 	if(padapter->HalFunc.inirp_deinit)
 		return padapter->HalFunc.inirp_deinit(padapter);
 
 	return _FAIL;
-
+		
 }
 
 u8 rtw_hal_intf_ps_func(_adapter *padapter,HAL_INTF_PS_FUNC efunc_id, u8* val)
@@ -288,7 +288,7 @@ s32	rtw_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe)
 	if(padapter->HalFunc.hal_xmitframe_enqueue)
 		return padapter->HalFunc.hal_xmitframe_enqueue(padapter, pxmitframe);
 
-	return _FALSE;
+	return _FALSE;	
 }
 
 s32 rtw_hal_xmit(_adapter *padapter, struct xmit_frame *pxmitframe)
@@ -304,7 +304,7 @@ s32	rtw_hal_mgnt_xmit(_adapter *padapter, struct xmit_frame *pmgntframe)
 	s32 ret = _FAIL;
 	unsigned char	*pframe;
 	struct rtw_ieee80211_hdr	*pwlanhdr;
-
+	
 	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
 	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
 	_rtw_memcpy(pmgntframe->attrib.ra, pwlanhdr->addr1, ETH_ALEN);
@@ -316,7 +316,7 @@ s32	rtw_hal_mgnt_xmit(_adapter *padapter, struct xmit_frame *pmgntframe)
 		{
 			pmgntframe->attrib.encrypt = _BIP_;
 			//pmgntframe->attrib.bswenc = _TRUE;
-		}
+		}	
 		else
 		{
 			pmgntframe->attrib.encrypt = _AES_;
@@ -325,7 +325,7 @@ s32	rtw_hal_mgnt_xmit(_adapter *padapter, struct xmit_frame *pmgntframe)
 		rtw_mgmt_xmitframe_coalesce(padapter, pmgntframe->pkt, pmgntframe);
 	}
 #endif //CONFIG_IEEE80211W
-
+	
 	if(padapter->HalFunc.mgnt_xmit)
 		ret = padapter->HalFunc.mgnt_xmit(padapter, pmgntframe);
 	return ret;
@@ -353,7 +353,7 @@ s32 rtw_hal_init_recv_priv(_adapter *padapter)
 }
 
 void rtw_hal_free_recv_priv(_adapter *padapter)
-{
+{	
 	if(padapter->HalFunc.free_recv_priv)
 		padapter->HalFunc.free_recv_priv(padapter);
 }
@@ -543,3 +543,4 @@ c2h_id_filter rtw_hal_c2h_id_filter_ccx(_adapter *adapter)
 {
 	return adapter->HalFunc.c2h_id_filter_ccx;
 }
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_cmd.c b/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_cmd.c
old mode 100644
new mode 100755
index 27e8d54..33921e2
--- a/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_cmd.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_cmd.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -41,26 +41,26 @@ static u8 _is_fw_read_cmd_down(_adapter* padapter, u8 msgbox_num)
 {
 	u8	read_down = _FALSE;
 	int 	retry_cnts = 100;
-
+	
 	u8 valid;
 
 //	DBG_8192C(" _is_fw_read_cmd_down ,isnormal_chip(%x),reg_1cc(%x),msg_box(%d)...\n",isvern,rtw_read8(padapter,REG_HMETFR),msgbox_num);
-
+	
 	do{
 		valid = rtw_read8(padapter,REG_HMETFR) & BIT(msgbox_num);
 		if(0 == valid ){
 			read_down = _TRUE;
-		}
+		}			
 	}while( (!read_down) && (retry_cnts--));
 
 	return read_down;
-
+	
 }
 
 
 /*****************************************
 * H2C Msg format :
-*| 31 - 8		|7		| 6 - 0	|
+*| 31 - 8		|7		| 6 - 0	|	
 *| h2c_msg 	|Ext_bit	|CMD_ID	|
 *
 ******************************************/
@@ -76,9 +76,9 @@ int rtl8192c_FillH2CCmd(_adapter* padapter, u8 ElementID, u32 CmdLen, u8* pCmdBu
 	u16	h2c_cmd_ex = 0;
 	int ret = _FAIL;
 
-_func_enter_;
+_func_enter_;	
 
-	padapter = GET_PRIMARY_ADAPTER(padapter);
+	padapter = GET_PRIMARY_ADAPTER(padapter);		
 	pHalData = GET_HAL_DATA(padapter);
 
 	if(padapter->bFWReady == _FALSE)
@@ -135,7 +135,7 @@ int rtl8192c_FillH2CCmd(_adapter* padapter, u8 ElementID, u32 CmdLen, u8* pCmdBu
 	}while((!bcmd_down) && (retry_cnts--));
 /*
 	if(bcmd_down)
-		DBG_8192C("H2C Cmd exe down. \n"	);
+		DBG_8192C("H2C Cmd exe down. \n"	);	
 	else
 		DBG_8192C("H2C Cmd exe failed. \n"	);
 */
@@ -143,7 +143,7 @@ int rtl8192c_FillH2CCmd(_adapter* padapter, u8 ElementID, u32 CmdLen, u8* pCmdBu
 
 exit:
 
-	_exit_critical_mutex(&(adapter_to_dvobj(padapter)->h2c_fwcmd_mutex), NULL);
+	_exit_critical_mutex(&(adapter_to_dvobj(padapter)->h2c_fwcmd_mutex), NULL);	
 
 _func_exit_;
 
@@ -152,11 +152,11 @@ int rtl8192c_FillH2CCmd(_adapter* padapter, u8 ElementID, u32 CmdLen, u8* pCmdBu
 }
 
 u8 rtl8192c_h2c_msg_hdl(_adapter *padapter, unsigned char *pbuf)
-{
+{	
 	u8 ElementID, CmdLen;
 	u8 *pCmdBuffer;
 	struct cmd_msg_parm  *pcmdmsg;
-
+	
 	if(!pbuf)
 		return H2C_PARAMETERS_ERROR;
 
@@ -178,13 +178,13 @@ u8 rtl8192c_set_FwSelectSuspend_cmd(_adapter *padapter ,u8 bfwpoll, u16 period)
 	DBG_8192C("==>%s bfwpoll(%x)\n",__FUNCTION__,bfwpoll);
 	param.gpio_period = period;//Polling GPIO_11 period time
 	param.ROFOn = (_TRUE == bfwpoll)?1:0;
-	rtl8192c_FillH2CCmd(padapter, SELECTIVE_SUSPEND_ROF_CMD, sizeof(param), (u8*)(&param));
+	rtl8192c_FillH2CCmd(padapter, SELECTIVE_SUSPEND_ROF_CMD, sizeof(param), (u8*)(&param));		
 	return res;
 }
 #endif //CONFIG_AUTOSUSPEND && SUPPORT_HW_RFOFF_DETECTED
 
 u8 rtl8192c_set_rssi_cmd(_adapter*padapter, u8 *param)
-{
+{	
 	u8	res=_SUCCESS;
 
 _func_enter_;
@@ -199,19 +199,19 @@ u8 rtl8192c_set_rssi_cmd(_adapter*padapter, u8 *param)
 }
 
 u8 rtl8192c_set_raid_cmd(_adapter*padapter, u32 mask, u8 arg)
-{
+{	
 	u8	buf[5];
 	u8	res=_SUCCESS;
-
-_func_enter_;
-
+	
+_func_enter_;	
+	
 	_rtw_memset(buf, 0, 5);
 	mask = cpu_to_le32( mask );
 	_rtw_memcpy(buf, &mask, 4);
 	buf[4]  = arg;
 
 	rtl8192c_FillH2CCmd(padapter, MACID_CONFIG_EID, 5, buf);
-
+	
 _func_exit_;
 
 	return res;
@@ -223,10 +223,10 @@ u8 rtl8192c_set_raid_cmd(_adapter*padapter, u32 mask, u8 arg)
 //arg[0:4] = macid
 //arg[5] = Short GI
 void rtl8192c_Add_RateATid(PADAPTER pAdapter, u32 bitmap, u8 arg)
-{
-
+{	
+	
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
-
+		
 	if(pHalData->fw_ractrl == _TRUE)
 	{
 		rtl8192c_set_raid_cmd(pAdapter, bitmap, arg);
@@ -236,15 +236,15 @@ void rtl8192c_Add_RateATid(PADAPTER pAdapter, u32 bitmap, u8 arg)
 		u8 macid, init_rate, shortGIrate=_FALSE;
 
 		init_rate = get_highest_rate_idx(bitmap&0x0fffffff)&0x3f;
-
+		
 		macid = arg&0x1f;
-
+		
 		shortGIrate = (arg&BIT(5)) ? _TRUE:_FALSE;
-
+		
 		if (shortGIrate==_TRUE)
 			init_rate |= BIT(6);
 
-		rtw_write8(pAdapter, (REG_INIDATA_RATE_SEL+macid), (u8)init_rate);
+		rtw_write8(pAdapter, (REG_INIDATA_RATE_SEL+macid), (u8)init_rate);		
 	}
 
 }
@@ -253,7 +253,7 @@ void rtl8192c_set_FwPwrMode_cmd(_adapter*padapter, u8 Mode)
 {
 	SETPWRMODE_PARM H2CSetPwrMode;
 	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
-
+	
 _func_enter_;
 
 	DBG_871X("%s(): Mode = %d, SmartPS = %d\n", __FUNCTION__,Mode,pwrpriv->smart_ps);
@@ -265,7 +265,7 @@ void rtl8192c_set_FwPwrMode_cmd(_adapter*padapter, u8 Mode)
 	H2CSetPwrMode.BcnPassTime = 1;//pPSC->RegMaxLPSAwakeIntvl;
 
 	rtl8192c_FillH2CCmd(padapter, SET_PWRMODE_EID, sizeof(H2CSetPwrMode), (u8 *)&H2CSetPwrMode);
-
+	
 _func_exit_;
 }
 
@@ -282,11 +282,11 @@ void ConstructBeacon(_adapter *padapter, u8 *pframe, u32 *pLength)
 
 	//DBG_871X("%s\n", __FUNCTION__);
 
-	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;	
 
 	fctrl = &(pwlanhdr->frame_ctl);
 	*(fctrl) = 0;
-
+	
 	_rtw_memcpy(pwlanhdr->addr1, bc_addr, ETH_ALEN);
 	_rtw_memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);
 	_rtw_memcpy(pwlanhdr->addr3, get_my_bssid(cur_network), ETH_ALEN);
@@ -294,16 +294,16 @@ void ConstructBeacon(_adapter *padapter, u8 *pframe, u32 *pLength)
 	SetSeqNum(pwlanhdr, 0/*pmlmeext->mgnt_seq*/);
 	//pmlmeext->mgnt_seq++;
 	SetFrameSubType(pframe, WIFI_BEACON);
-
-	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);
+	
+	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);	
 	pktlen = sizeof (struct rtw_ieee80211_hdr_3addr);
-
+	
 	//timestamp will be inserted by hardware
 	pframe += 8;
 	pktlen += 8;
 
 	// beacon interval: 2 bytes
-	_rtw_memcpy(pframe, (unsigned char *)(rtw_get_beacon_interval_from_ie(cur_network->IEs)), 2);
+	_rtw_memcpy(pframe, (unsigned char *)(rtw_get_beacon_interval_from_ie(cur_network->IEs)), 2); 
 
 	pframe += 2;
 	pktlen += 2;
@@ -319,7 +319,7 @@ void ConstructBeacon(_adapter *padapter, u8 *pframe, u32 *pLength)
 		//DBG_871X("ie len=%d\n", cur_network->IELength);
 		pktlen += cur_network->IELength - sizeof(NDIS_802_11_FIXED_IEs);
 		_rtw_memcpy(pframe, cur_network->IEs+sizeof(NDIS_802_11_FIXED_IEs), pktlen);
-
+		
 		goto _ConstructBeacon;
 	}
 
@@ -342,12 +342,12 @@ void ConstructBeacon(_adapter *padapter, u8 *pframe, u32 *pLength)
 		//ATIMWindow = cur->Configuration.ATIMWindow;
 		ATIMWindow = 0;
 		pframe = rtw_set_ie(pframe, _IBSS_PARA_IE_, 2, (unsigned char *)(&ATIMWindow), &pktlen);
-	}
+	}	
 
 
 	//todo: ERP IE
-
-
+	
+	
 	// EXTERNDED SUPPORTED RATE
 	if (rate_len > 8)
 	{
@@ -423,7 +423,7 @@ void ConstructNullFunctionData(_adapter *padapter, u8 *pframe, u32 *pLength, u8
 	}
 
 	switch(cur_network->network.InfrastructureMode)
-	{
+	{			
 		case Ndis802_11Infrastructure:
 			SetToDs(fctrl);
 			_rtw_memcpy(pwlanhdr->addr1, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
@@ -457,21 +457,21 @@ void ConstructNullFunctionData(_adapter *padapter, u8 *pframe, u32 *pLength, u8
 void ConstructProbeRsp(_adapter *padapter, u8 *pframe, u32 *pLength, u8 *StaAddr, BOOLEAN bHideSSID)
 {
 	struct rtw_ieee80211_hdr	*pwlanhdr;
-	u16					*fctrl;
+	u16					*fctrl;	
 	u8					*mac, *bssid;
 	u32					pktlen;
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	WLAN_BSSID_EX 		*cur_network = &(pmlmeinfo->network);
-
-
+	
+	
 	//DBG_871X("%s\n", __FUNCTION__);
-
-	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
-
+	
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;	
+	
 	mac = myid(&(padapter->eeprompriv));
 	bssid = cur_network->MacAddress;
-
+	
 	fctrl = &(pwlanhdr->frame_ctl);
 	*(fctrl) = 0;
 	_rtw_memcpy(pwlanhdr->addr1, StaAddr, ETH_ALEN);
@@ -480,7 +480,7 @@ void ConstructProbeRsp(_adapter *padapter, u8 *pframe, u32 *pLength, u8 *StaAddr
 
 	SetSeqNum(pwlanhdr, 0);
 	SetFrameSubType(fctrl, WIFI_PROBERSP);
-
+	
 	pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
 	pframe += pktlen;
 
@@ -490,13 +490,13 @@ void ConstructProbeRsp(_adapter *padapter, u8 *pframe, u32 *pLength, u8 *StaAddr
 	_rtw_memcpy(pframe, cur_network->IEs, cur_network->IELength);
 	pframe += cur_network->IELength;
 	pktlen += cur_network->IELength;
-
+	
 	*pLength = pktlen;
 }
 
 //
 // Description: In normal chip, we should send some packet to Hw which will be used by Fw
-//			in FW LPS mode. The function is to fill the Tx descriptor of this packets, then
+//			in FW LPS mode. The function is to fill the Tx descriptor of this packets, then 
 //			Fw can tell Hw to send these packet derectly.
 // Added by tynli. 2009.10.15.
 //
@@ -542,7 +542,7 @@ void ConstructProbeRsp(_adapter *padapter, u8 *pframe, u32 *pLength, u8 *StaAddr
 	// Using this checksum can let hardware recovery from packet bulk out error (e.g. Cancel URC, Bulk out error.).
 	rtl8192cu_cal_txdesc_chksum(ptxdesc);
 #endif
-
+	
 	//RT_PRINT_DATA(COMP_CMD, DBG_TRACE, "TxFillCmdDesc8192C(): H2C Tx Cmd Content ----->\n", pDesc, TX_DESC_SIZE);
 }
 
@@ -554,23 +554,23 @@ void ConstructProbeRsp(_adapter *padapter, u8 *pframe, u32 *pLength, u8 *StaAddr
 )
 {
 	HAL_DATA_TYPE*	pHalData = GET_HAL_DATA(Adapter);
-	u32	MaxBcnPageNum;
-
-	if(pHalData->FwRsvdPageStartOffset != 0)
-	{
-		/*MaxBcnPageNum = PageNum_128(pMgntInfo->MaxBeaconSize);
-		RT_ASSERT((MaxBcnPageNum <= pHalData->FwRsvdPageStartOffset),
+	u32	MaxBcnPageNum;	
+	
+ 	if(pHalData->FwRsvdPageStartOffset != 0)
+ 	{
+ 		/*MaxBcnPageNum = PageNum_128(pMgntInfo->MaxBeaconSize);
+		RT_ASSERT((MaxBcnPageNum <= pHalData->FwRsvdPageStartOffset), 
 			("CheckFwRsvdPageContent(): The reserved page content has been"\
 			"destroyed by beacon!!! MaxBcnPageNum(%d) FwRsvdPageStartOffset(%d)\n!",
 			MaxBcnPageNum, pHalData->FwRsvdPageStartOffset));*/
-	}
+ 	}
 }
 
 //
-// Description: Fill the reserved packets that FW will use to RSVD page.
+// Description: Fill the reserved packets that FW will use to RSVD page. 
 //			Now we just send 4 types packet to rsvd page.
 //			(1)Beacon, (2)Ps-poll, (3)Null data, (4)ProbeRsp.
-//	Input:
+//	Input: 
 //	    bDLFinished - FALSE: At the first time we will send all the packets as a large packet to Hw,
 //				 		so we need to set the packet length to total lengh.
 //			      TRUE: At the second time, we should send the first packet (default:beacon)
@@ -578,7 +578,7 @@ void ConstructProbeRsp(_adapter *padapter, u8 *pframe, u32 *pLength, u8 *StaAddr
 // 2009.10.15 by tynli.
 static void SetFwRsvdPagePkt(PADAPTER Adapter, BOOLEAN bDLFinished)
 {
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);	
 	struct xmit_frame	*pmgntframe;
 	struct pkt_attrib	*pattrib;
 	struct xmit_priv	*pxmitpriv = &(Adapter->xmitpriv);
@@ -619,7 +619,7 @@ static void SetFwRsvdPagePkt(PADAPTER Adapter, BOOLEAN bDLFinished)
 
 //--------------------------------------------------------------------
 
-	// When we count the first page size, we need to reserve description size for the RSVD
+	// When we count the first page size, we need to reserve description size for the RSVD 
 	// packet, it will be filled in front of the packet in TXPKTBUF.
 	U1bTmp = (u8)PageNum_128(BeaconLength+TxDescLen);
 	PageNum += U1bTmp;
@@ -629,10 +629,10 @@ static void SetFwRsvdPagePkt(PADAPTER Adapter, BOOLEAN bDLFinished)
 	pHalData->FwRsvdPageStartOffset = PageNum;
 
 	BufIndex = (PageNum*128) + TxDescOffset;
-
+		
 	//(2) ps-poll
 	ConstructPSPoll(Adapter, &ReservedPagePacket[BufIndex],&PSPollLength);
-
+	
 	FillFakeTxDescriptor92C(Adapter, &ReservedPagePacket[BufIndex-TxDescLen], PSPollLength, _TRUE);
 
 	//DBG_8192C("SetFwRsvdPagePkt(): HW_VAR_SET_TX_CMD: PS-POLL\n", &ReservedPagePacket[BufIndex-TxDescLen], (PSPollLength+TxDescLen));
@@ -640,7 +640,7 @@ static void SetFwRsvdPagePkt(PADAPTER Adapter, BOOLEAN bDLFinished)
 	RsvdPageLoc.LocPsPoll = PageNum;
 
 //------------------------------------------------------------------
-
+			
 	U1bTmp = (u8)PageNum_128(PSPollLength+TxDescLen);
 	PageNum += U1bTmp;
 
@@ -648,16 +648,16 @@ static void SetFwRsvdPagePkt(PADAPTER Adapter, BOOLEAN bDLFinished)
 
 	//(3) null data
 	ConstructNullFunctionData(
-		Adapter,
+		Adapter, 
 		&ReservedPagePacket[BufIndex],
 		&NullFunctionDataLength,
 		get_my_bssid(&(pmlmeinfo->network)),
 		_FALSE);
-
+	
 	FillFakeTxDescriptor92C(Adapter, &ReservedPagePacket[BufIndex-TxDescLen], NullFunctionDataLength, _FALSE);
 
 	RsvdPageLoc.LocNullData = PageNum;
-
+	
 	//DBG_8192C("SetFwRsvdPagePkt(): HW_VAR_SET_TX_CMD: NULL DATA \n", &ReservedPagePacket[BufIndex-TxDescLen], (NullFunctionDataLength+TxDescLen));
 //------------------------------------------------------------------
 
@@ -665,15 +665,15 @@ static void SetFwRsvdPagePkt(PADAPTER Adapter, BOOLEAN bDLFinished)
 	PageNum += U1bTmp;
 
 	BufIndex = (PageNum*128) + TxDescOffset;
-
+	
 	//(4) probe response
 	ConstructProbeRsp(
-		Adapter,
+		Adapter, 
 		&ReservedPagePacket[BufIndex],
 		&ProbeRspLength,
 		get_my_bssid(&(pmlmeinfo->network)),
 		_FALSE);
-
+	
 	FillFakeTxDescriptor92C(Adapter, &ReservedPagePacket[BufIndex-TxDescLen], ProbeRspLength, _FALSE);
 
 	RsvdPageLoc.LocProbeRsp = PageNum;
@@ -720,7 +720,7 @@ void rtl8192c_set_FwJoinBssReport_cmd(_adapter* padapter, u8 mstatus)
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-
+	
 _func_enter_;
 
 	DBG_871X("%s mstatus(%x)\n", __FUNCTION__,mstatus);
@@ -728,7 +728,7 @@ void rtl8192c_set_FwJoinBssReport_cmd(_adapter* padapter, u8 mstatus)
 	if(mstatus == 1)
 	{
 		BOOLEAN bRecover = _FALSE;
-
+	
 		// We should set AID, correct TSF, HW seq enable before set JoinBssReport to Fw in 88/92C.
 		// Suggested by filen. Added by tynli.
 		rtw_write16(padapter, REG_BCN_PSR_RPT, (0xC000|pmlmeinfo->aid));
@@ -768,7 +768,7 @@ void rtl8192c_set_FwJoinBssReport_cmd(_adapter* padapter, u8 mstatus)
 
 		// To make sure that if there exists an adapter which would like to send beacon.
 		// If exists, the origianl value of 0x422[6] will be 1, we should check this to
-		// prevent from setting 0x422[6] to 0 after download reserved page, or it will cause
+		// prevent from setting 0x422[6] to 0 after download reserved page, or it will cause 
 		// the beacon cannot be sent by HW.
 		// 2010.06.23. Added by tynli.
 		if(bRecover)
@@ -784,7 +784,7 @@ void rtl8192c_set_FwJoinBssReport_cmd(_adapter* padapter, u8 mstatus)
 	JoinBssRptParm.OpMode = mstatus;
 
 	rtl8192c_FillH2CCmd(padapter, JOINBSS_RPT_EID, sizeof(JoinBssRptParm), (u8 *)&JoinBssRptParm);
-
+	
 _func_exit_;
 }
 
@@ -796,12 +796,12 @@ void rtl8192c_set_p2p_ctw_period_cmd(_adapter* padapter, u8 ctwindow)
 	p2p_ps_ctw.CTWPeriod = ctwindow;
 
 	rtl8192c_FillH2CCmd(padapter, P2P_PS_CTW_CMD_EID, 1, (u8 *)(&p2p_ps_ctw));
-
+	
 }
 
 void rtl8192c_set_p2p_ps_offload_cmd(_adapter* padapter, u8 p2p_ps_state)
 {
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);	
 	struct pwrctrl_priv		*pwrpriv = &padapter->pwrctrlpriv;
 	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo );
 	struct P2P_PS_Offload_t	*p2p_ps_offload = &pHalData->p2p_ps_offload;
@@ -967,7 +967,7 @@ int rtl8192c_IOL_exec_cmds_sync(ADAPTER *adapter, struct xmit_frame *xmit_frame,
 			//, rtw_read32(adapter, 0x134)
 		);
 		#if 0 //debug
-		rtw_write16(adapter, 0x1c4, 0x0000);
+		rtw_write16(adapter, 0x1c4, 0x0000); 
 		rtw_msleep_os(10);
 		DBG_871X("after reset, 0x1c4=0x%08x\n", rtw_read32(adapter, 0x1c4));
 		#endif
@@ -995,31 +995,31 @@ int rtl8192c_IOL_exec_cmds_sync(ADAPTER *adapter, struct xmit_frame *xmit_frame,
 
 
 #ifdef CONFIG_BEACON_DISABLE_OFFLOAD
-/*
+/* 
  rtl8192c_dis_beacon_fun_cmd()
 	This function shall only be called by PORT1.
 	PORT0's beacon function can't be disabled, because it's used by RA function in FW/HW.
-
+	
 	// Still has the REG_BCN_CTRL_1 modified by unknowned party issue in case of Primary Interface + PORT1 combination.
 */
 u8 rtl8192c_dis_beacon_fun_cmd(_adapter* padapter)
-{
+{	
 	u8	buf[2];
 	u8	res=_SUCCESS;
-
-_func_enter_;
-
+	
+_func_enter_;	
+	
 	_rtw_memset(buf, 0, sizeof(buf));
 
 	if (padapter->iface_type == IFACE_PORT0) {
 		//buf[0] = 0x1;
 		DBG_871X("%s(): ERROR! padapter->iface_type = %d\n", __FUNCTION__, padapter->iface_type);
-		return _FAIL;
+		return _FAIL;		
 	} else
 		buf[1] = 0x1;
 
 	rtl8192c_FillH2CCmd(padapter, H2C_92C_DISABLE_BCN_FUNC, 2, buf);
-
+	
 _func_exit_;
 
 	return res;
@@ -1033,14 +1033,14 @@ u8 rtl8192c_dis_beacon_fun_cmd(_adapter* padapter)
 	ask FW to Reset sync register at Beacon early interrupt
 */
 u8 rtl8192c_reset_tsf(_adapter *padapter, u8 reset_port )
-{
+{	
 	u8	buf[2];
 	u8	res=_SUCCESS;
-
+	
 _func_enter_;
 	if (IFACE_PORT0==reset_port) {
 		buf[0] = 0x1; buf[1] = 0;
-
+	
 	} else{
 		buf[0] = 0x0; buf[1] = 0x1;
 	}
@@ -1079,7 +1079,7 @@ void rtl8192c_set_wowlan_cmd(_adapter* padapter)
 	u8	res=_SUCCESS;
 	SETWOWLAN_PARM pwowlan_parm;
 	struct pwrctrl_priv *pwrpriv=&padapter->pwrctrlpriv;
-
+	
 _func_enter_;
 
 	pwowlan_parm.mode =0;
@@ -1087,7 +1087,7 @@ void rtl8192c_set_wowlan_cmd(_adapter* padapter)
 	pwowlan_parm.gpio_duration=0;
 	pwowlan_parm.second_mode =0;
 	pwowlan_parm.reserve=0;
-
+	
 	if(pwrpriv->wowlan_mode ==_TRUE){
 		pwowlan_parm.mode |=FW_WOWLAN_FUN_EN;
 		//printk("\n %s 1.pwowlan_parm.mode=0x%x \n",__FUNCTION__,pwowlan_parm.mode );
@@ -1107,12 +1107,12 @@ void rtl8192c_set_wowlan_cmd(_adapter* padapter)
 		//pwowlan_parm.mode |=FW_WOWLAN_GPIO_ACTIVE;
 		pwowlan_parm.mode |=FW_WOWLAN_REKEY_WAKEUP;
 		pwowlan_parm.mode |=FW_WOWLAN_DEAUTH_WAKEUP;
-
+		
 		rtl8192c_set_FwJoinBssReport_cmd( padapter, 1);
-
+		
 		//GPIO3
 		pwowlan_parm.gpio_index=3;
-
+		
 		//duration unit is 64us
 		pwowlan_parm.gpio_duration=0xff;
 		//
@@ -1134,7 +1134,7 @@ void rtl8192c_set_wowlan_cmd(_adapter* padapter)
 		pwowlan_parm.gpio_duration=0;
 		rtl8192c_FillH2CCmd(padapter, DISCONNECT_DECISION_CTRL_CMD, 3, (u8 *)&pwowlan_parm);
 		printk("%s after DISCONNECT_DECISION_CTRL_CMD register 0x81=%x \n",__FUNCTION__,rtw_read8(padapter, 0x81));
-
+		
 		//enable GPIO wakeup
 		pwowlan_parm.mode =1;
 		pwowlan_parm.gpio_index=0;
@@ -1144,7 +1144,7 @@ void rtl8192c_set_wowlan_cmd(_adapter* padapter)
 	else
 		rtl8192c_FillH2CCmd(padapter, H2C_WO_WLAN_CMD, 3, (u8 *)&pwowlan_parm);
 
-
+	
 _func_exit_;
 
 	return ;
@@ -1152,3 +1152,8 @@ void rtl8192c_set_wowlan_cmd(_adapter* padapter)
 }
 
 #endif  //CONFIG_WOWLAN
+
+
+
+
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_dm.c b/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_dm.c
old mode 100644
new mode 100755
index 98d6f14..8a4c153
--- a/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_dm.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_dm.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -36,7 +36,7 @@
 #include <rtl8192c_hal.h>
 #include "../dm.h"
 #ifdef CONFIG_INTEL_PROXIM
-#include "../proxim/intel_proxim.h"
+#include "../proxim/intel_proxim.h"	
 #endif
 //============================================================
 // Global var
@@ -78,11 +78,11 @@ static void	dm_DIGInit(
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	DIG_T	*pDigTable = &pdmpriv->DM_DigTable;
-
+	
 
 	pDigTable->Dig_Enable_Flag = _TRUE;
 	pDigTable->Dig_Ext_Port_Stage = DIG_EXT_PORT_STAGE_MAX;
-
+	
 	pDigTable->CurIGValue = 0x20;
 	pDigTable->PreIGValue = 0x0;
 
@@ -95,7 +95,7 @@ static void	dm_DIGInit(
 	pDigTable->FALowThresh	= DM_FALSEALARM_THRESH_LOW;
 	pDigTable->FAHighThresh	= DM_FALSEALARM_THRESH_HIGH;
 
-
+	
 	pDigTable->rx_gain_range_max = DM_DIG_MAX;
 	pDigTable->rx_gain_range_min = DM_DIG_MIN;
 	pDigTable->rx_gain_range_min_nolink = 0;
@@ -122,7 +122,7 @@ static u8 dm_initial_gain_MinPWDB(
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	DIG_T			*pDigTable = &pdmpriv->DM_DigTable;
 	int	Rssi_val_min = 0;
-
+	
 	if((pDigTable->CurMultiSTAConnectState == DIG_MultiSTA_CONNECT) &&
 		(pDigTable->CurSTAConnectState == DIG_STA_CONNECT) )
 	{
@@ -131,13 +131,13 @@ static u8 dm_initial_gain_MinPWDB(
 			Rssi_val_min  =  (pdmpriv->UndecoratedSmoothedPWDB+pdmpriv->EntryMinUndecoratedSmoothedPWDB)/2;
 #else
 			Rssi_val_min  =  (pdmpriv->EntryMinUndecoratedSmoothedPWDB > pdmpriv->UndecoratedSmoothedPWDB)?
-					pdmpriv->UndecoratedSmoothedPWDB:pdmpriv->EntryMinUndecoratedSmoothedPWDB;
+					pdmpriv->UndecoratedSmoothedPWDB:pdmpriv->EntryMinUndecoratedSmoothedPWDB;		
 #endif //CONFIG_CONCURRENT_MODE
 		else
 			Rssi_val_min = pdmpriv->UndecoratedSmoothedPWDB;
 	}
-	else if(pDigTable->CurSTAConnectState == DIG_STA_CONNECT ||
-			pDigTable->CurSTAConnectState == DIG_STA_BEFORE_CONNECT)
+	else if(pDigTable->CurSTAConnectState == DIG_STA_CONNECT || 
+			pDigTable->CurSTAConnectState == DIG_STA_BEFORE_CONNECT) 
 		Rssi_val_min = pdmpriv->UndecoratedSmoothedPWDB;
 	else if(pDigTable->CurMultiSTAConnectState == DIG_MultiSTA_CONNECT)
 		Rssi_val_min = pdmpriv->EntryMinUndecoratedSmoothedPWDB;
@@ -150,7 +150,7 @@ static u8 dm_initial_gain_MinPWDB(
 }
 
 
-static VOID
+static VOID 
 dm_FalseAlarmCounterStatistics(
 	IN	PADAPTER	Adapter
 	)
@@ -162,9 +162,9 @@ static u8 dm_initial_gain_MinPWDB(
 #ifdef CONFIG_CONCURRENT_MODE
 	PADAPTER pbuddy_adapter = Adapter->pbuddy_adapter;
 #endif //CONFIG_CONCURRENT_MODE
-
+	
 	ret_value = PHY_QueryBBReg(Adapter, rOFDM_PHYCounter1, bMaskDWord);
-       FalseAlmCnt->Cnt_Parity_Fail = ((ret_value&0xffff0000)>>16);
+       FalseAlmCnt->Cnt_Parity_Fail = ((ret_value&0xffff0000)>>16);	
 
        ret_value = PHY_QueryBBReg(Adapter, rOFDM_PHYCounter2, bMaskDWord);
 	FalseAlmCnt->Cnt_Rate_Illegal = (ret_value&0xffff);
@@ -179,21 +179,21 @@ static u8 dm_initial_gain_MinPWDB(
 								FalseAlmCnt->Cnt_Crc8_fail + FalseAlmCnt->Cnt_Mcs_fail+
 								FalseAlmCnt->Cnt_Fast_Fsync + FalseAlmCnt->Cnt_SB_Search_fail;
 
-
+	
 	//hold cck counter
 	PHY_SetBBReg(Adapter, rCCK0_FalseAlarmReport, BIT(14), 1);
-
+	
 	ret_value = PHY_QueryBBReg(Adapter, rCCK0_FACounterLower, bMaskByte0);
 	FalseAlmCnt->Cnt_Cck_fail = ret_value;
 
 	ret_value = PHY_QueryBBReg(Adapter, rCCK0_FACounterUpper, bMaskByte3);
 	FalseAlmCnt->Cnt_Cck_fail +=  (ret_value& 0xff)<<8;
-
+	
 	FalseAlmCnt->Cnt_all = (	FalseAlmCnt->Cnt_Parity_Fail +
 						FalseAlmCnt->Cnt_Rate_Illegal +
 						FalseAlmCnt->Cnt_Crc8_fail +
 						FalseAlmCnt->Cnt_Mcs_fail +
-						FalseAlmCnt->Cnt_Cck_fail);
+						FalseAlmCnt->Cnt_Cck_fail);	
 
 	Adapter->recvpriv.FalseAlmCnt_all = FalseAlmCnt->Cnt_all;
 #ifdef CONFIG_CONCURRENT_MODE
@@ -209,11 +209,11 @@ static u8 dm_initial_gain_MinPWDB(
 	//enable cck counter
 	PHY_SetBBReg(Adapter, rCCK0_FalseAlarmReport, 0x0000c000, 2);
 
-	//RT_TRACE(	COMP_DIG, DBG_LOUD, ("Cnt_Parity_Fail = %ld, Cnt_Rate_Illegal = %ld, Cnt_Crc8_fail = %ld, Cnt_Mcs_fail = %ld\n",
+	//RT_TRACE(	COMP_DIG, DBG_LOUD, ("Cnt_Parity_Fail = %ld, Cnt_Rate_Illegal = %ld, Cnt_Crc8_fail = %ld, Cnt_Mcs_fail = %ld\n", 
 	//			FalseAlmCnt->Cnt_Parity_Fail, FalseAlmCnt->Cnt_Rate_Illegal, FalseAlmCnt->Cnt_Crc8_fail, FalseAlmCnt->Cnt_Mcs_fail) );
-	//RT_TRACE(	COMP_DIG, DBG_LOUD, ("Cnt_Ofdm_fail = %ld, Cnt_Cck_fail = %ld, Cnt_all = %ld\n",
+	//RT_TRACE(	COMP_DIG, DBG_LOUD, ("Cnt_Ofdm_fail = %ld, Cnt_Cck_fail = %ld, Cnt_all = %ld\n", 
 	//			FalseAlmCnt->Cnt_Ofdm_fail, FalseAlmCnt->Cnt_Cck_fail, FalseAlmCnt->Cnt_all) );
-	//RT_TRACE(	COMP_DIG, DBG_LOUD, ("Cnt_Ofdm_fail = %ld, Cnt_Cck_fail = %ld, Cnt_all = %ld\n",
+	//RT_TRACE(	COMP_DIG, DBG_LOUD, ("Cnt_Ofdm_fail = %ld, Cnt_Cck_fail = %ld, Cnt_all = %ld\n", 
 	//			FalseAlmCnt->Cnt_Ofdm_fail, FalseAlmCnt->Cnt_Cck_fail, FalseAlmCnt->Cnt_all) );
 }
 
@@ -226,7 +226,7 @@ static u8 dm_initial_gain_MinPWDB(
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	DIG_T	*pDigTable = &pdmpriv->DM_DigTable;
-
+	
 #ifdef CONFIG_CONCURRENT_MODE
 	if(rtw_buddy_adapter_up(pAdapter))
 	{
@@ -239,10 +239,10 @@ static u8 dm_initial_gain_MinPWDB(
 		pbuddy_DigTable->PreIGValue = pDigTable->PreIGValue;
 		pbuddy_DigTable->CurIGValue = pDigTable->CurIGValue;
 	}
-#endif //CONFIG_CONCURRENT_MODE
+#endif //CONFIG_CONCURRENT_MODE	
 
 
-	//RT_TRACE(	COMP_DIG, DBG_LOUD, ("CurIGValue = 0x%lx, PreIGValue = 0x%lx, BackoffVal = %d\n",
+	//RT_TRACE(	COMP_DIG, DBG_LOUD, ("CurIGValue = 0x%lx, PreIGValue = 0x%lx, BackoffVal = %d\n", 
 	//			DM_DigTable.CurIGValue, DM_DigTable.PreIGValue, DM_DigTable.BackoffVal));
 
 	if (pDigTable->Dig_Enable_Flag == _FALSE)
@@ -276,10 +276,10 @@ static u8 dm_initial_gain_MinPWDB(
 }
 
 
-static VOID
+static VOID 
 dm_CtrlInitGainByFA(
 	IN	PADAPTER	pAdapter
-)
+)	
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
@@ -287,33 +287,33 @@ static u8 dm_initial_gain_MinPWDB(
 	PFALSE_ALARM_STATISTICS FalseAlmCnt = &(pdmpriv->FalseAlmCnt);
 
 	u8	value_IGI = pDigTable->CurIGValue;
-
-	if(FalseAlmCnt->Cnt_all < DM_DIG_FA_TH0)
+	
+	if(FalseAlmCnt->Cnt_all < DM_DIG_FA_TH0)	
 		value_IGI --;
-	else if(FalseAlmCnt->Cnt_all < DM_DIG_FA_TH1)
+	else if(FalseAlmCnt->Cnt_all < DM_DIG_FA_TH1)	
 		value_IGI += 0;
-	else if(FalseAlmCnt->Cnt_all < DM_DIG_FA_TH2)
+	else if(FalseAlmCnt->Cnt_all < DM_DIG_FA_TH2)	
 		value_IGI ++;
-	else if(FalseAlmCnt->Cnt_all >= DM_DIG_FA_TH2)
+	else if(FalseAlmCnt->Cnt_all >= DM_DIG_FA_TH2)	
 		value_IGI +=2;
-
-	if(value_IGI > DM_DIG_FA_UPPER)
+	
+	if(value_IGI > DM_DIG_FA_UPPER)			
 		value_IGI = DM_DIG_FA_UPPER;
 	if(value_IGI < DM_DIG_FA_LOWER)
 		value_IGI = DM_DIG_FA_LOWER;
 
 	if(FalseAlmCnt->Cnt_all > 10000)
 		value_IGI = DM_DIG_FA_UPPER;
-
+	
 	pDigTable->CurIGValue = value_IGI;
-
+	
 	DM_Write_DIG(pAdapter);
-
+	
 }
 
 #ifdef CONFIG_SPECIAL_SETTING_FOR_FUNAI_TV
-VOID dm_CtrlInitGainByRssi( IN PADAPTER pAdapter)
-{
+VOID dm_CtrlInitGainByRssi( IN PADAPTER pAdapter) 
+{ 
 
 	u32 isBT;
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
@@ -327,69 +327,69 @@ VOID dm_CtrlInitGainByRssi( IN PADAPTER pAdapter)
 	 //modify DIG upper bound
 	if((pDigTable->Rssi_val_min + 20) > DM_DIG_MAX )
 		pDigTable->rx_gain_range_max = DM_DIG_MAX;
-	else
-		pDigTable->rx_gain_range_max = pDigTable->Rssi_val_min + 20;
+ 	else
+  		pDigTable->rx_gain_range_max = pDigTable->Rssi_val_min + 20;
 
-	//modify DIG lower bound
+	//modify DIG lower bound	
 	if((FalseAlmCnt->Cnt_all > 500)&&(pdmpriv->DIG_Dynamic_MIN < 0x25))
-		pdmpriv->DIG_Dynamic_MIN++;
-	if((FalseAlmCnt->Cnt_all < 500)&&(pdmpriv->DIG_Dynamic_MIN > DM_DIG_MIN))
-		pdmpriv->DIG_Dynamic_MIN--;
+  		pdmpriv->DIG_Dynamic_MIN++;
+ 	if((FalseAlmCnt->Cnt_all < 500)&&(pdmpriv->DIG_Dynamic_MIN > DM_DIG_MIN))
+  		pdmpriv->DIG_Dynamic_MIN--;
 	if((pDigTable->Rssi_val_min < 8) && (pdmpriv->DIG_Dynamic_MIN > DM_DIG_MIN))
 		pdmpriv->DIG_Dynamic_MIN--;
-
-	//modify DIG lower bound, deal with abnorally large false alarm
-	if(FalseAlmCnt->Cnt_all > 10000)
-	{
-		//RT_TRACE(COMP_DIG, DBG_LOUD, ("dm_DIG(): Abnornally false alarm case. \n"));
-		pDigTable->LargeFAHit++;
-		 if(pDigTable->ForbiddenIGI < pDigTable->CurIGValue)
-		{
-			pDigTable->ForbiddenIGI = pDigTable->CurIGValue;
-			pDigTable->LargeFAHit = 1;
-		}
-		if(pDigTable->LargeFAHit >= 3)
-		{
+	
+ 	//modify DIG lower bound, deal with abnorally large false alarm
+ 	if(FalseAlmCnt->Cnt_all > 10000)
+ 	{
+ 		//RT_TRACE(COMP_DIG, DBG_LOUD, ("dm_DIG(): Abnornally false alarm case. \n"));
+  		pDigTable->LargeFAHit++;
+ 		 if(pDigTable->ForbiddenIGI < pDigTable->CurIGValue)
+  		{
+   			pDigTable->ForbiddenIGI = pDigTable->CurIGValue;
+	  		pDigTable->LargeFAHit = 1;
+	  	}
+	  	if(pDigTable->LargeFAHit >= 3)
+	  	{
 			if((pDigTable->ForbiddenIGI+1) >pDigTable->rx_gain_range_max)
-				pDigTable->rx_gain_range_min = pDigTable->rx_gain_range_max;
-			else
-				pDigTable->rx_gain_range_min = (pDigTable->ForbiddenIGI + 1);
-			pDigTable->Recover_cnt = 3600; //3600=2hr
+		    		pDigTable->rx_gain_range_min = pDigTable->rx_gain_range_max;
+		   	else
+		    		pDigTable->rx_gain_range_min = (pDigTable->ForbiddenIGI + 1);
+		   	pDigTable->Recover_cnt = 3600; //3600=2hr
 		  }
 	 }
 	 else
 	 {
 	  //Recovery mechanism for IGI lower bound
-		if(pDigTable->Recover_cnt != 0){
-			pDigTable->Recover_cnt --;
-		}
-		else
-		{
+	  	if(pDigTable->Recover_cnt != 0){
+	   		pDigTable->Recover_cnt --;
+	  	}
+	  	else
+	 	{
 			if(pDigTable->LargeFAHit == 0 )
-			{
-				if((pDigTable->ForbiddenIGI -1) < pdmpriv->DIG_Dynamic_MIN) //DM_DIG_MIN)
-				{
-					pDigTable->ForbiddenIGI = pdmpriv->DIG_Dynamic_MIN; //DM_DIG_MIN;
-					pDigTable->rx_gain_range_min = pdmpriv->DIG_Dynamic_MIN; //DM_DIG_MIN;
-				}
-				else
-				{
-					pDigTable->ForbiddenIGI --;
-					pDigTable->rx_gain_range_min = (pDigTable->ForbiddenIGI + 1);
-				}
-			}
-			else if(pDigTable->LargeFAHit == 3 )
-			{
-				pDigTable->LargeFAHit = 0;
-			}
-		}
+	   		{
+	   			if((pDigTable->ForbiddenIGI -1) < pdmpriv->DIG_Dynamic_MIN) //DM_DIG_MIN)
+			    	{
+			     		pDigTable->ForbiddenIGI = pdmpriv->DIG_Dynamic_MIN; //DM_DIG_MIN;
+			     		pDigTable->rx_gain_range_min = pdmpriv->DIG_Dynamic_MIN; //DM_DIG_MIN;
+			    	}
+			    	else
+			    	{
+			     		pDigTable->ForbiddenIGI --;
+			     		pDigTable->rx_gain_range_min = (pDigTable->ForbiddenIGI + 1);
+			    	}
+	   		}
+	   		else if(pDigTable->LargeFAHit == 3 )
+	   		{
+	    			pDigTable->LargeFAHit = 0;
+	   		}
+	  	}
 	 }
  #ifdef CONFIG_USB_HCI
 	if(FalseAlmCnt->Cnt_all < 250)
 	{
 #endif
 		//DBG_8192C("===> dm_CtrlInitGainByRssi, Enter DIG by SS mode\n");
-
+		
 		isBT = rtw_read8(pAdapter, 0x4fd) & 0x01;
 
 		if(!isBT){
@@ -399,36 +399,36 @@ VOID dm_CtrlInitGainByRssi( IN PADAPTER pAdapter)
 				if((pDigTable->BackoffVal -2) < pDigTable->BackoffVal_range_min)
 					pDigTable->BackoffVal = pDigTable->BackoffVal_range_min;
 				else
-					pDigTable->BackoffVal -= 2;
-			}
+					pDigTable->BackoffVal -= 2; 
+			}	
 			else if(FalseAlmCnt->Cnt_all < pDigTable->FALowThresh)
 			{
 				if((pDigTable->BackoffVal+2) > pDigTable->BackoffVal_range_max)
 					pDigTable->BackoffVal = pDigTable->BackoffVal_range_max;
 				else
 					pDigTable->BackoffVal +=2;
-			}
+			}	
 		}
 		else
 			pDigTable->BackoffVal = DM_DIG_BACKOFF_DEFAULT;
 
-		pDigTable->CurIGValue = pDigTable->Rssi_val_min+10-pDigTable->BackoffVal;
+		pDigTable->CurIGValue = pDigTable->Rssi_val_min+10-pDigTable->BackoffVal;	
 
 		//DBG_8192C("Rssi_val_min = %x BackoffVal %x\n",pDigTable->Rssi_val_min, pDigTable->BackoffVal);
 #ifdef CONFIG_USB_HCI
 	}
 	else
-	{
+	{		
 		//DBG_8192C("===> dm_CtrlInitGainByRssi, Enter DIG by FA mode\n");
 		//DBG_8192C("RSSI = 0x%x", pDigTable->Rssi_val_min);
 
-		//Adjust initial gain by false alarm
+		//Adjust initial gain by false alarm		
 		if(FalseAlmCnt->Cnt_all > 1000)
 			pDigTable->CurIGValue = pDigTable ->PreIGValue+2;
 		else if (FalseAlmCnt->Cnt_all > 750)
 			pDigTable->CurIGValue = pDigTable->PreIGValue+1;
 		else if(FalseAlmCnt->Cnt_all < 500)
-			pDigTable->CurIGValue = pDigTable->PreIGValue-1;
+			pDigTable->CurIGValue = pDigTable->PreIGValue-1;	
 	}
 #endif
 
@@ -457,13 +457,13 @@ VOID dm_CtrlInitGainByRssi( IN PADAPTER pAdapter)
 
 	//printk("%s => rx_gain_range_max(0x%02x) rx_gain_range_min(0x%02x)\n",__FUNCTION__,
 	//	pDigTable->rx_gain_range_max,pDigTable->rx_gain_range_min);
-	//printk("%s CurIGValue(0x%02x)  <====\n",__FUNCTION__,pDigTable->CurIGValue );
+	//printk("%s CurIGValue(0x%02x)  <====\n",__FUNCTION__,pDigTable->CurIGValue );		
 
 	DM_Write_DIG(pAdapter);
 
 }
 #else
-static VOID dm_CtrlInitGainByRssi(IN	PADAPTER	pAdapter)
+static VOID dm_CtrlInitGainByRssi(IN	PADAPTER	pAdapter)	
 {
 	u32 isBT;
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
@@ -537,7 +537,7 @@ static VOID dm_CtrlInitGainByRssi(IN	PADAPTER	pAdapter)
 	{
 #endif
 		//DBG_8192C("===> dm_CtrlInitGainByRssi, Enter DIG by SS mode\n");
-
+		
 		isBT = rtw_read8(pAdapter, 0x4fd) & 0x01;
 
 		if(!isBT){
@@ -547,36 +547,36 @@ static VOID dm_CtrlInitGainByRssi(IN	PADAPTER	pAdapter)
 				if((pDigTable->BackoffVal -2) < pDigTable->BackoffVal_range_min)
 					pDigTable->BackoffVal = pDigTable->BackoffVal_range_min;
 				else
-					pDigTable->BackoffVal -= 2;
-			}
+					pDigTable->BackoffVal -= 2; 
+			}	
 			else if(FalseAlmCnt->Cnt_all < pDigTable->FALowThresh)
 			{
 				if((pDigTable->BackoffVal+2) > pDigTable->BackoffVal_range_max)
 					pDigTable->BackoffVal = pDigTable->BackoffVal_range_max;
 				else
 					pDigTable->BackoffVal +=2;
-			}
+			}	
 		}
 		else
 			pDigTable->BackoffVal = DM_DIG_BACKOFF_DEFAULT;
 
-		pDigTable->CurIGValue = pDigTable->Rssi_val_min+10-pDigTable->BackoffVal;
+		pDigTable->CurIGValue = pDigTable->Rssi_val_min+10-pDigTable->BackoffVal;	
 
 		//DBG_8192C("Rssi_val_min = %x BackoffVal %x\n",pDigTable->Rssi_val_min, pDigTable->BackoffVal);
 #ifdef CONFIG_USB_HCI
 	}
 	else
-	{
+	{		
 		//DBG_8192C("===> dm_CtrlInitGainByRssi, Enter DIG by FA mode\n");
 		//DBG_8192C("RSSI = 0x%x", pDigTable->Rssi_val_min);
 
-		//Adjust initial gain by false alarm
+		//Adjust initial gain by false alarm		
 		if(FalseAlmCnt->Cnt_all > 1000)
 			pDigTable->CurIGValue = pDigTable ->PreIGValue+2;
 		else if (FalseAlmCnt->Cnt_all > 750)
 			pDigTable->CurIGValue = pDigTable->PreIGValue+1;
 		else if(FalseAlmCnt->Cnt_all < 500)
-			pDigTable->CurIGValue = pDigTable->PreIGValue-1;
+			pDigTable->CurIGValue = pDigTable->PreIGValue-1;	
 	}
 #endif
 
@@ -613,7 +613,7 @@ static VOID dm_CtrlInitGainByRssi(IN	PADAPTER	pAdapter)
 
 	//printk("%s => rx_gain_range_max(0x%02x) rx_gain_range_min(0x%02x)\n",__FUNCTION__,
 	//	pDigTable->rx_gain_range_max,pDigTable->rx_gain_range_min);
-	//printk("%s CurIGValue(0x%02x)  <====\n",__FUNCTION__,pDigTable->CurIGValue );
+	//printk("%s CurIGValue(0x%02x)  <====\n",__FUNCTION__,pDigTable->CurIGValue );		
 
 	DM_Write_DIG(pAdapter);
 
@@ -628,19 +628,19 @@ static VOID dm_CtrlInitGainByRssi(IN	PADAPTER	pAdapter)
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	struct mlme_priv	*pmlmepriv = &(pAdapter->mlmepriv);
 	DIG_T			*pDigTable = &pdmpriv->DM_DigTable;
-	int				rssi_strength =  pdmpriv->EntryMinUndecoratedSmoothedPWDB;
+	int				rssi_strength =  pdmpriv->EntryMinUndecoratedSmoothedPWDB;	
 	BOOLEAN			bMulti_STA = _FALSE;
-
+	
 #ifdef CONFIG_CONCURRENT_MODE
 	//AP Mode
 	if(check_buddy_fwstate(pAdapter, WIFI_AP_STATE) == _TRUE && (rssi_strength !=0))
 	{
 		bMulti_STA = _TRUE;
-	}
+	}	
 	else if(pDigTable->CurMultiSTAConnectState == DIG_MultiSTA_CONNECT && rssi_strength==0) //STA+STA MODE
 	{
 		bMulti_STA = _TRUE;
-		rssi_strength = pdmpriv->UndecoratedSmoothedPWDB;
+		rssi_strength = pdmpriv->UndecoratedSmoothedPWDB;		
 	}
 #endif //CONFIG_CONCURRENT_MODE
 
@@ -652,13 +652,13 @@ static VOID dm_CtrlInitGainByRssi(IN	PADAPTER	pAdapter)
 	}
 
 
-	if((bMulti_STA == _FALSE)
-		|| (pDigTable->CurSTAConnectState == DIG_STA_DISCONNECT))
+	if((bMulti_STA == _FALSE) 
+		|| (pDigTable->CurSTAConnectState == DIG_STA_DISCONNECT))	 
 	{
 		pdmpriv->binitialized = _FALSE;
 		pDigTable->Dig_Ext_Port_Stage = DIG_EXT_PORT_STAGE_MAX;
 		return;
-	}
+	}	
 	else if(pdmpriv->binitialized == _FALSE)
 	{
 		pdmpriv->binitialized = _TRUE;
@@ -667,26 +667,26 @@ static VOID dm_CtrlInitGainByRssi(IN	PADAPTER	pAdapter)
 		DM_Write_DIG(pAdapter);
 	}
 
-	// Initial gain control by ap mode
+	// Initial gain control by ap mode 
 	if(pDigTable->CurMultiSTAConnectState == DIG_MultiSTA_CONNECT)
 	{
-		if (	(rssi_strength < pDigTable->RssiLowThresh) 	&&
+		if (	(rssi_strength < pDigTable->RssiLowThresh) 	&& 
 			(pDigTable->Dig_Ext_Port_Stage != DIG_EXT_PORT_STAGE_1))
-		{
+		{					
 			// Set to dig value to 0x20 for Luke's opinion after disable dig
 			if(pDigTable->Dig_Ext_Port_Stage == DIG_EXT_PORT_STAGE_2)
 			{
 				pDigTable->CurIGValue = 0x20;
-				DM_Write_DIG(pAdapter);
-			}
-			pDigTable->Dig_Ext_Port_Stage = DIG_EXT_PORT_STAGE_1;
-		}
+				DM_Write_DIG(pAdapter);				
+			}	
+			pDigTable->Dig_Ext_Port_Stage = DIG_EXT_PORT_STAGE_1;	
+		}	
 		else if (rssi_strength > pDigTable->RssiHighThresh)
 		{
 			pDigTable->Dig_Ext_Port_Stage = DIG_EXT_PORT_STAGE_2;
 			dm_CtrlInitGainByFA(pAdapter);
-		}
-	}
+		} 
+	}	
 	else if(pDigTable->Dig_Ext_Port_Stage != DIG_EXT_PORT_STAGE_0)
 	{
 		pDigTable->Dig_Ext_Port_Stage = DIG_EXT_PORT_STAGE_0;
@@ -694,11 +694,11 @@ static VOID dm_CtrlInitGainByRssi(IN	PADAPTER	pAdapter)
 		DM_Write_DIG(pAdapter);
 	}
 
-	//RT_TRACE(	COMP_DIG, DBG_LOUD, ("CurMultiSTAConnectState = %x Dig_Ext_Port_Stage %x\n",
+	//RT_TRACE(	COMP_DIG, DBG_LOUD, ("CurMultiSTAConnectState = %x Dig_Ext_Port_Stage %x\n", 
 	//			DM_DigTable.CurMultiSTAConnectState, DM_DigTable.Dig_Ext_Port_Stage));
 }
 
-static VOID
+static VOID 
 dm_initial_gain_STA_beforelinked(
 	IN	PADAPTER	pAdapter)
 {
@@ -706,13 +706,13 @@ static VOID dm_CtrlInitGainByRssi(IN	PADAPTER	pAdapter)
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	DIG_T	*pDigTable = &pdmpriv->DM_DigTable;
 	PFALSE_ALARM_STATISTICS pFalseAlmCnt = &(pdmpriv->FalseAlmCnt);
-
+	
 	//CurrentIGI = pDM_DigTable->rx_gain_range_min;//pDM_DigTable->CurIGValue = pDM_DigTable->rx_gain_range_min
 	//ODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): DIG BeforeLink\n"));
 	//2012.03.30 LukeLee: enable DIG before link but with very high thresholds
 	//	Updated by Albert 2012/09/27
 	//	Copy the same rule from 8192du code.
-	if( pFalseAlmCnt->Cnt_all > 2000 )
+      	if( pFalseAlmCnt->Cnt_all > 2000 )
 		pDigTable->CurIGValue += 2;
 	else if ( ( pFalseAlmCnt->Cnt_all > 1000 ) && ( pFalseAlmCnt->Cnt_all <= 1000 ) )
 		pDigTable->CurIGValue += 1;
@@ -725,19 +725,19 @@ static VOID dm_CtrlInitGainByRssi(IN	PADAPTER	pAdapter)
 
 	if(pDigTable->CurIGValue < pDigTable->rx_gain_range_min)
 		pDigTable->CurIGValue = pDigTable->rx_gain_range_min;
-
-	printk("%s ==> FalseAlmCnt->Cnt_all:%d CurIGValue:0x%02x \n",__FUNCTION__,pFalseAlmCnt->Cnt_all ,pDigTable->CurIGValue);
+	
+	printk("%s ==> FalseAlmCnt->Cnt_all:%d CurIGValue:0x%02x \n",__FUNCTION__,pFalseAlmCnt->Cnt_all ,pDigTable->CurIGValue);		 
 }
 
-static VOID
+static VOID 
 dm_initial_gain_STA(
 	IN	PADAPTER	pAdapter)
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	DIG_T	*pDigTable = &pdmpriv->DM_DigTable;
-
-	//RT_TRACE(	COMP_DIG, DBG_LOUD, ("PreSTAConnectState = %x, CurSTAConnectState = %x\n",
+	
+	//RT_TRACE(	COMP_DIG, DBG_LOUD, ("PreSTAConnectState = %x, CurSTAConnectState = %x\n", 
 	//			DM_DigTable.PreSTAConnectState, DM_DigTable.CurSTAConnectState));
 
 
@@ -752,16 +752,16 @@ static VOID dm_CtrlInitGainByRssi(IN	PADAPTER	pAdapter)
 		{
 			pDigTable->Rssi_val_min = dm_initial_gain_MinPWDB(pAdapter);
 			dm_CtrlInitGainByRssi(pAdapter);
-		}
+		}	
 #if 0
-		else if((wdev_to_priv(pAdapter->rtw_wdev))->p2p_enabled == _TRUE
+		else if((wdev_to_priv(pAdapter->rtw_wdev))->p2p_enabled == _TRUE 
 				&& pAdapter->wdinfo.driver_interface == DRIVER_CFG80211)
 		{
 			//pDigTable->CurIGValue = 0x30;
 			DM_Write_DIG(pAdapter);
 		}
 #endif
-		else{ // pDigTable->CurSTAConnectState == DIG_STA_DISCONNECT
+		else{ // pDigTable->CurSTAConnectState == DIG_STA_DISCONNECT 
 		#ifdef CONFIG_BEFORE_LINKED_DIG
 			//printk("%s==> ##1 CurIGI(0x%02x),PreIGValue(0x%02x) \n",__FUNCTION__,pDigTable->CurIGValue,pDigTable->PreIGValue );
 			dm_initial_gain_STA_beforelinked(pAdapter);
@@ -769,19 +769,19 @@ static VOID dm_CtrlInitGainByRssi(IN	PADAPTER	pAdapter)
 		#endif //CONFIG_BEFORE_LINKED_DIG
 		}
 	}
-	else
-	{
+	else	
+	{		
 		// connect -> disconnect or beforeconnect -> disconnect
 		pDigTable->Rssi_val_min = 0;
 		pDigTable->Dig_Ext_Port_Stage = DIG_EXT_PORT_STAGE_MAX;
 		pDigTable->BackoffVal = DM_DIG_BACKOFF_DEFAULT;
 		pDigTable->CurIGValue = 0x20;
-		pDigTable->PreIGValue = 0;
-		#ifdef CONFIG_BEFORE_LINKED_DIG
-		//printk("%s==> ##2 CurIGI(0x%02x),PreIGValue(0x%02x) \n",__FUNCTION__,pDigTable->CurIGValue,pDigTable->PreIGValue );
-		dm_initial_gain_STA_beforelinked(pAdapter);
-		#endif //CONFIG_BEFORE_LINKED_DIG
-
+		pDigTable->PreIGValue = 0;	
+		#ifdef CONFIG_BEFORE_LINKED_DIG			
+		//printk("%s==> ##2 CurIGI(0x%02x),PreIGValue(0x%02x) \n",__FUNCTION__,pDigTable->CurIGValue,pDigTable->PreIGValue );	
+		dm_initial_gain_STA_beforelinked(pAdapter);			 
+ 		#endif //CONFIG_BEFORE_LINKED_DIG
+		
 
 		DM_Write_DIG(pAdapter);
 	}
@@ -816,14 +816,14 @@ static void dm_CCK_PacketDetectionThresh(
 	}
 	else
 		pDigTable->CurCCKPDState=CCK_PD_STAGE_MAX;
-
+	
 	if(pDigTable->PreCCKPDState != pDigTable->CurCCKPDState)
 	{
 		if((pDigTable->CurCCKPDState == CCK_PD_STAGE_LowRssi)||
 			(pDigTable->CurCCKPDState == CCK_PD_STAGE_MAX))
 		{
 			PHY_SetBBReg(pAdapter, rCCK0_CCA, bMaskByte2, 0x83);
-
+				
 			//PHY_SetBBReg(pAdapter, rCCK0_System, bMaskByte1, 0x40);
 			//if(IS_92C_SERIAL(pHalData->VersionID))
 				//PHY_SetBBReg(pAdapter, rCCK0_FalseAlarmReport , bMaskByte2, 0xd7);
@@ -838,10 +838,10 @@ static void dm_CCK_PacketDetectionThresh(
 
 		pDigTable->PreCCKPDState = pDigTable->CurCCKPDState;
 	}
-
+	
 	//RT_TRACE(	COMP_DIG, DBG_LOUD, ("CCKPDStage=%x\n",pDigTable->CurCCKPDState));
 	//RT_TRACE(	COMP_DIG, DBG_LOUD, ("is92C=%x\n",IS_92C_SERIAL(pHalData->VersionID)));
-
+	
 }
 
 
@@ -870,15 +870,15 @@ static void dm_CCK_PacketDetectionThresh(
 	{
 		pDigTable->CurSTAConnectState = DIG_STA_BEFORE_CONNECT;
 	}
-	else if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
+	else if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) 
 	{
 		pDigTable->CurSTAConnectState = DIG_STA_CONNECT;
-	}
+	}	
 	else
 	{
 		pDigTable->CurSTAConnectState = DIG_STA_DISCONNECT;
 	}
-
+	
 
 	pDigTable->CurMultiSTAConnectState = DIG_MultiSTA_DISCONNECT;
 	if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE) == _TRUE)
@@ -886,25 +886,25 @@ static void dm_CCK_PacketDetectionThresh(
 		if((is_IBSS_empty(pAdapter)==_FAIL) && (pAdapter->stapriv.asoc_sta_count > 2))
 			pDigTable->CurMultiSTAConnectState = DIG_MultiSTA_CONNECT;
 	}
-
+	
 	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
 	{
 		if(pAdapter->stapriv.asoc_sta_count > 2)
-			pDigTable->CurMultiSTAConnectState = DIG_MultiSTA_CONNECT;
+			pDigTable->CurMultiSTAConnectState = DIG_MultiSTA_CONNECT;					
 	}
 
 #ifdef CONFIG_CONCURRENT_MODE
 	if(check_buddy_fwstate(pAdapter, WIFI_AP_STATE) == _TRUE)
 	{
 		PADAPTER pbuddy_adapter = pAdapter->pbuddy_adapter;
-
+		
 		if(pbuddy_adapter->stapriv.asoc_sta_count > 2)
 		{
 			pDigTable->CurSTAConnectState = DIG_STA_CONNECT;
-			pDigTable->CurMultiSTAConnectState = DIG_MultiSTA_CONNECT;
-		}
-	}
-	else if(check_buddy_fwstate(pAdapter, WIFI_STATION_STATE) == _TRUE	&&
+			pDigTable->CurMultiSTAConnectState = DIG_MultiSTA_CONNECT;	
+		}	
+	}	
+	else if(check_buddy_fwstate(pAdapter, WIFI_STATION_STATE) == _TRUE	&& 
 		check_buddy_fwstate(pAdapter, _FW_LINKED) == _TRUE)
 	{
 		pDigTable->CurSTAConnectState = DIG_STA_CONNECT;
@@ -921,7 +921,7 @@ static void dm_CCK_PacketDetectionThresh(
 	dm_CCK_PacketDetectionThresh(pAdapter);
 
 	pDigTable->PreSTAConnectState = pDigTable->CurSTAConnectState;
-
+	
 }
 
 
@@ -936,20 +936,20 @@ static void dm_DIG(
 	pDigTable->PreIGValue = (u8)PHY_QueryBBReg(pAdapter, rOFDM0_XAAGCCore1, bMaskByte0);
 
 	//RTPRINT(FDM, DM_Monitor, ("dm_DIG() ==>\n"));
-
+	
 	if(pdmpriv->bDMInitialGainEnable == _FALSE)
 		return;
-
+	
 	//if(pDigTable->Dig_Enable_Flag == _FALSE)
 	//	return;
-
+	
 	if(!(pdmpriv->DMFlag & DYNAMIC_FUNC_DIG))
 		return;
-
+	
 	//RTPRINT(FDM, DM_Monitor, ("dm_DIG() progress \n"));
 
 	dm_CtrlInitGainByTwoPort(pAdapter);
-
+	
 	//RTPRINT(FDM, DM_Monitor, ("dm_DIG() <==\n"));
 }
 
@@ -959,7 +959,7 @@ static void dm_SavePowerIndex(IN	PADAPTER	Adapter)
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	u32			Power_Index_REG[6] = {0xc90, 0xc91, 0xc92, 0xc98, 0xc99, 0xc9a};
-
+	
 	for(index = 0; index< 6; index++)
 		pdmpriv->PowerIndex_backup[index] = rtw_read8(Adapter, Power_Index_REG[index]);
 }
@@ -970,19 +970,19 @@ static void dm_RestorePowerIndex(IN	PADAPTER	Adapter)
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	u32			Power_Index_REG[6] = {0xc90, 0xc91, 0xc92, 0xc98, 0xc99, 0xc9a};
-
+	
 	for(index = 0; index< 6; index++)
 		rtw_write8(Adapter, Power_Index_REG[index], pdmpriv->PowerIndex_backup[index]);
 }
 
 static void dm_WritePowerIndex(
-		IN	PADAPTER	Adapter,
+		IN	PADAPTER	Adapter, 
 		IN 	u8		Value)
 {
 	u8			index;
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	u32			Power_Index_REG[6] = {0xc90, 0xc91, 0xc92, 0xc98, 0xc99, 0xc9a};
-
+	
 	for(index = 0; index< 6; index++)
 		rtw_write8(Adapter, Power_Index_REG[index], Value);
 }
@@ -1001,8 +1001,8 @@ static void dm_InitDynamicTxPower(IN	PADAPTER	Adapter)
 	{
 		dm_SavePowerIndex(Adapter);
 		pdmpriv->bDynamicTxPowerEnable = _TRUE;
-	}
-	else
+	}		
+	else	
 #else
 		pdmpriv->bDynamicTxPowerEnable = _FALSE;
 #endif
@@ -1031,13 +1031,13 @@ static void dm_DynamicTxPower(IN	PADAPTER	Adapter)
 	}
 
 	// STA not connected and AP not connected
-	if((check_fwstate(pmlmepriv, _FW_LINKED) != _TRUE) &&
+	if((check_fwstate(pmlmepriv, _FW_LINKED) != _TRUE) &&	
 		(pdmpriv->EntryMinUndecoratedSmoothedPWDB == 0))
 	{
 		//RT_TRACE(COMP_HIPWR, DBG_LOUD, ("Not connected to any \n"));
 		pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
 
-		//the LastDTPlvl should reset when disconnect,
+		//the LastDTPlvl should reset when disconnect, 
 		//otherwise the tx power level wouldn't change when disconnect and connect again.
 		// Maddest 20091220.
 		pdmpriv->LastDTPLvl=TxHighPwrLevel_Normal;
@@ -1046,11 +1046,11 @@ static void dm_DynamicTxPower(IN	PADAPTER	Adapter)
 #ifdef CONFIG_INTEL_PROXIM
 	if(Adapter->proximity.proxim_on== _TRUE){
 		struct proximity_priv *prox_priv=Adapter->proximity.proximity_priv;
-	// Intel set fixed tx power
+	// Intel set fixed tx power 
 	printk("\n %s  Adapter->proximity.proxim_on=%d prox_priv->proxim_modeinfo->power_output=%d \n",__FUNCTION__,Adapter->proximity.proxim_on,prox_priv->proxim_modeinfo->power_output);
 	if(prox_priv!=NULL){
 	if(prox_priv->proxim_modeinfo->power_output> 0)
-
+	
 	{
 		switch(prox_priv->proxim_modeinfo->power_output){
 			case 1:
@@ -1077,12 +1077,12 @@ static void dm_DynamicTxPower(IN	PADAPTER	Adapter)
 				pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_100;
 				printk("TxHighPwrLevel_100\n");
 				break;
-		}
+		}		
 	}
 	}
 	}
 	else
-#endif
+#endif		
 {
 	if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)	// Default port
 	{
@@ -1100,11 +1100,11 @@ static void dm_DynamicTxPower(IN	PADAPTER	Adapter)
 		}
 	}
 	else // associated entry pwdb
-	{
+	{	
 		UndecoratedSmoothedPWDB = pdmpriv->EntryMinUndecoratedSmoothedPWDB;
 		//RT_TRACE(COMP_HIPWR, DBG_LOUD, ("AP Ext Port PWDB = 0x%x \n", UndecoratedSmoothedPWDB));
 	}
-
+		
 	if(UndecoratedSmoothedPWDB >= TX_POWER_NEAR_FIELD_THRESH_LVL2)
 	{
 		pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Level2;
@@ -1133,7 +1133,7 @@ static void dm_DynamicTxPower(IN	PADAPTER	Adapter)
 			dm_WritePowerIndex(Adapter, 0x10);
 	}
 	pdmpriv->LastDTPLvl = pdmpriv->DynamicTxHighPowerLvl;
-
+	
 }
 
 
@@ -1149,7 +1149,7 @@ static void dm_DynamicTxPower(IN	PADAPTER	Adapter)
 
 	if (DM_Type == DIG_TYPE_THRESH_HIGH)
 	{
-		pDigTable->RssiHighThresh = DM_Value;
+		pDigTable->RssiHighThresh = DM_Value;		
 	}
 	else if (DM_Type == DIG_TYPE_THRESH_LOW)
 	{
@@ -1158,11 +1158,11 @@ static void dm_DynamicTxPower(IN	PADAPTER	Adapter)
 	else if (DM_Type == DIG_TYPE_ENABLE)
 	{
 		pDigTable->Dig_Enable_Flag = _TRUE;
-	}
+	}	
 	else if (DM_Type == DIG_TYPE_DISABLE)
 	{
 		pDigTable->Dig_Enable_Flag = _FALSE;
-	}
+	}	
 	else if (DM_Type == DIG_TYPE_BACKOFF)
 	{
 		if(DM_Value > 30)
@@ -1206,27 +1206,27 @@ static VOID PWDB_Monitor(
 		struct sta_info *psta;
 		struct sta_priv *pstapriv = &Adapter->stapriv;
 		u8 bcast_addr[ETH_ALEN]= {0xff,0xff,0xff,0xff,0xff,0xff};
-
+	
 		_enter_critical_bh(&pstapriv->sta_hash_lock, &irqL);
 
 		for(i=0; i< NUM_STA; i++)
 		{
 			phead = &(pstapriv->sta_hash[i]);
 			plist = get_next(phead);
-
+		
 			while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
 			{
 				psta = LIST_CONTAINOR(plist, struct sta_info, hash_list);
 
 				plist = get_next(plist);
 
-				if(_rtw_memcmp(psta	->hwaddr, bcast_addr, ETH_ALEN) ||
+				if(_rtw_memcmp(psta	->hwaddr, bcast_addr, ETH_ALEN) || 
 					_rtw_memcmp(psta->hwaddr, myid(&Adapter->eeprompriv), ETH_ALEN))
 					continue;
 
 				if(psta->state & WIFI_ASOC_STATE)
 				{
-
+					
 					if(psta->rssi_stat.UndecoratedSmoothedPWDB < tmpEntryMinPWDB)
 						tmpEntryMinPWDB = psta->rssi_stat.UndecoratedSmoothedPWDB;
 
@@ -1235,15 +1235,15 @@ static VOID PWDB_Monitor(
 
 					PWDB_rssi[sta_cnt++] = (psta->mac_id | (psta->rssi_stat.UndecoratedSmoothedPWDB<<16));
 				}
-
+			
 			}
 
 		}
-
+	
 		_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);
 
 
-
+		
 		if(pHalData->fw_ractrl == _TRUE)
 		{
 			// Report every sta's RSSI to FW
@@ -1259,16 +1259,16 @@ static VOID PWDB_Monitor(
 
 	if(tmpEntryMaxPWDB != 0)	// If associated entry is found
 	{
-		pdmpriv->EntryMaxUndecoratedSmoothedPWDB = tmpEntryMaxPWDB;
+		pdmpriv->EntryMaxUndecoratedSmoothedPWDB = tmpEntryMaxPWDB;		
 	}
 	else
 	{
 		pdmpriv->EntryMaxUndecoratedSmoothedPWDB = 0;
 	}
-
+	
 	if(tmpEntryMinPWDB != 0xff) // If associated entry is found
 	{
-		pdmpriv->EntryMinUndecoratedSmoothedPWDB = tmpEntryMinPWDB;
+		pdmpriv->EntryMinUndecoratedSmoothedPWDB = tmpEntryMinPWDB;		
 	}
 	else
 	{
@@ -1278,13 +1278,13 @@ static VOID PWDB_Monitor(
 
 	if(check_fwstate(&Adapter->mlmepriv, WIFI_STATION_STATE) == _TRUE)
 	{
-
+	
 		if(pHalData->fw_ractrl == _TRUE)
 		{
 			u32 param = (u32)(pdmpriv->UndecoratedSmoothedPWDB<<16);
-
+		
 			param |= 0;//macid=0 for sta mode;
-
+			
 			rtl8192c_set_rssi_cmd(Adapter, (u8*)&param);
 		}
 	}
@@ -1323,7 +1323,7 @@ static VOID PWDB_Monitor(
 	struct mlme_ext_priv	*pmlmeext = &(Adapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 #ifdef CONFIG_BT_COEXIST
-	struct btcoexist_priv	*pbtpriv = &(pHalData->bt_coexist);
+	struct btcoexist_priv	*pbtpriv = &(pHalData->bt_coexist);	
 #endif
 
 
@@ -1342,7 +1342,7 @@ static VOID PWDB_Monitor(
 	{
 		if( (pbtpriv->BT_EDCA[UP_LINK]!=0) ||  (pbtpriv->BT_EDCA[DOWN_LINK]!=0))
 		{
-			bbtchange = _TRUE;
+			bbtchange = _TRUE;		
 		}
 	}
 #endif
@@ -1358,7 +1358,7 @@ static VOID PWDB_Monitor(
 		{
 			if (cur_tx_bytes > (cur_rx_bytes << 2))
 			{ // Uplink TP is present.
-				trafficIndex = UP_LINK;
+				trafficIndex = UP_LINK; 
 			}
 			else
 			{ // Balance TP is present.
@@ -1417,7 +1417,7 @@ static VOID PWDB_Monitor(
 
 			pdmpriv->prv_traffic_idx = trafficIndex;
 		}
-
+		
 		pHalData->bCurrentTurboEDCA = _TRUE;
 	}
 	else
@@ -1458,13 +1458,13 @@ static VOID PWDB_Monitor(
 	BOOLEAN		is2T = IS_92C_SERIAL(pHalData->VersionID);
 
 #if MP_DRIVER == 1
-	PMPT_CONTEXT	pMptCtx = &(Adapter->mppriv.MptCtx);
+	PMPT_CONTEXT	pMptCtx = &(Adapter->mppriv.MptCtx);	
 	u8			*TxPwrLevel = pMptCtx->TxPwrLevel;
 #endif
 	u8			OFDM_min_index = 6, rf; //OFDM BB Swing should be less than +3.0dB, which is required by Arthur
 #if 0
 	u32			DPK_delta_mapping[2][DPK_DELTA_MAPPING_NUM] = {
-					{0x1c, 0x1c, 0x1d, 0x1d, 0x1e,
+					{0x1c, 0x1c, 0x1d, 0x1d, 0x1e, 
 					 0x1f, 0x00, 0x00, 0x01, 0x01,
 					 0x02, 0x02, 0x03},
 					{0x1c, 0x1d, 0x1e, 0x1e, 0x1e,
@@ -1475,8 +1475,8 @@ static VOID PWDB_Monitor(
 	u8			ThermalValue_HP_count = 0;
 	u32			ThermalValue_HP = 0;
 	s32			index_mapping_HP[index_mapping_HP_NUM] = {
-					0,	1,	3,	4,	6,
-					7,	9,	10,	12,	13,
+					0,	1,	3,	4,	6,	
+					7,	9,	10,	12,	13,	
 					15,	16,	18,	19,	21
 					};
 
@@ -1493,7 +1493,7 @@ static VOID PWDB_Monitor(
 
 	//DBG_8192C("===>dm_TXPowerTrackingCallback_ThermalMeter_92C\n");
 
-	ThermalValue = (u8)PHY_QueryRFReg(Adapter, RF_PATH_A, RF_T_METER, 0x1f);	// 0x24: RF Reg[4:0]
+	ThermalValue = (u8)PHY_QueryRFReg(Adapter, RF_PATH_A, RF_T_METER, 0x1f);	// 0x24: RF Reg[4:0]	
 
 	//DBG_8192C("\n\nReadback Thermal Meter = 0x%x pre thermal meter 0x%x EEPROMthermalmeter 0x%x\n",ThermalValue,pdmpriv->ThermalValue,  pHalData->EEPROMThermalMeter);
 
@@ -1503,12 +1503,12 @@ static VOID PWDB_Monitor(
 		rf = 2;
 	else
 		rf = 1;
-
+	
 	if(ThermalValue)
 	{
 //		if(!pHalData->ThermalValue)
 		{
-			//Query OFDM path A default setting
+			//Query OFDM path A default setting 		
 			ele_D = PHY_QueryBBReg(Adapter, rOFDM0_XATxIQImbalance, bMaskDWord)&bMaskOFDM_D;
 			for(i=0; i<OFDM_TABLE_SIZE_92C; i++)	//find the index
 			{
@@ -1520,7 +1520,7 @@ static VOID PWDB_Monitor(
 				}
 			}
 
-			//Query OFDM path B default setting
+			//Query OFDM path B default setting 
 			if(is2T)
 			{
 				ele_D = PHY_QueryBBReg(Adapter, rOFDM0_XBTxIQImbalance, bMaskDWord)&bMaskOFDM_D;
@@ -1555,9 +1555,9 @@ static VOID PWDB_Monitor(
 						CCK_index_old =(u8)i;
 						//DBG_8192C("Initial reg0x%x = 0x%x, CCK_index=0x%x, ch14 %d\n", rCCK0_TxFilter2, TempCCk, CCK_index_old, pdmpriv->bCCKinCH14);
 						break;
-					}
+					}			
 				}
-			}
+			}	
 
 			if(!pdmpriv->ThermalValue)
 			{
@@ -1591,9 +1591,9 @@ static VOID PWDB_Monitor(
 					{
 						ThermalValue_HP += pdmpriv->ThermalValue_HP[i];
 						ThermalValue_HP_count++;
-					}
+					}			
 				}
-
+		
 				if(ThermalValue_HP_count)
 					ThermalValue = (u8)(ThermalValue_HP / ThermalValue_HP_count);
 			}
@@ -1607,12 +1607,12 @@ static VOID PWDB_Monitor(
 			if(pdmpriv->bDoneTxpower)
 				delta_HP = (ThermalValue > pdmpriv->ThermalValue)?(ThermalValue - pdmpriv->ThermalValue):(pdmpriv->ThermalValue - ThermalValue);
 			else
-				delta_HP = ThermalValue > pHalData->EEPROMThermalMeter?(ThermalValue - pHalData->EEPROMThermalMeter):(pHalData->EEPROMThermalMeter - ThermalValue);
+				delta_HP = ThermalValue > pHalData->EEPROMThermalMeter?(ThermalValue - pHalData->EEPROMThermalMeter):(pHalData->EEPROMThermalMeter - ThermalValue);						
 		}
 		else
-#endif
+#endif	
 		{
-			delta_HP = 0;
+			delta_HP = 0;			
 		}
 		delta_LCK = (ThermalValue > pdmpriv->ThermalValue_LCK)?(ThermalValue - pdmpriv->ThermalValue_LCK):(pdmpriv->ThermalValue_LCK - ThermalValue);
 		delta_IQK = (ThermalValue > pdmpriv->ThermalValue_IQK)?(ThermalValue - pdmpriv->ThermalValue_IQK):(pdmpriv->ThermalValue_IQK - ThermalValue);
@@ -1624,48 +1624,48 @@ static VOID PWDB_Monitor(
 			pdmpriv->ThermalValue_LCK = ThermalValue;
 			rtl8192c_PHY_LCCalibrate(Adapter);
 		}
-
+		
 		if((delta > 0 || delta_HP > 0) && pdmpriv->TxPowerTrackControl)
 		{
 #ifdef CONFIG_USB_HCI
 			if(pHalData->BoardType == BOARD_USB_High_PA)
 			{
 				pdmpriv->bDoneTxpower = _TRUE;
-				delta_HP = ThermalValue > pHalData->EEPROMThermalMeter?(ThermalValue - pHalData->EEPROMThermalMeter):(pHalData->EEPROMThermalMeter - ThermalValue);
-
-				if(delta_HP > index_mapping_HP_NUM-1)
+				delta_HP = ThermalValue > pHalData->EEPROMThermalMeter?(ThermalValue - pHalData->EEPROMThermalMeter):(pHalData->EEPROMThermalMeter - ThermalValue);						
+				
+				if(delta_HP > index_mapping_HP_NUM-1)					
 					index_HP = index_mapping_HP[index_mapping_HP_NUM-1];
 				else
 					index_HP = index_mapping_HP[delta_HP];
-
+				
 				if(ThermalValue > pHalData->EEPROMThermalMeter)	//set larger Tx power
 				{
 					for(i = 0; i < rf; i++)
-						OFDM_index[i] = pdmpriv->OFDM_index_HP[i] - index_HP;
-					CCK_index = pdmpriv->CCK_index_HP -index_HP;
+					 	OFDM_index[i] = pdmpriv->OFDM_index_HP[i] - index_HP;
+					CCK_index = pdmpriv->CCK_index_HP -index_HP;						
 				}
 				else
 				{
 					for(i = 0; i < rf; i++)
 						OFDM_index[i] = pdmpriv->OFDM_index_HP[i] + index_HP;
-					CCK_index = pdmpriv->CCK_index_HP + index_HP;
-				}
-
+					CCK_index = pdmpriv->CCK_index_HP + index_HP;						
+				}	
+				
 				delta_HP = (ThermalValue > pdmpriv->ThermalValue)?(ThermalValue - pdmpriv->ThermalValue):(pdmpriv->ThermalValue - ThermalValue);
-
+				
 			}
 			else
 #endif
 			{
 				if(ThermalValue > pdmpriv->ThermalValue)
-				{
+				{ 
 					for(i = 0; i < rf; i++)
-						pdmpriv->OFDM_index[i] -= delta;
+					 	pdmpriv->OFDM_index[i] -= delta;
 					pdmpriv->CCK_index -= delta;
 				}
 				else
 				{
-					for(i = 0; i < rf; i++)
+					for(i = 0; i < rf; i++)			
 						pdmpriv->OFDM_index[i] += delta;
 					pdmpriv->CCK_index += delta;
 				}
@@ -1673,7 +1673,7 @@ static VOID PWDB_Monitor(
 
 			/*if(is2T)
 			{
-				DBG_8192C("temp OFDM_A_index=0x%x, OFDM_B_index=0x%x, CCK_index=0x%x\n",
+				DBG_8192C("temp OFDM_A_index=0x%x, OFDM_B_index=0x%x, CCK_index=0x%x\n", 
 					pdmpriv->OFDM_index[0], pdmpriv->OFDM_index[1], pdmpriv->CCK_index);
 			}
 			else
@@ -1689,15 +1689,15 @@ static VOID PWDB_Monitor(
 			{
 				if(ThermalValue > pHalData->EEPROMThermalMeter)
 				{
-					for(i = 0; i < rf; i++)
+					for(i = 0; i < rf; i++)			
 						OFDM_index[i] = pdmpriv->OFDM_index[i]+1;
-					CCK_index = pdmpriv->CCK_index+1;
+					CCK_index = pdmpriv->CCK_index+1;			
 				}
 				else
 				{
-					for(i = 0; i < rf; i++)
+					for(i = 0; i < rf; i++)			
 						OFDM_index[i] = pdmpriv->OFDM_index[i];
-					CCK_index = pdmpriv->CCK_index;
+					CCK_index = pdmpriv->CCK_index;						
 				}
 
 #if MP_DRIVER == 1
@@ -1708,9 +1708,9 @@ static VOID PWDB_Monitor(
 						if(ThermalValue > pHalData->EEPROMThermalMeter)
 						{
 							if (delta < 5)
-								OFDM_index[i] -= 1;
-							else
-								OFDM_index[i] -= 2;
+								OFDM_index[i] -= 1;					
+							else 
+								OFDM_index[i] -= 2;					
 						}
 						else if(delta > 5 && ThermalValue < pHalData->EEPROMThermalMeter)
 						{
@@ -1720,13 +1720,13 @@ static VOID PWDB_Monitor(
 					else if (TxPwrLevel[i] >= 27 && TxPwrLevel[i] <= 32 && ThermalValue > pHalData->EEPROMThermalMeter)
 					{
 						if (delta < 5)
-							OFDM_index[i] -= 1;
-						else
-							OFDM_index[i] -= 2;
+							OFDM_index[i] -= 1;					
+						else 
+							OFDM_index[i] -= 2;								
 					}
 					else if (TxPwrLevel[i] >= 32 && TxPwrLevel[i] <= 38 && ThermalValue > pHalData->EEPROMThermalMeter && delta > 5)
 					{
-						OFDM_index[i] -= 1;
+						OFDM_index[i] -= 1;								
 					}
 				}
 
@@ -1736,9 +1736,9 @@ static VOID PWDB_Monitor(
 						if(ThermalValue > pHalData->EEPROMThermalMeter)
 						{
 							if (delta < 5)
-								CCK_index -= 1;
-							else
-								CCK_index -= 2;
+								CCK_index -= 1; 				
+							else 
+								CCK_index -= 2; 				
 						}
 						else if(delta > 5 && ThermalValue < pHalData->EEPROMThermalMeter)
 						{
@@ -1748,13 +1748,13 @@ static VOID PWDB_Monitor(
 					else if (TxPwrLevel[i] >= 27 && TxPwrLevel[i] <= 32 && ThermalValue > pHalData->EEPROMThermalMeter)
 					{
 						if (delta < 5)
-							CCK_index -= 1;
-						else
-							CCK_index -= 2;
+							CCK_index -= 1; 				
+						else 
+							CCK_index -= 2; 							
 					}
 					else if (TxPwrLevel[i] >= 32 && TxPwrLevel[i] <= 38 && ThermalValue > pHalData->EEPROMThermalMeter && delta > 5)
 					{
-						CCK_index -= 1;
+						CCK_index -= 1; 							
 					}
 				}
 #endif
@@ -1767,20 +1767,20 @@ static VOID PWDB_Monitor(
 				else if (OFDM_index[i] < OFDM_min_index)
 					OFDM_index[i] = OFDM_min_index;
 			}
-
+						
 			if(CCK_index > (CCK_TABLE_SIZE-1))
 				CCK_index = (CCK_TABLE_SIZE-1);
 			else if (CCK_index < 0)
-				CCK_index = 0;
+				CCK_index = 0;		
 
 			/*if(is2T)
 			{
-				DBG_8192C("new OFDM_A_index=0x%x, OFDM_B_index=0x%x, CCK_index=0x%x\n",
+				DBG_8192C("new OFDM_A_index=0x%x, OFDM_B_index=0x%x, CCK_index=0x%x\n", 
 					OFDM_index[0], OFDM_index[1], CCK_index);
 			}
 			else
 			{
-				DBG_8192C("new OFDM_A_index=0x%x, CCK_index=0x%x\n",
+				DBG_8192C("new OFDM_A_index=0x%x, CCK_index=0x%x\n", 
 					OFDM_index[0], CCK_index);
 			}*/
 		}
@@ -1790,23 +1790,23 @@ static VOID PWDB_Monitor(
 			//Adujst OFDM Ant_A according to IQK result
 			ele_D = (OFDMSwingTable[OFDM_index[0]] & 0xFFC00000)>>22;
 			X = pdmpriv->RegE94;
-			Y = pdmpriv->RegE9C;
+			Y = pdmpriv->RegE9C;		
 
 			if(X != 0)
 			{
 				if ((X & 0x00000200) != 0)
 					X = X | 0xFFFFFC00;
 				ele_A = ((X * ele_D)>>8)&0x000003FF;
-
+					
 				//new element C = element D x Y
 				if ((Y & 0x00000200) != 0)
 					Y = Y | 0xFFFFFC00;
 				ele_C = ((Y * ele_D)>>8)&0x000003FF;
-
+				
 				//wirte new elements A, C, D to regC80 and regC94, element B is always 0
 				value32 = (ele_D<<22)|((ele_C&0x3F)<<16)|ele_A;
 				PHY_SetBBReg(Adapter, rOFDM0_XATxIQImbalance, bMaskDWord, value32);
-
+				
 				value32 = (ele_C&0x000003C0)>>6;
 				PHY_SetBBReg(Adapter, rOFDM0_XCTxAFE, bMaskH4Bits, value32);
 
@@ -1819,12 +1819,12 @@ static VOID PWDB_Monitor(
 			}
 			else
 			{
-				PHY_SetBBReg(Adapter, rOFDM0_XATxIQImbalance, bMaskDWord, OFDMSwingTable[OFDM_index[0]]);
+				PHY_SetBBReg(Adapter, rOFDM0_XATxIQImbalance, bMaskDWord, OFDMSwingTable[OFDM_index[0]]);				
 				PHY_SetBBReg(Adapter, rOFDM0_XCTxAFE, bMaskH4Bits, 0x00);
 				PHY_SetBBReg(Adapter, rOFDM0_ECCAThreshold, BIT31|BIT29, 0x00);
 			}
 
-			//RTPRINT(FINIT, INIT_IQK, ("TxPwrTracking path A: X = 0x%x, Y = 0x%x ele_A = 0x%x ele_C = 0x%x ele_D = 0x%x\n", X, Y, ele_A, ele_C, ele_D));
+			//RTPRINT(FINIT, INIT_IQK, ("TxPwrTracking path A: X = 0x%x, Y = 0x%x ele_A = 0x%x ele_C = 0x%x ele_D = 0x%x\n", X, Y, ele_A, ele_C, ele_D));		
 
 			//Adjust CCK according to IQK result
 			if(!pdmpriv->bCCKinCH14){
@@ -1845,33 +1845,33 @@ static VOID PWDB_Monitor(
 				rtw_write8(Adapter, 0xa26, CCKSwingTable_Ch14[CCK_index][4]);
 				rtw_write8(Adapter, 0xa27, CCKSwingTable_Ch14[CCK_index][5]);
 				rtw_write8(Adapter, 0xa28, CCKSwingTable_Ch14[CCK_index][6]);
-				rtw_write8(Adapter, 0xa29, CCKSwingTable_Ch14[CCK_index][7]);
-			}
+				rtw_write8(Adapter, 0xa29, CCKSwingTable_Ch14[CCK_index][7]);	
+			}		
 
 			if(is2T)
-			{
+			{						
 				ele_D = (OFDMSwingTable[(u8)OFDM_index[1]] & 0xFFC00000)>>22;
-
+				
 				//new element A = element D x X
 				X = pdmpriv->RegEB4;
 				Y = pdmpriv->RegEBC;
-
+				
 				if(X != 0){
 					if ((X & 0x00000200) != 0)	//consider minus
 						X = X | 0xFFFFFC00;
 					ele_A = ((X * ele_D)>>8)&0x000003FF;
-
+					
 					//new element C = element D x Y
 					if ((Y & 0x00000200) != 0)
 						Y = Y | 0xFFFFFC00;
 					ele_C = ((Y * ele_D)>>8)&0x00003FF;
-
+					
 					//wirte new elements A, C, D to regC88 and regC9C, element B is always 0
 					value32=(ele_D<<22)|((ele_C&0x3F)<<16) |ele_A;
 					PHY_SetBBReg(Adapter, rOFDM0_XBTxIQImbalance, bMaskDWord, value32);
 
 					value32 = (ele_C&0x000003C0)>>6;
-					PHY_SetBBReg(Adapter, rOFDM0_XDTxAFE, bMaskH4Bits, value32);
+					PHY_SetBBReg(Adapter, rOFDM0_XDTxAFE, bMaskH4Bits, value32);	
 
 					value32 = ((X * ele_D)>>7)&0x01;
 					PHY_SetBBReg(Adapter, rOFDM0_ECCAThreshold, BIT27, value32);
@@ -1881,7 +1881,7 @@ static VOID PWDB_Monitor(
 
 				}
 				else{
-					PHY_SetBBReg(Adapter, rOFDM0_XBTxIQImbalance, bMaskDWord, OFDMSwingTable[OFDM_index[1]]);
+					PHY_SetBBReg(Adapter, rOFDM0_XBTxIQImbalance, bMaskDWord, OFDMSwingTable[OFDM_index[1]]);										
 					PHY_SetBBReg(Adapter, rOFDM0_XDTxAFE, bMaskH4Bits, 0x00);
 					PHY_SetBBReg(Adapter, rOFDM0_ECCAThreshold, BIT27|BIT25, 0x00);
 				}
@@ -1914,7 +1914,7 @@ static VOID PWDB_Monitor(
 	}
 
 	//DBG_8192C("<===dm_TXPowerTrackingCallback_ThermalMeter_92C\n");
-
+	
 	pdmpriv->TXPowercount = 0;
 
 }
@@ -1923,7 +1923,7 @@ static VOID PWDB_Monitor(
 static	VOID
 dm_InitializeTXPowerTracking_ThermalMeter(
 	IN	PADAPTER		Adapter)
-{
+{	
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 
@@ -1931,11 +1931,11 @@ static VOID PWDB_Monitor(
 	pdmpriv->TXPowercount = 0;
 	pdmpriv->bTXPowerTrackingInit = _FALSE;
 	pdmpriv->ThermalValue = 0;
-
+	
 #if	(MP_DRIVER != 1)	//for mp driver, turn off txpwrtracking as default
 	pdmpriv->TxPowerTrackControl = _TRUE;
 #endif
-
+	
 	MSG_8192C("pdmpriv->TxPowerTrackControl = %d\n", pdmpriv->TxPowerTrackControl);
 }
 
@@ -1944,8 +1944,8 @@ static VOID PWDB_Monitor(
 DM_InitializeTXPowerTracking(
 	IN	PADAPTER		Adapter)
 {
-	dm_InitializeTXPowerTracking_ThermalMeter(Adapter);
-}
+	dm_InitializeTXPowerTracking_ThermalMeter(Adapter);	
+}	
 
 //
 //	Description:
@@ -1961,14 +1961,14 @@ static VOID PWDB_Monitor(
 static VOID
 DM_TXPowerTracking92CDirectCall(
             IN	PADAPTER		Adapter)
-{
+{	
 	dm_TXPowerTrackingCallback_ThermalMeter_92C(Adapter);
 }
 
 static VOID
 dm_CheckTXPowerTracking_ThermalMeter(
 	IN	PADAPTER		Adapter)
-{
+{	
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	//u1Byte					TxPowerCheckCnt = 5;	//10 sec
@@ -1984,10 +1984,10 @@ static VOID PWDB_Monitor(
 		//pHalData->TxPowerCheckCnt++;	//cosa add for debug
 		PHY_SetRFReg(Adapter, RF_PATH_A, RF_T_METER, bRFRegOffsetMask, 0x60);
 		//DBG_8192C("Trigger 92C Thermal Meter!!\n");
-
+		
 		pdmpriv->TM_Trigger = 1;
 		return;
-
+		
 	}
 	else
 	{
@@ -2012,9 +2012,9 @@ static BOOLEAN BT_BTStateChange(PADAPTER Adapter)
 	PHAL_DATA_TYPE		pHalData = GET_HAL_DATA(Adapter);
 	struct btcoexist_priv	*pbtpriv = &(pHalData->bt_coexist);
 	struct registry_priv	*registry_par = &Adapter->registrypriv;
-
+	
 	struct mlme_priv *pmlmepriv = &(Adapter->mlmepriv);
-
+	
 	u32 		Polling, Ratio_Tx, Ratio_PRI;
 	u32 			BT_Tx, BT_PRI;
 	u8			BT_State;
@@ -2022,9 +2022,9 @@ static BOOLEAN BT_BTStateChange(PADAPTER Adapter)
 	u8			CurServiceType;
 	static u8		LastServiceType = BT_Idle;
 
-	if(check_fwstate(pmlmepriv, _FW_LINKED) == _FALSE)
+	if(check_fwstate(pmlmepriv, _FW_LINKED) == _FALSE)	
 		return _FALSE;
-
+	
 	BT_State = rtw_read8(Adapter, 0x4fd);
 /*
 	temp = PlatformEFIORead4Byte(Adapter, 0x488);
@@ -2032,18 +2032,18 @@ static BOOLEAN BT_BTStateChange(PADAPTER Adapter)
 	BT_PRI = (u2Byte)(((temp>>8)&0xff00)+((temp>>24)&0xff));
 
 	temp = PlatformEFIORead4Byte(Adapter, 0x48c);
-	Polling = ((temp<<8)&0xff000000) + ((temp>>8)&0x00ff0000) +
+	Polling = ((temp<<8)&0xff000000) + ((temp>>8)&0x00ff0000) + 
 			((temp<<8)&0x0000ff00) + ((temp>>8)&0x000000ff);
-
+	
 */
 	BT_Tx = rtw_read32(Adapter, 0x488);
-
+	
 	DBG_8192C("Ratio 0x488  =%x\n", BT_Tx);
 	BT_Tx =BT_Tx & 0x00ffffff;
 	//RTPRINT(FBT, BT_TRACE, ("Ratio BT_Tx  =%x\n", BT_Tx));
 
 	BT_PRI = rtw_read32(Adapter, 0x48c);
-
+	
 	DBG_8192C("Ratio 0x48c  =%x\n", BT_PRI);
 	BT_PRI =BT_PRI & 0x00ffffff;
 	//RTPRINT(FBT, BT_TRACE, ("Ratio BT_PRI  =%x\n", BT_PRI));
@@ -2061,22 +2061,22 @@ static BOOLEAN BT_BTStateChange(PADAPTER Adapter)
 	if(BT_State != pbtpriv->BT_CUR_State)
 	{
 		pbtpriv->BT_CUR_State = BT_State;
-
+	
 		if(registry_par->bt_sco == 3)
 		{
 			ServiceTypeCnt = 0;
-
+		
 			pbtpriv->BT_Service = BT_Idle;
 
 			DBG_8192C("BT_%s\n", BT_State?"ON":"OFF");
 
-			BT_State = BT_State |
+			BT_State = BT_State | 
 					((pbtpriv->BT_Ant_isolation==1)?0:BIT1) |BIT2;
 
 			rtw_write8(Adapter, 0x4fd, BT_State);
 			DBG_8192C("BT set 0x4fd to %x\n", BT_State);
 		}
-
+		
 		return _TRUE;
 	}
 	DBG_8192C("bRegBT_Sco =  %d\n",registry_par->bt_sco);
@@ -2086,11 +2086,11 @@ static BOOLEAN BT_BTStateChange(PADAPTER Adapter)
 
 	pbtpriv->Ratio_Tx=Ratio_Tx;
 	pbtpriv->Ratio_PRI=Ratio_PRI;
-
+	
 	DBG_8192C("Ratio_Tx=%d\n", Ratio_Tx);
 	DBG_8192C("Ratio_PRI=%d\n", Ratio_PRI);
 
-
+	
 	if(BT_State && registry_par->bt_sco==3)
 	{
 		DBG_8192C("bt_sco  ==3 Follow Counter\n");
@@ -2107,13 +2107,13 @@ static BOOLEAN BT_BTStateChange(PADAPTER Adapter)
 
 			pHalData->bt_coexist.Ratio_Tx=Ratio_Tx;
 			pHalData->bt_coexist.Ratio_PRI=Ratio_PRI;
-
+			
 			RTPRINT(FBT, BT_TRACE, ("Ratio_Tx=%d\n", Ratio_Tx));
 			RTPRINT(FBT, BT_TRACE, ("Ratio_PRI=%d\n", Ratio_PRI));
 
-		*/
-			if((Ratio_Tx < 30)  && (Ratio_PRI < 30))
-				CurServiceType = BT_Idle;
+		*/	
+			if((Ratio_Tx < 30)  && (Ratio_PRI < 30)) 
+			  	CurServiceType = BT_Idle;
 			else if((Ratio_PRI > 110) && (Ratio_PRI < 250))
 				CurServiceType = BT_SCO;
 			else if((Ratio_Tx >= 200)&&(Ratio_PRI >= 200))
@@ -2153,7 +2153,7 @@ static BOOLEAN BT_BTStateChange(PADAPTER Adapter)
 		if(ServiceTypeCnt==2)
 		{
 			pbtpriv->BT_Service = LastServiceType;
-			BT_State = BT_State |
+			BT_State = BT_State | 
 					((pbtpriv->BT_Ant_isolation==1)?0:BIT1) |
 					//((pbtpriv->BT_Service==BT_SCO)?0:BIT2);
 					((pbtpriv->BT_Service!=BT_Idle)?0:BIT2);
@@ -2185,23 +2185,23 @@ static BOOLEAN BT_BTStateChange(PADAPTER Adapter)
 			{
 				DBG_8192C("BT TYPE Set to ==> BT_OtherBusy\n");
 			}
-
+				
 			//Add interrupt migration when bt is not in idel state (no traffic).
 			//suggestion by Victor.
 			if(pbtpriv->BT_Service!=BT_Idle)//EDCA_VI_PARAM modify
 			{
-
+			
 				rtw_write16(Adapter, 0x504, 0x0ccc);
 				rtw_write8(Adapter, 0x506, 0x54);
 				rtw_write8(Adapter, 0x507, 0x54);
-
+			
 			}
 			else
 			{
 				rtw_write8(Adapter, 0x506, 0x00);
-				rtw_write8(Adapter, 0x507, 0x00);
+				rtw_write8(Adapter, 0x507, 0x00);			
 			}
-
+				
 			rtw_write8(Adapter, 0x4fd, BT_State);
 			DBG_8192C("BT_SCO set 0x4fd to %x\n", BT_State);
 			return _TRUE;
@@ -2222,7 +2222,7 @@ static BOOLEAN BT_BTStateChange(PADAPTER Adapter)
 	static BOOLEAN	bMediaConnect = _FALSE;
 
 	//if(!pMgntInfo->bMediaConnect || MgntRoamingInProgress(pMgntInfo))
-	if(check_fwstate(pmlmepriv, _FW_LINKED) == _FALSE)
+	if(check_fwstate(pmlmepriv, _FW_LINKED) == _FALSE)	
 	{
 		bMediaConnect = _FALSE;
 	}
@@ -2244,16 +2244,16 @@ static BOOLEAN BT_BTStateChange(PADAPTER Adapter)
 #define BT_RSSI_STATE_SPECIAL_LOW	BIT2
 #define BT_RSSI_STATE_BG_EDCA_LOW	BIT3
 
-static s32 GET_UNDECORATED_AVERAGE_RSSI(PADAPTER	Adapter)
+static s32 GET_UNDECORATED_AVERAGE_RSSI(PADAPTER	Adapter)	
 {
 	PHAL_DATA_TYPE	pHalData = GET_HAL_DATA(Adapter);
 	struct mlme_priv	*pmlmepriv = &(Adapter->mlmepriv);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	s32 	average_rssi;
-
+	
 	if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE|WIFI_AP_STATE))
-	{
-		average_rssi = 	pdmpriv->EntryMinUndecoratedSmoothedPWDB;
+	{	
+		average_rssi = 	pdmpriv->EntryMinUndecoratedSmoothedPWDB;	
 	}
 	else
 	{
@@ -2278,7 +2278,7 @@ static u8 BT_RssiStateChange(
 
 
 	//if(pMgntInfo->bMediaConnect)	// Default port
-	if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
+	if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)	
 	{
 		UndecoratedSmoothedPWDB = GET_UNDECORATED_AVERAGE_RSSI(Adapter);
 	}
@@ -2313,7 +2313,7 @@ static u8 BT_RssiStateChange(
 		CurrBtRssiState |=  BT_RSSI_STATE_BG_EDCA_LOW;
 	else
 		CurrBtRssiState &= (~BT_RSSI_STATE_BG_EDCA_LOW);
-
+	
 	if(CurrBtRssiState != pbtpriv->BtRssiState)
 	{
 		pbtpriv->BtRssiState = CurrBtRssiState;
@@ -2336,7 +2336,7 @@ static void dm_BTCoexist(PADAPTER Adapter )
 	struct btcoexist_priv		*pbtpriv = &(pHalData->bt_coexist);
 	//PMGNT_INFO				pMgntInfo = &Adapter->MgntInfo;
 	//PRT_HIGH_THROUGHPUT		pHTInfo = GET_HT_INFO(pMgntInfo);
-
+	
 	//PRX_TS_RECORD	pRxTs = NULL;
 	u8			BT_gpio_mux;
 
@@ -2345,13 +2345,13 @@ static void dm_BTCoexist(PADAPTER Adapter )
 	if(pbtpriv->bCOBT == _FALSE)		return;
 
 	if(!( pdmpriv->DMFlag & DYNAMIC_FUNC_BT)) return;
-
+	
 	if( (pbtpriv->BT_Coexist) &&(pbtpriv->BT_CoexistType == BT_CSR_BC4) && (check_fwstate(pmlmepriv, WIFI_AP_STATE) == _FALSE)	)
 	{
 		bWifiConnectChange = BT_WifiConnectChange(Adapter);
 		bBtStateChange	= BT_BTStateChange(Adapter);
 		bRssiStateChange 	= BT_RssiStateChange(Adapter);
-
+		
 		DBG_8192C("bWifiConnectChange %d, bBtStateChange  %d,bRssiStateChange  %d\n",
 			bWifiConnectChange,bBtStateChange,bRssiStateChange);
 
@@ -2363,18 +2363,18 @@ static void dm_BTCoexist(PADAPTER Adapter )
 		{
 			if(pbtpriv->BT_CUR_State)
 			{
-
+				
 				// Do not allow receiving A-MPDU aggregation.
 				if(pbtpriv->BT_Ampdu)// 0:Disable BT control A-MPDU, 1:Enable BT control A-MPDU.
 				{
-
-					if(pmlmeinfo->assoc_AP_vendor == ciscoAP)
+			
+					if(pmlmeinfo->assoc_AP_vendor == ciscoAP)	
 					{
 						if(pbtpriv->BT_Service!=BT_Idle)
 						{
 							if(pmlmeinfo->bAcceptAddbaReq)
 							{
-								DBG_8192C("BT_Disallow AMPDU \n");
+								DBG_8192C("BT_Disallow AMPDU \n");	
 								pmlmeinfo->bAcceptAddbaReq = _FALSE;
 								send_delba(Adapter,0, get_my_bssid(&(pmlmeinfo->network)));
 							}
@@ -2383,7 +2383,7 @@ static void dm_BTCoexist(PADAPTER Adapter )
 						{
 							if(!pmlmeinfo->bAcceptAddbaReq)
 							{
-								DBG_8192C("BT_Allow AMPDU  RSSI >=40\n");
+								DBG_8192C("BT_Allow AMPDU  RSSI >=40\n");	
 								pmlmeinfo->bAcceptAddbaReq = _TRUE;
 							}
 						}
@@ -2392,20 +2392,20 @@ static void dm_BTCoexist(PADAPTER Adapter )
 					{
 						if(!pmlmeinfo->bAcceptAddbaReq)
 						{
-							DBG_8192C("BT_Allow AMPDU BT Idle\n");
+							DBG_8192C("BT_Allow AMPDU BT Idle\n");	
 							pmlmeinfo->bAcceptAddbaReq = _TRUE;
 						}
 					}
 				}
-
+				
 #if 0
 				else if((pHalData->bt_coexist.BT_Service==BT_SCO) || (pHalData->bt_coexist.BT_Service==BT_Busy))
-				{
+				{				
 					if(pHalData->bt_coexist.BtRssiState & BT_RSSI_STATE_AMDPU_OFF)
 					{
 						if(pMgntInfo->bBT_Ampdu && pHTInfo->bAcceptAddbaReq)
 						{
-							RTPRINT(FBT, BT_TRACE, ("BT_Disallow AMPDU RSSI <=32\n"));
+							RTPRINT(FBT, BT_TRACE, ("BT_Disallow AMPDU RSSI <=32\n"));	
 							pHTInfo->bAcceptAddbaReq = FALSE;
 							if(GetTs(Adapter, (PTS_COMMON_INFO*)(&pRxTs), pMgntInfo->Bssid, 0, RX_DIR, FALSE))
 								TsInitDelBA(Adapter, (PTS_COMMON_INFO)pRxTs, RX_DIR);
@@ -2415,7 +2415,7 @@ static void dm_BTCoexist(PADAPTER Adapter )
 					{
 						if(pMgntInfo->bBT_Ampdu && !pHTInfo->bAcceptAddbaReq)
 						{
-							RTPRINT(FBT, BT_TRACE, ("BT_Allow AMPDU  RSSI >=40\n"));
+							RTPRINT(FBT, BT_TRACE, ("BT_Allow AMPDU  RSSI >=40\n"));	
 							pHTInfo->bAcceptAddbaReq = TRUE;
 						}
 					}
@@ -2424,14 +2424,14 @@ static void dm_BTCoexist(PADAPTER Adapter )
 				{
 					if(pMgntInfo->bBT_Ampdu && !pHTInfo->bAcceptAddbaReq)
 					{
-						RTPRINT(FBT, BT_TRACE, ("BT_Allow AMPDU BT not in SCO or BUSY\n"));
+						RTPRINT(FBT, BT_TRACE, ("BT_Allow AMPDU BT not in SCO or BUSY\n"));	
 						pHTInfo->bAcceptAddbaReq = TRUE;
 					}
 				}
 #endif
 
 				if(pbtpriv->BT_Ant_isolation)
-				{
+				{			
 					DBG_8192C("BT_IsolationLow\n");
 
 // 20100427 Joseph: Do not adjust Rate adaptive for BT coexist suggested by SD3.
@@ -2454,7 +2454,7 @@ static void dm_BTCoexist(PADAPTER Adapter )
 					else
 					{
 						Adapter->HalFunc.UpdateHalRATRTableHandler(
-									Adapter,
+									Adapter, 
 									&pMgntInfo->dot11OperationalRateSet,
 									pMgntInfo->dot11HTOperationalRateSet,NULL);
 					}
@@ -2468,7 +2468,7 @@ static void dm_BTCoexist(PADAPTER Adapter )
 							pbtpriv->BT_Service==BT_OtherAction)
 						{
 							DBG_8192C("BT_Turn ON Coexist\n");
-							rtw_write8(Adapter, REG_GPIO_MUXCFG, 0xa0);
+							rtw_write8(Adapter, REG_GPIO_MUXCFG, 0xa0);	
 						}
 						else
 						{
@@ -2482,12 +2482,12 @@ static void dm_BTCoexist(PADAPTER Adapter )
 									(pbtpriv->BtRssiState & BT_RSSI_STATE_SPECIAL_LOW))
 							{
 								DBG_8192C("BT_Turn ON Coexist\n");
-								rtw_write8(Adapter, REG_GPIO_MUXCFG, 0xa0);
+								rtw_write8(Adapter, REG_GPIO_MUXCFG, 0xa0);	
 							}
 							else if(pbtpriv->BT_Service==BT_PAN)
 							{
 								DBG_8192C("BT_Turn ON Coexist\n");
-								rtw_write8(Adapter, REG_GPIO_MUXCFG, 0x00);
+								rtw_write8(Adapter, REG_GPIO_MUXCFG, 0x00);	
 							}
 							else
 							{
@@ -2507,18 +2507,18 @@ static void dm_BTCoexist(PADAPTER Adapter )
 						if(pbtpriv->BT_Service==BT_PAN)
 						{
 							DBG_8192C("BT_Turn ON Coexist(Reg0x44 = 0x10100)\n");
-							rtw_write32(Adapter, REG_GPIO_PIN_CTRL, 0x10100);
+							rtw_write32(Adapter, REG_GPIO_PIN_CTRL, 0x10100);	
 						}
 						else
 						{
 							DBG_8192C("BT_Turn OFF Coexist(Reg0x44 = 0x0)\n");
-							rtw_write32(Adapter, REG_GPIO_PIN_CTRL, 0x0);
+							rtw_write32(Adapter, REG_GPIO_PIN_CTRL, 0x0);	
 						}
 					}
 					else
 					{
 						DBG_8192C("BT: There is no Wifi traffic!! Turn off Coexist(Reg0x44 = 0x0)\n");
-						rtw_write32(Adapter, REG_GPIO_PIN_CTRL, 0x0);
+						rtw_write32(Adapter, REG_GPIO_PIN_CTRL, 0x0);	
 					}
 
 					// 20100430 Joseph: Integrate the BT coexistence EDCA tuning here.
@@ -2529,8 +2529,8 @@ static void dm_BTCoexist(PADAPTER Adapter )
 							//pbtpriv->BtEdcaUL = 0x5ea72b;
 							//pbtpriv->BtEdcaDL = 0x5ea72b;
 							pbtpriv->BT_EDCA[UP_LINK] = 0x5ea72b;
-							pbtpriv->BT_EDCA[DOWN_LINK] = 0x5ea72b;
-
+							pbtpriv->BT_EDCA[DOWN_LINK] = 0x5ea72b;							
+							
 							DBG_8192C("BT in BT_OtherBusy state Tx (%d) >350 parameter(0x%x) = 0x%x\n", pbtpriv->Ratio_Tx ,REG_EDCA_BE_PARAM, 0x5ea72b);
 						}
 						else if(pbtpriv->BT_Service==BT_Busy)
@@ -2539,9 +2539,9 @@ static void dm_BTCoexist(PADAPTER Adapter )
 							//pbtpriv->BtEdcaDL = 0x5eb82f;
 
 							pbtpriv->BT_EDCA[UP_LINK] = 0x5eb82f;
-							pbtpriv->BT_EDCA[DOWN_LINK] = 0x5eb82f;
-
-							DBG_8192C("BT in BT_Busy state parameter(0x%x) = 0x%x\n", REG_EDCA_BE_PARAM, 0x5eb82f);
+							pbtpriv->BT_EDCA[DOWN_LINK] = 0x5eb82f;							
+							
+							DBG_8192C("BT in BT_Busy state parameter(0x%x) = 0x%x\n", REG_EDCA_BE_PARAM, 0x5eb82f);		
 						}
 						else if(pbtpriv->BT_Service==BT_SCO)
 						{
@@ -2550,7 +2550,7 @@ static void dm_BTCoexist(PADAPTER Adapter )
 								//pbtpriv->BtEdcaUL = 0x5ea72f;
 								//pbtpriv->BtEdcaDL = 0x5ea72f;
 								pbtpriv->BT_EDCA[UP_LINK] = 0x5ea72f;
-								pbtpriv->BT_EDCA[DOWN_LINK] = 0x5ea72f;
+								pbtpriv->BT_EDCA[DOWN_LINK] = 0x5ea72f;							
 								DBG_8192C("BT in BT_SCO state Tx (%d) >160 parameter(0x%x) = 0x%x\n",pbtpriv->Ratio_Tx, REG_EDCA_BE_PARAM, 0x5ea72f);
 							}
 							else
@@ -2559,10 +2559,10 @@ static void dm_BTCoexist(PADAPTER Adapter )
 								//pbtpriv->BtEdcaDL = 0x5ea42b;
 
 								pbtpriv->BT_EDCA[UP_LINK] = 0x5ea32b;
-								pbtpriv->BT_EDCA[DOWN_LINK] = 0x5ea42b;
-
+								pbtpriv->BT_EDCA[DOWN_LINK] = 0x5ea42b;						
+								
 								DBG_8192C("BT in BT_SCO state Tx (%d) <160 parameter(0x%x) = 0x%x\n", pbtpriv->Ratio_Tx,REG_EDCA_BE_PARAM, 0x5ea32f);
-							}
+							}									
 						}
 						else
 						{
@@ -2571,7 +2571,7 @@ static void dm_BTCoexist(PADAPTER Adapter )
 							//pbtpriv->BtEdcaDL = 0;
 
 							pbtpriv->BT_EDCA[UP_LINK] = 0;
-							pbtpriv->BT_EDCA[DOWN_LINK] = 0;
+							pbtpriv->BT_EDCA[DOWN_LINK] = 0;							
 							DBG_8192C("BT in  State  %d  and parameter(0x%x) use original setting.\n",pbtpriv->BT_Service, REG_EDCA_BE_PARAM);
 						}
 
@@ -2583,9 +2583,9 @@ static void dm_BTCoexist(PADAPTER Adapter )
 							//pbtpriv->BtEdcaDL = 0x5eb82b;
 
 							pbtpriv->BT_EDCA[UP_LINK] = 0x5eb82b;
-							pbtpriv->BT_EDCA[DOWN_LINK] = 0x5eb82b;
-
-							DBG_8192C("BT set parameter(0x%x) = 0x%x\n", REG_EDCA_BE_PARAM, 0x5eb82b);
+							pbtpriv->BT_EDCA[DOWN_LINK] = 0x5eb82b;							
+							
+							DBG_8192C("BT set parameter(0x%x) = 0x%x\n", REG_EDCA_BE_PARAM, 0x5eb82b);		
 						}
 					}
 					else
@@ -2595,7 +2595,7 @@ static void dm_BTCoexist(PADAPTER Adapter )
 						//pbtpriv->BtEdcaDL = 0;
 
 						pbtpriv->BT_EDCA[UP_LINK] = 0;
-						pbtpriv->BT_EDCA[DOWN_LINK] = 0;
+						pbtpriv->BT_EDCA[DOWN_LINK] = 0;					
 					}
 
 					// 20100415 Joseph: Set RF register 0x1E and 0x1F for BT coexist suggested by Yaying.
@@ -2612,23 +2612,23 @@ static void dm_BTCoexist(PADAPTER Adapter )
 						PHY_SetRFReg(Adapter, PathA, 0x1e, 0xf0, pbtpriv->BtRfRegOrigin1E);
 						//RTPRINT(FBT, BT_TRACE, ("BT Set RfReg0x1F[7:4] = 0x%x \n", pHalData->bt_coexist.BtRfRegOrigin1F));
 						//PHY_SetRFReg(Adapter, PathA, 0x1f, 0xf0, pHalData->bt_coexist.BtRfRegOrigin1F);
-					}
+					}	
 				}
 				else
 				{
 					DBG_8192C("BT_IsolationHigh\n");
 					// Do nothing.
-				}
+				}			
 			}
 			else
 			{
-
+			
 				if(pbtpriv->BT_Ampdu && !pmlmeinfo->bAcceptAddbaReq)
 				{
-					DBG_8192C("BT_Allow AMPDU bt is off\n");
+					DBG_8192C("BT_Allow AMPDU bt is off\n");	
 					pmlmeinfo->bAcceptAddbaReq = _TRUE;
 				}
-
+			
 				DBG_8192C("BT_Turn OFF Coexist bt is off \n");
 				rtw_write8(Adapter, REG_GPIO_MUXCFG, 0x00);
 
@@ -2641,8 +2641,8 @@ static void dm_BTCoexist(PADAPTER Adapter )
 				//pbtpriv->BtEdcaUL = 0;
 				//pbtpriv->BtEdcaDL = 0;
 				pbtpriv->BT_EDCA[UP_LINK] = 0;
-				pbtpriv->BT_EDCA[DOWN_LINK] = 0;
-
+				pbtpriv->BT_EDCA[DOWN_LINK] = 0;				
+				
 
 // 20100427 Joseph: Do not adjust Rate adaptive for BT coexist suggested by SD3.
 #if 0
@@ -2664,7 +2664,7 @@ static void dm_BTCoexist(PADAPTER Adapter )
 				else
 				{
 					Adapter->HalFunc.UpdateHalRATRTableHandler(
-								Adapter,
+								Adapter, 
 								&pMgntInfo->dot11OperationalRateSet,
 								pMgntInfo->dot11HTOperationalRateSet,NULL);
 				}
@@ -2680,7 +2680,7 @@ static void dm_InitBtCoexistDM(	PADAPTER	Adapter)
 	struct btcoexist_priv	*pbtpriv = &(pHalData->bt_coexist);
 
 	if( !pbtpriv->BT_Coexist ) return;
-
+	
 	pbtpriv->BtRfRegOrigin1E = (u8)PHY_QueryRFReg(Adapter, PathA, 0x1e, 0xf0);
 	pbtpriv->BtRfRegOrigin1F = (u8)PHY_QueryRFReg(Adapter, PathA, 0x1f, 0xf0);
 }
@@ -2691,11 +2691,11 @@ void rtl8192c_set_dm_bt_coexist(_adapter *padapter, u8 bStart)
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct btcoexist_priv	*pbtpriv = &(pHalData->bt_coexist);
-
+	
 	pbtpriv->bCOBT = bStart;
 	send_delba(padapter,0, get_my_bssid(&(pmlmeinfo->network)));
 	send_delba(padapter,1, get_my_bssid(&(pmlmeinfo->network)));
-
+	
 }
 
 void rtl8192c_issue_delete_ba(_adapter *padapter, u8 dir)
@@ -2716,7 +2716,7 @@ void rtl8192c_issue_delete_ba(_adapter *padapter, u8 dir)
 {
 	PHAL_DATA_TYPE	pHalData = GET_HAL_DATA(Adapter);
 	PMGNT_INFO		pMgntInfo = &Adapter->MgntInfo;
-
+	
 	u4Byte 			temp, Polling, Ratio_Tx, Ratio_PRI;
 	u4Byte 			BT_Tx, BT_PRI;
 	u1Byte			BT_State;
@@ -2726,7 +2726,7 @@ void rtl8192c_issue_delete_ba(_adapter *padapter, u8 dir)
 
 	if(!pMgntInfo->bMediaConnect)
 		return FALSE;
-
+	
 	BT_State = PlatformEFIORead1Byte(Adapter, 0x4fd);
 /*
 	temp = PlatformEFIORead4Byte(Adapter, 0x488);
@@ -2734,18 +2734,18 @@ void rtl8192c_issue_delete_ba(_adapter *padapter, u8 dir)
 	BT_PRI = (u2Byte)(((temp>>8)&0xff00)+((temp>>24)&0xff));
 
 	temp = PlatformEFIORead4Byte(Adapter, 0x48c);
-	Polling = ((temp<<8)&0xff000000) + ((temp>>8)&0x00ff0000) +
+	Polling = ((temp<<8)&0xff000000) + ((temp>>8)&0x00ff0000) + 
 			((temp<<8)&0x0000ff00) + ((temp>>8)&0x000000ff);
-
+	
 */
 	BT_Tx = PlatformEFIORead4Byte(Adapter, 0x488);
-
+	
 	RTPRINT(FBT, BT_TRACE, ("Ratio 0x488  =%x\n", BT_Tx));
 	BT_Tx =BT_Tx & 0x00ffffff;
 	//RTPRINT(FBT, BT_TRACE, ("Ratio BT_Tx  =%x\n", BT_Tx));
 
 	BT_PRI = PlatformEFIORead4Byte(Adapter, 0x48c);
-
+	
 	RTPRINT(FBT, BT_TRACE, ("Ratio Ratio 0x48c  =%x\n", BT_PRI));
 	BT_PRI =BT_PRI & 0x00ffffff;
 	//RTPRINT(FBT, BT_TRACE, ("Ratio BT_PRI  =%x\n", BT_PRI));
@@ -2763,22 +2763,22 @@ void rtl8192c_issue_delete_ba(_adapter *padapter, u8 dir)
 	if(BT_State != pHalData->bt_coexist.BT_CUR_State)
 	{
 		pHalData->bt_coexist.BT_CUR_State = BT_State;
-
+	
 		if(pMgntInfo->bRegBT_Sco == 3)
 		{
 			ServiceTypeCnt = 0;
-
+		
 			pHalData->bt_coexist.BT_Service = BT_Idle;
 
 			RTPRINT(FBT, BT_TRACE, ("BT_%s\n", BT_State?"ON":"OFF"));
 
-			BT_State = BT_State |
+			BT_State = BT_State | 
 					((pHalData->bt_coexist.BT_Ant_isolation==1)?0:BIT1) |BIT2;
 
 			PlatformEFIOWrite1Byte(Adapter, 0x4fd, BT_State);
 			RTPRINT(FBT, BT_TRACE, ("BT set 0x4fd to %x\n", BT_State));
 		}
-
+		
 		return TRUE;
 	}
 	RTPRINT(FBT, BT_TRACE, ("bRegBT_Sco   %d\n", pMgntInfo->bRegBT_Sco));
@@ -2788,11 +2788,11 @@ void rtl8192c_issue_delete_ba(_adapter *padapter, u8 dir)
 
 	pHalData->bt_coexist.Ratio_Tx=Ratio_Tx;
 	pHalData->bt_coexist.Ratio_PRI=Ratio_PRI;
-
+	
 	RTPRINT(FBT, BT_TRACE, ("Ratio_Tx=%d\n", Ratio_Tx));
 	RTPRINT(FBT, BT_TRACE, ("Ratio_PRI=%d\n", Ratio_PRI));
 
-
+	
 	if(BT_State && pMgntInfo->bRegBT_Sco==3)
 	{
 		RTPRINT(FBT, BT_TRACE, ("bRegBT_Sco  ==3 Follow Counter\n"));
@@ -2809,13 +2809,13 @@ void rtl8192c_issue_delete_ba(_adapter *padapter, u8 dir)
 
 			pHalData->bt_coexist.Ratio_Tx=Ratio_Tx;
 			pHalData->bt_coexist.Ratio_PRI=Ratio_PRI;
-
+			
 			RTPRINT(FBT, BT_TRACE, ("Ratio_Tx=%d\n", Ratio_Tx));
 			RTPRINT(FBT, BT_TRACE, ("Ratio_PRI=%d\n", Ratio_PRI));
 
-		*/
-			if((Ratio_Tx <= 50)  && (Ratio_PRI <= 50))
-				CurServiceType = BT_Idle;
+		*/	
+			if((Ratio_Tx <= 50)  && (Ratio_PRI <= 50)) 
+			  	CurServiceType = BT_Idle;
 			else if((Ratio_PRI > 150) && (Ratio_PRI < 200))
 				CurServiceType = BT_SCO;
 			else if((Ratio_Tx >= 200)&&(Ratio_PRI >= 200))
@@ -2851,7 +2851,7 @@ void rtl8192c_issue_delete_ba(_adapter *padapter, u8 dir)
 		if(ServiceTypeCnt==2)
 		{
 			pHalData->bt_coexist.BT_Service = LastServiceType;
-			BT_State = BT_State |
+			BT_State = BT_State | 
 					((pHalData->bt_coexist.BT_Ant_isolation==1)?0:BIT1) |
 					((pHalData->bt_coexist.BT_Service==BT_SCO)?0:BIT2);
 
@@ -2878,23 +2878,23 @@ void rtl8192c_issue_delete_ba(_adapter *padapter, u8 dir)
 			{
 				RTPRINT(FBT, BT_TRACE, ("BT TYPE Set to ==> BT_OtherBusy\n"));
 			}
-
+				
 			//Add interrupt migration when bt is not in idel state (no traffic).
 			//suggestion by Victor.
 			if(pHalData->bt_coexist.BT_Service!=BT_Idle)
 			{
-
+			
 				PlatformEFIOWrite2Byte(Adapter, 0x504, 0x0ccc);
 				PlatformEFIOWrite1Byte(Adapter, 0x506, 0x54);
 				PlatformEFIOWrite1Byte(Adapter, 0x507, 0x54);
-
+			
 			}
 			else
 			{
 				PlatformEFIOWrite1Byte(Adapter, 0x506, 0x00);
-				PlatformEFIOWrite1Byte(Adapter, 0x507, 0x00);
+				PlatformEFIOWrite1Byte(Adapter, 0x507, 0x00);			
 			}
-
+				
 			PlatformEFIOWrite1Byte(Adapter, 0x4fd, BT_State);
 			RTPRINT(FBT, BT_TRACE, ("BT_SCO set 0x4fd to %x\n", BT_State));
 			return TRUE;
@@ -2942,10 +2942,10 @@ void rtl8192c_issue_delete_ba(_adapter *padapter, u8 dir)
 		return FALSE;
 
 	RTPRINT(FBT, BT_TRACE, ("RSSI is %d\n",pHalData->UndecoratedSmoothedPWDB));
-
+	
 	if((pHalData->UndecoratedSmoothedPWDB<=32) && pMgntInfo->pHTInfo->bAcceptAddbaReq)
 	{
-		RTPRINT(FBT, BT_TRACE, ("BT_Disallow AMPDU RSSI <=32  Need change\n"));
+		RTPRINT(FBT, BT_TRACE, ("BT_Disallow AMPDU RSSI <=32  Need change\n"));				
 		return TRUE;
 
 	}
@@ -2954,7 +2954,7 @@ void rtl8192c_issue_delete_ba(_adapter *padapter, u8 dir)
 		RTPRINT(FBT, BT_TRACE, ("BT_Allow AMPDU RSSI >=40, Need change\n"));
 		return TRUE;
 	}
-	else
+	else 
 		return FALSE;
 
 }
@@ -2973,7 +2973,7 @@ void rtl8192c_issue_delete_ba(_adapter *padapter, u8 dir)
 	BOOLEAN			bWifiConnectChange, bBtStateChange,bRSSIChangeWithAMPDU;
 
 	if( (pHalData->bt_coexist.BluetoothCoexist) &&
-		(pHalData->bt_coexist.BT_CoexistType == BT_CSR_BC4) &&
+		(pHalData->bt_coexist.BT_CoexistType == BT_CSR_BC4) && 
 		(!ACTING_AS_AP(Adapter))	)
 	{
 		bWifiConnectChange = BT_WifiConnectChange(Adapter);
@@ -2995,7 +2995,7 @@ void rtl8192c_issue_delete_ba(_adapter *padapter, u8 dir)
 					{
 						if(Adapter->pNdisCommon->bRegBT_Ampdu && Adapter->pNdisCommon->bRegAcceptAddbaReq)
 						{
-							RTPRINT(FBT, BT_TRACE, ("BT_Disallow AMPDU RSSI <=32\n"));
+							RTPRINT(FBT, BT_TRACE, ("BT_Disallow AMPDU RSSI <=32\n"));	
 							pMgntInfo->pHTInfo->bAcceptAddbaReq = FALSE;
 							if(GetTs(Adapter, (PTS_COMMON_INFO*)(&pRxTs), pMgntInfo->Bssid, 0, RX_DIR, FALSE))
 								TsInitDelBA(Adapter, (PTS_COMMON_INFO)pRxTs, RX_DIR);
@@ -3005,7 +3005,7 @@ void rtl8192c_issue_delete_ba(_adapter *padapter, u8 dir)
 					{
 						if(Adapter->pNdisCommon->bRegBT_Ampdu && Adapter->pNdisCommon->bRegAcceptAddbaReq)
 						{
-							RTPRINT(FBT, BT_TRACE, ("BT_Allow AMPDU  RSSI >=40\n"));
+							RTPRINT(FBT, BT_TRACE, ("BT_Allow AMPDU  RSSI >=40\n"));	
 							pMgntInfo->pHTInfo->bAcceptAddbaReq = TRUE;
 						}
 					}
@@ -3014,25 +3014,25 @@ void rtl8192c_issue_delete_ba(_adapter *padapter, u8 dir)
 				{
 					if(Adapter->pNdisCommon->bRegBT_Ampdu && Adapter->pNdisCommon->bRegAcceptAddbaReq)
 					{
-						RTPRINT(FBT, BT_TRACE, ("BT_Allow AMPDU BT not in SCO or BUSY\n"));
+						RTPRINT(FBT, BT_TRACE, ("BT_Allow AMPDU BT not in SCO or BUSY\n"));	
 						pMgntInfo->pHTInfo->bAcceptAddbaReq = TRUE;
 					}
 				}
 
 				if(pHalData->bt_coexist.BT_Ant_isolation)
-				{
+				{			
 					RTPRINT(FBT, BT_TRACE, ("BT_IsolationLow\n"));
 					RTPRINT(FBT, BT_TRACE, ("BT_Update Rate table\n"));
 					Adapter->HalFunc.UpdateHalRATRTableHandler(
-								Adapter,
+								Adapter, 
 								&pMgntInfo->dot11OperationalRateSet,
 								pMgntInfo->dot11HTOperationalRateSet,NULL);
-
+					
 					if(pHalData->bt_coexist.BT_Service==BT_SCO)
 					{
 
 						RTPRINT(FBT, BT_TRACE, ("BT_Turn OFF Coexist with SCO \n"));
-						PlatformEFIOWrite1Byte(Adapter, REG_GPIO_MUXCFG, 0x14);
+						PlatformEFIOWrite1Byte(Adapter, REG_GPIO_MUXCFG, 0x14);					
 					}
 					else if(pHalData->DynamicTxHighPowerLvl == TxHighPwrLevel_Normal)
 					{
@@ -3055,7 +3055,7 @@ void rtl8192c_issue_delete_ba(_adapter *padapter, u8 dir)
 			{
 				if(Adapter->pNdisCommon->bRegBT_Ampdu && Adapter->pNdisCommon->bRegAcceptAddbaReq)
 				{
-					RTPRINT(FBT, BT_TRACE, ("BT_Allow AMPDU bt is off\n"));
+					RTPRINT(FBT, BT_TRACE, ("BT_Allow AMPDU bt is off\n"));	
 					pMgntInfo->pHTInfo->bAcceptAddbaReq = TRUE;
 				}
 
@@ -3064,7 +3064,7 @@ void rtl8192c_issue_delete_ba(_adapter *padapter, u8 dir)
 
 				RTPRINT(FBT, BT_TRACE, ("BT_Update Rate table\n"));
 				Adapter->HalFunc.UpdateHalRATRTableHandler(
-							Adapter,
+							Adapter, 
 							&pMgntInfo->dot11OperationalRateSet,
 							pMgntInfo->dot11HTOperationalRateSet,NULL);
 			}
@@ -3087,7 +3087,7 @@ void rtl8192c_issue_delete_ba(_adapter *padapter, u8 dir)
  *
  * Revised History:
  *	When		Who		Remark
- *	01/10/2008	MHC		Create Version 0.
+ *	01/10/2008	MHC		Create Version 0.  
  *
  *---------------------------------------------------------------------------*/
 static VOID
@@ -3121,14 +3121,14 @@ void rtl8192c_issue_delete_ba(_adapter *padapter, u8 dir)
 //#if ((HAL_CODE_BASE == RTL8192_S) )
 	//Adapter->HalFunc.GPIOChangeRFHandler(Adapter, GPIORF_POLLING);
 //#else
-	// 2010/07/27 MH Only Minicard and support selective suspend, we can not turn off all MAC power to
+	// 2010/07/27 MH Only Minicard and support selective suspend, we can not turn off all MAC power to 
 	// stop 8051. For dongle and minicard, we both support selective suspend mode.
 	//if(pDevice->RegUsbSS && Adapter->HalFunc.GetInterfaceSelectionHandler(Adapter) == INTF_SEL2_MINICARD)
 
 	//
 	// 2010/08/12 MH We support severl power consumption combination as below.
 	//
-	// Power consumption combination
+	// Power consumption combination  
 	//	SS Enable: (LPS disable + IPS + SW/HW radio off)
 	//	1. Dongle + PDN  (support HW radio off)
 	//	2. Dongle + Normal  (No HW radio off)
@@ -3157,14 +3157,14 @@ void rtl8192c_issue_delete_ba(_adapter *padapter, u8 dir)
 		}
 		else
 		{	// Dongle does not support HW radio detection.?? In the fufure??
-			RT_TRACE(COMP_RF, DBG_LOUD, ("USB DONGLE Non-GPIO-Detect\n"));
-		}
+			RT_TRACE(COMP_RF, DBG_LOUD, ("USB DONGLE Non-GPIO-Detect\n"));				
+		}			
 	}
 	else if (IS_HARDWARE_TYPE_8192CU(Adapter) ||
 		IS_HARDWARE_TYPE_8723AU(Adapter)||
 		IS_HARDWARE_TYPE_8192DU(Adapter) ||
 		IS_HARDWARE_TYPE_8723AS(Adapter))
-	{	// Not support Selective suspend
+	{	// Not support Selective suspend 
 		RT_TRACE(COMP_RF, DBG_LOUD, ("USB SS Disable\n"));
 		if (SUPPORT_HW_RADIO_DETECT(Adapter))
 		{
@@ -3177,7 +3177,7 @@ void rtl8192c_issue_delete_ba(_adapter *padapter, u8 dir)
 		}
 	}
 	else
-	{	// CE only support noemal HW radio detection now. Support timers GPIO detection in SE/CU.
+	{	// CE only support noemal HW radio detection now. Support timers GPIO detection in SE/CU.		
 		PlatformScheduleWorkItem( &(pHalData->GPIOChangeRFWorkItem) );
 	}
 //#endif
@@ -3185,7 +3185,7 @@ void rtl8192c_issue_delete_ba(_adapter *padapter, u8 dir)
 	if(Adapter->bInHctTest)
 		return;
 
-	// CE only support noemal HW radio detection now. We support timers GPIO detection in SE.
+	// CE only support noemal HW radio detection now. We support timers GPIO detection in SE.		
 	PlatformScheduleWorkItem( &(pHalData->GPIOChangeRFWorkItem) );
 #endif
 #endif
@@ -3193,20 +3193,20 @@ void rtl8192c_issue_delete_ba(_adapter *padapter, u8 dir)
 
 static VOID
 dm_InitRateAdaptiveMask(
-	IN	PADAPTER	Adapter
+	IN	PADAPTER	Adapter	
 	)
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	PRATE_ADAPTIVE	pRA = (PRATE_ADAPTIVE)&pdmpriv->RateAdaptive;
-
+	
 	pRA->RATRState = DM_RATR_STA_INIT;
 	pRA->PreRATRState = DM_RATR_STA_INIT;
 
 	if (pdmpriv->DM_Type == DM_Type_ByDriver)
 		pdmpriv->bUseRAMask = _TRUE;
 	else
-		pdmpriv->bUseRAMask = _FALSE;
+		pdmpriv->bUseRAMask = _FALSE;	
 }
 
 /*-----------------------------------------------------------------------------
@@ -3222,7 +3222,7 @@ void rtl8192c_issue_delete_ba(_adapter *padapter, u8 dir)
  *
  * Revised History:
  *	When		Who		Remark
- *	05/27/2009	hpfan	Create Version 0.
+ *	05/27/2009	hpfan	Create Version 0.  
  *
  *---------------------------------------------------------------------------*/
 static VOID
@@ -3250,7 +3250,7 @@ void rtl8192c_issue_delete_ba(_adapter *padapter, u8 dir)
 	// if default port is connected, update RA table for default port (infrastructure mode only)
 	if(pAdapter->MgntInfo.mAssoc && (!ACTING_AS_AP(pAdapter)))
 	{
-
+		
 		// decide rastate according to rssi
 		switch (pRA->PreRATRState)
 		{
@@ -3258,12 +3258,12 @@ void rtl8192c_issue_delete_ba(_adapter *padapter, u8 dir)
 				HighRSSIThreshForRA = 50;
 				LowRSSIThreshForRA = 20;
 				break;
-
+			
 			case DM_RATR_STA_MIDDLE:
 				HighRSSIThreshForRA = 55;
 				LowRSSIThreshForRA = 20;
 				break;
-
+			
 			case DM_RATR_STA_LOW:
 				HighRSSIThreshForRA = 50;
 				LowRSSIThreshForRA = 25;
@@ -3335,14 +3335,14 @@ void rtl8192c_issue_delete_ba(_adapter *padapter, u8 dir)
 						LowRSSIThreshForRA = 20;
 					}
 					break;
-
+					
 					case DM_RATR_STA_MIDDLE:
 					{
 						HighRSSIThreshForRA = 55;
 						LowRSSIThreshForRA = 20;
 					}
 					break;
-
+					
 					case DM_RATR_STA_LOW:
 					{
 						HighRSSIThreshForRA = 50;
@@ -3383,7 +3383,7 @@ void rtl8192c_issue_delete_ba(_adapter *padapter, u8 dir)
 			}
 		}
 	}
-#endif
+#endif	
 }
 
 static VOID
@@ -3428,14 +3428,14 @@ void rtl8192c_issue_delete_ba(_adapter *padapter, u8 dir)
 	// Calculate current Tx Rate(Successful transmited!!)
 
 	// Calculate current Rx Rate(Successful received!!)
-
+	
 	//for tx tx retry count
 	rtw_hal_get_hwreg( Adapter, HW_VAR_RETRY_COUNT, (pu1Byte)(&Adapter->TxStats.NumTxRetryCount) );
-#endif
+#endif	
 }
 
 static void dm_CheckPbcGPIO(_adapter *padapter)
-{
+{	
 	u8	tmp1byte;
 	u8	bPbcPressed = _FALSE;
 	int i=0;
@@ -3459,12 +3459,12 @@ static void dm_CheckPbcGPIO(_adapter *padapter)
 	rtw_write8(padapter, GPIO_IO_SEL, tmp1byte);	//enable GPIO[2] as input mode
 
 	tmp1byte =rtw_read8(padapter, GPIO_IN);
-
+	
 	if (tmp1byte == 0xff)
 	{
 		bPbcPressed = _FALSE;
 		break ;
-	}
+	}	
 
 	if (tmp1byte&HAL_8192C_HW_GPIO_WPS_BIT)
 	{
@@ -3490,16 +3490,16 @@ static void dm_CheckPbcGPIO(_adapter *padapter)
 		if(i<=3)
 			rtw_msleep_os(50);
 	}
-#endif
+#endif		
 
 	}while(i<=3 && bPbcPressed == _TRUE);
-
+	
 	if( _TRUE == bPbcPressed)
 	{
 		// Here we only set bPbcPressed to true
-		// After trigger PBC, the variable will be set to false
+		// After trigger PBC, the variable will be set to false		
 		DBG_8192C("CheckPbcGPIO - PBC is pressed, try_cnt=%d\n", i-1);
-
+                
 #ifdef RTK_DMP_PLATFORM
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,12))
 		kobject_uevent(&padapter->pnetdev->dev.kobj, KOBJ_NET_PBC);
@@ -3517,7 +3517,7 @@ static void dm_CheckPbcGPIO(_adapter *padapter)
 		rtw_signal_process(padapter->pid[0], SIGUSR1);
 #endif
 #endif
-	}
+	}	
 }
 
 #ifdef CONFIG_PCI_HCI
@@ -3538,36 +3538,36 @@ static void dm_CheckPbcGPIO(_adapter *padapter)
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	struct mlme_priv	*pmlmepriv = &(Adapter->mlmepriv);
 	BOOLEAN			bCurrentIntMt, bCurrentACIntDisable;
-	BOOLEAN			IntMtToSet = _FALSE;
+	BOOLEAN			IntMtToSet = _FALSE; 
 	BOOLEAN			ACIntToSet = _FALSE;
-
-
+	
+	
 	// Retrieve current interrupt migration and Tx four ACs IMR settings first.
 	bCurrentIntMt = pHalData->bInterruptMigration;
 	bCurrentACIntDisable = pHalData->bDisableTxInt;
 
 	//
-	// <Roger_Notes> Currently we use busy traffic for reference instead of RxIntOK counts to prevent non-linear Rx statistics
+	// <Roger_Notes> Currently we use busy traffic for reference instead of RxIntOK counts to prevent non-linear Rx statistics 
 	// when interrupt migration is set before. 2010.03.05.
-	//
-	if(!Adapter->registrypriv.wifi_spec &&
+	// 
+	if(!Adapter->registrypriv.wifi_spec && 
 		(check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE) &&
 		pmlmepriv->LinkDetectInfo.bHigherBusyTraffic)
-	{
+	{			
 		IntMtToSet = _TRUE;
 
 		// To check whether we should disable Tx interrupt or not.
 		if(pmlmepriv->LinkDetectInfo.bHigherBusyRxTraffic )
-			ACIntToSet = _TRUE;
-	}
-
+			ACIntToSet = _TRUE;				
+	}		
+	
 	//Update current settings.
 	if( bCurrentIntMt != IntMtToSet ){
 		DBG_8192C("%s(): Update interrrupt migration(%d)\n",__FUNCTION__,IntMtToSet);
 		if(IntMtToSet)
 		{
 			//
-			// <Roger_Notes> Set interrrupt migration timer and corresponging Tx/Rx counter.
+			// <Roger_Notes> Set interrrupt migration timer and corresponging Tx/Rx counter. 
 			// timer 25ns*0xfa0=100us for 0xf packets.
 			// 2010.03.05.
 			//
@@ -3600,7 +3600,7 @@ static void dm_CheckPbcGPIO(_adapter *padapter)
 			pHalData->bDisableTxInt = ACIntToSet;
 		}
 	}*/
-
+	
 }
 
 #endif
@@ -3614,20 +3614,20 @@ static void dm_CheckPbcGPIO(_adapter *padapter)
 	)
 {
 	PHAL_DATA_TYPE		pHalData = GET_HAL_DATA(Adapter);
-
+	
 	u8	tmp1byte;
-
+	
 	tmp1byte = rtw_read8(Adapter, REG_GPIO_MUXCFG);
 	tmp1byte &= (GPIOSEL_GPIO | ~GPIOSEL_ENBT);
-
+	
 #ifdef CONFIG_BT_COEXIST
 	// UMB-B cut bug. We need to support the modification.
-	if (IS_81xxC_VENDOR_UMC_B_CUT(pHalData->VersionID) &&
+	if (IS_81xxC_VENDOR_UMC_B_CUT(pHalData->VersionID) && 
 		pHalData->bt_coexist.BT_Coexist)
 	{
-		tmp1byte |= (BIT5);
+		tmp1byte |= (BIT5);	
 	}
-#endif
+#endif	
 	rtw_write8(Adapter, REG_GPIO_MUXCFG, tmp1byte);
 
 }
@@ -3645,12 +3645,12 @@ static void update_EDCA_param(_adapter *padapter)
 	struct registry_priv	*pregpriv = &padapter->registrypriv;
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-
+	
 #ifdef CONFIG_BT_COEXIST
-	struct btcoexist_priv	*pbtpriv = &(pHalData->bt_coexist);
+	struct btcoexist_priv	*pbtpriv = &(pHalData->bt_coexist);	
 	u8	bbtchange = _FALSE;
 #endif
-
+	
 
 	//DBG_871X("%s\n", __FUNCTION__);
 
@@ -3659,7 +3659,7 @@ static void update_EDCA_param(_adapter *padapter)
 	{
 		return;
 	}
-
+	
 	if (pmlmeinfo->assoc_AP_vendor >= maxAP)
 	{
 		return;
@@ -3673,7 +3673,7 @@ static void update_EDCA_param(_adapter *padapter)
 	{
 		if (cur_tx_bytes > (cur_rx_bytes << 2))
 		{ // Uplink TP is present.
-			trafficIndex = UP_LINK;
+			trafficIndex = UP_LINK; 
 		}
 		else
 		{ // Balance TP is present.
@@ -3706,8 +3706,8 @@ static void update_EDCA_param(_adapter *padapter)
 	{
 #if 0
 #ifdef CONFIG_BT_COEXIST
-		if(_TRUE == bbtchange)
-			rtw_write32(padapter, REG_EDCA_BE_PARAM, pbtpriv->BT_EDCA[trafficIndex]);
+		if(_TRUE == bbtchange)		
+			rtw_write32(padapter, REG_EDCA_BE_PARAM, pbtpriv->BT_EDCA[trafficIndex]);		
 		else
 #endif
 		//adjust EDCA parameter for BE queue
@@ -3730,7 +3730,7 @@ static void update_EDCA_param(_adapter *padapter)
 		}
 
 #ifdef CONFIG_BT_COEXIST
-		if(_TRUE == bbtchange)
+		if(_TRUE == bbtchange)		
 			edca_param = pbtpriv->BT_EDCA[trafficIndex];
 #endif
 
@@ -3738,8 +3738,8 @@ static void update_EDCA_param(_adapter *padapter)
 #endif
 		pdmpriv->prv_traffic_idx = trafficIndex;
 	}
-
-//exit_update_EDCA_param:
+	
+//exit_update_EDCA_param:	
 
 	pxmitpriv->last_tx_bytes = pxmitpriv->tx_bytes;
 	precvpriv->last_rx_bytes = precvpriv->rx_bytes;
@@ -3816,7 +3816,7 @@ static void dm_1R_CCA(
 void
 rtl8192c_dm_RF_Saving(
 	IN	PADAPTER	pAdapter,
-	IN	u8	bForceInNormal
+	IN	u8	bForceInNormal 
 	)
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
@@ -3836,7 +3836,7 @@ static void dm_1R_CCA(
 	{
 		if(pPSTable->Rssi_val_min != 0)
 		{
-
+			 
 			if(pPSTable->PreRFState == RF_Normal)
 			{
 			#ifdef CONFIG_SPECIAL_SETTING_FOR_FUNAI_TV
@@ -3866,7 +3866,7 @@ static void dm_1R_CCA(
 	{
 		pPSTable->CurRFState = RF_Normal;
 	}
-
+	
 	if(pPSTable->PreRFState != pPSTable->CurRFState)
 	{
 		if(pPSTable->CurRFState == RF_Save)
@@ -3897,15 +3897,15 @@ static void dm_1R_CCA(
 dm_DynamicBBPowerSaving(
 IN	PADAPTER	pAdapter
 	)
-{
+{	
 
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
 	struct mlme_priv	*pmlmepriv = &pAdapter->mlmepriv;
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	PS_T	*pPSTable = &pdmpriv->DM_PSTable;
 
-	//1 1.Determine the minimum RSSI
-	if((check_fwstate(pmlmepriv, _FW_LINKED) != _TRUE) &&
+	//1 1.Determine the minimum RSSI 
+	if((check_fwstate(pmlmepriv, _FW_LINKED) != _TRUE) &&	
 		(pdmpriv->EntryMinUndecoratedSmoothedPWDB == 0))
 	{
 		pPSTable->Rssi_val_min = 0;
@@ -3927,19 +3927,19 @@ static void dm_1R_CCA(
 		}
 	}
 	else // associated entry pwdb
-	{
+	{	
 		pPSTable->Rssi_val_min = pdmpriv->EntryMinUndecoratedSmoothedPWDB;
 		//RT_TRACE(COMP_BB_POWERSAVING, DBG_LOUD, ("AP Ext Port PWDB = 0x%lx \n", pPSTable->Rssi_val_min));
 	}
-
+	
 	//1 2.Power Saving for 92C
 	if(IS_92C_SERIAL(pHalData->VersionID))
 	{
 		//dm_1R_CCA(pAdapter);
 	}
-
+	
 	// 20100628 Joseph: Turn off BB power save for 88CE because it makesthroughput unstable.
-	// 20100831 Joseph: Turn ON BB power save again after modifying AGC delay from 900ns to 600ns.
+	// 20100831 Joseph: Turn ON BB power save again after modifying AGC delay from 900ns to 600ns. 
 	//1 3.Power Saving for 88C
 	else
 	{
@@ -3956,7 +3956,7 @@ void SwAntDivResetBeforeLink8192C(IN PADAPTER Adapter)
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	SWAT_T *pDM_SWAT_Table = &pdmpriv->DM_SWAT_Table;
-
+	
 	pDM_SWAT_Table->SWAS_NoLink_State = 0;
 }
 
@@ -3973,7 +3973,7 @@ void	SwAntDivCompare8192C(PADAPTER Adapter, WLAN_BSSID_EX *dst, WLAN_BSSID_EX *s
 		if(dst->Rssi >=  src->Rssi )//keep org parameter
 		{
 			src->Rssi = dst->Rssi;
-			src->PhyInfo.Optimum_antenna = dst->PhyInfo.Optimum_antenna;
+			src->PhyInfo.Optimum_antenna = dst->PhyInfo.Optimum_antenna;						
 		}
 	}
 }
@@ -3985,7 +3985,7 @@ u8 SwAntDivBeforeLink8192C(IN PADAPTER Adapter)
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	SWAT_T			*pDM_SWAT_Table = &pdmpriv->DM_SWAT_Table;
 	struct mlme_priv	*pmlmepriv = &(Adapter->mlmepriv);
-
+	
 	// Condition that does not need to use antenna diversity.
 	if(IS_92C_SERIAL(pHalData->VersionID) ||(pHalData->AntDivCfg==0))
 	{
@@ -3993,28 +3993,28 @@ u8 SwAntDivBeforeLink8192C(IN PADAPTER Adapter)
 		return _FALSE;
 	}
 
-	if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
+	if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)	
 	{
 		pDM_SWAT_Table->SWAS_NoLink_State = 0;
 		return _FALSE;
 	}
 	// Since driver is going to set BB register, it shall check if there is another thread controlling BB/RF.
-/*
+/*	
 	if(pHalData->eRFPowerState!=eRfOn || pMgntInfo->RFChangeInProgress || pMgntInfo->bMediaConnect)
 	{
-
-
-		RT_TRACE(COMP_SWAS, DBG_LOUD,
-				("SwAntDivCheckBeforeLink8192C(): RFChangeInProgress(%x), eRFPowerState(%x)\n",
+	
+	
+		RT_TRACE(COMP_SWAS, DBG_LOUD, 
+				("SwAntDivCheckBeforeLink8192C(): RFChangeInProgress(%x), eRFPowerState(%x)\n", 
 				pMgntInfo->RFChangeInProgress,
 				pHalData->eRFPowerState));
-
+	
 		pDM_SWAT_Table->SWAS_NoLink_State = 0;
-
+		
 		return FALSE;
 	}
-*/
-
+*/	
+	
 	if(pDM_SWAT_Table->SWAS_NoLink_State == 0){
 		//switch channel
 		pDM_SWAT_Table->SWAS_NoLink_State = 1;
@@ -4030,7 +4030,7 @@ u8 SwAntDivBeforeLink8192C(IN PADAPTER Adapter)
 		pDM_SWAT_Table->SWAS_NoLink_State = 0;
 		return _FALSE;
 	}
-
+		
 
 
 }
@@ -4049,20 +4049,20 @@ u8 SwAntDivBeforeLink8192C(IN PADAPTER Adapter)
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	SWAT_T			*pDM_SWAT_Table = &pdmpriv->DM_SWAT_Table;
 
-	if(IS_92C_SERIAL(pHalData->VersionID) ||(pHalData->AntDivCfg==0))
+	if(IS_92C_SERIAL(pHalData->VersionID) ||(pHalData->AntDivCfg==0))	
 		return;
 
 	//DBG_8192C("======>   SwAntDivRestAfterLink <========== \n");
 	pHalData->RSSI_cnt_A= 0;
 	pHalData->RSSI_cnt_B= 0;
 	pHalData->RSSI_test = _FALSE;
-
+	
 	pDM_SWAT_Table->try_flag = 0xff;
-	pDM_SWAT_Table->RSSI_Trying = 0;
+	pDM_SWAT_Table->RSSI_Trying = 0;	
 	pDM_SWAT_Table->SelectAntennaMap=0xAA;
 	pDM_SWAT_Table->CurAntenna = pHalData->CurAntenna;
 	pDM_SWAT_Table->PreAntenna = pHalData->CurAntenna;
-
+		
 	pdmpriv->lastTxOkCnt=0;
 	pdmpriv->lastRxOkCnt=0;
 
@@ -4070,9 +4070,9 @@ u8 SwAntDivBeforeLink8192C(IN PADAPTER Adapter)
 	pdmpriv->TXByteCnt_B=0;
 	pdmpriv->RXByteCnt_A=0;
 	pdmpriv->RXByteCnt_B=0;
-	pdmpriv->DoubleComfirm=0;
+	pdmpriv->DoubleComfirm=0;	
 	pdmpriv->TrafficLoad = TRAFFIC_LOW;
-
+	
 }
 
 
@@ -4086,7 +4086,7 @@ u8 SwAntDivBeforeLink8192C(IN PADAPTER Adapter)
 // After 500ms, dm_SW_AntennaSwitchCallback() calls this function to compare the signal just
 // listened on the air with the RSSI of original antenna.
 // It chooses the antenna with better RSSI.
-// There is also a aged policy for error trying. Each error trying will cost more 5 seconds waiting
+// There is also a aged policy for error trying. Each error trying will cost more 5 seconds waiting 
 // penalty to get next try.
 //
 static VOID
@@ -4100,7 +4100,7 @@ u8 SwAntDivBeforeLink8192C(IN PADAPTER Adapter)
 	SWAT_T	*pDM_SWAT_Table = &pdmpriv->DM_SWAT_Table;
 	s32			curRSSI=100, RSSI_A, RSSI_B;
 	u64			curTxOkCnt, curRxOkCnt;
-	u64			CurByteCnt = 0, PreByteCnt = 0;
+	u64			CurByteCnt = 0, PreByteCnt = 0;	
 	u8		nextAntenna = 0;
 	u8			Score_A=0, Score_B=0;
 	u8			i;
@@ -4113,10 +4113,10 @@ u8 SwAntDivBeforeLink8192C(IN PADAPTER Adapter)
 	}
 	// If dynamic ant_div is disabled.
 	if(!(pdmpriv->DMFlag & DYNAMIC_FUNC_ANT_DIV) )
-	{
+	{	
 		return;
 	}
-
+	
 	if (check_fwstate(&Adapter->mlmepriv, _FW_LINKED)	==_FALSE)
 		return;
 #if 0 //to do
@@ -4151,7 +4151,7 @@ u8 SwAntDivBeforeLink8192C(IN PADAPTER Adapter)
 			u8			index = 0;
 			PRT_WLAN_STA	pEntry = NULL;
 			PADAPTER		pTargetAdapter = NULL;
-
+		
 			if(	pMgntInfo->mIbss || ACTING_AS_AP(Adapter) )
 			{
 				// Target: AP/IBSS peer.
@@ -4171,7 +4171,7 @@ u8 SwAntDivBeforeLink8192C(IN PADAPTER Adapter)
 					if(pEntry != NULL)
 					{
 						if(pEntry->bAssociated)
-							break;
+							break;			
 					}
 				}
 			}
@@ -4188,10 +4188,10 @@ u8 SwAntDivBeforeLink8192C(IN PADAPTER Adapter)
 				RT_TRACE(COMP_SWAS, DBG_LOUD, ("dm_SW_AntennaSwitch(): RSSI_target is PEER STA\n"));
 			}
 		}
-
-
+			
+			
 #endif
-
+		
 		pHalData->RSSI_cnt_A= 0;
 		pHalData->RSSI_cnt_B= 0;
 		pDM_SWAT_Table->try_flag = 0;
@@ -4220,46 +4220,46 @@ u8 SwAntDivBeforeLink8192C(IN PADAPTER Adapter)
 				pdmpriv->RXByteCnt_B += curRxOkCnt;
 				//DBG_8192C("#####  TXByteCnt_B(%lld) , RXByteCnt_B(%lld) ####\n",pdmpriv->TXByteCnt_B,pdmpriv->RXByteCnt_B);
 			}
-
+		
 			nextAntenna = (pDM_SWAT_Table->CurAntenna == Antenna_A)? Antenna_B : Antenna_A;
 			pDM_SWAT_Table->RSSI_Trying--;
 			//DBG_8192C("RSSI_Trying = %d\n",pDM_SWAT_Table->RSSI_Trying);
-
+			
 			if(pDM_SWAT_Table->RSSI_Trying == 0)
 			{
 				CurByteCnt = (pDM_SWAT_Table->CurAntenna == Antenna_A)? (pdmpriv->TXByteCnt_A+pdmpriv->RXByteCnt_A) : (pdmpriv->TXByteCnt_B+pdmpriv->RXByteCnt_B);
 				PreByteCnt = (pDM_SWAT_Table->CurAntenna == Antenna_A)? (pdmpriv->TXByteCnt_B+pdmpriv->RXByteCnt_B) : (pdmpriv->TXByteCnt_A+pdmpriv->RXByteCnt_A);
 
 				//DBG_8192C("CurByteCnt = %lld\n", CurByteCnt);
-				//DBG_8192C("PreByteCnt = %lld\n",PreByteCnt);
-
+				//DBG_8192C("PreByteCnt = %lld\n",PreByteCnt);		
+				
 				if(pdmpriv->TrafficLoad == TRAFFIC_HIGH)
 				{
-					PreByteCnt = PreByteCnt*9;	//normalize:Cur=90ms:Pre=10ms
+					PreByteCnt = PreByteCnt*9;	//normalize:Cur=90ms:Pre=10ms					
 				}
 				else if(pdmpriv->TrafficLoad == TRAFFIC_LOW)
-				{
+				{					
 					//CurByteCnt = CurByteCnt/2;
-					CurByteCnt = CurByteCnt>>1;//normalize:100ms:50ms
+					CurByteCnt = CurByteCnt>>1;//normalize:100ms:50ms					
 				}
 
 
 				//DBG_8192C("After DIV=>CurByteCnt = %lld\n", CurByteCnt);
-				//DBG_8192C("PreByteCnt = %lld\n",PreByteCnt);
+				//DBG_8192C("PreByteCnt = %lld\n",PreByteCnt);		
 
 				if(pHalData->RSSI_cnt_A > 0)
-					RSSI_A = pHalData->RSSI_sum_A/pHalData->RSSI_cnt_A;
+					RSSI_A = pHalData->RSSI_sum_A/pHalData->RSSI_cnt_A; 
 				else
 					RSSI_A = 0;
 				if(pHalData->RSSI_cnt_B > 0)
-					RSSI_B = pHalData->RSSI_sum_B/pHalData->RSSI_cnt_B;
+					RSSI_B = pHalData->RSSI_sum_B/pHalData->RSSI_cnt_B; 
 				else
 					RSSI_B = 0;
-
+				
 				curRSSI = (pDM_SWAT_Table->CurAntenna == Antenna_A)? RSSI_A : RSSI_B;
 				pDM_SWAT_Table->PreRSSI =  (pDM_SWAT_Table->CurAntenna == Antenna_A)? RSSI_B : RSSI_A;
 				//DBG_8192C("Luke:PreRSSI = %d, CurRSSI = %d\n",pDM_SWAT_Table->PreRSSI, curRSSI);
-				//DBG_8192C("SWAS: preAntenna= %s, curAntenna= %s \n",
+				//DBG_8192C("SWAS: preAntenna= %s, curAntenna= %s \n", 
 				//(pDM_SWAT_Table->PreAntenna == Antenna_A?"A":"B"), (pDM_SWAT_Table->CurAntenna == Antenna_A?"A":"B"));
 				//DBG_8192C("Luke:RSSI_A= %d, RSSI_cnt_A = %d, RSSI_B= %d, RSSI_cnt_B = %d\n",
 					//RSSI_A, pHalData->RSSI_cnt_A, RSSI_B, pHalData->RSSI_cnt_B);
@@ -4268,19 +4268,19 @@ u8 SwAntDivBeforeLink8192C(IN PADAPTER Adapter)
 			}
 			else
 			{
-
+		
 			if(pHalData->RSSI_cnt_A > 0)
-				RSSI_A = pHalData->RSSI_sum_A/pHalData->RSSI_cnt_A;
+				RSSI_A = pHalData->RSSI_sum_A/pHalData->RSSI_cnt_A; 
 			else
 				RSSI_A = 0;
 			if(pHalData->RSSI_cnt_B > 0)
-				RSSI_B = pHalData->RSSI_sum_B/pHalData->RSSI_cnt_B;
+				RSSI_B = pHalData->RSSI_sum_B/pHalData->RSSI_cnt_B; 
 			else
 				RSSI_B = 0;
 			curRSSI = (pDM_SWAT_Table->CurAntenna == Antenna_A)? RSSI_A : RSSI_B;
 			pDM_SWAT_Table->PreRSSI =  (pDM_SWAT_Table->PreAntenna == Antenna_A)? RSSI_A : RSSI_B;
 			//DBG_8192C("Ekul:PreRSSI = %d, CurRSSI = %d\n", pDM_SWAT_Table->PreRSSI, curRSSI);
-			//DBG_8192C("SWAS: preAntenna= %s, curAntenna= %s \n",
+			//DBG_8192C("SWAS: preAntenna= %s, curAntenna= %s \n", 
 			//(pDM_SWAT_Table->PreAntenna == Antenna_A?"A":"B"), (pDM_SWAT_Table->CurAntenna == Antenna_A?"A":"B"));
 
 			//DBG_8192C("Ekul:RSSI_A= %d, RSSI_cnt_A = %d, RSSI_B= %d, RSSI_cnt_B = %d\n",
@@ -4297,7 +4297,7 @@ u8 SwAntDivBeforeLink8192C(IN PADAPTER Adapter)
 			{
 				//DBG_8192C("SWAS: TestMode = TP_MODE\n");
 				//DBG_8192C("TRY:CurByteCnt = %lld\n", CurByteCnt);
-				//DBG_8192C("TRY:PreByteCnt = %lld\n",PreByteCnt);
+				//DBG_8192C("TRY:PreByteCnt = %lld\n",PreByteCnt);		
 				if(CurByteCnt < PreByteCnt)
 				{
 					if(pDM_SWAT_Table->CurAntenna == Antenna_A)
@@ -4321,7 +4321,7 @@ u8 SwAntDivBeforeLink8192C(IN PADAPTER Adapter)
 				}
 				//DBG_8192C("SelectAntennaMap=%x\n ",pDM_SWAT_Table->SelectAntennaMap);
 				//DBG_8192C("Score_A=%d, Score_B=%d\n", Score_A, Score_B);
-
+				
 				if(pDM_SWAT_Table->CurAntenna == Antenna_A)
 				{
 					nextAntenna = (Score_A > Score_B)?Antenna_A:Antenna_B;
@@ -4331,7 +4331,7 @@ u8 SwAntDivBeforeLink8192C(IN PADAPTER Adapter)
 					nextAntenna = (Score_B > Score_A)?Antenna_B:Antenna_A;
 				}
 				//RT_TRACE(COMP_SWAS, DBG_LOUD, ("nextAntenna=%s\n",(nextAntenna==Antenna_A)?"A":"B"));
-				//RT_TRACE(COMP_SWAS, DBG_LOUD, ("preAntenna= %s, curAntenna= %s \n",
+				//RT_TRACE(COMP_SWAS, DBG_LOUD, ("preAntenna= %s, curAntenna= %s \n", 
 					//(DM_SWAT_Table.PreAntenna == Antenna_A?"A":"B"), (DM_SWAT_Table.CurAntenna == Antenna_A?"A":"B")));
 
 				if(nextAntenna != pDM_SWAT_Table->CurAntenna)
@@ -4341,11 +4341,11 @@ u8 SwAntDivBeforeLink8192C(IN PADAPTER Adapter)
 				else
 				{
 					//DBG_8192C("SWAS: current anntena is good\n");
-				}
+				}	
 			}
 
 			if(pDM_SWAT_Table->TestMode == RSSI_MODE)
-			{
+			{	
 				//DBG_8192C("SWAS: TestMode = RSSI_MODE\n");
 				pDM_SWAT_Table->SelectAntennaMap=0xAA;
 				if(curRSSI < pDM_SWAT_Table->PreRSSI) //Current antenna is worse than previous antenna
@@ -4369,7 +4369,7 @@ u8 SwAntDivBeforeLink8192C(IN PADAPTER Adapter)
 				pdmpriv->TXByteCnt_B = 0;
 				pdmpriv->RXByteCnt_A = 0;
 				pdmpriv->RXByteCnt_B = 0;
-
+			
 			}
 
 		//1 Normal State
@@ -4393,7 +4393,7 @@ u8 SwAntDivBeforeLink8192C(IN PADAPTER Adapter)
 				pDM_SWAT_Table->bTriggerAntennaSwitch = 0;
 			//DBG_8192C("Normal:TrafficLoad = %lld\n", curTxOkCnt+curRxOkCnt);
 
-			//Prepare To Try Antenna
+			//Prepare To Try Antenna		
 					nextAntenna = (pDM_SWAT_Table->CurAntenna == Antenna_A)? Antenna_B : Antenna_A;
 					pDM_SWAT_Table->try_flag = 1;
 					pHalData->RSSI_test = _TRUE;
@@ -4409,8 +4409,8 @@ u8 SwAntDivBeforeLink8192C(IN PADAPTER Adapter)
 
 			}
 			//DBG_8192C("SWAS: Normal State -> Begin Trying! TestMode=%s\n",(pDM_SWAT_Table->TestMode == TP_MODE)?"TP":"RSSI");
-
-
+			
+			
 			pHalData->RSSI_sum_A = 0;
 			pHalData->RSSI_cnt_A = 0;
 			pHalData->RSSI_sum_B = 0;
@@ -4421,7 +4421,7 @@ u8 SwAntDivBeforeLink8192C(IN PADAPTER Adapter)
 	//1 4.Change TRX antenna
 	if(nextAntenna != pDM_SWAT_Table->CurAntenna)
 	{
-		//DBG_8192C("@@@@@@@@ SWAS: Change TX Antenna!\n ");
+		//DBG_8192C("@@@@@@@@ SWAS: Change TX Antenna!\n ");		
 		rtw_antenna_select_cmd(Adapter, nextAntenna, 1);
 	}
 
@@ -4461,8 +4461,8 @@ u8 SwAntDivBeforeLink8192C(IN PADAPTER Adapter)
 	{
 		if(pDM_SWAT_Table->TestMode == TP_MODE)
 		{
-			if(pdmpriv->TrafficLoad == TRAFFIC_HIGH)
-				_set_timer(&pdmpriv->SwAntennaSwitchTimer,90 ); //ms
+			if(pdmpriv->TrafficLoad == TRAFFIC_HIGH)			
+				_set_timer(&pdmpriv->SwAntennaSwitchTimer,90 ); //ms			
 			else if(pdmpriv->TrafficLoad == TRAFFIC_LOW)
 				_set_timer(&pdmpriv->SwAntennaSwitchTimer,100 ); //ms
 		}
@@ -4487,7 +4487,7 @@ static void dm_SW_AntennaSwitchCallback(void *FunctionContext)
 
 	if(padapter->net_closed == _TRUE)
 			return;
-	// Only
+	// Only 
 	dm_SW_AntennaSwitch(padapter, SWAW_STEP_DETERMINE);
 }
 
@@ -4499,7 +4499,7 @@ static void dm_SW_AntennaSwitchCallback(void *FunctionContext)
 //
 void SwAntDivRSSICheck8192C(_adapter *padapter ,u32 RxPWDBAll)
 {
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);	
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 
@@ -4507,11 +4507,11 @@ void SwAntDivRSSICheck8192C(_adapter *padapter ,u32 RxPWDBAll)
 
 	if(IS_92C_SERIAL(pHalData->VersionID) ||pHalData->AntDivCfg==0)
 		return;
-
-	if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
-	{
+	
+	if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)		
+	{			
 		if(pDM_SWAT_Table->CurAntenna == Antenna_A)
-		{
+		{			
 			pHalData->RSSI_sum_A += RxPWDBAll;
 			pHalData->RSSI_cnt_A++;
 		}
@@ -4519,11 +4519,11 @@ void SwAntDivRSSICheck8192C(_adapter *padapter ,u32 RxPWDBAll)
 		{
 			pHalData->RSSI_sum_B+= RxPWDBAll;
 			pHalData->RSSI_cnt_B++;
-
+		
 		}
 		//DBG_8192C("%s Ant_(%s),RSSI_sum(%d),RSSI_cnt(%d)\n",__FUNCTION__,(2==pHalData->CurAntenna)?"A":"B",pHalData->RSSI_sum,pHalData->RSSI_cnt);
 	}
-
+	
 }
 
 
@@ -4537,7 +4537,7 @@ void SwAntDivRSSICheck8192C(_adapter *padapter ,u32 RxPWDBAll)
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	SWAT_T	*pDM_SWAT_Table = &pdmpriv->DM_SWAT_Table;
 
-	pHalData->RSSI_sum_A = 0;
+	pHalData->RSSI_sum_A = 0;	
 	pHalData->RSSI_sum_B = 0;
 	pHalData->RSSI_cnt_A = 0;
 	pHalData->RSSI_cnt_B = 0;
@@ -4546,11 +4546,11 @@ void SwAntDivRSSICheck8192C(_adapter *padapter ,u32 RxPWDBAll)
 	pDM_SWAT_Table->PreAntenna = pHalData->CurAntenna;
 	pDM_SWAT_Table->try_flag = 0xff;
 	pDM_SWAT_Table->PreRSSI = 0;
-	pDM_SWAT_Table->bTriggerAntennaSwitch = 0;
+	pDM_SWAT_Table->bTriggerAntennaSwitch = 0;	
 	pDM_SWAT_Table->SelectAntennaMap=0xAA;
-
+	
 	// Move the timer initialization to InitializeVariables function.
-	//PlatformInitializeTimer(Adapter, &pMgntInfo->SwAntennaSwitchTimer, (RT_TIMER_CALL_BACK)dm_SW_AntennaSwitchCallback, NULL, "SwAntennaSwitchTimer");
+	//PlatformInitializeTimer(Adapter, &pMgntInfo->SwAntennaSwitchTimer, (RT_TIMER_CALL_BACK)dm_SW_AntennaSwitchCallback, NULL, "SwAntennaSwitchTimer");	
 }
 
 #endif
@@ -4577,19 +4577,19 @@ static void dm_RSSIMonitorCheck(
 
 	if(check_fwstate(pmlmepriv, _FW_LINKED) == _FALSE)
 		return;
-
+		
 	if(check_fwstate(pmlmepriv, WIFI_AP_STATE |WIFI_ADHOC_STATE) == _TRUE )
 	{
 		if(Adapter->stapriv.asoc_sta_count < 2)
-			return;
-	}
-
+			return;			
+	}		
+	
 	if(pdmpriv->OFDM_Pkt_Cnt == 0)
 		pdmpriv->RSSI_Select = RSSI_CCK;
 	else
 		pdmpriv->RSSI_Select = RSSI_OFDM;
 
-	pdmpriv->OFDM_Pkt_Cnt = 0;
+	pdmpriv->OFDM_Pkt_Cnt = 0;	
 	//DBG_8192C("RSSI_Select=%s OFDM_Pkt_Cnt(%d)\n",
 		//(pdmpriv->RSSI_Select == RSSI_OFDM)?"RSSI_OFDM":"RSSI_CCK",
 		//pdmpriv->OFDM_Pkt_Cnt);
@@ -4606,8 +4606,10 @@ void rtl8192c_init_dm_priv(IN PADAPTER Adapter)
 	//_rtw_memset(pdmpriv, 0, sizeof(struct dm_priv));
 
 #ifdef CONFIG_SW_ANTENNA_DIVERSITY
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
 	_init_timer(&(pdmpriv->SwAntennaSwitchTimer),  Adapter->pnetdev , dm_SW_AntennaSwitchCallback, Adapter);
 #endif
+#endif
 }
 
 void rtl8192c_deinit_dm_priv(IN PADAPTER Adapter)
@@ -4626,7 +4628,7 @@ void dm_InitHybridAntDiv(IN PADAPTER Adapter)
 
 	if(IS_92C_SERIAL(pHalData->VersionID) ||pHalData->AntDivCfg==0)
 		return;
-
+	
 	//Set OFDM HW RX Antenna Diversity
 	PHY_SetBBReg(Adapter,0xc50, BIT7, 1); //Enable Hardware antenna switch
 	PHY_SetBBReg(Adapter,0x870, BIT9|BIT8, 0); //Enable hardware control of "ANT_SEL" & "ANT_SELB"
@@ -4641,7 +4643,7 @@ void dm_InitHybridAntDiv(IN PADAPTER Adapter)
 	PHY_SetBBReg(Adapter,0xA0C, 0xf, 0xf); //Threshold for antenna diversity. Check another antenna power if input power < ANT_lim*4
 	PHY_SetBBReg(Adapter,0xA10, BIT13, 1); //polarity ana_A=1 and ana_B=0
 	PHY_SetBBReg(Adapter,0xA14, 0x1f, 0x8); //default antenna power = inpwr*(0.5 + r_ant_step/16)
-
+	
 	pHalData->CCK_Ant1_Cnt = 0;
 	pHalData->CCK_Ant2_Cnt = 0;
 	pHalData->OFDM_Ant1_Cnt = 0;
@@ -4655,14 +4657,14 @@ void dm_InitHybridAntDiv(IN PADAPTER Adapter)
 void dm_SelectRXDefault(IN	PADAPTER	Adapter)
 {
 	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
-
+	
 	if(IS_92C_SERIAL(pHalData->VersionID) ||pHalData->AntDivCfg==0)
 		return;
-
+	
 	//DbgPrint(" Ant1_Cnt=%d, Ant2_Cnt=%d\n", pHalData->Ant1_Cnt, pHalData->Ant2_Cnt);
 	//DBG_8192C(" CCK_Ant1_Cnt = %d,  CCK_Ant2_Cnt = %d\n", pHalData->CCK_Ant1_Cnt, pHalData->CCK_Ant2_Cnt);
 	//DBG_8192C(" OFDM_Ant1_Cnt = %d,  OFDM_Ant2_Cnt = %d\n", pHalData->OFDM_Ant1_Cnt, pHalData->OFDM_Ant2_Cnt);
-	if((pHalData->OFDM_Ant1_Cnt == 0) && (pHalData->OFDM_Ant2_Cnt == 0))
+	if((pHalData->OFDM_Ant1_Cnt == 0) && (pHalData->OFDM_Ant2_Cnt == 0)) 
 	{
 		if((pHalData->CCK_Ant1_Cnt + pHalData->CCK_Ant2_Cnt) >=10 )
 		{
@@ -4728,12 +4730,12 @@ void dm_SelectRXDefault(IN	PADAPTER	Adapter)
 	dm_InitGPIOSetting(Adapter);
 #endif
 
-	pdmpriv->DM_Type = DM_Type_ByDriver;
+	pdmpriv->DM_Type = DM_Type_ByDriver;	
 	pdmpriv->DMFlag = DYNAMIC_FUNC_DISABLE;
 	pdmpriv->UndecoratedSmoothedPWDB = (-1);
 	pdmpriv->UndecoratedSmoothedCCK = (-1);
-
-
+	
+	
 	//.1 DIG INIT
 	pdmpriv->bDMInitialGainEnable = _TRUE;
 	pdmpriv->DMFlag |= DYNAMIC_FUNC_DIG;
@@ -4799,36 +4801,36 @@ static void FindMinimumRSSI(PADAPTER Adapter)
 
 	if(!rtw_buddy_adapter_up(Adapter))
 		return;
-
+	
 	pbuddy_HalData = GET_HAL_DATA(pbuddy_adapter);
 	pbuddy_dmpriv = &pbuddy_HalData->dmpriv;
 
 	//get min. [PWDB] when both interfaces are connected
-	if((check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE
-		&& Adapter->stapriv.asoc_sta_count > 2
-		&& check_buddy_fwstate(Adapter, _FW_LINKED)) ||
-		(check_buddy_fwstate(Adapter, WIFI_AP_STATE) == _TRUE
+	if((check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE 
+		&& Adapter->stapriv.asoc_sta_count > 2 
+		&& check_buddy_fwstate(Adapter, _FW_LINKED)) || 
+		(check_buddy_fwstate(Adapter, WIFI_AP_STATE) == _TRUE 
 		&& pbuddy_adapter->stapriv.asoc_sta_count > 2
 		&& check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) ||
-		(check_fwstate(pmlmepriv, WIFI_STATION_STATE)
+		(check_fwstate(pmlmepriv, WIFI_STATION_STATE) 
 		&& check_fwstate(pmlmepriv, _FW_LINKED)
-		&& check_buddy_fwstate(Adapter,WIFI_STATION_STATE)
+		&& check_buddy_fwstate(Adapter,WIFI_STATION_STATE) 
 		&& check_buddy_fwstate(Adapter,_FW_LINKED)))
 	{
 		if(pdmpriv->UndecoratedSmoothedPWDB > pbuddy_dmpriv->UndecoratedSmoothedPWDB)
 			pdmpriv->UndecoratedSmoothedPWDB = pbuddy_dmpriv->UndecoratedSmoothedPWDB;
 	}//primary interface is not connected
-	else if((check_buddy_fwstate(Adapter, WIFI_AP_STATE) == _TRUE
-		&& pbuddy_adapter->stapriv.asoc_sta_count > 2) ||
-		(check_buddy_fwstate(Adapter,WIFI_STATION_STATE)
+	else if((check_buddy_fwstate(Adapter, WIFI_AP_STATE) == _TRUE 
+		&& pbuddy_adapter->stapriv.asoc_sta_count > 2) || 
+		(check_buddy_fwstate(Adapter,WIFI_STATION_STATE) 
 		&& check_buddy_fwstate(Adapter,_FW_LINKED)))
 	{
 		pdmpriv->UndecoratedSmoothedPWDB = pbuddy_dmpriv->UndecoratedSmoothedPWDB;
 	}
 	//secondary is not connected
-	else if((check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE
-		&& Adapter->stapriv.asoc_sta_count > 2) ||
-		(check_fwstate(pmlmepriv, WIFI_STATION_STATE)
+	else if((check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE 
+		&& Adapter->stapriv.asoc_sta_count > 2) || 
+		(check_fwstate(pmlmepriv, WIFI_STATION_STATE) 
 		&& check_fwstate(pmlmepriv, _FW_LINKED)))
 	{
 		pbuddy_dmpriv->UndecoratedSmoothedPWDB = 0;
@@ -4839,7 +4841,7 @@ static void FindMinimumRSSI(PADAPTER Adapter)
 		pdmpriv->UndecoratedSmoothedPWDB = 0;
 		pbuddy_dmpriv->UndecoratedSmoothedPWDB = 0;
 	}
-
+		
 	//primary interface is ap mode
 	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE && Adapter->stapriv.asoc_sta_count > 2)
 	{
@@ -4854,7 +4856,7 @@ static void FindMinimumRSSI(PADAPTER Adapter)
 		pdmpriv->EntryMinUndecoratedSmoothedPWDB = pbuddy_dmpriv->EntryMinUndecoratedSmoothedPWDB = 0;
 	}
 
-}
+} 
 
 #endif //CONFIG_CONCURRENT_MODE
 
@@ -4910,12 +4912,12 @@ static void FindMinimumRSSI(PADAPTER Adapter)
 	// 2. Fw is under power saving mode for FwLPS. (Prevent from SW/FW I/O racing.)
 	// 3. IPS workitem is scheduled. (Prevent from IPS sequence to be swapped with DM.
 	//     Sometimes DM execution time is longer than 100ms such that the assertion
-	//     in MgntActSet_RF_State() called by InactivePsWorkItem will be triggered by
+	//     in MgntActSet_RF_State() called by InactivePsWorkItem will be triggered by 
 	//     wating to long for RFChangeInProgress.)
 	// 4. RFChangeInProgress is TRUE. (Prevent from broken by IPS/HW/SW Rf off.)
 	// Noted by tynli. 2010.06.01.
 	//if(rfState == eRfOn)
-	if( (hw_init_completed == _TRUE)
+	if( (hw_init_completed == _TRUE) 
 		&& ((!bFwCurrentInPSMode) && bFwPSAwake))
 	{
 		//
@@ -5038,7 +5040,7 @@ static void FindMinimumRSSI(PADAPTER Adapter)
 skip_dm:
 
 	// Check GPIO to determine current RF on/off and Pbc status.
-	// Check Hardware Radio ON/OFF or not
+	// Check Hardware Radio ON/OFF or not	
 	//if(Adapter->MgntInfo.PowerSaveControl.bGpioRfSw)
 	//{
 		//RTPRINT(FPWR, PWRHW, ("dm_CheckRfCtrlGPIO \n"));
@@ -5053,3 +5055,4 @@ static void FindMinimumRSSI(PADAPTER Adapter)
 	}
 
 }
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_hal_init.c b/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_hal_init.c
old mode 100644
new mode 100755
index bf5518f..b9e91d7
--- a/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_hal_init.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_hal_init.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -44,21 +44,21 @@
 	IN	BOOLEAN			bPseudoTest);
 static BOOLEAN
 hal_EfusePgPacketWrite1ByteHeader(
-	IN	PADAPTER		pAdapter,
+	IN	PADAPTER		pAdapter, 
 	IN	u8				efuseType,
 	IN	u16				*pAddr,
 	IN	PPGPKT_STRUCT	pTargetPkt,
 	IN	BOOLEAN			bPseudoTest);
 static BOOLEAN
 hal_EfusePgPacketWriteData(
-	IN	PADAPTER		pAdapter,
+	IN	PADAPTER		pAdapter, 
 	IN	u8				efuseType,
 	IN	u16				*pAddr,
 	IN	PPGPKT_STRUCT	pTargetPkt,
 	IN	BOOLEAN			bPseudoTest);
-static BOOLEAN
+static BOOLEAN 
 hal_EfusePgPacketWrite_BT(
-	IN	PADAPTER		pAdapter,
+	IN	PADAPTER		pAdapter, 
 	IN	u8				offset,
 	IN	u8				word_en,
 	IN	u8				*pData,
@@ -81,7 +81,7 @@
 				DBG_871X("DBG_SHOW_MCUFWDL_BEFORE_51_ENABLE %s:%d REG_MCUFWDL:0x%02x\n", __FUNCTION__, __LINE__, val);
 		}
 		#endif
-
+	
 		// 8051 enable
 		tmp = rtw_read8(Adapter, REG_SYS_FUNC_EN+1);
 		rtw_write8(Adapter, REG_SYS_FUNC_EN+1, tmp|0x04);
@@ -141,20 +141,20 @@
 			break;
 		case 3:
 			remainFW[2]=*(p+2);
-		case 2:
+		case 2: 	
 			remainFW[1]=*(p+1);
-		case 1:
+		case 1: 	
 			remainFW[0]=*(p);
-			ret = rtw_write32(Adapter, (FW_8192C_START_ADDRESS + blockCount * blockSize),
-				 le32_to_cpu(*(u32*)remainFW));
+			ret = rtw_write32(Adapter, (FW_8192C_START_ADDRESS + blockCount * blockSize), 
+				 le32_to_cpu(*(u32*)remainFW));	
 		}
 		return ret;
 	}
 #else
-
+  
 #ifdef SUPPORTED_BLOCK_IO
-	u32			blockSize	= MAX_REG_BOLCK_SIZE;	// Use 196-byte write to download FW
-	u32			blockSize2  	= MIN_REG_BOLCK_SIZE;
+	u32			blockSize	= MAX_REG_BOLCK_SIZE;	// Use 196-byte write to download FW	
+	u32			blockSize2  	= MIN_REG_BOLCK_SIZE;	
 #else
 	u32			blockSize	= sizeof(u32);	// Use 4-byte write to download FW
 	u32*		pu4BytePtr	= (u32*)buffer;
@@ -184,7 +184,7 @@
 		ret = rtw_writeN(Adapter, (FW_8192C_START_ADDRESS + offset), remainSize, (bufferPtr + offset));
 		goto exit;
 		#endif
-		offset2 = blockCount * blockSize;
+		offset2 = blockCount * blockSize;		
 		blockCount = remainSize / blockSize2;
 		remainSize2 = remainSize % blockSize2;
 
@@ -198,13 +198,13 @@
 
 			if(ret == _FAIL)
 				goto exit;
-		}
+		}		
 
 		if(remainSize2)
 		{
 			offset += blockSize2;
 			bufferPtr += offset;
-
+			
 			for(i = 0 ; i < remainSize2 ; i++){
 				ret = rtw_write8(Adapter, (FW_8192C_START_ADDRESS + offset + i), *(bufferPtr + i));
 
@@ -271,19 +271,19 @@
 	u8*	bufferPtr = (u8*)buffer;
 
 #ifdef CONFIG_PCI_HCI
-	// 20100120 Joseph: Add for 88CE normal chip.
+	// 20100120 Joseph: Add for 88CE normal chip. 
 	// Fill in zero to make firmware image to dword alignment.
 //		_FillDummy(bufferPtr, &size);
 #endif
 
-	pageNums = size / MAX_PAGE_SIZE ;
-	//RT_ASSERT((pageNums <= 4), ("Page numbers should not greater then 4 \n"));
-	remainSize = size % MAX_PAGE_SIZE;
-
+	pageNums = size / MAX_PAGE_SIZE ;		
+	//RT_ASSERT((pageNums <= 4), ("Page numbers should not greater then 4 \n"));			
+	remainSize = size % MAX_PAGE_SIZE;		
+	
 	for(page = 0; page < pageNums;  page++){
 		offset = page *MAX_PAGE_SIZE;
-		ret = _PageWrite(Adapter,page, (bufferPtr+offset),MAX_PAGE_SIZE);
-
+		ret = _PageWrite(Adapter,page, (bufferPtr+offset),MAX_PAGE_SIZE);			
+		
 		if(ret == _FAIL)
 			goto exit;
 	}
@@ -294,7 +294,7 @@
 
 		if(ret == _FAIL)
 			goto exit;
-	}
+	}	
 	//RT_TRACE(COMP_INIT, DBG_LOUD, ("_WriteFW Done- for Normal chip.\n"));
 
 exit:
@@ -308,13 +308,13 @@ static int _FWFreeToGo(
 	u32			counter = 0;
 	u32			value32;
 	u32	restarted = _FALSE;
-
+	
 	// polling CheckSum report
 	do{
 		value32 = rtw_read32(Adapter, REG_MCUFWDL);
-	}while((counter ++ < POLLING_READY_TIMEOUT_COUNT) && (!(value32 & FWDL_ChkSum_rpt)));
+	}while((counter ++ < POLLING_READY_TIMEOUT_COUNT) && (!(value32 & FWDL_ChkSum_rpt)));	
 
-	if(counter >= POLLING_READY_TIMEOUT_COUNT){
+	if(counter >= POLLING_READY_TIMEOUT_COUNT){	
 		DBG_8192C("chksum report faill ! REG_MCUFWDL:0x%08x\n",value32);
 		return _FAIL;
 	} else {
@@ -327,9 +327,9 @@ static int _FWFreeToGo(
 	value32 |= MCUFWDL_RDY;
 	value32 &= ~WINTINI_RDY;
 	rtw_write32(Adapter, REG_MCUFWDL, value32);
+	
 
-
-POLLING_FW_READY:
+POLLING_FW_READY:	
 	// polling for FW ready
 	counter = 0;
 	do
@@ -352,10 +352,10 @@ static int _FWFreeToGo(
 		restarted = _TRUE;
 		goto POLLING_FW_READY;
 	}
-
-
+		
+	
 	return _FAIL;
-
+	
 }
 
 
@@ -367,14 +367,14 @@ static int _FWFreeToGo(
 	u8	u1bTmp;
 	u8	Delay = 100;
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-
+		
 	if((pHalData->FirmwareVersion > 0x21) ||
 		(pHalData->FirmwareVersion == 0x21 &&
 		pHalData->FirmwareSubVersion >= 0x01)) // after 88C Fw v33.1
 	{
 		//0x1cf=0x20. Inform 8051 to reset. 2009.12.25. tynli_test
 		rtw_write8(Adapter, REG_HMETFR+3, 0x20);
-
+	
 		u1bTmp = rtw_read8(Adapter, REG_SYS_FUNC_EN+1);
 		while(u1bTmp&BIT2)
 		{
@@ -416,8 +416,8 @@ int FirmwareDownload92C(
 	IN	PADAPTER			Adapter,
 	IN	BOOLEAN			bUsedWoWLANFw
 )
-{
-	int	rtStatus = _SUCCESS;
+{	
+	int	rtStatus = _SUCCESS;	
 	u8 writeFW_retry = 0;
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	s8 			R92CFwImageFileName_TSMC[] ={RTL8192C_FW_TSMC_IMG};
@@ -428,11 +428,11 @@ int FirmwareDownload92C(
 	s8 			R92CFwImageFileName_UMC_WW[] ={RTL8192C_FW_UMC_WW_IMG};
 	s8 			R92CFwImageFileName_UMC_B_WW[] ={RTL8192C_FW_UMC_B_WW_IMG};
 #endif //CONFIG_WOWLAN
-
+	
 	//s8 			R8723FwImageFileName_UMC[] ={RTL8723_FW_UMC_IMG};
 	u8*			FwImage = NULL;
 	u32			FwImageLen = 0;
-	char*		pFwImageFileName;
+	char*		pFwImageFileName;	
 #ifdef CONFIG_WOWLAN
 	u8*			FwImageWoWLAN;
 	u32			FwImageWoWLANLen;
@@ -441,7 +441,7 @@ int FirmwareDownload92C(
 	u8*			pucMappedFile = NULL;
 	//vivi, merge 92c and 92s into one driver, 20090817
 	//vivi modify this temply, consider it later!!!!!!!!
-	//PRT_FIRMWARE	pFirmware = GET_FIRMWARE_819X(Adapter);
+	//PRT_FIRMWARE	pFirmware = GET_FIRMWARE_819X(Adapter);	
 	//PRT_FIRMWARE_92C	pFirmware = GET_FIRMWARE_8192C(Adapter);
 	PRT_FIRMWARE_92C	pFirmware = NULL;
 	PRT_8192C_FIRMWARE_HDR		pFwHdr = NULL;
@@ -449,7 +449,7 @@ int FirmwareDownload92C(
 	u32		FirmwareLen;
 
 	pFirmware = (PRT_FIRMWARE_92C)rtw_zvmalloc(sizeof(RT_FIRMWARE_92C));
-
+	
 	if(!pFirmware)
 	{
 		rtStatus = _FAIL;
@@ -465,7 +465,7 @@ int FirmwareDownload92C(
 		pFwImageFileName_WoWLAN = R92CFwImageFileName_UMC_WW;
 		FwImageWoWLAN= Rtl8192C_FwUMCWWImageArray;
 		FwImageWoWLANLen =UMCACutWWImgArrayLength ;
-#endif	//CONFIG_WOWLAN
+#endif	//CONFIG_WOWLAN		
 		DBG_8192C(" ===> FirmwareDownload91C() fw:Rtl819XFwImageArray_UMC\n");
 	}
 	else if(IS_81xxC_VENDOR_UMC_B_CUT(pHalData->VersionID))
@@ -479,7 +479,7 @@ int FirmwareDownload92C(
 		FwImageWoWLAN= Rtl8192C_FwUMCBCutWWImageArray;
 		FwImageWoWLANLen =UMCBCutWWImgArrayLength ;
 #endif //CONFIG_WOWLAN
-
+		
 		DBG_8192C(" ===> FirmwareDownload91C() fw:Rtl819XFwImageArray_UMC_B\n");
 	}
 	else
@@ -514,7 +514,7 @@ int FirmwareDownload92C(
 	switch(pFirmware->eFWSource)
 	{
 		case FW_SOURCE_IMG_FILE:
-
+			
 			#ifdef CONFIG_FILE_FWIMG
 			rtStatus = rtw_retrive_from_file(rtw_fw_file_path, FwBuffer8192C, FW_8192C_SIZE);
 			pFirmware->ulFwLength = rtStatus>=0?rtStatus:0;
@@ -543,19 +543,19 @@ int FirmwareDownload92C(
 				pFirmware->ulWoWLANFwLength = FwImageWoWLANLen;
 			}
 #endif //CONFIG_WOWLAN
-
+			
 			break;
 	}
 
-#ifdef CONFIG_WOWLAN
-	if(bUsedWoWLANFw)	{
-		pFirmwareBuf = pFirmware->szWoWLANFwBuffer;
-		FirmwareLen = pFirmware->ulWoWLANFwLength;
-		pFwHdr = (PRT_8192C_FIRMWARE_HDR)pFirmware->szWoWLANFwBuffer;
-	}
+#ifdef CONFIG_WOWLAN	
+	if(bUsedWoWLANFw)	{		
+		pFirmwareBuf = pFirmware->szWoWLANFwBuffer;		
+		FirmwareLen = pFirmware->ulWoWLANFwLength;		
+		pFwHdr = (PRT_8192C_FIRMWARE_HDR)pFirmware->szWoWLANFwBuffer;	
+	}	
 	else
 #endif	//CONFIG_WOWLAN
-	{
+	{	
 	#ifdef DBG_FW_STORE_FILE_PATH //used to store firmware to file...
 	if(pFirmware->ulFwLength > 0)
 	{
@@ -569,13 +569,13 @@ int FirmwareDownload92C(
 	// To Check Fw header. Added by tynli. 2009.12.04.
 	pFwHdr = (PRT_8192C_FIRMWARE_HDR)pFirmware->szFwBuffer;
 	}
-	pHalData->FirmwareVersion =  le16_to_cpu(pFwHdr->Version);
-	pHalData->FirmwareSubVersion = le16_to_cpu(pFwHdr->Subversion);
+	pHalData->FirmwareVersion =  le16_to_cpu(pFwHdr->Version); 
+	pHalData->FirmwareSubVersion = le16_to_cpu(pFwHdr->Subversion); 
 
-	//RT_TRACE(COMP_INIT, DBG_LOUD, (" FirmwareVersion(%#x), Signature(%#x)\n",
+	//RT_TRACE(COMP_INIT, DBG_LOUD, (" FirmwareVersion(%#x), Signature(%#x)\n", 
 	//	Adapter->MgntInfo.FirmwareVersion, pFwHdr->Signature));
 
-	DBG_8192C("fw_ver=v%d, fw_subver=%d, sig=0x%x\n",
+	DBG_8192C("fw_ver=v%d, fw_subver=%d, sig=0x%x\n", 
 		pHalData->FirmwareVersion, pHalData->FirmwareSubVersion, le16_to_cpu(pFwHdr->Signature)&0xFFF0);
 
 	if(IS_FW_HEADER_EXIST(pFwHdr))
@@ -584,35 +584,35 @@ int FirmwareDownload92C(
 		pFirmwareBuf = pFirmwareBuf + 32;
 		FirmwareLen = FirmwareLen -32;
 	}
-
+		
 	// Suggested by Filen. If 8051 is running in RAM code, driver should inform Fw to reset by itself,
 	// or it will cause download Fw fail. 2010.02.01. by tynli.
 	if(rtw_read8(Adapter, REG_MCUFWDL)&BIT7) //8051 RAM code
-	{
+	{	
 		rtl8192c_FirmwareSelfReset(Adapter);
-		rtw_write8(Adapter, REG_MCUFWDL, 0x00);
+		rtw_write8(Adapter, REG_MCUFWDL, 0x00);		
 	}
 
-
+		
 	_FWDownloadEnable(Adapter, _TRUE);
 	while(1) {
 		u8 tmp8;
 		tmp8 = rtw_read8(Adapter, REG_MCUFWDL);
-
+		
 		//reset the FWDL chksum
 		rtw_write8(Adapter, REG_MCUFWDL, tmp8|FWDL_ChkSum_rpt);
-
+		
 		//tmp8 = rtw_read8(Adapter, REG_MCUFWDL);
 		//DBG_8192C("Before _WriteFW, REG_MCUFWDL:0x%02x, writeFW_retry:%u\n", tmp8, writeFW_retry);
-
+		
 		rtStatus = _WriteFW(Adapter, pFirmwareBuf, FirmwareLen);
-
+		
 		//tmp8 = rtw_read8(Adapter, REG_MCUFWDL);
 		//DBG_8192C("After _WriteFW, REG_MCUFWDL:0x%02x, rtStatus:%d\n", tmp8, rtStatus);
 
 		if(rtStatus == _SUCCESS || ++writeFW_retry>3)
 			break;
-	}
+	} 
 	_FWDownloadEnable(Adapter, _FALSE);
 
 	if(_SUCCESS != rtStatus){
@@ -624,7 +624,7 @@ int FirmwareDownload92C(
 	if(_SUCCESS != rtStatus){
 		DBG_8192C("DL Firmware failed!\n");
 		goto Exit;
-	}
+	}	
 	//RT_TRACE(COMP_INIT, DBG_LOUD, (" Firmware is ready to run!\n"));
 
 Exit:
@@ -668,11 +668,11 @@ int FirmwareDownload92C(
 	IN	PADAPTER			padapter,
 	IN	u8			bHostIsGoingtoSleep
 )
-{
+{	
 	int	status=_FAIL;
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
 	u8	 bRecover = _FALSE;
-
+	
 	if(bHostIsGoingtoSleep)
 	{
 		//
@@ -694,7 +694,7 @@ int FirmwareDownload92C(
 		//
 		InitializeFirmwareVars92C(padapter);
 
-
+		
 	}
 }
 #endif // CONFIG_WOWLAN
@@ -716,7 +716,7 @@ static void _update_bt_param(_adapter *padapter)
 	else if(registry_par->bt_sco==4)
 		pbtpriv->BT_Service = BT_Busy;
 	else if(registry_par->bt_sco==5)
-		pbtpriv->BT_Service = BT_OtherBusy;
+		pbtpriv->BT_Service = BT_OtherBusy;		
 	else
 		pbtpriv->BT_Service = BT_Idle;
 
@@ -771,7 +771,7 @@ static void _update_bt_param(_adapter *padapter)
 				break;
 			case BT_OtherBusy:
 				DBG_8192C("BlueTooth BT_Service = BT_OtherBusy\n");
-				break;
+				break;			
 			default:
 				DBG_8192C("BlueTooth BT_Service = BT_Idle\n");
 				break;
@@ -787,7 +787,7 @@ static void _update_bt_param(_adapter *padapter)
 #define GET_BT_COEXIST(priv) (&priv->bt_coexist)
 
 void rtl8192c_ReadBluetoothCoexistInfo(
-	IN	PADAPTER	Adapter,
+	IN	PADAPTER	Adapter,	
 	IN	u8*		PROMContent,
 	IN	BOOLEAN		AutoloadFail
 	)
@@ -801,7 +801,7 @@ void rtl8192c_ReadBluetoothCoexistInfo(
 		pbtpriv->BT_CoexistType= BT_2Wire;
 		pbtpriv->BT_Ant_Num = Ant_x2;
 		pbtpriv->BT_Ant_isolation= 0;
-		pbtpriv->BT_RadioSharedType = BT_Radio_Shared;
+		pbtpriv->BT_RadioSharedType = BT_Radio_Shared;		
 		return;
 	}
 
@@ -835,21 +835,21 @@ void rtl8192c_ReadBluetoothCoexistInfo(
 		// Test chip.
 		if(IS_HARDWARE_TYPE_8723A(Adapter)) {
 			ChipVersion |= ((value32 & VENDOR_ID) ? CHIP_VENDOR_UMC : 0);
-			ChipVersion |= ((value32 & BT_FUNC) ? CHIP_8723: 0); // RTL8723 with BT function.
+			ChipVersion |= ((value32 & BT_FUNC) ? CHIP_8723: 0); // RTL8723 with BT function.			
 		}
 		else	 {
-		version = (value32 & TYPE_ID) ?VERSION_TEST_CHIP_92C :VERSION_TEST_CHIP_88C;
+		version = (value32 & TYPE_ID) ?VERSION_TEST_CHIP_92C :VERSION_TEST_CHIP_88C;		
 	}
 #else
 		// tynli_test. 2011.01.10.
 		if(IS_HARDWARE_TYPE_8192C(Adapter))
 		{
-			ChipVersion = (value32 & TYPE_ID) ? VERSION_TEST_CHIP_92C : VERSION_TEST_CHIP_88C;
+			ChipVersion = (value32 & TYPE_ID) ? VERSION_TEST_CHIP_92C : VERSION_TEST_CHIP_88C;						
 		}
 		else
 		{
 			ChipVersion |= ((value32 & VENDOR_ID) ? CHIP_VENDOR_UMC : 0);
-			ChipVersion |= ((value32 & BT_FUNC) ? CHIP_8723: 0); // RTL8723 with BT function.
+			ChipVersion |= ((value32 & BT_FUNC) ? CHIP_8723: 0); // RTL8723 with BT function.			
 		}
 #endif
 	}
@@ -911,13 +911,13 @@ void rtl8192c_ReadBluetoothCoexistInfo(
 		if(IS_92C_SERIAL(ChipVersion))
 		{
 			value32 = rtw_read32(Adapter, REG_HPON_FSM);
-			ChipVersion |= ((CHIP_BONDING_IDENTIFIER(value32) == CHIP_BONDING_92C_1T2R) ? RF_TYPE_1T2R : 0);
+			ChipVersion |= ((CHIP_BONDING_IDENTIFIER(value32) == CHIP_BONDING_92C_1T2R) ? RF_TYPE_1T2R : 0);			
 		}
 		else if(IS_8723_SERIES(ChipVersion))
 		{
 			//RT_ASSERT(IS_HARDWARE_TYPE_8723A(Adapter), ("Incorrect chip version!!\n"));
 			value32 = rtw_read32(Adapter, REG_GPIO_OUTSTS);
-			ChipVersion |= ((value32 & RF_RL_ID)>>20);	 //ROM code version.
+			ChipVersion |= ((value32 & RF_RL_ID)>>20);	 //ROM code version.	
 		}
 #endif
 
@@ -962,7 +962,7 @@ void rtl8192c_ReadBluetoothCoexistInfo(
 			break;
 		case VERSION_NORMAL_UMC_CHIP_88C_A_CUT:
 			MSG_8192C("Chip Version ID: VERSION_NORMAL_UMC_CHIP_88C_A_CUT.\n");
-			break;
+			break;			
 		case VERSION_NORMAL_UMC_CHIP_92C_1T2R_B_CUT:
 			MSG_8192C("Chip Version ID: VERSION_NORMAL_UMC_CHIP_92C_1T2R_B_CUT.\n");
 			break;
@@ -986,7 +986,7 @@ void rtl8192c_ReadBluetoothCoexistInfo(
 			break;
 		case VERSION_NORMAL_UMC_CHIP_8723_1T1R_B_CUT:
 			MSG_8192C("Chip Version ID: VERSION_NORMA_UMC_CHIP_8723_1T1R_B_CUT.\n");
-			break;
+			break;			
 		default:
 			MSG_8192C("Chip Version ID: ???????????????.\n");
 			break;
@@ -1034,9 +1034,9 @@ u8 GetEEPROMSize8192C(PADAPTER Adapter)
 
 	curRCR = rtw_read16(Adapter, REG_9346CR);
 	size = (curRCR & BOOT_FROM_EEPROM) ? 6 : 4; // 6: EEPROM used is 93C46, 4: boot from E-Fuse.
-
+	
 	MSG_8192C("EEPROM type is %s\n", size==4 ? "E-FUSE" : "93C46");
-
+	
 	return size;
 }
 
@@ -1122,7 +1122,7 @@ enum{
 
 	if (PwrState == _TRUE)
 	{
-		rtw_write8(pAdapter, REG_EFUSE_ACCESS, EFUSE_ACCESS_ON);
+		rtw_write8(pAdapter, REG_EFUSE_ACCESS, EFUSE_ACCESS_ON);	
 
 		// 1.2V Power: From VDDON with Power Cut(0x0000h[15]), defualt valid
 		tmpV16 = rtw_read16(pAdapter,REG_SYS_ISO_CTRL);
@@ -1162,7 +1162,7 @@ enum{
 			tempval = rtw_read8(pAdapter, EFUSE_TEST+3);
 			rtw_write8(pAdapter, EFUSE_TEST+3, (tempval & 0x7F));
 		}
-	}
+	}	
 }
 
 static VOID
@@ -1178,7 +1178,7 @@ enum{
 	else if(IS_HARDWARE_TYPE_8723A(pAdapter))
 	{
 		hal_EfusePowerSwitch_RTL8723(pAdapter, bWrite, PwrState);
-	}
+	}	
 }
 
 static VOID
@@ -1216,9 +1216,9 @@ enum{
 
 	//
 	// 1. Read the first byte to check if efuse is empty!!!
+	// 
 	//
-	//
-	ReadEFuseByte(Adapter, eFuse_Addr, rtemp8, bPseudoTest);
+	ReadEFuseByte(Adapter, eFuse_Addr, rtemp8, bPseudoTest);	
 	if(*rtemp8 != 0xFF)
 	{
 		efuse_utilized++;
@@ -1242,16 +1242,16 @@ enum{
 
 			for(i=0; i<EFUSE_MAX_WORD_UNIT; i++)
 			{
-				// Check word enable condition in the section
+				// Check word enable condition in the section				
 				if(!(wren & 0x01))
 				{
 					//RTPRINT(FEEPROM, EFUSE_READ_ALL, ("Addr=%d\n", eFuse_Addr));
 					ReadEFuseByte(Adapter, eFuse_Addr, rtemp8, bPseudoTest);	eFuse_Addr++;
 					efuse_utilized++;
 					eFuseWord[offset][i] = (*rtemp8 & 0xff);
+					
 
-
-					if(eFuse_Addr >= EFUSE_REAL_CONTENT_LEN)
+					if(eFuse_Addr >= EFUSE_REAL_CONTENT_LEN) 
 						break;
 
 					//RTPRINT(FEEPROM, EFUSE_READ_ALL, ("Addr=%d\n", eFuse_Addr));
@@ -1259,18 +1259,18 @@ enum{
 					efuse_utilized++;
 					eFuseWord[offset][i] |= (((u16)*rtemp8 << 8) & 0xff00);
 
-					if(eFuse_Addr >= EFUSE_REAL_CONTENT_LEN)
+					if(eFuse_Addr >= EFUSE_REAL_CONTENT_LEN) 
 						break;
 				}
-
+				
 				wren >>= 1;
-
+				
 			}
 		}
 
 		//RTPRINT(FEEPROM, EFUSE_READ_ALL, ("Addr=%d\n", eFuse_Addr));
 		// Read next PG header
-		ReadEFuseByte(Adapter, eFuse_Addr, rtemp8, bPseudoTest);
+		ReadEFuseByte(Adapter, eFuse_Addr, rtemp8, bPseudoTest);	
 		if(*rtemp8 != 0xFF && (eFuse_Addr < 512))
 		{
 			efuse_utilized++;
@@ -1294,7 +1294,7 @@ enum{
 	// 4. Copy from Efuse map to output pointer memory!!!
 	//
 	for(i=0; i<_size_byte; i++)
-	{
+	{		
 		pbuf[i] = efuseTbl[_offset+i];
 	}
 
@@ -1340,10 +1340,10 @@ enum{
 
 	//
 	// 1. Read the first byte to check if efuse is empty!!!
-	//
+	// 
 	//
 	ReadEFuseByte(Adapter, eFuse_Addr++, &efuseHeader, bPseudoTest);
-
+	
 	if(efuseHeader != 0xFF)
 	{
 		efuse_utilized++;
@@ -1361,7 +1361,7 @@ enum{
 	while((efuseHeader != 0xFF) && AVAILABLE_EFUSE_ADDR(eFuse_Addr))
 	{
 		//RTPRINT(FEEPROM, EFUSE_READ_ALL, ("efuse[%d]=%x\n", eFuse_Addr-1, efuseHeader));
-
+	
 		// Check PG header for section num.
 		if(EXT_HEADER(efuseHeader))		//extended header
 		{
@@ -1409,7 +1409,7 @@ enum{
 
 			for(i=0; i<EFUSE_MAX_WORD_UNIT; i++)
 			{
-				// Check word enable condition in the section
+				// Check word enable condition in the section				
 				if(!(wden & (0x01<<i)))
 				{
 					ReadEFuseByte(Adapter, eFuse_Addr++, &efuseData, bPseudoTest);
@@ -1425,7 +1425,7 @@ enum{
 					efuse_utilized++;
 					eFuseWord[offset][i] |= (((u16)efuseData << 8) & 0xff00);
 
-					if(!AVAILABLE_EFUSE_ADDR(eFuse_Addr))
+					if(!AVAILABLE_EFUSE_ADDR(eFuse_Addr)) 
 						break;
 				}
 			}
@@ -1456,7 +1456,7 @@ enum{
 	// 4. Copy from Efuse map to output pointer memory!!!
 	//
 	for(i=0; i<_size_byte; i++)
-	{
+	{		
 		pbuf[i] = efuseTbl[_offset+i];
 	}
 
@@ -1486,9 +1486,9 @@ enum{
 	}
 	else
 	{
-		if(IS_HARDWARE_TYPE_8723A(pAdapter) &&
+		if(IS_HARDWARE_TYPE_8723A(pAdapter) && 
 			INCLUDE_MULTI_FUNC_BT(pAdapter))
-		{
+		{		
 			value32 = rtw_read32(pAdapter, EFUSE_TEST);
 			bRet = _TRUE;
 			switch(bank)
@@ -1584,9 +1584,9 @@ enum{
 		eFuse_Addr = 0;
 		//
 		// 1. Read the first byte to check if efuse is empty!!!
-		//
+		// 
 		ReadEFuseByte(Adapter, eFuse_Addr++, &efuseHeader, bPseudoTest);
-
+		
 		if(efuseHeader != 0xFF)
 		{
 			efuse_utilized++;
@@ -1602,7 +1602,7 @@ enum{
 		while((efuseHeader != 0xFF) && AVAILABLE_EFUSE_ADDR(eFuse_Addr))
 		{
 			//RTPRINT(FEEPROM, EFUSE_READ_ALL, ("efuse[%d]=0x%02x (header)\n", (((bank-1)*EFUSE_REAL_CONTENT_LEN)+eFuse_Addr-1), efuseHeader));
-
+		
 			// Check PG header for section num.
 			if(EXT_HEADER(efuseHeader))		//extended header
 			{
@@ -1650,7 +1650,7 @@ enum{
 
 				for(i=0; i<EFUSE_MAX_WORD_UNIT; i++)
 				{
-					// Check word enable condition in the section
+					// Check word enable condition in the section				
 					if(!(wden & (0x01<<i)))
 					{
 						ReadEFuseByte(Adapter, eFuse_Addr++, &efuseData, bPseudoTest);
@@ -1666,7 +1666,7 @@ enum{
 						efuse_utilized++;
 						eFuseWord[offset][i] |= (((u16)efuseData << 8) & 0xff00);
 
-						if(!AVAILABLE_EFUSE_ADDR(eFuse_Addr))
+						if(!AVAILABLE_EFUSE_ADDR(eFuse_Addr)) 
 							break;
 					}
 				}
@@ -1696,7 +1696,7 @@ enum{
 
 	// switch bank back to bank 0 for later BT and wifi use.
 	Hal_EfuseSwitchToBank(Adapter, 0, bPseudoTest);
-
+		
 	//
 	// 3. Collect 16 sections and 4 word unit into Efuse map.
 	//
@@ -1713,10 +1713,10 @@ enum{
 	// 4. Copy from Efuse map to output pointer memory!!!
 	//
 	for(i=0; i<_size_byte; i++)
-	{
+	{		
 		pbuf[i] = efuseTbl[_offset+i];
 	}
-
+	
 	//
 	// 5. Calculate Efuse utilization.
 	//
@@ -2000,15 +2000,15 @@ enum{
 static u8
 Hal_EfuseWordEnableDataWrite(	IN	PADAPTER	pAdapter,
 							IN	u16		efuse_addr,
-							IN	u8		word_en,
+							IN	u8		word_en, 
 							IN	u8		*data,
 							IN	BOOLEAN		bPseudoTest)
-{
+{		
 	u16	tmpaddr = 0;
 	u16	start_addr = efuse_addr;
 	u8	badworden = 0x0F;
-	u8	tmpdata[8];
-
+	u8	tmpdata[8]; 
+	
 	_rtw_memset((PVOID)tmpdata, 0xff, PGPKT_DATA_SIZE);
 	//RT_TRACE(COMP_EFUSE, DBG_LOUD, ("word_en = %x efuse_addr=%x\n", word_en, efuse_addr));
 
@@ -2029,7 +2029,7 @@ enum{
 		tmpaddr = start_addr;
 		efuse_OneByteWrite(pAdapter,start_addr++, data[2], bPseudoTest);
 		efuse_OneByteWrite(pAdapter,start_addr++, data[3], bPseudoTest);
-
+				
 		efuse_OneByteRead(pAdapter,tmpaddr    , &tmpdata[2], bPseudoTest);
 		efuse_OneByteRead(pAdapter,tmpaddr+1, &tmpdata[3], bPseudoTest);
 		if((data[2]!=tmpdata[2])||(data[3]!=tmpdata[3])){
@@ -2042,7 +2042,7 @@ enum{
 		efuse_OneByteWrite(pAdapter,start_addr++, data[4], bPseudoTest);
 		efuse_OneByteWrite(pAdapter,start_addr++, data[5], bPseudoTest);
 
-		efuse_OneByteRead(pAdapter,tmpaddr, &tmpdata[4], bPseudoTest);
+		efuse_OneByteRead(pAdapter,tmpaddr, &tmpdata[4], bPseudoTest);							
 		efuse_OneByteRead(pAdapter,tmpaddr+1, &tmpdata[5], bPseudoTest);
 		if((data[4]!=tmpdata[4])||(data[5]!=tmpdata[5])){
 			badworden &=( ~BIT2);
@@ -2066,12 +2066,12 @@ enum{
 static u8
 Hal_EfuseWordEnableDataWrite_Pseudo(	IN	PADAPTER	pAdapter,
 							IN	u16		efuse_addr,
-							IN	u8		word_en,
+							IN	u8		word_en, 
 							IN	u8		*data,
 							IN	BOOLEAN		bPseudoTest)
 {
 	u8	ret=0;
-
+	
 	ret = Hal_EfuseWordEnableDataWrite(pAdapter, efuse_addr, word_en, data, bPseudoTest);
 
 	return ret;
@@ -2080,7 +2080,7 @@ enum{
 static u8
 rtl8192c_Efuse_WordEnableDataWrite(	IN	PADAPTER	pAdapter,
 							IN	u16		efuse_addr,
-							IN	u8		word_en,
+							IN	u8		word_en, 
 							IN	u8		*data,
 							IN	BOOLEAN		bPseudoTest)
 {
@@ -2094,7 +2094,7 @@ enum{
 	{
 		ret = Hal_EfuseWordEnableDataWrite(pAdapter, efuse_addr, word_en, data, bPseudoTest);
 	}
-
+	
 	return ret;
 }
 
@@ -2106,28 +2106,28 @@ enum{
 	int bContinual = _TRUE;
 
 	u16	efuse_addr = 0;
-	u8	hoffset=0,hworden=0;
+	u8	hoffset=0,hworden=0;	
 	u8	efuse_data,word_cnts=0;
-
-	while (	bContinual &&
-			efuse_OneByteRead(pAdapter, efuse_addr ,&efuse_data, bPseudoTest) &&
+		
+	while (	bContinual && 
+			efuse_OneByteRead(pAdapter, efuse_addr ,&efuse_data, bPseudoTest) && 
 			(efuse_addr  < EFUSE_REAL_CONTENT_LEN) )
-	{
+	{			
 		if(efuse_data!=0xFF)
-		{
+		{					
 			hoffset = (efuse_data>>4) & 0x0F;
-			hworden =  efuse_data & 0x0F;
+			hworden =  efuse_data & 0x0F;									
 			word_cnts = Efuse_CalculateWordCnts(hworden);
-			//read next header
-			efuse_addr = efuse_addr + (word_cnts*2)+1;
+			//read next header							
+			efuse_addr = efuse_addr + (word_cnts*2)+1;						
 		}
 		else
 		{
-			bContinual = _FALSE ;
+			bContinual = _FALSE ;			
 		}
 	}
 
-	return efuse_addr;
+	return efuse_addr;	
 }
 
 static u16
@@ -2136,7 +2136,7 @@ enum{
 {
 	int	bContinual = _TRUE;
 	u16	efuse_addr = 0;
-	u8	hoffset=0,hworden=0;
+	u8	hoffset=0,hworden=0;	
 	u8	efuse_data,word_cnts=0;
 	u8	bank=0, startBank=0;
 	u16	retU2=0;
@@ -2157,7 +2157,7 @@ enum{
 		DBG_8192C("Error, bank error, bank=%d\n", bank);
 
 	//RTPRINT(FEEPROM, EFUSE_PG, ("Hal_EfuseGetCurrentSize_BT(), start bank=%d, start_efuse_addr = %d\n", startBank, efuse_addr));
-
+	
 	for(bank=startBank; bank<EFUSE_MAX_BANK; bank++)
 	{
 		if(!Hal_EfuseSwitchToBank(pAdapter, bank, bPseudoTest))
@@ -2168,11 +2168,11 @@ enum{
 			if(bank != startBank)	// only when bank is switched we have to reset the efuse_addr.
 				efuse_addr = 0;
 		}
-
-		while (	bContinual &&
-				efuse_OneByteRead(pAdapter, efuse_addr ,&efuse_data, bPseudoTest) &&
+		
+		while (	bContinual && 
+				efuse_OneByteRead(pAdapter, efuse_addr ,&efuse_data, bPseudoTest) && 
 				AVAILABLE_EFUSE_ADDR(efuse_addr))
-		{
+		{			
 			if(efuse_data!=0xFF)
 			{
 				if((efuse_data&0x1F) == 0x0F)		//extended header
@@ -2190,15 +2190,15 @@ enum{
 						hoffset = ((hoffset & 0xE0) >> 5) | ((efuse_data & 0xF0) >> 1);
 						hworden = efuse_data & 0x0F;
 					}
-				}
+				}		
 				else
 				{
 					hoffset = (efuse_data>>4) & 0x0F;
-					hworden =  efuse_data & 0x0F;
+					hworden =  efuse_data & 0x0F;									
 				}
 				word_cnts = Efuse_CalculateWordCnts(hworden);
-				//read next header
-				efuse_addr = efuse_addr + (word_cnts*2)+1;
+				//read next header							
+				efuse_addr = efuse_addr + (word_cnts*2)+1;						
 			}
 			else
 			{
@@ -2226,7 +2226,7 @@ enum{
 	}
 
 	return retU2;
-}
+}	
 
 
 static u16
@@ -2236,7 +2236,7 @@ enum{
 	int	bContinual = _TRUE;
 
 	u16	efuse_addr = 0;
-	u8	hoffset=0,hworden=0;
+	u8	hoffset=0,hworden=0;	
 	u8	efuse_data,word_cnts=0;
 
 	if(bPseudoTest)
@@ -2248,13 +2248,13 @@ enum{
 		rtw_hal_get_hwreg(pAdapter, HW_VAR_EFUSE_BYTES, (u8 *)&efuse_addr);
 	}
 	//RTPRINT(FEEPROM, EFUSE_PG, ("hal_EfuseGetCurrentSize_8723(), start_efuse_addr = %d\n", efuse_addr));
-
-	while (	bContinual &&
-			efuse_OneByteRead(pAdapter, efuse_addr ,&efuse_data, bPseudoTest) &&
+	
+	while (	bContinual && 
+			efuse_OneByteRead(pAdapter, efuse_addr ,&efuse_data, bPseudoTest) && 
 			AVAILABLE_EFUSE_ADDR(efuse_addr))
-	{
+	{			
 		if(efuse_data!=0xFF)
-		{
+		{					
 			if((efuse_data&0x1F) == 0x0F)		//extended header
 			{
 				hoffset = efuse_data;
@@ -2270,19 +2270,19 @@ enum{
 					hoffset = ((hoffset & 0xE0) >> 5) | ((efuse_data & 0xF0) >> 1);
 					hworden = efuse_data & 0x0F;
 				}
-			}
+			}		
 			else
 			{
 				hoffset = (efuse_data>>4) & 0x0F;
-				hworden =  efuse_data & 0x0F;
+				hworden =  efuse_data & 0x0F;									
 			}
 			word_cnts = Efuse_CalculateWordCnts(hworden);
-			//read next header
-			efuse_addr = efuse_addr + (word_cnts*2)+1;
+			//read next header							
+			efuse_addr = efuse_addr + (word_cnts*2)+1;						
 		}
 		else
 		{
-			bContinual = _FALSE ;
+			bContinual = _FALSE ;			
 		}
 	}
 
@@ -2296,16 +2296,16 @@ enum{
 		rtw_hal_set_hwreg(pAdapter, HW_VAR_EFUSE_BYTES, (u8 *)&efuse_addr);
 		//RTPRINT(FEEPROM, EFUSE_PG, ("hal_EfuseGetCurrentSize_8723(), return %d\n", efuse_addr));
 	}
-
-	return efuse_addr;
-}
+	
+	return efuse_addr;	
+}	
 
 static u16
 Hal_EfuseGetCurrentSize_Pseudo(IN	PADAPTER	pAdapter,
 		IN		BOOLEAN			bPseudoTest)
 {
 	u16	ret=0;
-
+	
 	ret = hal_EfuseGetCurrentSize_8723(pAdapter, bPseudoTest);
 
 	return ret;
@@ -2350,38 +2350,38 @@ enum{
 					IN	u8			offset,
 					IN	u8			*data,
 					IN	BOOLEAN			bPseudoTest)
-{
-	u8	ReadState = PG_STATE_HEADER;
-
+{	
+	u8	ReadState = PG_STATE_HEADER;	
+	
 	int	bContinual = _TRUE;
-	int	bDataEmpty = _TRUE ;
+	int	bDataEmpty = _TRUE ;	
 
 	u8	efuse_data,word_cnts=0;
 	u16	efuse_addr = 0;
-	u8	hoffset=0,hworden=0;
+	u8	hoffset=0,hworden=0;	
 	u8	tmpidx=0;
 	u8	tmpdata[8];
-
+	
 	if(data==NULL)	return _FALSE;
-	if(offset>15)		return _FALSE;
-
+	if(offset>15)		return _FALSE;	
+	
 
 	_rtw_memset((PVOID)data, 0xff, sizeof(u8)*PGPKT_DATA_SIZE);
 	_rtw_memset((PVOID)tmpdata, 0xff, sizeof(u8)*PGPKT_DATA_SIZE);
-
+	
 	//
 	// <Roger_TODO> Efuse has been pre-programmed dummy 5Bytes at the end of Efuse by CP.
 	// Skip dummy parts to prevent unexpected data read from Efuse.
 	// By pass right now. 2009.02.19.
 	//
 	while(bContinual && (efuse_addr  < EFUSE_REAL_CONTENT_LEN) )
-	{
+	{			
 		//-------  Header Read -------------
 		if(ReadState & PG_STATE_HEADER)
 		{
-			if(efuse_OneByteRead(pAdapter, efuse_addr ,&efuse_data, bPseudoTest)&&(efuse_data!=0xFF)){
+			if(efuse_OneByteRead(pAdapter, efuse_addr ,&efuse_data, bPseudoTest)&&(efuse_data!=0xFF)){				
 				hoffset = (efuse_data>>4) & 0x0F;
-				hworden =  efuse_data & 0x0F;
+				hworden =  efuse_data & 0x0F;									
 				word_cnts = Efuse_CalculateWordCnts(hworden);
 				bDataEmpty = _TRUE ;
 
@@ -2389,38 +2389,38 @@ enum{
 					for(tmpidx = 0;tmpidx< word_cnts*2 ;tmpidx++){
 						if(efuse_OneByteRead(pAdapter, efuse_addr+1+tmpidx ,&efuse_data, bPseudoTest) ){
 							tmpdata[tmpidx] = efuse_data;
-							if(efuse_data!=0xff){
+							if(efuse_data!=0xff){						
 								bDataEmpty = _FALSE;
 							}
-						}
+						}					
 					}
 					if(bDataEmpty==_FALSE){
-						ReadState = PG_STATE_DATA;
-					}else{//read next header
+						ReadState = PG_STATE_DATA;							
+					}else{//read next header							
 						efuse_addr = efuse_addr + (word_cnts*2)+1;
-						ReadState = PG_STATE_HEADER;
+						ReadState = PG_STATE_HEADER; 
 					}
 				}
-				else{//read next header
+				else{//read next header	
 					efuse_addr = efuse_addr + (word_cnts*2)+1;
-					ReadState = PG_STATE_HEADER;
+					ReadState = PG_STATE_HEADER; 
 				}
-
+				
 			}
 			else{
 				bContinual = _FALSE ;
 			}
-		}
+		}		
 		//-------  Data section Read -------------
 		else if(ReadState & PG_STATE_DATA)
 		{
 			efuse_WordEnableDataRead(hworden,tmpdata,data);
 			efuse_addr = efuse_addr + (word_cnts*2)+1;
-			ReadState = PG_STATE_HEADER;
+			ReadState = PG_STATE_HEADER; 
 		}
-
+		
 	}
-
+		
 	if(	(data[0]==0xff) &&(data[1]==0xff) && (data[2]==0xff)  && (data[3]==0xff) &&
 		(data[4]==0xff) &&(data[5]==0xff) && (data[6]==0xff)  && (data[7]==0xff))
 		return _FALSE;
@@ -2434,22 +2434,22 @@ enum{
 					IN	u8			offset,
 					IN	u8			*data,
 					IN	BOOLEAN			bPseudoTest)
-{
-	u8	ReadState = PG_STATE_HEADER;
-
+{	
+	u8	ReadState = PG_STATE_HEADER;	
+	
 	int	bContinual = _TRUE;
-	int	bDataEmpty = _TRUE ;
+	int	bDataEmpty = _TRUE ;	
 
 	u8	efuse_data,word_cnts=0;
 	u16	efuse_addr = 0;
-	u8	hoffset=0,hworden=0;
+	u8	hoffset=0,hworden=0;	
 	u8	tmpidx=0;
 	u8	tmpdata[8];
 	u8	max_section=0;
 	u8	tmp_header = 0;
 
 	EFUSE_GetEfuseDefinition(pAdapter, EFUSE_WIFI, TYPE_EFUSE_MAX_SECTION, (PVOID)&max_section, bPseudoTest);
-
+	
 	if(data==NULL)
 		return _FALSE;
 	if(offset>max_section)
@@ -2457,19 +2457,19 @@ enum{
 
 	_rtw_memset((PVOID)data, 0xff, sizeof(u8)*PGPKT_DATA_SIZE);
 	_rtw_memset((PVOID)tmpdata, 0xff, sizeof(u8)*PGPKT_DATA_SIZE);
-
-
+	
+	
 	//
 	// <Roger_TODO> Efuse has been pre-programmed dummy 5Bytes at the end of Efuse by CP.
 	// Skip dummy parts to prevent unexpected data read from Efuse.
 	// By pass right now. 2009.02.19.
 	//
 	while(bContinual && AVAILABLE_EFUSE_ADDR(efuse_addr) )
-	{
+	{			
 		//-------  Header Read -------------
 		if(ReadState & PG_STATE_HEADER)
 		{
-			if(efuse_OneByteRead(pAdapter, efuse_addr ,&efuse_data, bPseudoTest)&&(efuse_data!=0xFF))
+			if(efuse_OneByteRead(pAdapter, efuse_addr ,&efuse_data, bPseudoTest)&&(efuse_data!=0xFF))			
 			{
 				if(EXT_HEADER(efuse_data))
 				{
@@ -2479,7 +2479,7 @@ enum{
 					if(!ALL_WORDS_DISABLED(efuse_data))
 					{
 						hoffset = ((tmp_header & 0xE0) >> 5) | ((efuse_data & 0xF0) >> 1);
-						hworden = efuse_data & 0x0F;
+						hworden = efuse_data & 0x0F;						
 					}
 					else
 					{
@@ -2488,10 +2488,10 @@ enum{
 						continue;
 					}
 				}
-				else
+				else	
 				{
 					hoffset = (efuse_data>>4) & 0x0F;
-					hworden =  efuse_data & 0x0F;
+					hworden =  efuse_data & 0x0F;									
 				}
 				word_cnts = Efuse_CalculateWordCnts(hworden);
 				bDataEmpty = _TRUE ;
@@ -2504,38 +2504,38 @@ enum{
 						{
 							tmpdata[tmpidx] = efuse_data;
 							if(efuse_data!=0xff)
-							{
+							{						
 								bDataEmpty = _FALSE;
 							}
-						}
+						}					
 					}
 					if(bDataEmpty==_FALSE){
-						ReadState = PG_STATE_DATA;
-					}else{//read next header
+						ReadState = PG_STATE_DATA;							
+					}else{//read next header							
 						efuse_addr = efuse_addr + (word_cnts*2)+1;
-						ReadState = PG_STATE_HEADER;
+						ReadState = PG_STATE_HEADER; 
 					}
 				}
-				else{//read next header
+				else{//read next header	
 					efuse_addr = efuse_addr + (word_cnts*2)+1;
-					ReadState = PG_STATE_HEADER;
+					ReadState = PG_STATE_HEADER; 
 				}
-
+				
 			}
 			else{
 				bContinual = _FALSE ;
 			}
-		}
+		}		
 		//-------  Data section Read -------------
 		else if(ReadState & PG_STATE_DATA)
 		{
 			efuse_WordEnableDataRead(hworden,tmpdata,data);
 			efuse_addr = efuse_addr + (word_cnts*2)+1;
-			ReadState = PG_STATE_HEADER;
+			ReadState = PG_STATE_HEADER; 
 		}
-
-	}
-
+		
+	}			
+	
 	if(	(data[0]==0xff) &&(data[1]==0xff) && (data[2]==0xff)  && (data[3]==0xff) &&
 		(data[4]==0xff) &&(data[5]==0xff) && (data[6]==0xff)  && (data[7]==0xff))
 		return _FALSE;
@@ -2571,7 +2571,7 @@ enum{
 					IN	BOOLEAN		bPseudoTest)
 {
 	int	ret=0;
-
+	
 	ret = hal_EfusePgPacketRead_8723(pAdapter, offset, data, bPseudoTest);
 
 	return ret;
@@ -2609,9 +2609,9 @@ enum{
 	u8	originaldata[8], badworden=0;
 	u16	efuse_addr=*pAddr;
 	u32	PgWriteSuccess=0;
-
+	
 	_rtw_memset((PVOID)originaldata, 0xff, 8);
-
+					
 	if(Efuse_PgPacketRead(pAdapter, pFixPkt->offset, originaldata, bPseudoTest))
 	{	//check if data exist
 		badworden = Efuse_WordEnableDataWrite(pAdapter, efuse_addr+1, pFixPkt->word_en, originaldata, bPseudoTest);
@@ -2674,7 +2674,7 @@ enum{
 			efuse_OneByteWrite(pAdapter, efuse_addr, pg_header, bPseudoTest);
 			efuse_OneByteRead(pAdapter, efuse_addr, &tmp_header, bPseudoTest);
 		}
-
+		
 		//to write ext_header
 		if(tmp_header == pg_header)
 		{
@@ -2686,12 +2686,12 @@ enum{
 			efuse_OneByteRead(pAdapter, efuse_addr, &tmp_header, bPseudoTest);
 
 			while(tmp_header == 0xFF)
-			{
+			{											
 				if(repeatcnt++ > EFUSE_REPEAT_THRESHOLD_)
 				{
 					//RTPRINT(FEEPROM, EFUSE_PG, ("Repeat over limit for ext_header!!\n"));
 					return _FALSE;
-				}
+				}							
 
 				efuse_OneByteWrite(pAdapter, efuse_addr, pg_header, bPseudoTest);
 				efuse_OneByteRead(pAdapter, efuse_addr, &tmp_header, bPseudoTest);
@@ -2710,12 +2710,12 @@ enum{
 					continue;
 				}
 			}
-			else if(pg_header != tmp_header)	//offset PG fail
+			else if(pg_header != tmp_header)	//offset PG fail						
 			{
 				PGPKT_STRUCT	fixPkt;
 				//RTPRINT(FEEPROM, EFUSE_PG, ("Error condition for offset PG fail, need to cover the existed data\n"));
 				fixPkt.offset = ((pg_header_temp & 0xE0) >> 5) | ((tmp_header & 0xF0) >> 1);
-				fixPkt.word_en = tmp_header & 0x0F;
+				fixPkt.word_en = tmp_header & 0x0F;					
 				fixPkt.word_cnts = Efuse_CalculateWordCnts(fixPkt.word_en);
 				if(!hal_EfuseFixHeaderProcess(pAdapter, efuseType, &fixPkt, &efuse_addr, bPseudoTest))
 					return _FALSE;
@@ -2729,7 +2729,7 @@ enum{
 		else if ((tmp_header & 0x1F) == 0x0F)		//wrong extended header
 		{
 			efuse_addr+=2;
-			continue;
+			continue;						
 		}
 	}
 
@@ -2739,7 +2739,7 @@ enum{
 
 static BOOLEAN
 hal_EfusePgPacketWrite1ByteHeader(
-	IN			PADAPTER		pAdapter,
+	IN			PADAPTER		pAdapter, 
 	IN			u8				efuseType,
 	IN			u16				*pAddr,
 	IN			PPGPKT_STRUCT	pTargetPkt,
@@ -2752,7 +2752,7 @@ enum{
 
 	//RTPRINT(FEEPROM, EFUSE_PG, ("Wirte 1byte header\n"));
 	pg_header = ((pTargetPkt->offset << 4) & 0xf0) |pTargetPkt->word_en;
-
+	
 	efuse_OneByteWrite(pAdapter, efuse_addr, pg_header, bPseudoTest);
 	efuse_OneByteRead(pAdapter, efuse_addr, &tmp_header, bPseudoTest);
 
@@ -2765,7 +2765,7 @@ enum{
 		efuse_OneByteWrite(pAdapter,efuse_addr, pg_header, bPseudoTest);
 		efuse_OneByteRead(pAdapter,efuse_addr, &tmp_header, bPseudoTest);
 	}
-
+	
 	if(pg_header == tmp_header)
 	{
 		bRet = _TRUE;
@@ -2775,19 +2775,19 @@ enum{
 		PGPKT_STRUCT	fixPkt;
 		//RTPRINT(FEEPROM, EFUSE_PG, ("Error condition for fixed PG packet, need to cover the existed data\n"));
 		fixPkt.offset = (tmp_header>>4) & 0x0F;
-		fixPkt.word_en = tmp_header & 0x0F;
+		fixPkt.word_en = tmp_header & 0x0F;					
 		fixPkt.word_cnts = Efuse_CalculateWordCnts(fixPkt.word_en);
 		if(!hal_EfuseFixHeaderProcess(pAdapter, efuseType, &fixPkt, &efuse_addr, bPseudoTest))
 			return _FALSE;
 	}
-
+	
 	*pAddr = efuse_addr;
 	return bRet;
 }
 
 static BOOLEAN
 hal_EfusePgPacketWriteData(
-	IN			PADAPTER		pAdapter,
+	IN			PADAPTER		pAdapter, 
 	IN			u8				efuseType,
 	IN			u16				*pAddr,
 	IN			PPGPKT_STRUCT	pTargetPkt,
@@ -2825,7 +2825,7 @@ enum{
 
 static BOOLEAN
 hal_EfusePgPacketWriteHeader(
-	IN			PADAPTER		pAdapter,
+	IN			PADAPTER		pAdapter, 
 	IN			u8				efuseType,
 	IN			u16				*pAddr,
 	IN			PPGPKT_STRUCT	pTargetPkt,
@@ -2853,7 +2853,7 @@ enum{
 	)
 {
 	u16	efuse_max_available_len=0;
-
+	
 	EFUSE_GetEfuseDefinition(pAdapter, efuseType, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (PVOID)&efuse_max_available_len, bPseudoTest);
 	//RTPRINT(FEEPROM, EFUSE_PG, ("efuse_max_available_len = %d\n", efuse_max_available_len));
 
@@ -2893,7 +2893,7 @@ enum{
 {
 	BOOLEAN		bRet=_FALSE;
 	u8	i, efuse_data;
-
+	
 	for(i=0; i<(word_cnts*2) ; i++)
 	{
 		if(efuse_OneByteRead(pAdapter, (startAddr+i) ,&efuse_data, bPseudoTest)&&(efuse_data != 0xFF))
@@ -2988,12 +2988,12 @@ enum{
 
 	while(1)
 	{
-		if(startAddr >= efuse_max_available_len)
+		if(startAddr >= efuse_max_available_len) 
 		{
 			bRet = _FALSE;
 			break;
 		}
-
+		
 		if(efuse_OneByteRead(pAdapter, startAddr, &efuse_data, bPseudoTest) && (efuse_data!=0xFF))
 		{
 			if(EXT_HEADER(efuse_data))
@@ -3015,7 +3015,7 @@ enum{
 			}
 			else
 			{
-				cur_header  =  efuse_data;
+				cur_header  =  efuse_data;					
 				curPkt.offset = (cur_header>>4) & 0x0F;
 				curPkt.word_en = cur_header & 0x0F;
 			}
@@ -3023,7 +3023,7 @@ enum{
 			curPkt.word_cnts = Efuse_CalculateWordCnts(curPkt.word_en);
 			// if same header is found but no data followed
 			// write some part of data followed by the header.
-			if( (curPkt.offset == pTargetPkt->offset) &&
+			if( (curPkt.offset == pTargetPkt->offset) && 
 				(!hal_EfuseCheckIfDatafollowed(pAdapter, curPkt.word_cnts, startAddr+1, bPseudoTest)) &&
 				wordEnMatched(pTargetPkt, &curPkt, &matched_wden) )
 			{
@@ -3043,9 +3043,9 @@ enum{
 					{
 						bRet = _FALSE;	// write fail, return
 						break;
-					}
+					}					
 				}
-				// partial write ok, update the target packet for later use
+				// partial write ok, update the target packet for later use		
 				for(i=0; i<4; i++)
 				{
 					if((matched_wden & (0x1<<i)) == 0)	// this word has been written
@@ -3056,7 +3056,7 @@ enum{
 				pTargetPkt->word_cnts = Efuse_CalculateWordCnts(pTargetPkt->word_en);
 			}
 			// read from next header
-			startAddr = startAddr + (curPkt.word_cnts*2) +1;
+			startAddr = startAddr + (curPkt.word_cnts*2) +1;	
 		}
 		else
 		{
@@ -3066,13 +3066,13 @@ enum{
 			bRet = _TRUE;
 			break;
 		}
-	}
+	}	
 	return bRet;
 }
 
-static BOOLEAN
+static BOOLEAN 
 hal_EfusePgPacketWrite_BT(
-					IN	PADAPTER	pAdapter,
+					IN	PADAPTER	pAdapter, 
 					IN	u8 			offset,
 					IN	u8			word_en,
 					IN	u8			*pData,
@@ -3082,7 +3082,7 @@ enum{
 	PGPKT_STRUCT 	targetPkt;
 	u16	startAddr=0;
 	u8	efuseType=EFUSE_BT;
-
+	
 	if(!hal_EfusePgCheckAvailableAddr(pAdapter, efuseType, bPseudoTest))
 		return _FALSE;
 
@@ -3100,9 +3100,9 @@ enum{
 	return _TRUE;
 }
 
-static BOOLEAN
+static BOOLEAN 
 hal_EfusePgPacketWrite_8723(
-					IN	PADAPTER		pAdapter,
+					IN	PADAPTER		pAdapter, 
 					IN	u8 			offset,
 					IN	u8			word_en,
 					IN	u8			*pData,
@@ -3112,7 +3112,7 @@ enum{
 	PGPKT_STRUCT 	targetPkt;
 	u16			startAddr=0;
 	u8			efuseType=EFUSE_WIFI;
-
+	
 	if(!hal_EfusePgCheckAvailableAddr(pAdapter, efuseType, bPseudoTest))
 		return _FALSE;
 
@@ -3131,13 +3131,13 @@ enum{
 }
 
 static int
-hal_EfusePgPacketWrite_8192C(IN	PADAPTER	pAdapter,
+hal_EfusePgPacketWrite_8192C(IN	PADAPTER	pAdapter, 
 					IN	u8 			offset,
 					IN	u8			word_en,
 					IN	u8			*data,
 					IN	BOOLEAN		bPseudoTest)
 {
-	u8	WriteState = PG_STATE_HEADER;
+	u8	WriteState = PG_STATE_HEADER;		
 
 	int	bContinual = _TRUE,bDataEmpty=_TRUE, bResult = _TRUE;
 	u16	efuse_addr = 0;
@@ -3148,9 +3148,9 @@ enum{
 	u8	tmp_word_cnts=0,target_word_cnts=0;
 	u8	tmp_header,match_word_en,tmp_word_en;
 
-	PGPKT_STRUCT target_pkt;
+	PGPKT_STRUCT target_pkt;	
 	PGPKT_STRUCT tmp_pkt;
-
+	
 	u8	originaldata[sizeof(u8)*8];
 	u8	tmpindex = 0,badworden = 0x0F;
 
@@ -3175,7 +3175,7 @@ enum{
 	target_pkt.word_en= word_en;
 
 	_rtw_memset((PVOID)target_pkt.data, 0xFF, sizeof(u8)*8);
-
+	
 	efuse_WordEnableDataRead(word_en,data,target_pkt.data);
 	target_word_cnts = Efuse_CalculateWordCnts(target_pkt.word_en);
 
@@ -3190,20 +3190,20 @@ enum{
 	//
 	while( bContinual && (efuse_addr  < (EFUSE_REAL_CONTENT_LEN-EFUSE_OOB_PROTECT_BYTES)) )
 	{
-
+		
 		if(WriteState==PG_STATE_HEADER)
-		{
+		{	
 			bDataEmpty=_TRUE;
-			badworden = 0x0F;
+			badworden = 0x0F;		
 			//************  so *******************
 			//RTPRINT(FEEPROM, EFUSE_PG, ("EFUSE PG_STATE_HEADER\n"));
 			if (	efuse_OneByteRead(pAdapter, efuse_addr ,&efuse_data, bPseudoTest) &&
 				(efuse_data!=0xFF))
-			{
+			{ 	
 				tmp_header  =  efuse_data;
-
+				
 				tmp_pkt.offset 	= (tmp_header>>4) & 0x0F;
-				tmp_pkt.word_en 	= tmp_header & 0x0F;
+				tmp_pkt.word_en 	= tmp_header & 0x0F;					
 				tmp_word_cnts =  Efuse_CalculateWordCnts(tmp_pkt.word_en);
 
 				//************  so-1 *******************
@@ -3215,18 +3215,18 @@ enum{
 					#endif
 				}
 				else
-				{
+				{	
 					//************  so-2 *******************
 					for(tmpindex=0 ; tmpindex<(tmp_word_cnts*2) ; tmpindex++)
 					{
 						if(efuse_OneByteRead(pAdapter, (efuse_addr+1+tmpindex) ,&efuse_data, bPseudoTest)&&(efuse_data != 0xFF)){
-							bDataEmpty = _FALSE;
+							bDataEmpty = _FALSE;	
 						}
-					}
+					}	
 					//************  so-2-1 *******************
 					if(bDataEmpty == _FALSE)
-					{
-						efuse_addr = efuse_addr + (tmp_word_cnts*2) +1; //Next pg_packet
+					{						
+						efuse_addr = efuse_addr + (tmp_word_cnts*2) +1; //Next pg_packet										
 						#if (EFUSE_ERROE_HANDLE == 1)
 						WriteState=PG_STATE_HEADER;
 						#endif
@@ -3237,7 +3237,7 @@ enum{
 						if(   !( (target_pkt.word_en&BIT0)|(tmp_pkt.word_en&BIT0)  ))
 						{
 							 match_word_en &= (~BIT0);
-						}
+						}	
 						if(   !( (target_pkt.word_en&BIT1)|(tmp_pkt.word_en&BIT1)  ))
 						{
 							 match_word_en &= (~BIT1);
@@ -3249,24 +3249,24 @@ enum{
 						if(   !( (target_pkt.word_en&BIT3)|(tmp_pkt.word_en&BIT3)  ))
 						{
 							 match_word_en &= (~BIT3);
-						}
-
+						}					
+												
 						//************  so-2-2-A *******************
 						if((match_word_en&0x0F)!=0x0F)
-						{
+						{							
 							badworden = Efuse_WordEnableDataWrite(pAdapter,efuse_addr+1, tmp_pkt.word_en ,target_pkt.data, bPseudoTest);
-
+							
 							//************  so-2-2-A-1 *******************
 							//############################
 							if(0x0F != (badworden&0x0F))
-							{
+							{														
 								u8	reorg_offset = offset;
-								u8	reorg_worden=badworden;
+								u8	reorg_worden=badworden;								
 								Efuse_PgPacketWrite(pAdapter,reorg_offset,reorg_worden,originaldata, bPseudoTest);
-							}
-							//############################
+							}	
+							//############################						
 
-							tmp_word_en = 0x0F;
+							tmp_word_en = 0x0F;	
 							if(  (target_pkt.word_en&BIT0)^(match_word_en&BIT0)  )
 							{
 								tmp_word_en &= (~BIT0);
@@ -3278,22 +3278,22 @@ enum{
 							if(   (target_pkt.word_en&BIT2)^(match_word_en&BIT2) )
 							{
 								tmp_word_en &= (~BIT2);
-							}
+							}						
 							if(   (target_pkt.word_en&BIT3)^(match_word_en&BIT3) )
 							{
 								tmp_word_en &=(~BIT3);
-							}
-
-							//************  so-2-2-A-2 *******************
+							}							
+						
+							//************  so-2-2-A-2 *******************	
 							if((tmp_word_en&0x0F)!=0x0F){
-								//reorganize other pg packet
-								//efuse_addr = efuse_addr + (2*tmp_word_cnts) +1;//next pg packet addr
+								//reorganize other pg packet						
+								//efuse_addr = efuse_addr + (2*tmp_word_cnts) +1;//next pg packet addr							
 								efuse_addr = Efuse_GetCurrentSize(pAdapter, efuseType, bPseudoTest);
 								//===========================
 								target_pkt.offset = offset;
-								target_pkt.word_en= tmp_word_en;
+								target_pkt.word_en= tmp_word_en;					
 								//===========================
-							}else{
+							}else{								
 								bContinual = _FALSE;
 							}
 							#if (EFUSE_ERROE_HANDLE == 1)
@@ -3306,18 +3306,18 @@ enum{
 							#endif
 						}
 						else{//************  so-2-2-B *******************
-							//reorganize other pg packet
-							efuse_addr = efuse_addr + (2*tmp_word_cnts) +1;//next pg packet addr
+							//reorganize other pg packet						
+							efuse_addr = efuse_addr + (2*tmp_word_cnts) +1;//next pg packet addr							
 							//===========================
 							target_pkt.offset = offset;
-							target_pkt.word_en= target_pkt.word_en;
-							//===========================
+							target_pkt.word_en= target_pkt.word_en;					
+							//===========================			
 							#if (EFUSE_ERROE_HANDLE == 1)
 							WriteState=PG_STATE_HEADER;
 							#endif
-						}
-					}
-				}
+						}		
+					}				
+				}				
 				//RTPRINT(FEEPROM, EFUSE_PG, ("EFUSE PG_STATE_HEADER-1\n"));
 			}
 			else		//************  s1: header == oxff  *******************
@@ -3326,15 +3326,15 @@ enum{
 
 				efuse_OneByteWrite(pAdapter,efuse_addr, pg_header, bPseudoTest);
 				efuse_OneByteRead(pAdapter,efuse_addr, &tmp_header, bPseudoTest);
-
+		
 				if(tmp_header == pg_header)
-				{ //************  s1-1*******************
-					WriteState = PG_STATE_DATA;
-				}
+				{ //************  s1-1*******************								
+					WriteState = PG_STATE_DATA;						
+				}				
 				#if (EFUSE_ERROE_HANDLE == 1)
-				else if(tmp_header == 0xFF){//************  s1-3: if Write or read func doesn't work *******************
+				else if(tmp_header == 0xFF){//************  s1-3: if Write or read func doesn't work *******************		
 					//efuse_addr doesn't change
-					WriteState = PG_STATE_HEADER;
+					WriteState = PG_STATE_HEADER;					
 					repeat_times++;
 					if(repeat_times>EFUSE_REPEAT_THRESHOLD_){
 						bContinual = _FALSE;
@@ -3343,30 +3343,30 @@ enum{
 				}
 				#endif
 				else
-				{//************  s1-2 : fixed the header procedure *******************
+				{//************  s1-2 : fixed the header procedure *******************							
 					tmp_pkt.offset = (tmp_header>>4) & 0x0F;
-					tmp_pkt.word_en=  tmp_header & 0x0F;
+					tmp_pkt.word_en=  tmp_header & 0x0F;					
 					tmp_word_cnts =  Efuse_CalculateWordCnts(tmp_pkt.word_en);
-
+																											
 					//************  s1-2-A :cover the exist data *******************
 					//memset(originaldata,0xff,sizeof(UINT8)*8);
 					_rtw_memset((PVOID)originaldata, 0xff, sizeof(u8)*8);
-
+					
 					if(Efuse_PgPacketRead( pAdapter, tmp_pkt.offset,originaldata, bPseudoTest))
-					{	//check if data exist
+					{	//check if data exist 					
 						//efuse_reg_ctrl(pAdapter,_TRUE);//power on
-						badworden = Efuse_WordEnableDataWrite(pAdapter,efuse_addr+1,tmp_pkt.word_en,originaldata, bPseudoTest);
+						badworden = Efuse_WordEnableDataWrite(pAdapter,efuse_addr+1,tmp_pkt.word_en,originaldata, bPseudoTest);	
 						//############################
 						if(0x0F != (badworden&0x0F))
-						{
+						{														
 							u8	reorg_offset = tmp_pkt.offset;
-							u8	reorg_worden=badworden;
+							u8	reorg_worden=badworden;								
 							Efuse_PgPacketWrite(pAdapter,reorg_offset,reorg_worden,originaldata, bPseudoTest);
-							efuse_addr = Efuse_GetCurrentSize(pAdapter, efuseType, bPseudoTest);
+							efuse_addr = Efuse_GetCurrentSize(pAdapter, efuseType, bPseudoTest);	 
 						}
 						//############################
 						else{
-							efuse_addr = efuse_addr + (tmp_word_cnts*2) +1; //Next pg_packet
+							efuse_addr = efuse_addr + (tmp_word_cnts*2) +1; //Next pg_packet							
 						}
 					}
 					 //************  s1-2-B: wrong address*******************
@@ -3376,14 +3376,14 @@ enum{
 					}
 
 					#if (EFUSE_ERROE_HANDLE == 1)
-					WriteState=PG_STATE_HEADER;
+					WriteState=PG_STATE_HEADER;	
 					repeat_times++;
 					if(repeat_times>EFUSE_REPEAT_THRESHOLD_){
 						bContinual = _FALSE;
 						bResult = _FALSE;
 					}
 					#endif
-
+					
 					//RTPRINT(FEEPROM, EFUSE_PG, ("EFUSE PG_STATE_HEADER-2\n"));
 				}
 
@@ -3391,11 +3391,11 @@ enum{
 
 		}
 		//write data state
-		else if(WriteState==PG_STATE_DATA)
+		else if(WriteState==PG_STATE_DATA) 
 		{	//************  s1-1  *******************
 			//RTPRINT(FEEPROM, EFUSE_PG, ("EFUSE PG_STATE_DATA\n"));
 			badworden = 0x0f;
-			badworden = Efuse_WordEnableDataWrite(pAdapter,efuse_addr+1,target_pkt.word_en,target_pkt.data, bPseudoTest);
+			badworden = Efuse_WordEnableDataWrite(pAdapter,efuse_addr+1,target_pkt.word_en,target_pkt.data, bPseudoTest);	
 			if((badworden&0x0F)==0x0F)
 			{ //************  s1-1-A *******************
 				bContinual = _FALSE;
@@ -3403,14 +3403,14 @@ enum{
 			else
 			{//reorganize other pg packet //************  s1-1-B *******************
 				efuse_addr = efuse_addr + (2*target_word_cnts) +1;//next pg packet addr
-
+										
 				//===========================
 				target_pkt.offset = offset;
-				target_pkt.word_en= badworden;
-				target_word_cnts =  Efuse_CalculateWordCnts(target_pkt.word_en);
-				//===========================
+				target_pkt.word_en= badworden;		
+				target_word_cnts =  Efuse_CalculateWordCnts(target_pkt.word_en); 
+				//===========================			
 				#if (EFUSE_ERROE_HANDLE == 1)
-				WriteState=PG_STATE_HEADER;
+				WriteState=PG_STATE_HEADER;	
 				repeat_times++;
 				if(repeat_times>EFUSE_REPEAT_THRESHOLD_){
 					bContinual = _FALSE;
@@ -3427,26 +3427,26 @@ enum{
 		//RT_TRACE(COMP_EFUSE, DBG_LOUD, ("hal_EfusePgPacketWrite_8192C(): efuse_addr(%#x) Out of size!!\n", efuse_addr));
 	}
 	//efuse_reg_ctrl(pAdapter,_FALSE);//power off
-
+	
 	return _TRUE;
 }
 
-static int
-Hal_EfusePgPacketWrite_Pseudo(IN	PADAPTER	pAdapter,
+static int 
+Hal_EfusePgPacketWrite_Pseudo(IN	PADAPTER	pAdapter, 
 					IN	u8 			offset,
 					IN	u8			word_en,
 					IN	u8			*data,
 					IN	BOOLEAN		bPseudoTest)
 {
 	int ret;
-
+	
 	ret = hal_EfusePgPacketWrite_8723(pAdapter, offset, word_en, data, bPseudoTest);
 
 	return ret;
 }
 
 static int
-Hal_EfusePgPacketWrite(IN	PADAPTER	pAdapter,
+Hal_EfusePgPacketWrite(IN	PADAPTER	pAdapter, 
 					IN	u8 			offset,
 					IN	u8			word_en,
 					IN	u8			*data,
@@ -3466,8 +3466,8 @@ enum{
 	return ret;
 }
 
-static int
-rtl8192c_Efuse_PgPacketWrite(IN	PADAPTER	pAdapter,
+static int 
+rtl8192c_Efuse_PgPacketWrite(IN	PADAPTER	pAdapter, 
 					IN	u8 			offset,
 					IN	u8			word_en,
 					IN	u8			*data,
@@ -3495,7 +3495,7 @@ enum{
 	EEPROM_EFUSE_PRIV *pEEPROM = GET_EEPROM_EFUSE_PRIV(pAdapter);
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
 	u16			i,EEPROMId;
-
+	
 	// Checl 0x8129 again for making sure autoload status!!
 	EEPROMId = *((u16 *)&hwinfo[0]);
 	if( le16_to_cpu(EEPROMId) != RTL_EEPROM_ID)
@@ -3544,7 +3544,7 @@ s32 c2h_id_filter_ccx_8192c(u8 id)
 	s32 ret = _FALSE;
 	if (id == C2H_CCX_TX_RPT)
 		ret = _TRUE;
-
+	
 	return ret;
 }
 
@@ -3608,7 +3608,7 @@ void rtl8192c_set_hal_ops(struct hal_ops *pHalFunc)
 
 #ifdef DBG_CONFIG_ERROR_DETECT
 	pHalFunc->sreset_init_value = &sreset_init_value;
-	pHalFunc->sreset_reset_value = &sreset_reset_value;
+	pHalFunc->sreset_reset_value = &sreset_reset_value;	
 	pHalFunc->silentreset = &sreset_reset;
 	pHalFunc->sreset_xmit_status_check = &rtl8192c_sreset_xmit_status_check;
 	pHalFunc->sreset_linked_status_check  = &rtl8192c_sreset_linked_status_check;
@@ -3625,3 +3625,4 @@ void rtl8192c_set_hal_ops(struct hal_ops *pHalFunc)
 	pHalFunc->c2h_handler = c2h_handler_8192c;
 	pHalFunc->c2h_id_filter_ccx = c2h_id_filter_ccx_8192c;
 }
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_mp.c b/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_mp.c
old mode 100644
new mode 100755
index 4d574d3..a4194c4
--- a/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_mp.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_mp.c
@@ -880,7 +880,7 @@ s32 Hal_SetThermalMeter(PADAPTER pAdapter, u8 target_ther)
 
 void Hal_TriggerRFThermalMeter(PADAPTER pAdapter)
 {
-
+  
 	write_rfreg(pAdapter, RF_PATH_A, RF_T_METER, 0x60);	// 0x24: RF Reg[6:5]
 
 //	RT_TRACE(_module_mp_,_drv_alert_, ("TriggerRFThermalMeter() finished.\n" ));
@@ -987,7 +987,7 @@ void Hal_SetSingleToneTx(PADAPTER pAdapter, u8 bStart)
 		write_bbreg(pAdapter, rFPGA0_RFMOD, bOFDMEn, 0x0);
 
 		if (is92C)
-		 {
+       		 {
 			_write_rfreg(pAdapter, RF_PATH_A, 0x21, BIT19, 0x01);
 			rtw_usleep_os(100);
 			if (rfPath == RF_PATH_A)
@@ -998,7 +998,7 @@ void Hal_SetSingleToneTx(PADAPTER pAdapter, u8 bStart)
 			write_rfreg(pAdapter, rfPath, 0x21, 0xd4000);
 			rtw_usleep_os(100);
 		}
-
+		
 		write_rfreg(pAdapter, rfPath, 0x00, 0x2001f); // PAD all on.
 		rtw_usleep_os(100);
 	}
@@ -1022,7 +1022,7 @@ void Hal_SetSingleToneTx(PADAPTER pAdapter, u8 bStart)
 			rtw_usleep_os(100);
 		}
 	}
-
+	
 }
 
 
diff --git a/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_phycfg.c b/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_phycfg.c
old mode 100644
new mode 100755
index 8b19ced..1bae6da
--- a/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_phycfg.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_phycfg.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -19,25 +19,25 @@
  ******************************************************************************/
 /******************************************************************************
 
- Module:	rtl8192c_phycfg.c
+ Module:	rtl8192c_phycfg.c	
 
  Note:		Merge 92SE/SU PHY config as below
 			1. BB register R/W API
-			2. RF register R/W API
-			3. Initial BB/RF/MAC config by reading BB/MAC/RF txt.
-			3. Power setting API
-			4. Channel switch API
-			5. Initial gain switch API.
-			6. Other BB/MAC/RF API.
-
+ 			2. RF register R/W API
+ 			3. Initial BB/RF/MAC config by reading BB/MAC/RF txt.
+ 			3. Power setting API
+ 			4. Channel switch API
+ 			5. Initial gain switch API.
+ 			6. Other BB/MAC/RF API.
+ 			
  Function:	PHY: Extern function, phy: local function
-
+ 		 
  Export:	PHY_FunctionName
 
  Abbrev:	NONE
 
  History:
-	Data		Who		Remark
+	Data		Who		Remark	
 	08/08/2008  MHC    	1. Port from 9x series phycfg.c
 						2. Reorganize code arch and ad description.
 						3. Collect similar function.
@@ -46,7 +46,7 @@
 	10/07/2008	MHC		Add IQ calibration for PHY.(Only 1T2R mode now!!!)
 	11/06/2008	MHC		Add TX Power index PG file to config in 0xExx register
 						area to map with EEPROM/EFUSE tx pwr index.
-
+	
 ******************************************************************************/
 #define _HAL_8192C_PHYCFG_C_
 
@@ -93,7 +93,7 @@
 * OverView:	Get shifted position of the BitMask
 *
 * Input:
-*			u4Byte		BitMask,
+*			u4Byte		BitMask,	
 *
 * Output:	none
 * Return:		u4Byte		Return the shift bit bit position of the mask
@@ -124,7 +124,7 @@
 *			PADAPTER		Adapter,
 *			u4Byte			RegAddr,		//The target address to be readback
 *			u4Byte			BitMask		//The target bit position in the target address
-*										//to be readback
+*										//to be readback	
 * Output:	None
 * Return:		u4Byte			Data			//The readback register value
 * Note:		This function is equal to "GetRegSetting" in PHY programming guide
@@ -135,8 +135,8 @@
 	IN	u32		RegAddr,
 	IN	u32		BitMask
 	)
-{
-	u32	ReturnValue = 0, OriginalValue, BitShift;
+{	
+  	u32	ReturnValue = 0, OriginalValue, BitShift;
 	u16	BBWaitCounter = 0;
 
 #if (DISABLE_BB_RF == 1)
@@ -160,15 +160,15 @@
 /**
 * Function:	PHY_SetBBReg
 *
-* OverView:	Write "Specific bits" to BB register (page 8~)
+* OverView:	Write "Specific bits" to BB register (page 8~) 
 *
 * Input:
 *			PADAPTER		Adapter,
 *			u4Byte			RegAddr,		//The target address to be modified
 *			u4Byte			BitMask		//The target bit position in the target address
-*										//to be modified
+*										//to be modified	
 *			u4Byte			Data			//The new register value in the target bit position
-*										//of the target address
+*										//of the target address			
 *
 * Output:	None
 * Return:		None
@@ -203,7 +203,7 @@
 
 	//RTPRINT(FPHY, PHY_BBW, ("BBW MASK=0x%lx Addr[0x%lx]=0x%lx\n", BitMask, RegAddr, Data));
 	//RT_TRACE(COMP_RF, DBG_TRACE, ("<---PHY_SetBBReg(): RegAddr(%#lx), BitMask(%#lx), Data(%#lx)\n", RegAddr, BitMask, Data));
-
+	
 }
 
 
@@ -224,7 +224,7 @@
  *
  * Revised History:
  *	When		Who		Remark
- *	01/21/2008	MHC		Create Version 0.
+ *	01/21/2008	MHC		Create Version 0.  
  *
  *---------------------------------------------------------------------------*/
 static	u32
@@ -233,7 +233,7 @@
 	IN	RF_RADIO_PATH_E	eRFPath,
 	IN	u32				Offset	)
 {
-	u32		retValue = 0;
+	u32		retValue = 0;		
 	//RT_ASSERT(FALSE,("deprecate!\n"));
 	return	(retValue);
 
@@ -253,7 +253,7 @@
  *
  * Revised History:
  *	When		Who		Remark
- *	01/21/2008	MHC		Create Version 0.
+ *	01/21/2008	MHC		Create Version 0.  
  *
  *---------------------------------------------------------------------------*/
 static	VOID
@@ -270,18 +270,18 @@
 /**
 * Function:	phy_RFSerialRead
 *
-* OverView:	Read regster from RF chips
+* OverView:	Read regster from RF chips 
 *
 * Input:
 *			PADAPTER		Adapter,
 *			RF_RADIO_PATH_E	eRFPath,	//Radio path of A/B/C/D
-*			u4Byte			Offset,		//The target address to be read
+*			u4Byte			Offset,		//The target address to be read			
 *
 * Output:	None
 * Return:		u4Byte			reback value
-* Note:		Threre are three types of serial operations:
+* Note:		Threre are three types of serial operations: 
 *			1. Software serial write
-*			2. Hardware LSSI-Low Speed Serial Interface
+*			2. Hardware LSSI-Low Speed Serial Interface 
 *			3. Hardware HSSI-High speed
 *			serial write. Driver need to implement (1) and (2).
 *			This function is equal to the combination of RF_ReadReg() and  RFLSSIRead()
@@ -306,7 +306,7 @@
 		return	retValue;
 #endif
 	//
-	// Make sure RF register offset is correct
+	// Make sure RF register offset is correct 
 	//
 	Offset &= 0x3f;
 
@@ -323,7 +323,7 @@
 	//}
 
 	// For 92S LSSI Read RFLSSIRead
-	// For RF A/B write 0x824/82c(does not work in the future)
+	// For RF A/B write 0x824/82c(does not work in the future) 
 	// We must use 0x824 for RF A and B to execute read trigger
 	tmplong = PHY_QueryBBReg(Adapter, rFPGA0_XA_HSSIParameter2, bMaskDWord);
 	if(eRFPath == RF_PATH_A)
@@ -332,21 +332,21 @@
 		tmplong2 = PHY_QueryBBReg(Adapter, pPhyReg->rfHSSIPara2, bMaskDWord);
 
 	tmplong2 = (tmplong2 & (~bLSSIReadAddress)) | (NewOffset<<23) | bLSSIReadEdge;	//T65 RF
-
-	PHY_SetBBReg(Adapter, rFPGA0_XA_HSSIParameter2, bMaskDWord, tmplong&(~bLSSIReadEdge));
+	
+	PHY_SetBBReg(Adapter, rFPGA0_XA_HSSIParameter2, bMaskDWord, tmplong&(~bLSSIReadEdge));	
 	rtw_udelay_os(10);// PlatformStallExecution(10);
-
-	PHY_SetBBReg(Adapter, pPhyReg->rfHSSIPara2, bMaskDWord, tmplong2);
+	
+	PHY_SetBBReg(Adapter, pPhyReg->rfHSSIPara2, bMaskDWord, tmplong2);	
 	rtw_udelay_os(100);//PlatformStallExecution(100);
-
-	PHY_SetBBReg(Adapter, rFPGA0_XA_HSSIParameter2, bMaskDWord, tmplong|bLSSIReadEdge);
+	
+	PHY_SetBBReg(Adapter, rFPGA0_XA_HSSIParameter2, bMaskDWord, tmplong|bLSSIReadEdge);	
 	rtw_udelay_os(10);//PlatformStallExecution(10);
 
 	if(eRFPath == RF_PATH_A)
 		RfPiEnable = (u8)PHY_QueryBBReg(Adapter, rFPGA0_XA_HSSIParameter1, BIT8);
 	else if(eRFPath == RF_PATH_B)
 		RfPiEnable = (u8)PHY_QueryBBReg(Adapter, rFPGA0_XB_HSSIParameter1, BIT8);
-
+	
 	if(RfPiEnable)
 	{	// Read from BBreg8b8, 12 bits for 8190, 20bits for T65 RF
 		retValue = PHY_QueryBBReg(Adapter, pPhyReg->rfLSSIReadBackPi, bLSSIReadBackData);
@@ -358,9 +358,9 @@
 		//DBG_8192C("Readback from RF-SI : 0x%x\n", retValue);
 	}
 	//DBG_8192C("RFR-%d Addr[0x%x]=0x%x\n", eRFPath, pPhyReg->rfLSSIReadBack, retValue);
-
-	return retValue;
-
+	
+	return retValue;	
+		
 }
 
 
@@ -368,29 +368,29 @@
 /**
 * Function:	phy_RFSerialWrite
 *
-* OverView:	Write data to RF register (page 8~)
+* OverView:	Write data to RF register (page 8~) 
 *
 * Input:
 *			PADAPTER		Adapter,
 *			RF_RADIO_PATH_E	eRFPath,	//Radio path of A/B/C/D
-*			u4Byte			Offset,		//The target address to be read
+*			u4Byte			Offset,		//The target address to be read			
 *			u4Byte			Data			//The new register Data in the target bit position
-*										//of the target to be read
+*										//of the target to be read			
 *
 * Output:	None
 * Return:		None
-* Note:		Threre are three types of serial operations:
+* Note:		Threre are three types of serial operations: 
 *			1. Software serial write
-*			2. Hardware LSSI-Low Speed Serial Interface
+*			2. Hardware LSSI-Low Speed Serial Interface 
 *			3. Hardware HSSI-High speed
 *			serial write. Driver need to implement (1) and (2).
 *			This function is equal to the combination of RF_ReadReg() and  RFLSSIRead()
  *
  * Note: 		  For RF8256 only
- *			 The total count of RTL8256(Zebra4) register is around 36 bit it only employs
- *			 4-bit RF address. RTL8256 uses "register mode control bit" (Reg00[12], Reg00[10])
+ *			 The total count of RTL8256(Zebra4) register is around 36 bit it only employs 
+ *			 4-bit RF address. RTL8256 uses "register mode control bit" (Reg00[12], Reg00[10]) 
  *			 to access register address bigger than 0xf. See "Appendix-4 in PHY Configuration
- *			 programming guide" for more details.
+ *			 programming guide" for more details. 
  *			 Thus, we define a sub-finction for RTL8526 register address conversion
  *		       ===========================================================
  *			 Register Mode		RegCTL[1]		RegCTL[0]		Note
@@ -404,7 +404,7 @@
  *		       ------------------------------------------------------------------
  *
  *	2008/09/02	MH	Add 92S RF definition
- *
+ *	
  *
  *
 */
@@ -420,7 +420,7 @@
 	HAL_DATA_TYPE				*pHalData = GET_HAL_DATA(Adapter);
 	BB_REGISTER_DEFINITION_T	*pPhyReg = &pHalData->PHYRegDef[eRFPath];
 	u32						NewOffset;
-
+	
 #if 0
 	//<Roger_TODO> We should check valid regs for RF_6052 case.
 	if(pHalData->RFChipID == RF_8225 && Offset > 0x24) //36 valid regs
@@ -466,14 +466,14 @@
 /**
 * Function:	PHY_QueryRFReg
 *
-* OverView:	Query "Specific bits" to RF register (page 8~)
+* OverView:	Query "Specific bits" to RF register (page 8~) 
 *
 * Input:
 *			PADAPTER		Adapter,
 *			RF_RADIO_PATH_E	eRFPath,	//Radio path of A/B/C/D
 *			u4Byte			RegAddr,		//The target address to be read
 *			u4Byte			BitMask		//The target bit position in the target address
-*										//to be read
+*										//to be read	
 *
 * Output:	None
 * Return:		u4Byte			Readback value
@@ -487,7 +487,7 @@
 	IN	u32				BitMask
 	)
 {
-	u32 Original_Value, Readback_Value, BitShift;
+	u32 Original_Value, Readback_Value, BitShift;	
 	//HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
 	//u8	RFWaitCounter = 0;
 	//_irqL	irqL;
@@ -495,20 +495,20 @@
 #if (DISABLE_BB_RF == 1)
 	return 0;
 #endif
-
+	
 	//RT_TRACE(COMP_RF, DBG_TRACE, ("--->PHY_QueryRFReg(): RegAddr(%#lx), eRFPath(%#x), BitMask(%#lx)\n", RegAddr, eRFPath,BitMask));
-
+	
 #ifdef CONFIG_USB_HCI
 	//PlatformAcquireMutex(&pHalData->mxRFOperate);
 #else
 	//_enter_critical(&pHalData->rf_lock, &irqL);
 #endif
 
-
+	
 	Original_Value = phy_RFSerialRead(Adapter, eRFPath, RegAddr);
-
+	
 	BitShift =  phy_CalculateBitShift(BitMask);
-	Readback_Value = (Original_Value & BitMask) >> BitShift;
+	Readback_Value = (Original_Value & BitMask) >> BitShift;	
 
 #ifdef CONFIG_USB_HCI
 	//PlatformReleaseMutex(&pHalData->mxRFOperate);
@@ -518,25 +518,25 @@
 
 
 	//RTPRINT(FPHY, PHY_RFR, ("RFR-%d MASK=0x%lx Addr[0x%lx]=0x%lx\n", eRFPath, BitMask, RegAddr, Original_Value));//BitMask(%#lx),BitMask,
-	//RT_TRACE(COMP_RF, DBG_TRACE, ("<---PHY_QueryRFReg(): RegAddr(%#lx), eRFPath(%#x),  Original_Value(%#lx)\n",
+	//RT_TRACE(COMP_RF, DBG_TRACE, ("<---PHY_QueryRFReg(): RegAddr(%#lx), eRFPath(%#x),  Original_Value(%#lx)\n", 
 	//				RegAddr, eRFPath, Original_Value));
-
+	
 	return (Readback_Value);
 }
 
 /**
 * Function:	PHY_SetRFReg
 *
-* OverView:	Write "Specific bits" to RF register (page 8~)
+* OverView:	Write "Specific bits" to RF register (page 8~) 
 *
 * Input:
 *			PADAPTER		Adapter,
 *			RF_RADIO_PATH_E	eRFPath,	//Radio path of A/B/C/D
 *			u4Byte			RegAddr,		//The target address to be modified
 *			u4Byte			BitMask		//The target bit position in the target address
-*										//to be modified
+*										//to be modified	
 *			u4Byte			Data			//The new register Data in the target bit position
-*										//of the target address
+*										//of the target address			
 *
 * Output:	None
 * Return:		None
@@ -560,10 +560,10 @@
 #if (DISABLE_BB_RF == 1)
 	return;
 #endif
-
-	//RT_TRACE(COMP_RF, DBG_TRACE, ("--->PHY_SetRFReg(): RegAddr(%#lx), BitMask(%#lx), Data(%#lx), eRFPath(%#x)\n",
+	
+	//RT_TRACE(COMP_RF, DBG_TRACE, ("--->PHY_SetRFReg(): RegAddr(%#lx), BitMask(%#lx), Data(%#lx), eRFPath(%#x)\n", 
 	//	RegAddr, BitMask, Data, eRFPath));
-	//RTPRINT(FINIT, INIT_RF, ("PHY_SetRFReg(): RegAddr(%#lx), BitMask(%#lx), Data(%#lx), eRFPath(%#x)\n",
+	//RTPRINT(FINIT, INIT_RF, ("PHY_SetRFReg(): RegAddr(%#lx), BitMask(%#lx), Data(%#lx), eRFPath(%#x)\n", 
 	//	RegAddr, BitMask, Data, eRFPath));
 
 
@@ -573,17 +573,17 @@
 	//_enter_critical(&pHalData->rf_lock, &irqL);
 #endif
 
-
+	
 	// RF data is 12 bits only
-	if (BitMask != bRFRegOffsetMask)
+	if (BitMask != bRFRegOffsetMask) 
 	{
 		Original_Value = phy_RFSerialRead(Adapter, eRFPath, RegAddr);
 		BitShift =  phy_CalculateBitShift(BitMask);
 		Data = ((Original_Value & (~BitMask)) | (Data<< BitShift));
 	}
-
+		
 	phy_RFSerialWrite(Adapter, eRFPath, RegAddr, Data);
-
+	
 
 
 #ifdef CONFIG_USB_HCI
@@ -591,9 +591,9 @@
 #else
 	//_exit_critical(&pHalData->rf_lock, &irqL);
 #endif
-
+	
 	//PHY_QueryRFReg(Adapter,eRFPath,RegAddr,BitMask);
-	//RT_TRACE(COMP_RF, DBG_TRACE, ("<---PHY_SetRFReg(): RegAddr(%#lx), BitMask(%#lx), Data(%#lx), eRFPath(%#x)\n",
+	//RT_TRACE(COMP_RF, DBG_TRACE, ("<---PHY_SetRFReg(): RegAddr(%#lx), BitMask(%#lx), Data(%#lx), eRFPath(%#x)\n", 
 	//		RegAddr, BitMask, Data, eRFPath));
 
 }
@@ -607,16 +607,16 @@
  * Function:    phy_ConfigMACWithParaFile()
  *
  * Overview:    This function read BB parameters from general file format, and do register
- *			  Read/Write
+ *			  Read/Write 
  *
  * Input:      	PADAPTER		Adapter
- *			ps1Byte 			pFileName
+ *			ps1Byte 			pFileName			
  *
  * Output:      NONE
  *
  * Return:      RT_STATUS_SUCCESS: configuration file exist
- *
- * Note: 		The format of MACPHY_REG.txt is different from PHY and RF.
+ *			
+ * Note: 		The format of MACPHY_REG.txt is different from PHY and RF. 
  *			[Register][Mask][Value]
  *---------------------------------------------------------------------------*/
 static	int
@@ -626,7 +626,7 @@
 )
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-
+	
 	int		rtStatus = _SUCCESS;
 
 	return rtStatus;
@@ -636,16 +636,16 @@
  * Function:    phy_ConfigMACWithHeaderFile()
  *
  * Overview:    This function read BB parameters from Header file we gen, and do register
- *			  Read/Write
+ *			  Read/Write 
  *
  * Input:      	PADAPTER		Adapter
- *			ps1Byte 			pFileName
+ *			ps1Byte 			pFileName			
  *
  * Output:      NONE
  *
  * Return:      RT_STATUS_SUCCESS: configuration file exist
- *
- * Note: 		The format of MACPHY_REG.txt is different from PHY and RF.
+ *			
+ * Note: 		The format of MACPHY_REG.txt is different from PHY and RF. 
  *			[Register][Mask][Value]
  *---------------------------------------------------------------------------*/
 static	int
@@ -655,7 +655,7 @@
 {
 	u32					i = 0;
 	u32					ArrayLength = 0;
-	u32*				ptrArray;
+	u32*				ptrArray;	
 	//HAL_DATA_TYPE			*pHalData = GET_HAL_DATA(Adapter);
 
 	//2008.11.06 Modified by tynli.
@@ -683,9 +683,9 @@
 			rtw_write8(Adapter, ptrArray[i], (u8)ptrArray[i+1]);
 		}
 	}
-
+	
 	return _SUCCESS;
-
+	
 }
 
 
@@ -728,7 +728,7 @@
 #ifdef CONFIG_EMBEDDED_FWIMG
 	rtStatus = phy_ConfigMACWithHeaderFile(Adapter);
 #else
-
+	
 	// Not make sure EEPROM, add later
 	//RT_TRACE(COMP_INIT, DBG_LOUD, ("Read MACREG.txt\n"));
 	rtStatus = phy_ConfigMACWithParaFile(Adapter, pszMACRegFile);
@@ -747,8 +747,8 @@
 	rtw_write8(Adapter, REG_MAX_AGGR_NUM, 0x0A); //By tynli. 2010.11.18.
 #ifdef CONFIG_USB_HCI
 	if(is92C && (BOARD_USB_DONGLE == pHalData->BoardType))
-		rtw_write8(Adapter, 0x40,0x04);
-#endif
+		rtw_write8(Adapter, 0x40,0x04);	
+#endif		
 
 	return rtStatus;
 
@@ -772,7 +772,7 @@
 	IN	PADAPTER		Adapter
 )
 {
-	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
+	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);	
 
 	// RF Interface Sowrtware Control
 	pHalData->PHYRegDef[RF_PATH_A].rfintfs = rFPGA0_XAB_RFInterfaceSW; // 16 LSBs if read 32-bit from 0x870
@@ -781,7 +781,7 @@
 	pHalData->PHYRegDef[RF_PATH_D].rfintfs = rFPGA0_XCD_RFInterfaceSW;// 16 MSBs if read 32-bit from 0x874 (16-bit for 0x876)
 
 	// RF Interface Readback Value
-	pHalData->PHYRegDef[RF_PATH_A].rfintfi = rFPGA0_XAB_RFInterfaceRB; // 16 LSBs if read 32-bit from 0x8E0
+	pHalData->PHYRegDef[RF_PATH_A].rfintfi = rFPGA0_XAB_RFInterfaceRB; // 16 LSBs if read 32-bit from 0x8E0	
 	pHalData->PHYRegDef[RF_PATH_B].rfintfi = rFPGA0_XAB_RFInterfaceRB;// 16 MSBs if read 32-bit from 0x8E0 (16-bit for 0x8E2)
 	pHalData->PHYRegDef[RF_PATH_C].rfintfi = rFPGA0_XCD_RFInterfaceRB;// 16 LSBs if read 32-bit from 0x8E4
 	pHalData->PHYRegDef[RF_PATH_D].rfintfi = rFPGA0_XCD_RFInterfaceRB;// 16 MSBs if read 32-bit from 0x8E4 (16-bit for 0x8E6)
@@ -824,53 +824,53 @@
 	pHalData->PHYRegDef[RF_PATH_C].rfSwitchControl = rFPGA0_XCD_SwitchControl;
 	pHalData->PHYRegDef[RF_PATH_D].rfSwitchControl = rFPGA0_XCD_SwitchControl;
 
-	// AGC control 1
+	// AGC control 1 
 	pHalData->PHYRegDef[RF_PATH_A].rfAGCControl1 = rOFDM0_XAAGCCore1;
 	pHalData->PHYRegDef[RF_PATH_B].rfAGCControl1 = rOFDM0_XBAGCCore1;
 	pHalData->PHYRegDef[RF_PATH_C].rfAGCControl1 = rOFDM0_XCAGCCore1;
 	pHalData->PHYRegDef[RF_PATH_D].rfAGCControl1 = rOFDM0_XDAGCCore1;
 
-	// AGC control 2
+	// AGC control 2 
 	pHalData->PHYRegDef[RF_PATH_A].rfAGCControl2 = rOFDM0_XAAGCCore2;
 	pHalData->PHYRegDef[RF_PATH_B].rfAGCControl2 = rOFDM0_XBAGCCore2;
 	pHalData->PHYRegDef[RF_PATH_C].rfAGCControl2 = rOFDM0_XCAGCCore2;
 	pHalData->PHYRegDef[RF_PATH_D].rfAGCControl2 = rOFDM0_XDAGCCore2;
 
-	// RX AFE control 1
+	// RX AFE control 1 
 	pHalData->PHYRegDef[RF_PATH_A].rfRxIQImbalance = rOFDM0_XARxIQImbalance;
 	pHalData->PHYRegDef[RF_PATH_B].rfRxIQImbalance = rOFDM0_XBRxIQImbalance;
 	pHalData->PHYRegDef[RF_PATH_C].rfRxIQImbalance = rOFDM0_XCRxIQImbalance;
-	pHalData->PHYRegDef[RF_PATH_D].rfRxIQImbalance = rOFDM0_XDRxIQImbalance;
+	pHalData->PHYRegDef[RF_PATH_D].rfRxIQImbalance = rOFDM0_XDRxIQImbalance;	
 
-	// RX AFE control 1
+	// RX AFE control 1  
 	pHalData->PHYRegDef[RF_PATH_A].rfRxAFE = rOFDM0_XARxAFE;
 	pHalData->PHYRegDef[RF_PATH_B].rfRxAFE = rOFDM0_XBRxAFE;
 	pHalData->PHYRegDef[RF_PATH_C].rfRxAFE = rOFDM0_XCRxAFE;
-	pHalData->PHYRegDef[RF_PATH_D].rfRxAFE = rOFDM0_XDRxAFE;
+	pHalData->PHYRegDef[RF_PATH_D].rfRxAFE = rOFDM0_XDRxAFE;	
 
-	// Tx AFE control 1
+	// Tx AFE control 1 
 	pHalData->PHYRegDef[RF_PATH_A].rfTxIQImbalance = rOFDM0_XATxIQImbalance;
 	pHalData->PHYRegDef[RF_PATH_B].rfTxIQImbalance = rOFDM0_XBTxIQImbalance;
 	pHalData->PHYRegDef[RF_PATH_C].rfTxIQImbalance = rOFDM0_XCTxIQImbalance;
-	pHalData->PHYRegDef[RF_PATH_D].rfTxIQImbalance = rOFDM0_XDTxIQImbalance;
+	pHalData->PHYRegDef[RF_PATH_D].rfTxIQImbalance = rOFDM0_XDTxIQImbalance;	
 
-	// Tx AFE control 2
+	// Tx AFE control 2 
 	pHalData->PHYRegDef[RF_PATH_A].rfTxAFE = rOFDM0_XATxAFE;
 	pHalData->PHYRegDef[RF_PATH_B].rfTxAFE = rOFDM0_XBTxAFE;
 	pHalData->PHYRegDef[RF_PATH_C].rfTxAFE = rOFDM0_XCTxAFE;
-	pHalData->PHYRegDef[RF_PATH_D].rfTxAFE = rOFDM0_XDTxAFE;
+	pHalData->PHYRegDef[RF_PATH_D].rfTxAFE = rOFDM0_XDTxAFE;	
 
-	// Tranceiver LSSI Readback SI mode
+	// Tranceiver LSSI Readback SI mode 
 	pHalData->PHYRegDef[RF_PATH_A].rfLSSIReadBack = rFPGA0_XA_LSSIReadBack;
 	pHalData->PHYRegDef[RF_PATH_B].rfLSSIReadBack = rFPGA0_XB_LSSIReadBack;
 	pHalData->PHYRegDef[RF_PATH_C].rfLSSIReadBack = rFPGA0_XC_LSSIReadBack;
-	pHalData->PHYRegDef[RF_PATH_D].rfLSSIReadBack = rFPGA0_XD_LSSIReadBack;
+	pHalData->PHYRegDef[RF_PATH_D].rfLSSIReadBack = rFPGA0_XD_LSSIReadBack;	
 
-	// Tranceiver LSSI Readback PI mode
+	// Tranceiver LSSI Readback PI mode 
 	pHalData->PHYRegDef[RF_PATH_A].rfLSSIReadBackPi = TransceiverA_HSPI_Readback;
 	pHalData->PHYRegDef[RF_PATH_B].rfLSSIReadBackPi = TransceiverB_HSPI_Readback;
 	//pHalData->PHYRegDef[RF_PATH_C].rfLSSIReadBackPi = rFPGA0_XC_LSSIReadBack;
-	//pHalData->PHYRegDef[RF_PATH_D].rfLSSIReadBackPi = rFPGA0_XD_LSSIReadBack;
+	//pHalData->PHYRegDef[RF_PATH_D].rfLSSIReadBackPi = rFPGA0_XD_LSSIReadBack;	
 
 }
 
@@ -879,17 +879,17 @@
  * Function:    phy_ConfigBBWithParaFile()
  *
  * Overview:    This function read BB parameters from general file format, and do register
- *			  Read/Write
+ *			  Read/Write 
  *
  * Input:      	PADAPTER		Adapter
- *			ps1Byte 			pFileName
+ *			ps1Byte 			pFileName			
  *
  * Output:      NONE
  *
  * Return:      RT_STATUS_SUCCESS: configuration file exist
- *	2008/11/06	MH	For 92S we do not support silent reset now. Disable
+ *	2008/11/06	MH	For 92S we do not support silent reset now. Disable 
  *					parameter file compare!!!!!!??
- *
+ *			
  *---------------------------------------------------------------------------*/
 static	int
 phy_ConfigBBWithParaFile(
@@ -898,10 +898,10 @@
 )
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-
+	
 	int		rtStatus = _SUCCESS;
 
-	return rtStatus;
+	return rtStatus;	
 }
 
 
@@ -924,7 +924,7 @@
 		return;
 	}
 
-	// 2010/10/19 MH According to Jenyu/EEChou 's opinion, we need not to execute the
+	// 2010/10/19 MH According to Jenyu/EEChou 's opinion, we need not to execute the 
 	// same code as SU. It is already updated in PHY_REG_1T_HP.txt.
 #if 0
 	PHY_SetBBReg(Adapter, 0xee8, BIT28, 1);
@@ -943,7 +943,7 @@
  * Function:    phy_ConfigBBWithHeaderFile()
  *
  * Overview:    This function read BB parameters from general file format, and do register
- *			  Read/Write
+ *			  Read/Write 
  *
  * Input:      	PADAPTER		Adapter
  *			u1Byte 			ConfigType     0 => PHY_CONFIG
@@ -952,7 +952,7 @@
  * Output:      NONE
  *
  * Return:      RT_STATUS_SUCCESS: configuration file exist
- *
+ *			
  *---------------------------------------------------------------------------*/
 static	int
 phy_ConfigBBWithHeaderFile(
@@ -980,7 +980,7 @@
 		if(pHalData->BoardType == BOARD_MINICARD )
 		{
 			PHY_REGArrayLen = PHY_REG_2T_mCardArrayLength;
-			Rtl819XPHY_REGArray_Table = Rtl819XPHY_REG_2T_mCardArray;
+			Rtl819XPHY_REGArray_Table = Rtl819XPHY_REG_2T_mCardArray;			
 		}
 #endif
 	}
@@ -994,14 +994,14 @@
 		if(pHalData->BoardType == BOARD_MINICARD )
 		{
 			PHY_REGArrayLen = PHY_REG_1T_mCardArrayLength;
-			Rtl819XPHY_REGArray_Table = Rtl819XPHY_REG_1T_mCardArray;
+			Rtl819XPHY_REGArray_Table = Rtl819XPHY_REG_1T_mCardArray;			
 		}
 		else if(pHalData->BoardType == BOARD_USB_High_PA)
 		{
 			AGCTAB_ArrayLen = AGCTAB_1T_HPArrayLength;
 			Rtl819XAGCTAB_Array_Table = Rtl819XAGCTAB_1T_HPArray;
 			PHY_REGArrayLen = PHY_REG_1T_HPArrayLength;
-			Rtl819XPHY_REGArray_Table = Rtl819XPHY_REG_1T_HPArray;
+			Rtl819XPHY_REGArray_Table = Rtl819XPHY_REG_1T_HPArray;			
 		}
 #endif
 	}
@@ -1022,7 +1022,7 @@
 			for(i=0;i<PHY_REGArrayLen;i=i+2)
 			{
 				tmp_value=Rtl819XPHY_REGArray_Table[i+1];
-
+				
 				if (Rtl819XPHY_REGArray_Table[i] == 0xfe)
 					rtw_IOL_append_DELAY_MS_cmd(xmit_frame, 50);
 				else if (Rtl819XPHY_REGArray_Table[i] == 0xfd)
@@ -1036,10 +1036,10 @@
 				else if (Rtl819XPHY_REGArray_Table[i] == 0xf9)
 					rtw_IOL_append_DELAY_US_cmd(xmit_frame, 1);
 
-				rtw_IOL_append_WD_cmd(xmit_frame, Rtl819XPHY_REGArray_Table[i], tmp_value);
+				rtw_IOL_append_WD_cmd(xmit_frame, Rtl819XPHY_REGArray_Table[i], tmp_value);	
 				//RT_TRACE(COMP_INIT, DBG_TRACE, ("The Rtl819XPHY_REGArray_Table[0] is %lx Rtl819XPHY_REGArray[1] is %lx \n",Rtl819XPHY_REGArray_Table[i], Rtl819XPHY_REGArray_Table[i+1]));
 			}
-
+		
 			ret = rtw_IOL_exec_cmds_sync(Adapter, xmit_frame, 1000);
 		}
 		else
@@ -1073,7 +1073,7 @@
 				//RT_TRACE(COMP_INIT, DBG_TRACE, ("The Rtl819XPHY_REGArray_Table[0] is %lx Rtl819XPHY_REGArray[1] is %lx \n",Rtl819XPHY_REGArray_Table[i], Rtl819XPHY_REGArray_Table[i+1]));
 			}
 		}
-
+	
 		// for External PA
 		phy_ConfigBBExternalPA(Adapter);
 	}
@@ -1091,10 +1091,10 @@
 
 			for(i=0;i<AGCTAB_ArrayLen;i=i+2)
 			{
-				rtw_IOL_append_WD_cmd(xmit_frame, Rtl819XAGCTAB_Array_Table[i], Rtl819XAGCTAB_Array_Table[i+1]);
+				rtw_IOL_append_WD_cmd(xmit_frame, Rtl819XAGCTAB_Array_Table[i], Rtl819XAGCTAB_Array_Table[i+1]);							
 				//RT_TRACE(COMP_INIT, DBG_TRACE, ("The Rtl819XAGCTAB_Array_Table[0] is %lx Rtl819XPHY_REGArray[1] is %lx \n",Rtl819XAGCTAB_Array_Table[i], Rtl819XAGCTAB_Array_Table[i+1]));
 			}
-
+		
 			ret = rtw_IOL_exec_cmds_sync(Adapter, xmit_frame, 1000);
 		}
 		else
@@ -1102,11 +1102,11 @@
 		{
 			for(i=0;i<AGCTAB_ArrayLen;i=i+2)
 			{
-				PHY_SetBBReg(Adapter, Rtl819XAGCTAB_Array_Table[i], bMaskDWord, Rtl819XAGCTAB_Array_Table[i+1]);
+				PHY_SetBBReg(Adapter, Rtl819XAGCTAB_Array_Table[i], bMaskDWord, Rtl819XAGCTAB_Array_Table[i+1]);		
 
 				// Add 1us delay between BB/RF register setting.
 				rtw_udelay_os(1);
-
+				
 				//RT_TRACE(COMP_INIT, DBG_TRACE, ("The Rtl819XAGCTAB_Array_Table[0] is %lx Rtl819XPHY_REGArray[1] is %lx \n",Rtl819XAGCTAB_Array_Table[i], Rtl819XAGCTAB_Array_Table[i+1]));
 			}
 		}
@@ -1114,7 +1114,7 @@
 
 exit:
 	return ret;
-
+	
 }
 
 
@@ -1127,7 +1127,7 @@
 	)
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-
+	
 	if(RegAddr == rTxAGC_A_Rate18_06)
 	{
 		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][0] = Data;
@@ -1151,7 +1151,7 @@
 		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][7] = Data;
 		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][7] = 0x%lx\n", pHalData->pwrGroupCnt,
 		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][7]));
-	}
+	}	
 	if(RegAddr == rTxAGC_A_Mcs03_Mcs00)
 	{
 		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][2] = Data;
@@ -1199,7 +1199,7 @@
 		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][15] = Data;
 		//RT_TRACE(COMP_INIT, DBG_TRACE, ("MCSTxPowerLevelOriginalOffset[%d][15] = 0x%lx\n", pHalData->pwrGroupCnt,
 		//	pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][15]));
-	}
+	}	
 	if(RegAddr == rTxAGC_B_Mcs03_Mcs00)
 	{
 		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][10] = Data;
@@ -1229,7 +1229,7 @@
 /*-----------------------------------------------------------------------------
  * Function:	phy_ConfigBBWithPgParaFile
  *
- * Overview:
+ * Overview:	
  *
  * Input:       NONE
  *
@@ -1248,19 +1248,19 @@
 	IN	u8* 			pFileName)
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-
+	
 	int		rtStatus = _SUCCESS;
 
 
 	return rtStatus;
-
+	
 }	/* phy_ConfigBBWithPgParaFile */
 
 
 /*-----------------------------------------------------------------------------
  * Function:	phy_ConfigBBWithPgHeaderFile
  *
- * Overview:	Config PHY_REG_PG array
+ * Overview:	Config PHY_REG_PG array 
  *
  * Input:       NONE
  *
@@ -1324,11 +1324,11 @@
 				rtw_udelay_os(5);
 			else if (Rtl819XPHY_REGArray_Table_PG[i] == 0xf9)
 				rtw_udelay_os(1);
-			//PHY_SetBBReg(Adapter, Rtl819XPHY_REGArray_Table_PG[i], Rtl819XPHY_REGArray_Table_PG[i+1], Rtl819XPHY_REGArray_Table_PG[i+2]);
+			//PHY_SetBBReg(Adapter, Rtl819XPHY_REGArray_Table_PG[i], Rtl819XPHY_REGArray_Table_PG[i+1], Rtl819XPHY_REGArray_Table_PG[i+2]);		
 			#endif
-
-			storePwrIndexDiffRateOffset(Adapter, Rtl819XPHY_REGArray_Table_PG[i],
-				Rtl819XPHY_REGArray_Table_PG[i+1],
+			
+			storePwrIndexDiffRateOffset(Adapter, Rtl819XPHY_REGArray_Table_PG[i], 
+				Rtl819XPHY_REGArray_Table_PG[i+1], 
 				Rtl819XPHY_REGArray_Table_PG[i+2]);
 			//RT_TRACE(COMP_SEND, DBG_TRACE, ("The Rtl819XPHY_REGArray_Table_PG[0] is %lx Rtl819XPHY_REGArray_Table_PG[1] is %lx \n",Rtl819XPHY_REGArray_Table_PG[i], Rtl819XPHY_REGArray_Table_PG[i+1]));
 		}
@@ -1338,9 +1338,9 @@
 
 		//RT_TRACE(COMP_SEND, DBG_LOUD, ("phy_ConfigBBWithPgHeaderFile(): ConfigType != BaseBand_Config_PHY_REG\n"));
 	}
-
+	
 	return _SUCCESS;
-
+	
 }	/* phy_ConfigBBWithPgHeaderFile */
 
 #if (MP_DRIVER == 1)
@@ -1349,17 +1349,17 @@
  * Function:    phy_ConfigBBWithMpParaFile()
  *
  * Overview:    This function read BB parameters from general file format, and do register
- *			  Read/Write
+ *			  Read/Write 
  *
  * Input:      	PADAPTER		Adapter
- *			ps1Byte 			pFileName
+ *			ps1Byte 			pFileName			
  *
  * Output:      NONE
  *
  * Return:      RT_STATUS_SUCCESS: configuration file exist
- *	2008/11/06	MH	For 92S we do not support silent reset now. Disable
+ *	2008/11/06	MH	For 92S we do not support silent reset now. Disable 
  *					parameter file compare!!!!!!??
- *
+ *			
  *---------------------------------------------------------------------------*/
 static	int
 phy_ConfigBBWithMpParaFile(
@@ -1376,11 +1376,11 @@
 	ps1Byte 		szLine;
 	u4Byte			u4bRegOffset, u4bRegMask, u4bRegValue;
 	u4Byte			u4bMove;
-
+	
 	if(ADAPTER_TEST_STATUS_FLAG(Adapter, ADAPTER_STATUS_FIRST_INIT))
 	{
 		rtStatus = PlatformReadFile(
-					Adapter,
+					Adapter, 
 					pFileName,
 					(pu1Byte)(pHalData->BufOfLines),
 					MAX_LINES_HWCONFIG_TXT,
@@ -1437,7 +1437,7 @@
 						PlatformStallExecution(5);
 					else if (u4bRegOffset == 0xf9)
 						PlatformStallExecution(1);
-
+					
 					// Get 2nd hex value as register value.
 					szLine += u4bMove;
 					if(GetHexValueFromString(szLine, &u4bRegValue, &u4bMove))
@@ -1464,7 +1464,7 @@
 /*-----------------------------------------------------------------------------
  * Function:	phy_ConfigBBWithMpHeaderFile
  *
- * Overview:	Config PHY_REG_MP array
+ * Overview:	Config PHY_REG_MP array 
  *
  * Input:       NONE
  *
@@ -1515,7 +1515,7 @@
 				rtw_mdelay_os(5);
 			else if (Rtl8192CPHY_REGArray_Table_MP[i] == 0xf9)
 				rtw_mdelay_os(1);
-			PHY_SetBBReg(Adapter, Rtl8192CPHY_REGArray_Table_MP[i], bMaskDWord, Rtl8192CPHY_REGArray_Table_MP[i+1]);
+			PHY_SetBBReg(Adapter, Rtl8192CPHY_REGArray_Table_MP[i], bMaskDWord, Rtl8192CPHY_REGArray_Table_MP[i+1]);		
 
 			// Add 1us delay between BB/RF register setting.
 			rtw_mdelay_os(1);
@@ -1556,14 +1556,14 @@
 	PHY_SetBBReg(Adapter, rCCK0_AFESetting, bMaskByte3, 0x45);
 	PHY_SetBBReg(Adapter, rOFDM0_TRxPathEnable, bMaskByte0, 0x23);
 	PHY_SetBBReg(Adapter, rOFDM0_AGCParameter1, 0x30, 0x1);	// B path first AGC
-
+	
 	PHY_SetBBReg(Adapter, 0xe74, 0x0c000000, 0x2);
 	PHY_SetBBReg(Adapter, 0xe78, 0x0c000000, 0x2);
 	PHY_SetBBReg(Adapter, 0xe7c, 0x0c000000, 0x2);
 	PHY_SetBBReg(Adapter, 0xe80, 0x0c000000, 0x2);
 	PHY_SetBBReg(Adapter, 0xe88, 0x0c000000, 0x2);
 
-
+	
 }
 
 // Joseph test: new initialize order!!
@@ -1588,15 +1588,15 @@
 	int			rtStatus = _SUCCESS;
 
 	u8				szBBRegPgFile[] = RTL819X_PHY_REG_PG;
-
-	u8				sz88CBBRegFile[] = RTL8188C_PHY_REG;
+	
+	u8				sz88CBBRegFile[] = RTL8188C_PHY_REG;	
 	u8				sz88CAGCTableFile[] = RTL8188C_AGC_TAB;
 
-	u8				sz92CBBRegFile[] = RTL8192C_PHY_REG;
+	u8				sz92CBBRegFile[] = RTL8192C_PHY_REG;	
 	u8				sz92CAGCTableFile[] = RTL8192C_AGC_TAB;
-
+	
 	u8				*pszBBRegFile, *pszAGCTableFile, *pszBBRegMpFile;
-
+	
 	//RT_TRACE(COMP_INIT, DBG_TRACE, ("==>phy_BB8192S_Config_ParaFile\n"));
 
 	if(IS_92C_SERIAL(pHalData->VersionID)){
@@ -1613,10 +1613,10 @@
 	// We will seperate as 88C / 92C according to chip version
 	//
 #ifdef CONFIG_EMBEDDED_FWIMG
-	rtStatus = phy_ConfigBBWithHeaderFile(Adapter, BaseBand_Config_PHY_REG);
-#else
-	// No matter what kind of CHIP we always read PHY_REG.txt. We must copy different
-	// type of parameter files to phy_reg.txt at first.
+	rtStatus = phy_ConfigBBWithHeaderFile(Adapter, BaseBand_Config_PHY_REG);	
+#else	
+	// No matter what kind of CHIP we always read PHY_REG.txt. We must copy different 
+	// type of parameter files to phy_reg.txt at first.	
 	rtStatus = phy_ConfigBBWithParaFile(Adapter,pszBBRegFile);
 #endif
 
@@ -1631,17 +1631,17 @@
 	// We will seperate as 88C / 92C according to chip version
 	//
 #ifdef CONFIG_EMBEDDED_FWIMG
-	rtStatus = phy_ConfigBBWithMpHeaderFile(Adapter, BaseBand_Config_PHY_REG);
-#else
-	// No matter what kind of CHIP we always read PHY_REG.txt. We must copy different
-	// type of parameter files to phy_reg.txt at first.
+	rtStatus = phy_ConfigBBWithMpHeaderFile(Adapter, BaseBand_Config_PHY_REG);	
+#else	
+	// No matter what kind of CHIP we always read PHY_REG.txt. We must copy different 
+	// type of parameter files to phy_reg.txt at first.	
 	rtStatus = phy_ConfigBBWithMpParaFile(Adapter, pszBBRegMpFile);
 #endif
 
 	if(rtStatus != _SUCCESS){
 //		RT_TRACE(COMP_INIT, DBG_SERIOUS, ("phy_BB8192S_Config_ParaFile():Write BB Reg MP Fail!!"));
 		goto phy_BB8190_Config_ParaFile_Fail;
-	}
+	}	
 #endif	// #if (MP_DRIVER == 1)
 
 	//
@@ -1666,7 +1666,7 @@
 		rtStatus = phy_ConfigBBWithPgParaFile(Adapter, (u8*)&szBBRegPgFile);
 #endif
 	}
-
+	
 	if(rtStatus != _SUCCESS){
 		//RT_TRACE(COMP_INIT, DBG_SERIOUS, ("phy_BB8192S_Config_ParaFile():BB_PG Reg Fail!!"));
 		goto phy_BB8190_Config_ParaFile_Fail;
@@ -1690,7 +1690,7 @@
 	// Check if the CCK HighPower is turned ON.
 	// This is used to calculate PWDB.
 	pHalData->bCckHighPower = (BOOLEAN)(PHY_QueryBBReg(Adapter, rFPGA0_XA_HSSIParameter2, 0x200));
-
+	
 phy_BB8190_Config_ParaFile_Fail:
 
 	return rtStatus;
@@ -1718,26 +1718,26 @@
 		rtw_udelay_os(2);
 		rtw_write8(Adapter, REG_AFE_PLL_CTRL, (TmpU1B|BIT1));
 		rtw_udelay_os(2);
-
+		
 		//2. 0x29[7:0] = 0xFF
 		rtw_write8(Adapter, REG_AFE_PLL_CTRL+1, 0xff);
 		rtw_udelay_os(2);
-
+		
 		//3. 0x02[1:0] = 2b'11
 		TmpU1B = rtw_read8(Adapter, REG_SYS_FUNC_EN);
 		rtw_write8(Adapter, REG_SYS_FUNC_EN, (TmpU1B|FEN_BB_GLB_RSTn|FEN_BBRSTB));
-
+		
 		//undo clock gated
 		rtw_write32(Adapter, rFPGA0_XCD_RFParameter, rtw_read32(Adapter, rFPGA0_XCD_RFParameter)&(~BIT31));
-
+		
 		//4. 0x25[6] = 0
 		TmpU1B = rtw_read8(Adapter, REG_AFE_XTAL_CTRL+1);
 		rtw_write8(Adapter, REG_AFE_XTAL_CTRL+1, (TmpU1B&(~BIT6)));
-
+		
 		//5. 0x24[20] = 0 	//Advised by SD3 Alex Wang. 2011.02.09.
 		TmpU1B = rtw_read8(Adapter, REG_AFE_XTAL_CTRL+2);
 		rtw_write8(Adapter, REG_AFE_XTAL_CTRL+2, (TmpU1B&(~BIT4)));
-
+		
 		//6. 0x1f[7:0] = 0x07
 		rtw_write8(Adapter, REG_RF_CTRL, 0x07);
 	}
@@ -1758,14 +1758,14 @@
 #else
 		rtw_write8(Adapter, REG_SYS_FUNC_EN, FEN_PPLL|FEN_PCIEA|FEN_DIO_PCIE|FEN_BB_GLB_RSTn|FEN_BBRSTB);
 #endif
-
+		
 		//undo clock gated
 		rtw_write32(Adapter, rFPGA0_XCD_RFParameter, rtw_read32(Adapter, rFPGA0_XCD_RFParameter)&(~BIT31));
 
-		// 2009/10/21 by SD1 Jong. Modified by tynli. Not in Documented in V8.1.
+		// 2009/10/21 by SD1 Jong. Modified by tynli. Not in Documented in V8.1. 
 #ifdef CONFIG_USB_HCI
 		//To Fix MAC loopback mode fail. Suggested by SD4 Johnny. 2010.03.23.
-		rtw_write8(Adapter, REG_LDOHCI12_CTRL, 0x0f);
+		rtw_write8(Adapter, REG_LDOHCI12_CTRL, 0x0f);	
 		rtw_write8(Adapter, 0x15, 0xe9);
 #endif
 
@@ -1786,7 +1786,7 @@
 	// Config BB and AGC
 	//
 	rtStatus = phy_BB8192C_Config_ParaFile(Adapter);
-#if 0
+#if 0	
 	switch(Adapter->MgntInfo.bRegHwParaFile)
 	{
 		case 0:
@@ -1798,7 +1798,7 @@
 			break;
 
 		case 2:
-			// Partial Modify.
+			// Partial Modify. 
 			phy_BB8190_Config_HardCode(Adapter);
 			phy_BB8192C_Config_ParaFile(Adapter);
 			break;
@@ -1807,11 +1807,11 @@
 			phy_BB8190_Config_HardCode(Adapter);
 			break;
 	}
-#endif
+#endif	
 #ifdef CONFIG_USB_HCI
 	if(IS_HARDWARE_TYPE_8192CU(Adapter)&&IS_81xxC_VENDOR_UMC_B_CUT(pHalData->VersionID)
 		&&(pHalData->BoardType == BOARD_USB_High_PA))
-			rtw_write8(Adapter, 0xc72, 0x50);
+			rtw_write8(Adapter, 0xc72, 0x50);		
 #endif
 
 	return rtStatus;
@@ -1830,7 +1830,7 @@
 	// RF config
 	//
 	rtStatus = PHY_RF6052_Config8192C(Adapter);
-#if 0
+#if 0	
 	switch(pHalData->rf_chip)
 	{
 		case RF_6052:
@@ -1839,7 +1839,7 @@
 		case RF_8225:
 			rtStatus = PHY_RF8225_Config(Adapter);
 			break;
-		case RF_8256:
+		case RF_8256:			
 			rtStatus = PHY_RF8256_Config(Adapter);
 			break;
 		case RF_8258:
@@ -1861,13 +1861,13 @@
  * Overview:    This function read RF parameters from general file format, and do RF 3-wire
  *
  * Input:      	PADAPTER			Adapter
- *			ps1Byte 				pFileName
+ *			ps1Byte 				pFileName			
  *			RF_RADIO_PATH_E	eRFPath
  *
  * Output:      NONE
  *
  * Return:      RT_STATUS_SUCCESS: configuration file exist
- *
+ *			
  * Note:		Delay may be required for RF configuration
  *---------------------------------------------------------------------------*/
 int
@@ -1878,12 +1878,12 @@
 )
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-
+	
 	int	rtStatus = _SUCCESS;
 
 
 	return rtStatus;
-
+	
 }
 
 //****************************************
@@ -1920,10 +1920,10 @@
 	{
 		return rtStatus;
 	}
-
-	// 2010/10/19 MH According to Jenyu/EEChou 's opinion, we need not to execute the
+	
+	// 2010/10/19 MH According to Jenyu/EEChou 's opinion, we need not to execute the 
 	// same code as SU. It is already updated in radio_a_1T_HP.txt.
-#if 0
+#if 0	
 	//add for SU High Power PA
 	for(i = 0;i<HighPowerRadioAArrayLen; i=i+2)
 	{
@@ -1942,13 +1942,13 @@
  * Overview:    This function read RF parameters from general file format, and do RF 3-wire
  *
  * Input:      	PADAPTER			Adapter
- *			ps1Byte 				pFileName
+ *			ps1Byte 				pFileName			
  *			RF_RADIO_PATH_E	eRFPath
  *
  * Output:      NONE
  *
  * Return:      RT_STATUS_SUCCESS: configuration file exist
- *
+ *			
  * Note:		Delay may be required for RF configuration
  *---------------------------------------------------------------------------*/
 int
@@ -1964,7 +1964,7 @@
 	u32*		Rtl819XRadioB_Array_Table;
 	u16		RadioA_ArrayLen,RadioB_ArrayLen;
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-
+	
 	//
 	// 2009.11.24. Modified by tynli.
 	//
@@ -1979,15 +1979,15 @@
 	{
 		RadioA_ArrayLen = RadioA_1TArrayLength;
 		Rtl819XRadioA_Array_Table = Rtl819XRadioA_1TArray;
-		RadioB_ArrayLen = RadioB_1TArrayLength;
+		RadioB_ArrayLen = RadioB_1TArrayLength;	
 		Rtl819XRadioB_Array_Table = Rtl819XRadioB_1TArray;
 #ifdef CONFIG_USB_HCI
 		if( BOARD_MINICARD == pHalData->BoardType )
 		{
 			RadioA_ArrayLen = RadioA_1T_mCardArrayLength;
 			Rtl819XRadioA_Array_Table = Rtl819XRadioA_1T_mCardArray;
-			RadioB_ArrayLen = RadioB_1T_mCardArrayLength;
-			Rtl819XRadioB_Array_Table = Rtl819XRadioB_1T_mCardArray;
+			RadioB_ArrayLen = RadioB_1T_mCardArrayLength;	
+			Rtl819XRadioB_Array_Table = Rtl819XRadioB_1T_mCardArray;			
 		}
 		else if( BOARD_USB_High_PA == pHalData->BoardType )
 		{
@@ -2007,7 +2007,7 @@
 					rtStatus = _FAIL;
 					goto exit;
 				}
-
+				
 				for(i = 0;i<RadioA_ArrayLen; i=i+2)
 				{
 					if(Rtl819XRadioA_Array_Table[i] == 0xfe)
@@ -2027,12 +2027,12 @@
 						BB_REGISTER_DEFINITION_T	*pPhyReg = &pHalData->PHYRegDef[eRFPath];
 						u32	NewOffset = 0;
 						u32	DataAndAddr = 0;
-
+						
 						NewOffset = Rtl819XRadioA_Array_Table[i] & 0x3f;
 						DataAndAddr = ((NewOffset<<20) | (Rtl819XRadioA_Array_Table[i+1]&0x000fffff)) & 0x0fffffff;	// T65 RF
 						rtw_IOL_append_WD_cmd(xmit_frame, pPhyReg->rf3wireOffset, DataAndAddr);
 					}
-				}
+				}	
 				rtStatus = rtw_IOL_exec_cmds_sync(Adapter, xmit_frame, 1000);
 			}
 			else
@@ -2078,7 +2078,7 @@
 					rtStatus = _FAIL;
 					goto exit;
 				}
-
+			
 				for(i = 0;i<RadioB_ArrayLen; i=i+2)
 				{
 					if(Rtl819XRadioB_Array_Table[i] == 0xfe)
@@ -2098,12 +2098,12 @@
 						BB_REGISTER_DEFINITION_T	*pPhyReg = &pHalData->PHYRegDef[eRFPath];
 						u32	NewOffset = 0;
 						u32	DataAndAddr = 0;
-
+						
 						NewOffset = Rtl819XRadioB_Array_Table[i] & 0x3f;
 						DataAndAddr = ((NewOffset<<20) | (Rtl819XRadioB_Array_Table[i+1]&0x000fffff)) & 0x0fffffff;	// T65 RF
 						rtw_IOL_append_WD_cmd(xmit_frame, pPhyReg->rf3wireOffset, DataAndAddr);
 					}
-				}
+				}	
 				rtStatus = rtw_IOL_exec_cmds_sync(Adapter, xmit_frame, 1000);
 			}
 			else
@@ -2112,7 +2112,7 @@
 				for(i = 0;i<RadioB_ArrayLen; i=i+2)
 				{
 					if(Rtl819XRadioB_Array_Table[i] == 0xfe)
-					{ // Deay specific ms. Only RF configuration require delay.
+					{ // Deay specific ms. Only RF configuration require delay.												
 #if 0//#ifdef CONFIG_USB_HCI
 						#ifdef CONFIG_LONG_DELAY_ISSUE
 						rtw_msleep_os(1000);
@@ -2142,7 +2142,7 @@
 						PHY_SetRFReg(Adapter, eRFPath, Rtl819XRadioB_Array_Table[i], bRFRegOffsetMask, Rtl819XRadioB_Array_Table[i+1]);
 						// Add 1us delay between BB/RF register setting.
 						rtw_udelay_os(1);
-					}
+					}	
 				}
 			}
 
@@ -2153,7 +2153,7 @@
 			break;
 	}
 
-exit:
+exit:	
 	return rtStatus;
 
 }
@@ -2172,7 +2172,7 @@
  * Output:      NONE
  *
  * Return:      RT_STATUS_SUCCESS: PHY is OK
- *
+ *			
  * Note:		This function may be removed in the ASIC
  *---------------------------------------------------------------------------*/
 int
@@ -2194,7 +2194,7 @@
 	WriteAddr[HW90_BLOCK_PHY0] = 0x900;
 	WriteAddr[HW90_BLOCK_PHY1] = 0x800;
 	WriteAddr[HW90_BLOCK_RF] = 0x3;
-
+	
 	for(i=0 ; i < CheckTimes ; i++)
 	{
 
@@ -2207,7 +2207,7 @@
 			//RT_ASSERT(FALSE, ("PHY_CheckBBRFOK(): Never Write 0x100 here!"));
 			//RT_TRACE(COMP_INIT, DBG_LOUD, ("PHY_CheckBBRFOK(): Never Write 0x100 here!\n"));
 			break;
-
+			
 		case HW90_BLOCK_PHY0:
 		case HW90_BLOCK_PHY1:
 			rtw_write32(Adapter, WriteAddr[CheckBlock], WriteData[i]);
@@ -2215,20 +2215,20 @@
 			break;
 
 		case HW90_BLOCK_RF:
-			// When initialization, we want the delay function(delay_ms(), delay_us()
+			// When initialization, we want the delay function(delay_ms(), delay_us() 
 			// ==> actually we call PlatformStallExecution()) to do NdisStallExecution()
-			// [busy wait] instead of NdisMSleep(). So we acquire RT_INITIAL_SPINLOCK
-			// to run at Dispatch level to achive it.
+			// [busy wait] instead of NdisMSleep(). So we acquire RT_INITIAL_SPINLOCK 
+			// to run at Dispatch level to achive it.	
 			//cosa PlatformAcquireSpinLock(Adapter, RT_INITIAL_SPINLOCK);
 			WriteData[i] &= 0xfff;
 			PHY_SetRFReg(Adapter, eRFPath, WriteAddr[HW90_BLOCK_RF], bRFRegOffsetMask, WriteData[i]);
 			// TODO: we should not delay for such a long time. Ask SD3
 			rtw_mdelay_os(10);
-			ulRegRead = PHY_QueryRFReg(Adapter, eRFPath, WriteAddr[HW90_BLOCK_RF], bMaskDWord);
+			ulRegRead = PHY_QueryRFReg(Adapter, eRFPath, WriteAddr[HW90_BLOCK_RF], bMaskDWord);				
 			rtw_mdelay_os(10);
 			//cosa PlatformReleaseSpinLock(Adapter, RT_INITIAL_SPINLOCK);
 			break;
-
+			
 		default:
 			rtStatus = _FAIL;
 			break;
@@ -2241,7 +2241,7 @@
 		if(ulRegRead != WriteData[i])
 		{
 			//RT_TRACE(COMP_FPGA, DBG_LOUD, ("ulRegRead: %lx, WriteData: %lx \n", ulRegRead, WriteData[i]));
-			rtStatus = _FAIL;
+			rtStatus = _FAIL;			
 			break;
 		}
 	}
@@ -2256,28 +2256,28 @@
 	)
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-
+	
 	// read rx initial gain
 	pHalData->DefaultInitialGain[0] = (u8)PHY_QueryBBReg(Adapter, rOFDM0_XAAGCCore1, bMaskByte0);
 	pHalData->DefaultInitialGain[1] = (u8)PHY_QueryBBReg(Adapter, rOFDM0_XBAGCCore1, bMaskByte0);
 	pHalData->DefaultInitialGain[2] = (u8)PHY_QueryBBReg(Adapter, rOFDM0_XCAGCCore1, bMaskByte0);
 	pHalData->DefaultInitialGain[3] = (u8)PHY_QueryBBReg(Adapter, rOFDM0_XDAGCCore1, bMaskByte0);
 	//RT_TRACE(COMP_INIT, DBG_LOUD,
-	//("Default initial gain (c50=0x%x, c58=0x%x, c60=0x%x, c68=0x%x) \n",
-	//pHalData->DefaultInitialGain[0], pHalData->DefaultInitialGain[1],
+	//("Default initial gain (c50=0x%x, c58=0x%x, c60=0x%x, c68=0x%x) \n", 
+	//pHalData->DefaultInitialGain[0], pHalData->DefaultInitialGain[1], 
 	//pHalData->DefaultInitialGain[2], pHalData->DefaultInitialGain[3]));
 
 	// read framesync
-	pHalData->framesync = (u8)PHY_QueryBBReg(Adapter, rOFDM0_RxDetector3, bMaskByte0);
+	pHalData->framesync = (u8)PHY_QueryBBReg(Adapter, rOFDM0_RxDetector3, bMaskByte0);	 
 	pHalData->framesyncC34 = PHY_QueryBBReg(Adapter, rOFDM0_RxDetector2, bMaskDWord);
-	//RT_TRACE(COMP_INIT, DBG_LOUD, ("Default framesync (0x%x) = 0x%x \n",
+	//RT_TRACE(COMP_INIT, DBG_LOUD, ("Default framesync (0x%x) = 0x%x \n", 
 	//	rOFDM0_RxDetector3, pHalData->framesync));
 }
 
 
 //
 //	Description:
-//		Map dBm into Tx power index according to
+//		Map dBm into Tx power index according to 
 //		current HW model, for example, RF and PA, and
 //		current wireless mode.
 //	By Bruce, 2008-01-29.
@@ -2291,15 +2291,15 @@
 {
 	u8				TxPwrIdx = 0;
 	int				Offset = 0;
-
+	
 
 	//
-	// Tested by MP, we found that CCK Index 0 equals to 8dbm, OFDM legacy equals to
+	// Tested by MP, we found that CCK Index 0 equals to 8dbm, OFDM legacy equals to 
 	// 3dbm, and OFDM HT equals to 0dbm repectively.
 	// Note:
-	//	The mapping may be different by different NICs. Do not use this formula for what needs accurate result.
+	//	The mapping may be different by different NICs. Do not use this formula for what needs accurate result.  
 	// By Bruce, 2008-01-29.
-	//
+	// 
 	switch(WirelessMode)
 	{
 	case WIRELESS_MODE_B:
@@ -2333,7 +2333,7 @@
 
 //
 //	Description:
-//		Map Tx power index into dBm according to
+//		Map Tx power index into dBm according to 
 //		current HW model, for example, RF and PA, and
 //		current wireless mode.
 //	By Bruce, 2008-01-29.
@@ -2347,13 +2347,13 @@
 {
 	int				Offset = 0;
 	int				PwrOutDbm = 0;
-
+	
 	//
 	// Tested by MP, we found that CCK Index 0 equals to -7dbm, OFDM legacy equals to -8dbm.
 	// Note:
-	//	The mapping may be different by different NICs. Do not use this formula for what needs accurate result.
+	//	The mapping may be different by different NICs. Do not use this formula for what needs accurate result.  
 	// By Bruce, 2008-01-29.
-	//
+	// 
 	switch(WirelessMode)
 	{
 	case WIRELESS_MODE_B:
@@ -2364,7 +2364,7 @@
 	case WIRELESS_MODE_N_24G:
 		Offset = -8;
 	default:
-		Offset = -8;
+		Offset = -8;	
 		break;
 	}
 
@@ -2396,9 +2396,9 @@
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	u8			TxPwrLevel = 0;
 	int			TxPwrDbm;
-
+	
 	//
-	// Because the Tx power indexes are different, we report the maximum of them to
+	// Because the Tx power indexes are different, we report the maximum of them to 
 	// meet the CCX TPC request. By Bruce, 2008-01-31.
 	//
 
@@ -2415,7 +2415,7 @@
 
 	// HT OFDM
 	TxPwrLevel = pHalData->CurrentOfdm24GTxPwrIdx;
-
+	
 	// Compare with HT OFDM Tx power.
 	if(phy_TxPwrIdxToDbm(Adapter, WIRELESS_MODE_N_24G, TxPwrLevel) > TxPwrDbm)
 		TxPwrDbm = phy_TxPwrIdxToDbm(Adapter, WIRELESS_MODE_N_24G, TxPwrLevel);
@@ -2470,13 +2470,13 @@ static void ccxPowerIndexCheck(
 	// 1. We shall not exceed Cell Power Limit as possible as we can.
 	// 2. Tolerance is +/- 5dB.
 	// 3. 802.11h Power Contraint takes higher precedence over CCX Cell Power Limit.
-	//
-	// TODO:
-	// 1. 802.11h power contraint
+	// 
+	// TODO: 
+	// 1. 802.11h power contraint 
 	//
 	// 071011, by rcnjko.
 	//
-	if(	pMgntInfo->OpMode == RT_OP_MODE_INFRASTRUCTURE &&
+	if(	pMgntInfo->OpMode == RT_OP_MODE_INFRASTRUCTURE && 
 		pMgntInfo->mAssoc &&
 		pCcxInfo->bUpdateCcxPwr &&
 		pCcxInfo->bWithCcxCellPwr &&
@@ -2486,12 +2486,12 @@ static void ccxPowerIndexCheck(
 		u1Byte	LegacyOfdmCellPwrIdx = phy_DbmToTxPwrIdx(Adapter, WIRELESS_MODE_G, pCcxInfo->CcxCellPwr);
 		u1Byte	OfdmCellPwrIdx = phy_DbmToTxPwrIdx(Adapter, WIRELESS_MODE_N_24G, pCcxInfo->CcxCellPwr);
 
-		RT_TRACE(COMP_TXAGC, DBG_LOUD,
-		("CCX Cell Limit: %d dbm => CCK Tx power index : %d, Legacy OFDM Tx power index : %d, OFDM Tx power index: %d\n",
+		RT_TRACE(COMP_TXAGC, DBG_LOUD, 
+		("CCX Cell Limit: %d dbm => CCK Tx power index : %d, Legacy OFDM Tx power index : %d, OFDM Tx power index: %d\n", 
 		pCcxInfo->CcxCellPwr, CckCellPwrIdx, LegacyOfdmCellPwrIdx, OfdmCellPwrIdx));
-		RT_TRACE(COMP_TXAGC, DBG_LOUD,
+		RT_TRACE(COMP_TXAGC, DBG_LOUD, 
 		("EEPROM channel(%d) => CCK Tx power index: %d, Legacy OFDM Tx power index : %d, OFDM Tx power index: %d\n",
-		channel, cckPowerLevel[0], ofdmPowerLevel[0] + pHalData->LegacyHTTxPowerDiff, ofdmPowerLevel[0]));
+		channel, cckPowerLevel[0], ofdmPowerLevel[0] + pHalData->LegacyHTTxPowerDiff, ofdmPowerLevel[0])); 
 
 		// CCK
 		if(cckPowerLevel[0] > CckCellPwrIdx)
@@ -2509,18 +2509,18 @@ static void ccxPowerIndexCheck(
 			}
 		}
 
-		RT_TRACE(COMP_TXAGC, DBG_LOUD,
-		("Altered CCK Tx power index : %d, Legacy OFDM Tx power index: %d, OFDM Tx power index: %d\n",
+		RT_TRACE(COMP_TXAGC, DBG_LOUD, 
+		("Altered CCK Tx power index : %d, Legacy OFDM Tx power index: %d, OFDM Tx power index: %d\n", 
 		cckPowerLevel[0], ofdmPowerLevel[0] + pHalData->LegacyHTTxPowerDiff, ofdmPowerLevel[0]));
 	}
 
 	pHalData->CurrentCckTxPwrIdx = cckPowerLevel[0];
 	pHalData->CurrentOfdm24GTxPwrIdx = ofdmPowerLevel[0];
 
-	RT_TRACE(COMP_TXAGC, DBG_LOUD,
-		("PHY_SetTxPowerLevel8192S(): CCK Tx power index : %d, Legacy OFDM Tx power index: %d, OFDM Tx power index: %d\n",
+	RT_TRACE(COMP_TXAGC, DBG_LOUD, 
+		("PHY_SetTxPowerLevel8192S(): CCK Tx power index : %d, Legacy OFDM Tx power index: %d, OFDM Tx power index: %d\n", 
 		cckPowerLevel[0], ofdmPowerLevel[0] + pHalData->LegacyHTTxPowerDiff, ofdmPowerLevel[0]));
-#endif
+#endif	
 }
 /*-----------------------------------------------------------------------------
  * Function:    SetTxPowerLevel8190()
@@ -2556,7 +2556,7 @@ static void ccxPowerIndexCheck(
 		return;
 
 	getTxPowerIndex(Adapter, channel, &cckPowerLevel[0], &ofdmPowerLevel[0]);
-	//RTPRINT(FPHY, PHY_TXPWR, ("Channel-%d, cckPowerLevel (A / B) = 0x%x / 0x%x,   ofdmPowerLevel (A / B) = 0x%x / 0x%x\n",
+	//RTPRINT(FPHY, PHY_TXPWR, ("Channel-%d, cckPowerLevel (A / B) = 0x%x / 0x%x,   ofdmPowerLevel (A / B) = 0x%x / 0x%x\n", 
 	//	channel, cckPowerLevel[0], cckPowerLevel[1], ofdmPowerLevel[0], ofdmPowerLevel[1]));
 
 	ccxPowerIndexCheck(Adapter, channel, &cckPowerLevel[0], &ofdmPowerLevel[0]);
@@ -2594,7 +2594,7 @@ static void ccxPowerIndexCheck(
 //	Description:
 //		Update transmit power level of all channel supported.
 //
-//	TODO:
+//	TODO: 
 //		A mode.
 //	By Bruce, 2008-02-04.
 //
@@ -2624,37 +2624,37 @@ static void ccxPowerIndexCheck(
 		for (rf_path = 0; rf_path < 2; rf_path++)
 		{
 			pHalData->TxPwrLevelCck[rf_path][idx] = CckTxPwrIdx;
-			pHalData->TxPwrLevelHT40_1S[rf_path][idx] =
+			pHalData->TxPwrLevelHT40_1S[rf_path][idx] = 
 			pHalData->TxPwrLevelHT40_2S[rf_path][idx] = OfdmTxPwrIdx;
 		}
 	}
 
 	//Adapter->HalFunc.SetTxPowerLevelHandler(Adapter, pHalData->CurrentChannel);//gtest:todo
 
-	return _TRUE;
+	return _TRUE;	
 }
 
 
 /*
 	Description:
-		When beacon interval is changed, the values of the
+		When beacon interval is changed, the values of the 
 		hw registers should be modified.
 	By tynli, 2008.10.24.
 
 */
 
 
-void
-rtl8192c_PHY_SetBeaconHwReg(
+void	
+rtl8192c_PHY_SetBeaconHwReg(	
 	IN	PADAPTER		Adapter,
-	IN	u16			BeaconInterval
+	IN	u16			BeaconInterval	
 	)
 {
 
 }
 
 
-VOID
+VOID 
 PHY_ScanOperationBackup8192C(
 	IN	PADAPTER	Adapter,
 	IN	u8		Operation
@@ -2662,7 +2662,7 @@ static void ccxPowerIndexCheck(
 {
 #if 0
 	IO_TYPE	IoType;
-
+	
 	if(!Adapter->bDriverStopped)
 	{
 		switch(Operation)
@@ -2683,7 +2683,7 @@ static void ccxPowerIndexCheck(
 				break;
 		}
 	}
-#endif
+#endif	
 }
 
 /*-----------------------------------------------------------------------------
@@ -2715,7 +2715,7 @@ static void ccxPowerIndexCheck(
 
 	// Added it for 20/40 mhz switch time evaluation by guangan 070531
 	//u4Byte				NowL, NowH;
-	//u8Byte				BeginTime, EndTime;
+	//u8Byte				BeginTime, EndTime; 
 
 	/*RT_TRACE(COMP_SCAN, DBG_LOUD, ("==>PHY_SetBWModeCallback8192C()  Switch to %s bandwidth\n", \
 					pHalData->CurrentChannelBW == HT_CHANNEL_WIDTH_20?"20MHz":"40MHz"))*/
@@ -2737,16 +2737,16 @@ static void ccxPowerIndexCheck(
 	//NowL = PlatformEFIORead4Byte(Adapter, TSFR);
 	//NowH = PlatformEFIORead4Byte(Adapter, TSFR+4);
 	//BeginTime = ((u8Byte)NowH << 32) + NowL;
-
+		
 	//3//
 	//3//<1>Set MAC register
 	//3//
 	//Adapter->HalFunc.SetBWModeHandler();
-
+	
 	regBwOpMode = rtw_read8(Adapter, REG_BWOPMODE);
 	regRRSR_RSC = rtw_read8(Adapter, REG_RRSR+2);
 	//regBwOpMode = rtw_hal_get_hwreg(Adapter,HW_VAR_BWMODE,(pu1Byte)&regBwOpMode);
-
+	
 	switch(pHalData->CurrentChannelBW)
 	{
 		case HT_CHANNEL_WIDTH_20:
@@ -2754,7 +2754,7 @@ static void ccxPowerIndexCheck(
 			   // 2007/02/07 Mark by Emily becasue we have not verify whether this register works
 			rtw_write8(Adapter, REG_BWOPMODE, regBwOpMode);
 			break;
-
+			   
 		case HT_CHANNEL_WIDTH_40:
 			regBwOpMode &= ~BW_OPMODE_20MHZ;
 				// 2007/02/07 Mark by Emily becasue we have not verify whether this register works
@@ -2769,7 +2769,7 @@ static void ccxPowerIndexCheck(
 						unknown Bandwidth: %#X\n",pHalData->CurrentChannelBW));*/
 			break;
 	}
-
+	
 	//3//
 	//3//<2>Set PHY related register
 	//3//
@@ -2780,7 +2780,7 @@ static void ccxPowerIndexCheck(
 			PHY_SetBBReg(Adapter, rFPGA0_RFMOD, bRFMOD, 0x0);
 			PHY_SetBBReg(Adapter, rFPGA1_RFMOD, bRFMOD, 0x0);
 			PHY_SetBBReg(Adapter, rFPGA0_AnalogParameter2, BIT10, 1);
-
+			
 			break;
 
 
@@ -2788,23 +2788,23 @@ static void ccxPowerIndexCheck(
 		case HT_CHANNEL_WIDTH_40:
 			PHY_SetBBReg(Adapter, rFPGA0_RFMOD, bRFMOD, 0x1);
 			PHY_SetBBReg(Adapter, rFPGA1_RFMOD, bRFMOD, 0x1);
-
+			
 			// Set Control channel to upper or lower. These settings are required only for 40MHz
 			PHY_SetBBReg(Adapter, rCCK0_System, bCCKSideBand, (pHalData->nCur40MhzPrimeSC>>1));
 			PHY_SetBBReg(Adapter, rOFDM1_LSTF, 0xC00, pHalData->nCur40MhzPrimeSC);
 			PHY_SetBBReg(Adapter, rFPGA0_AnalogParameter2, BIT10, 0);
 
 			PHY_SetBBReg(Adapter, 0x818, (BIT26|BIT27), (pHalData->nCur40MhzPrimeSC==HAL_PRIME_CHNL_OFFSET_LOWER)?2:1);
-
+			
 			break;
 
 
-
+			
 		default:
 			/*RT_TRACE(COMP_DBG, DBG_LOUD, ("PHY_SetBWModeCallback8192C(): unknown Bandwidth: %#X\n"\
 						,pHalData->CurrentChannelBW));*/
 			break;
-
+			
 	}
 	//Skip over setting of J-mode in BB register here. Default value is "None J mode". Emily 20070315
 
@@ -2817,15 +2817,15 @@ static void ccxPowerIndexCheck(
 	//3<3>Set RF related register
 	switch(pHalData->rf_chip)
 	{
-		case RF_8225:
+		case RF_8225:		
 			//PHY_SetRF8225Bandwidth(Adapter, pHalData->CurrentChannelBW);
-			break;
-
+			break;	
+			
 		case RF_8256:
 			// Please implement this function in Hal8190PciPhy8256.c
 			//PHY_SetRF8256Bandwidth(Adapter, pHalData->CurrentChannelBW);
 			break;
-
+			
 		case RF_8258:
 			// Please implement this function in Hal8190PciPhy8258.c
 			// PHY_SetRF8258Bandwidth();
@@ -2834,11 +2834,11 @@ static void ccxPowerIndexCheck(
 		case RF_PSEUDO_11N:
 			// Do Nothing
 			break;
-
+			
 		case RF_6052:
 			rtl8192c_PHY_RF6052SetBandwidth(Adapter, pHalData->CurrentChannelBW);
-			break;
-
+			break;	
+			
 		default:
 			//RT_ASSERT(FALSE, ("Unknown RFChipID: %d\n", pHalData->RFChipID));
 			break;
@@ -2877,11 +2877,11 @@ static void ccxPowerIndexCheck(
 	//PMGNT_INFO	pMgntInfo=&Adapter->MgntInfo;
 
 	//return;
-
+	
 	//if(pHalData->SwChnlInProgress)
 //	if(pMgntInfo->bScanInProgress)
 //	{
-//		RT_TRACE(COMP_SCAN, DBG_LOUD, ("PHY_SetBWMode8192C() %s Exit because bScanInProgress!\n",
+//		RT_TRACE(COMP_SCAN, DBG_LOUD, ("PHY_SetBWMode8192C() %s Exit because bScanInProgress!\n", 
 //					Bandwidth == HT_CHANNEL_WIDTH_20?"20MHz":"40MHz"));
 //		return;
 //	}
@@ -2889,7 +2889,7 @@ static void ccxPowerIndexCheck(
 //	if(pHalData->SetBWModeInProgress)
 //	{
 //		// Modified it for 20/40 mhz switch by guangan 070531
-//		RT_TRACE(COMP_SCAN, DBG_LOUD, ("PHY_SetBWMode8192C() %s cancel last timer because SetBWModeInProgress!\n",
+//		RT_TRACE(COMP_SCAN, DBG_LOUD, ("PHY_SetBWMode8192C() %s cancel last timer because SetBWModeInProgress!\n", 
 //					Bandwidth == HT_CHANNEL_WIDTH_20?"20MHz":"40MHz"));
 //		PlatformCancelTimer(Adapter, &pHalData->SetBWModeTimer);
 //		//return;
@@ -2899,7 +2899,7 @@ static void ccxPowerIndexCheck(
 	//	return;
 
 	//pHalData->SetBWModeInProgress= TRUE;
-
+	
 	pHalData->CurrentChannelBW = Bandwidth;
 
 #if 0
@@ -2915,7 +2915,7 @@ static void ccxPowerIndexCheck(
 
 	if((!Adapter->bDriverStopped) && (!Adapter->bSurpriseRemoved))
 	{
-#ifdef USE_WORKITEM
+#ifdef USE_WORKITEM	
 		//PlatformScheduleWorkItem(&(pHalData->SetBWModeWorkItem));
 #else
 	#if 0
@@ -2923,15 +2923,15 @@ static void ccxPowerIndexCheck(
 	#else
 		_PHY_SetBWMode92C(Adapter);
 	#endif
-#endif
+#endif		
 	}
 	else
 	{
-		//RT_TRACE(COMP_SCAN, DBG_LOUD, ("PHY_SetBWMode8192C() SetBWModeInProgress FALSE driver sleep or unload\n"));
-		//pHalData->SetBWModeInProgress= FALSE;
+		//RT_TRACE(COMP_SCAN, DBG_LOUD, ("PHY_SetBWMode8192C() SetBWModeInProgress FALSE driver sleep or unload\n"));	
+		//pHalData->SetBWModeInProgress= FALSE;	
 		pHalData->CurrentChannelBW = tmpBW;
 	}
-
+	
 }
 
 
@@ -2957,8 +2957,8 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 		pHalData->RfRegChnlVal[eRFPath] = ((pHalData->RfRegChnlVal[eRFPath] & 0xfffffc00) | param2);
 		PHY_SetRFReg(Adapter, (RF_RADIO_PATH_E)eRFPath, param1, bRFRegOffsetMask, pHalData->RfRegChnlVal[eRFPath]);
 	}
-
-
+	
+	
 	//s3. post common command - CmdID_End, None
 
 }
@@ -2977,9 +2977,9 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 	if(pHalData->rf_chip == RF_PSEUDO_11N)
 	{
 		//pHalData->SwChnlInProgress=FALSE;
-		return; 								//return immediately if it is peudo-phy
+		return; 								//return immediately if it is peudo-phy	
 	}
-
+	
 	//if(pHalData->SwChnlInProgress)
 	//	return;
 
@@ -2991,13 +2991,13 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 	{
 		case WIRELESS_MODE_A:
 		case WIRELESS_MODE_N_5G:
-			//RT_ASSERT((channel>14), ("WIRELESS_MODE_A but channel<=14"));
+			//RT_ASSERT((channel>14), ("WIRELESS_MODE_A but channel<=14"));		
 			break;
-
+		
 		case WIRELESS_MODE_B:
 			//RT_ASSERT((channel<=14), ("WIRELESS_MODE_B but channel>14"));
 			break;
-
+		
 		case WIRELESS_MODE_G:
 		case WIRELESS_MODE_N_24G:
 			//RT_ASSERT((channel<=14), ("WIRELESS_MODE_G but channel>14"));
@@ -3008,11 +3008,11 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 			break;
 	}
 	//--------------------------------------------
-
+	
 	//pHalData->SwChnlInProgress = TRUE;
 	if(channel == 0)
 		channel = 1;
-
+	
 	pHalData->CurrentChannel=channel;
 
 	//pHalData->SwChnlStage=0;
@@ -3020,10 +3020,10 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 
 	if((!Adapter->bDriverStopped) && (!Adapter->bSurpriseRemoved))
 	{
-#ifdef USE_WORKITEM
+#ifdef USE_WORKITEM	
 		//bResult = PlatformScheduleWorkItem(&(pHalData->SwChnlWorkItem));
 #else
-		#if 0
+		#if 0		
 		//PlatformSetTimer(Adapter, &(pHalData->SwChnlTimer), 0);
 		#else
 		_PHY_SwChnl8192C(Adapter, channel);
@@ -3035,21 +3035,21 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 		}
 		else
 		{
-			//RT_TRACE(COMP_SCAN, DBG_LOUD, ("PHY_SwChnl8192C SwChnlInProgress FALSE schdule workitem error\n"));
+			//RT_TRACE(COMP_SCAN, DBG_LOUD, ("PHY_SwChnl8192C SwChnlInProgress FALSE schdule workitem error\n"));		
 			//if(IS_HARDWARE_TYPE_8192SU(Adapter))
 			//{
-			//	pHalData->SwChnlInProgress = FALSE;
-				pHalData->CurrentChannel = tmpchannel;
+			//	pHalData->SwChnlInProgress = FALSE; 	
+				pHalData->CurrentChannel = tmpchannel;			
 			//}
 		}
 
 	}
 	else
 	{
-		//RT_TRACE(COMP_SCAN, DBG_LOUD, ("PHY_SwChnl8192C SwChnlInProgress FALSE driver sleep or unload\n"));
+		//RT_TRACE(COMP_SCAN, DBG_LOUD, ("PHY_SwChnl8192C SwChnlInProgress FALSE driver sleep or unload\n"));	
 		//if(IS_HARDWARE_TYPE_8192SU(Adapter))
 		//{
-		//	pHalData->SwChnlInProgress = FALSE;
+		//	pHalData->SwChnlInProgress = FALSE;		
 			pHalData->CurrentChannel = tmpchannel;
 		//}
 	}
@@ -3074,67 +3074,67 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 	u4Byte					PostCommonCmdCnt;
 	SwChnlCmd				RfDependCmd[MAX_RFDEPENDCMD_CNT];
 	u4Byte					RfDependCmdCnt;
-	SwChnlCmd				*CurrentCmd;
-	u1Byte					eRFPath;
+	SwChnlCmd				*CurrentCmd;	
+	u1Byte					eRFPath;	
 	u4Byte					RfTXPowerCtrl;
 	BOOLEAN					bAdjRfTXPowerCtrl = _FALSE;
-
-
+	
+	
 	RT_ASSERT((Adapter != NULL), ("Adapter should not be NULL\n"));
 #if(MP_DRIVER != 1)
 	RT_ASSERT(IsLegalChannel(Adapter, channel), ("illegal channel: %d\n", channel));
 #endif
 	RT_ASSERT((pHalData != NULL), ("pHalData should not be NULL\n"));
-
+	
 	pChnlAccessSetting = &Adapter->MgntInfo.Info8185.ChannelAccessSetting;
 	RT_ASSERT((pChnlAccessSetting != NULL), ("pChnlAccessSetting should not be NULL\n"));
-
+	
 	//for(eRFPath = RF_PATH_A; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
 	//for(eRFPath = 0; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
 	//{
 		// <1> Fill up pre common command.
 	PreCommonCmdCnt = 0;
-	phy_SetSwChnlCmdArray(PreCommonCmd, PreCommonCmdCnt++, MAX_PRECMD_CNT,
+	phy_SetSwChnlCmdArray(PreCommonCmd, PreCommonCmdCnt++, MAX_PRECMD_CNT, 
 				CmdID_SetTxPowerLevel, 0, 0, 0);
-	phy_SetSwChnlCmdArray(PreCommonCmd, PreCommonCmdCnt++, MAX_PRECMD_CNT,
+	phy_SetSwChnlCmdArray(PreCommonCmd, PreCommonCmdCnt++, MAX_PRECMD_CNT, 
 				CmdID_End, 0, 0, 0);
-
+	
 		// <2> Fill up post common command.
 	PostCommonCmdCnt = 0;
 
-	phy_SetSwChnlCmdArray(PostCommonCmd, PostCommonCmdCnt++, MAX_POSTCMD_CNT,
+	phy_SetSwChnlCmdArray(PostCommonCmd, PostCommonCmdCnt++, MAX_POSTCMD_CNT, 
 				CmdID_End, 0, 0, 0);
-
+	
 		// <3> Fill up RF dependent command.
 	RfDependCmdCnt = 0;
 	switch( pHalData->RFChipID )
 	{
-		case RF_8225:
+		case RF_8225:		
 		RT_ASSERT((channel >= 1 && channel <= 14), ("illegal channel for Zebra: %d\n", channel));
-		// 2008/09/04 MH Change channel.
+		// 2008/09/04 MH Change channel. 
 		if(channel==14) channel++;
-		phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++, MAX_RFDEPENDCMD_CNT,
+		phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++, MAX_RFDEPENDCMD_CNT, 
 			CmdID_RF_WriteReg, rZebra1_Channel, (0x10+channel-1), 10);
-		phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++, MAX_RFDEPENDCMD_CNT,
+		phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++, MAX_RFDEPENDCMD_CNT, 
 		CmdID_End, 0, 0, 0);
-		break;
-
+		break;	
+		
 	case RF_8256:
 		// TEST!! This is not the table for 8256!!
 		RT_ASSERT((channel >= 1 && channel <= 14), ("illegal channel for Zebra: %d\n", channel));
-		phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++, MAX_RFDEPENDCMD_CNT,
+		phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++, MAX_RFDEPENDCMD_CNT, 
 			CmdID_RF_WriteReg, rRfChannel, channel, 10);
-		phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++, MAX_RFDEPENDCMD_CNT,
+		phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++, MAX_RFDEPENDCMD_CNT, 
 		CmdID_End, 0, 0, 0);
 		break;
-
+		
 	case RF_6052:
 		RT_ASSERT((channel >= 1 && channel <= 14), ("illegal channel for Zebra: %d\n", channel));
-		phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++, MAX_RFDEPENDCMD_CNT,
-			CmdID_RF_WriteReg, RF_CHNLBW, channel, 10);
-		phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++, MAX_RFDEPENDCMD_CNT,
-		CmdID_End, 0, 0, 0);
-
+		phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++, MAX_RFDEPENDCMD_CNT, 
+			CmdID_RF_WriteReg, RF_CHNLBW, channel, 10);		
+		phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++, MAX_RFDEPENDCMD_CNT, 
+		CmdID_End, 0, 0, 0);		
+		
 		break;
 
 	case RF_8258:
@@ -3149,7 +3149,7 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 		break;
 	}
 
-
+	
 	do{
 		switch(*stage)
 		{
@@ -3163,7 +3163,7 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 			CurrentCmd=&PostCommonCmd[*step];
 			break;
 		}
-
+		
 		if(CurrentCmd->CmdID==CmdID_End)
 		{
 			if((*stage)==2)
@@ -3177,7 +3177,7 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 				continue;
 			}
 		}
-
+		
 		switch(CurrentCmd->CmdID)
 		{
 		case CmdID_SetTxPowerLevel:
@@ -3204,7 +3204,7 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 			}
 			break;
 		}
-
+		
 		break;
 	}while(TRUE);
 	//cosa }/*for(Number of RF paths)*/
@@ -3212,7 +3212,7 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 	(*delay)=CurrentCmd->msDelay;
 	(*step)++;
 	return FALSE;
-#endif
+#endif	
 	return _TRUE;
 }
 
@@ -3237,7 +3237,7 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 	}
 	if(CmdTableIdx >= CmdTableSz)
 	{
-		//RT_ASSERT(FALSE,
+		//RT_ASSERT(FALSE, 
 		//		("phy_SetSwChnlCmdArray(): Access invalid index, please check size of the table, CmdTableIdx:%ld, CmdTableSz:%ld\n",
 		//		CmdTableIdx, CmdTableSz));
 		return _FALSE;
@@ -3262,13 +3262,13 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 #if 0
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	u32			delay;
-
+  
 	while(!phy_SwChnlStepByStep(Adapter,channel,&pHalData->SwChnlStage,&pHalData->SwChnlStep,&delay))
 	{
 		if(delay>0)
 			rtw_mdelay_os(delay);
 	}
-#endif
+#endif	
 }
 
 
@@ -3281,7 +3281,7 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 // The following procedure is operted according to SwChanlCallback8190Pci().
 // However, this procedure is performed synchronously  which should be running under
 // passive level.
-//
+// 
 VOID
 PHY_SwChnlPhy8192C(	// Only called during initialize
 	IN	PADAPTER	Adapter,
@@ -3299,25 +3299,25 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 	// Channel Switching is in progress.
 	//if(pHalData->SwChnlInProgress)
 	//	return;
-
+	
 	//return immediately if it is peudo-phy
 	if(pHalData->rf_chip == RF_PSEUDO_11N)
 	{
 		//pHalData->SwChnlInProgress=FALSE;
 		return;
 	}
-
+	
 	//pHalData->SwChnlInProgress = TRUE;
 	if( channel == 0)
 		channel = 1;
-
+	
 	pHalData->CurrentChannel=channel;
-
+	
 	//pHalData->SwChnlStage = 0;
 	//pHalData->SwChnlStep = 0;
-
+	
 	phy_FinishSwChnlNow(Adapter,channel);
-
+	
 	//pHalData->SwChnlInProgress = FALSE;
 }
 
@@ -3325,7 +3325,7 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 //
 //	Description:
 //		Configure H/W functionality to enable/disable Monitor mode.
-//		Note, because we possibly need to configure BB and RF in this function,
+//		Note, because we possibly need to configure BB and RF in this function, 
 //		so caller should in PASSIVE_LEVEL. 080118, by rcnjko.
 //
 VOID
@@ -3357,7 +3357,7 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 		pHalData->bInMonitorMode = FALSE;
 		rtw_hal_set_hwreg(pAdapter, HW_VAR_CHECK_BSSID, (pu1Byte)&bFilterOutNonAssociatedBSSID);
 	}
-#endif
+#endif	
 }
 
 
@@ -3375,11 +3375,11 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
  *
  * Revised History:
  *	When		Who		Remark
- *	11/15/2007	MHC		Create Version 0.
+ *	11/15/2007	MHC		Create Version 0.  
  *
  *---------------------------------------------------------------------------*/
-BOOLEAN
-PHY_CheckIsLegalRfPath8192C(
+BOOLEAN	
+PHY_CheckIsLegalRfPath8192C(	
 	IN	PADAPTER	pAdapter,
 	IN	u32	eRFPath)
 {
@@ -3387,9 +3387,9 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 	BOOLEAN				rtValue = _TRUE;
 
 	// NOt check RF Path now.!
-#if 0
+#if 0	
 	if (pHalData->RF_Type == RF_1T2R && eRFPath != RF_PATH_A)
-	{
+	{		
 		rtValue = FALSE;
 	}
 	if (pHalData->RF_Type == RF_1T2R && eRFPath != RF_PATH_A)
@@ -3427,7 +3427,7 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 	PHY_SetBBReg(pAdapter, rRx_IQK_Tone_A, bMaskDWord, 0x10008c1f);
 	PHY_SetBBReg(pAdapter, rTx_IQK_PI_A, bMaskDWord, 0x82140102);
 
-	PHY_SetBBReg(pAdapter, rRx_IQK_PI_A, bMaskDWord, configPathB ? 0x28160202 :
+	PHY_SetBBReg(pAdapter, rRx_IQK_PI_A, bMaskDWord, configPathB ? 0x28160202 : 
 		IS_81xxC_VENDOR_UMC_B_CUT(pHalData->VersionID)?0x28160202:0x28160502);
 
 	//path-B IQK setting
@@ -3447,7 +3447,7 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 	//RTPRINT(FINIT, INIT_IQK, ("One shot, path A LOK & IQK!\n"));
 	PHY_SetBBReg(pAdapter, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
 	PHY_SetBBReg(pAdapter, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
-
+	
 	// delay x ms
 	//RTPRINT(FINIT, INIT_IQK, ("Delay %d ms for One shot, path A LOK & IQK.\n", IQK_DELAY_TIME));
 	rtw_udelay_os(IQK_DELAY_TIME*1000);//PlatformStallExecution(IQK_DELAY_TIME*1000);
@@ -3462,7 +3462,7 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 	regEA4= PHY_QueryBBReg(pAdapter, rRx_Power_Before_IQK_A_2, bMaskDWord);
 	//RTPRINT(FINIT, INIT_IQK, ("0xea4 = 0x%x\n", regEA4));
 
-        if(!(regEAC & BIT28) &&
+        if(!(regEAC & BIT28) &&		
 		(((regE94 & 0x03FF0000)>>16) != 0x142) &&
 		(((regE9C & 0x03FF0000)>>16) != 0x42) )
 		result |= 0x01;
@@ -3475,7 +3475,7 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 		result |= 0x02;
 	else
 		DBG_8192C("Path A Rx IQK fail!!\n");
-
+	
 	return result;
 
 
@@ -3524,7 +3524,7 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 		result |= 0x02;
 	else
 		DBG_8192C("Path B Rx IQK fail!!\n");
-
+	
 
 	return result;
 
@@ -3595,7 +3595,7 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 {
 	u32	Oldval_1, X, TX1_A, reg;
 	s32	Y, TX1_C;
-
+	
 	DBG_8192C("Path B IQ Calibration %s !\n",(bIQKOK)?"Success":"Failed");
 
 	if(final_candidate == 0xFF)
@@ -3606,7 +3606,7 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 
 		X = result[final_candidate][4];
 		if ((X & 0x00000200) != 0)
-			X = X | 0xFFFFFC00;
+			X = X | 0xFFFFFC00;		
 		TX1_A = (X * Oldval_1) >> 8;
 		//RTPRINT(FINIT, INIT_IQK, ("X = 0x%lx, TX1_A = 0x%lx\n", X, TX1_A));
 		PHY_SetBBReg(pAdapter, rOFDM0_XBTxIQImbalance, 0x3FF, TX1_A);
@@ -3614,7 +3614,7 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 
 		Y = result[final_candidate][5];
 		if ((Y & 0x00000200) != 0)
-			Y = Y | 0xFFFFFC00;
+			Y = Y | 0xFFFFFC00;		
 		TX1_C = (Y * Oldval_1) >> 8;
 		//RTPRINT(FINIT, INIT_IQK, ("Y = 0x%lx, TX1_C = 0x%lx\n", Y, TX1_C));
 		PHY_SetBBReg(pAdapter, rOFDM0_XDTxAFE, 0xF0000000, ((TX1_C&0x3C0)>>6));
@@ -3644,7 +3644,7 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 	)
 {
 	u32	i;
-
+	
 	//RTPRINT(FINIT, INIT_IQK, ("Save ADDA parameters.\n"));
 	for( i = 0 ; i < RegisterNum ; i++){
 		ADDABackup[i] = PHY_QueryBBReg(pAdapter, ADDAReg[i], bMaskDWord);
@@ -3659,12 +3659,12 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 	)
 {
 	u32	i;
-
+	
 	//RTPRINT(FINIT, INIT_IQK, ("Save MAC parameters.\n"));
 	for( i = 0 ; i < (IQK_MAC_REG_NUM - 1); i++){
-		MACBackup[i] =rtw_read8(pAdapter, MACReg[i]);
+		MACBackup[i] =rtw_read8(pAdapter, MACReg[i]);		
 	}
-	MACBackup[i] = rtw_read32(pAdapter, MACReg[i]);
+	MACBackup[i] = rtw_read32(pAdapter, MACReg[i]);		
 
 }
 
@@ -3697,7 +3697,7 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 	for(i = 0 ; i < (IQK_MAC_REG_NUM - 1); i++){
 		rtw_write8(pAdapter, MACReg[i], (u8)MACBackup[i]);
 	}
-	rtw_write32(pAdapter, MACReg[i], MACBackup[i]);
+	rtw_write32(pAdapter, MACReg[i], MACBackup[i]);	
 }
 
 static VOID
@@ -3721,18 +3721,18 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 	else{
 		PHY_SetBBReg(pAdapter, ADDAReg[0], bMaskDWord, pathOn);
 	}
-
+	
 	for( i = 1 ; i < IQK_ADDA_REG_NUM ; i++){
 		PHY_SetBBReg(pAdapter, ADDAReg[i], bMaskDWord, pathOn);
 	}
-
+	
 }
 
 static VOID
 _PHY_MACSettingCalibration(
 	IN	PADAPTER	pAdapter,
 	IN	u32*		MACReg,
-	IN	u32*		MACBackup
+	IN	u32*		MACBackup	
 	)
 {
 	u32	i = 0;
@@ -3744,7 +3744,7 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 	for(i = 1 ; i < (IQK_MAC_REG_NUM - 1); i++){
 		rtw_write8(pAdapter, MACReg[i], (u8)(MACBackup[i]&(~BIT3)));
 	}
-	rtw_write8(pAdapter, MACReg[i], (u8)(MACBackup[i]&(~BIT5)));
+	rtw_write8(pAdapter, MACReg[i], (u8)(MACBackup[i]&(~BIT5)));	
 
 }
 
@@ -3778,7 +3778,7 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 /*
 return _FALSE => do IQK again
 */
-static BOOLEAN
+static BOOLEAN							
 _PHY_SimularityCompare(
 	IN	PADAPTER	pAdapter,
 	IN	int 		result[][8],
@@ -3787,17 +3787,17 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 	)
 {
 	u32		i, j, diff, SimularityBitMap, bound = 0;
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);	
 	u8		final_candidate[2] = {0xFF, 0xFF};	//for path A and path B
 	BOOLEAN		bResult = _TRUE, is2T = IS_92C_SERIAL( pHalData->VersionID);
-
+	
 	if(is2T)
 		bound = 8;
 	else
 		bound = 4;
 
 	SimularityBitMap = 0;
-
+	
 	for( i = 0; i < bound; i++ )
 	{
 		diff = (result[c1][i] > result[c2][i]) ? (result[c1][i] - result[c2][i]) : (result[c2][i] - result[c1][i]);
@@ -3816,7 +3816,7 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 				SimularityBitMap = SimularityBitMap|(1<<i);
 		}
 	}
-
+	
 	if ( SimularityBitMap == 0)
 	{
 		for( i = 0; i < (bound/4); i++ )
@@ -3841,13 +3841,13 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 		for(i = 4; i < 8; i++)
 			result[3][i] = result[c1][i];
 		return _FALSE;
-	}
-	else
+	}	
+	else		
 		return _FALSE;
-
+	
 }
 
-static VOID
+static VOID	
 _PHY_IQCalibrate(
 	IN	PADAPTER	pAdapter,
 	IN	int 		result[][8],
@@ -3859,25 +3859,25 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 	u32			i;
 	u8			PathAOK, PathBOK;
-	u32			ADDA_REG[IQK_ADDA_REG_NUM] = {
-						rFPGA0_XCD_SwitchControl, 	rBlue_Tooth,
+	u32			ADDA_REG[IQK_ADDA_REG_NUM] = {	
+						rFPGA0_XCD_SwitchControl, 	rBlue_Tooth, 	
 						rRx_Wait_CCA, 		rTx_CCK_RFON,
-						rTx_CCK_BBON, 	rTx_OFDM_RFON,
+						rTx_CCK_BBON, 	rTx_OFDM_RFON, 	
 						rTx_OFDM_BBON, 	rTx_To_Rx,
-						rTx_To_Tx, 		rRx_CCK,
+						rTx_To_Tx, 		rRx_CCK, 	
 						rRx_OFDM, 		rRx_Wait_RIFS,
-						rRx_TO_Rx, 		rStandby,
+						rRx_TO_Rx, 		rStandby, 	
 						rSleep, 			rPMPD_ANAEN };
 
 	u32			IQK_MAC_REG[IQK_MAC_REG_NUM] = {
-						REG_TXPAUSE, 		REG_BCN_CTRL,
+						REG_TXPAUSE, 		REG_BCN_CTRL,	
 						REG_BCN_CTRL_1,	REG_GPIO_MUXCFG};
 
 	u32			IQK_BB_REG_92C[IQK_BB_REG_NUM] = {
-							rOFDM0_TRxPathEnable, 		rOFDM0_TRMuxPar,
+							rOFDM0_TRxPathEnable, 		rOFDM0_TRMuxPar,	
 							rFPGA0_XCD_RFInterfaceSW,	rConfig_AntA,	rConfig_AntB,
-							rFPGA0_XAB_RFInterfaceSW,	rFPGA0_XA_RFInterfaceOE,
-							rFPGA0_XB_RFInterfaceOE,	rFPGA0_RFMOD
+							rFPGA0_XAB_RFInterfaceSW,	rFPGA0_XA_RFInterfaceOE,	
+							rFPGA0_XB_RFInterfaceOE,	rFPGA0_RFMOD	
 							};
 
 #if MP_DRIVER
@@ -3886,24 +3886,24 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 	const u32	retryCount = 2;
 #endif
 
-	// Note: IQ calibration must be performed after loading
-	// 		PHY_REG.txt , and radio_a, radio_b.txt
-
+	// Note: IQ calibration must be performed after loading 
+	// 		PHY_REG.txt , and radio_a, radio_b.txt	
+	
 	u32 bbvalue;
 
 	if(t==0)
 	{
-		bbvalue = PHY_QueryBBReg(pAdapter, rFPGA0_RFMOD, bMaskDWord);
+	 	bbvalue = PHY_QueryBBReg(pAdapter, rFPGA0_RFMOD, bMaskDWord);
 		//RTPRINT(FINIT, INIT_IQK, ("PHY_IQCalibrate()==>0x%08lx\n",bbvalue));
 
 		//RTPRINT(FINIT, INIT_IQK, ("IQ Calibration for %s\n", (is2T ? "2T2R" : "1T1R")));
-
-		// Save ADDA parameters, turn Path A ADDA on
-		_PHY_SaveADDARegisters(pAdapter, ADDA_REG, pdmpriv->ADDA_backup,IQK_ADDA_REG_NUM);
+	
+	 	// Save ADDA parameters, turn Path A ADDA on
+	 	_PHY_SaveADDARegisters(pAdapter, ADDA_REG, pdmpriv->ADDA_backup,IQK_ADDA_REG_NUM);
 		_PHY_SaveMACRegisters(pAdapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
 		_PHY_SaveADDARegisters(pAdapter, IQK_BB_REG_92C, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM);
 	}
-	_PHY_PathADDAOn(pAdapter, ADDA_REG, _TRUE, is2T);
+ 	_PHY_PathADDAOn(pAdapter, ADDA_REG, _TRUE, is2T);
 
 	if(t==0)
 	{
@@ -3929,20 +3929,20 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 		PHY_SetBBReg(pAdapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x00010000);
 		PHY_SetBBReg(pAdapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x00010000);
 	}
-
+	
 	//MAC settings
 	_PHY_MACSettingCalibration(pAdapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
 
 	//Page B init
 	PHY_SetBBReg(pAdapter, rConfig_AntA, bMaskDWord, 0x00080000);
-
+	
 	if(is2T)
 	{
 		PHY_SetBBReg(pAdapter, rConfig_AntB, bMaskDWord, 0x00080000);
 	}
-
+	
 	// IQ calibration setting
-	//RTPRINT(FINIT, INIT_IQK, ("IQK setting!\n"));
+	//RTPRINT(FINIT, INIT_IQK, ("IQK setting!\n"));		
 	PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
 	PHY_SetBBReg(pAdapter, rTx_IQK, bMaskDWord, 0x01007c00);
 	PHY_SetBBReg(pAdapter, rRx_IQK, bMaskDWord, 0x01004800);
@@ -3960,13 +3960,13 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 		else if (i == (retryCount-1) && PathAOK == 0x01)	//Tx IQK OK
 		{
 			DBG_8192C("Path A IQK Only  Tx Success!!\n");
-
+			
 			result[t][0] = (PHY_QueryBBReg(pAdapter, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16;
-			result[t][1] = (PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+			result[t][1] = (PHY_QueryBBReg(pAdapter, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16;			
 		}
 	}
 
-	if(0x00 == PathAOK){
+	if(0x00 == PathAOK){		
 		DBG_8192C("Path A IQK failed!!\n");
 	}
 
@@ -3994,7 +3994,7 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 			}
 		}
 
-		if(0x00 == PathBOK){
+		if(0x00 == PathBOK){		
 			DBG_8192C("Path B IQK failed!!\n");
 		}
 	}
@@ -4011,13 +4011,13 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 		}
 
 		// Reload ADDA power saving parameters
-		_PHY_ReloadADDARegisters(pAdapter, ADDA_REG, pdmpriv->ADDA_backup, IQK_ADDA_REG_NUM);
+	 	_PHY_ReloadADDARegisters(pAdapter, ADDA_REG, pdmpriv->ADDA_backup, IQK_ADDA_REG_NUM);
 
 		// Reload MAC parameters
 		_PHY_ReloadMACRegisters(pAdapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
 
-		// Reload BB parameters
-		_PHY_ReloadADDARegisters(pAdapter, IQK_BB_REG_92C, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM);
+	 	// Reload BB parameters
+	 	_PHY_ReloadADDARegisters(pAdapter, IQK_BB_REG_92C, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM);
 
 		// Restore RX initial gain
 		PHY_SetBBReg(pAdapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x00032ed3);
@@ -4035,7 +4035,7 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 }
 
 
-static VOID
+static VOID	
 _PHY_LCCalibrate(
 	IN	PADAPTER	pAdapter,
 	IN	BOOLEAN		is2T
@@ -4060,7 +4060,7 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 
 		//Path-B
 		if(is2T)
-			RF_Bmode = PHY_QueryRFReg(pAdapter, RF_PATH_B, RF_AC, bMask12Bits);
+			RF_Bmode = PHY_QueryRFReg(pAdapter, RF_PATH_B, RF_AC, bMask12Bits);	
 
 		//2. Set RF mode = standby mode
 		//Path-A
@@ -4070,35 +4070,35 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 		if(is2T)
 			PHY_SetRFReg(pAdapter, RF_PATH_B, RF_AC, bMask12Bits, (RF_Bmode&0x8FFFF)|0x10000);
 	}
-
+	
 	//3. Read RF reg18
 	LC_Cal = PHY_QueryRFReg(pAdapter, RF_PATH_A, RF_CHNLBW, bMask12Bits);
-
+	
 	//4. Set LC calibration begin
 	PHY_SetRFReg(pAdapter, RF_PATH_A, RF_CHNLBW, bMask12Bits, LC_Cal|0x08000);
 
 	#ifdef CONFIG_LONG_DELAY_ISSUE
-	rtw_msleep_os(100);
+	rtw_msleep_os(100);	
 	#else
-	rtw_mdelay_os(100);
+	rtw_mdelay_os(100);		
 	#endif
 
 	//Restore original situation
-	if((tmpReg&0x70) != 0)	//Deal with contisuous TX case
-	{
+	if((tmpReg&0x70) != 0)	//Deal with contisuous TX case 
+	{  
 		//Path-A
 		rtw_write8(pAdapter, 0xd03, tmpReg);
 		PHY_SetRFReg(pAdapter, RF_PATH_A, RF_AC, bMask12Bits, RF_Amode);
-
+		
 		//Path-B
 		if(is2T)
 			PHY_SetRFReg(pAdapter, RF_PATH_B, RF_AC, bMask12Bits, RF_Bmode);
 	}
 	else // Deal with Packet TX case
 	{
-		rtw_write8(pAdapter, REG_TXPAUSE, 0x00);
+		rtw_write8(pAdapter, REG_TXPAUSE, 0x00);	
 	}
-
+	
 }
 
 
@@ -4107,7 +4107,7 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 #define		APK_CURVE_REG_NUM 4
 #define		PATH_NUM		2
 
-static VOID
+static VOID	
 _PHY_APCalibrate(
 	IN	PADAPTER	pAdapter,
 	IN	char 		delta,
@@ -4121,44 +4121,44 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 	u32			tmpReg, index, offset, i, apkbound;
 	u8			path, pathbound = PATH_NUM;
 	u32			BB_backup[APK_BB_REG_NUM];
-	u32			BB_REG[APK_BB_REG_NUM] = {
-						rFPGA1_TxBlock, 	rOFDM0_TRxPathEnable,
-						rFPGA0_RFMOD, 	rOFDM0_TRMuxPar,
-						rFPGA0_XCD_RFInterfaceSW,	rFPGA0_XAB_RFInterfaceSW,
+	u32			BB_REG[APK_BB_REG_NUM] = {	
+						rFPGA1_TxBlock, 	rOFDM0_TRxPathEnable, 
+						rFPGA0_RFMOD, 	rOFDM0_TRMuxPar, 
+						rFPGA0_XCD_RFInterfaceSW,	rFPGA0_XAB_RFInterfaceSW, 
 						rFPGA0_XA_RFInterfaceOE, 	rFPGA0_XB_RFInterfaceOE	};
-	u32			BB_AP_MODE[APK_BB_REG_NUM] = {
-						0x00000020, 0x00a05430, 0x02040000,
+	u32			BB_AP_MODE[APK_BB_REG_NUM] = {	
+						0x00000020, 0x00a05430, 0x02040000, 
 						0x000800e4, 0x00204000 };
-	u32			BB_normal_AP_MODE[APK_BB_REG_NUM] = {
-						0x00000020, 0x00a05430, 0x02040000,
-						0x000800e4, 0x22204000 };
+	u32			BB_normal_AP_MODE[APK_BB_REG_NUM] = {	
+						0x00000020, 0x00a05430, 0x02040000, 
+						0x000800e4, 0x22204000 };						
 
 	u32			AFE_backup[IQK_ADDA_REG_NUM];
-	u32			AFE_REG[IQK_ADDA_REG_NUM] = {
-						rFPGA0_XCD_SwitchControl, 	rBlue_Tooth,
+	u32			AFE_REG[IQK_ADDA_REG_NUM] = {	
+						rFPGA0_XCD_SwitchControl, 	rBlue_Tooth, 	
 						rRx_Wait_CCA, 		rTx_CCK_RFON,
-						rTx_CCK_BBON, 	rTx_OFDM_RFON,
+						rTx_CCK_BBON, 	rTx_OFDM_RFON, 	
 						rTx_OFDM_BBON, 	rTx_To_Rx,
-						rTx_To_Tx, 		rRx_CCK,
+						rTx_To_Tx, 		rRx_CCK, 	
 						rRx_OFDM, 		rRx_Wait_RIFS,
-						rRx_TO_Rx, 		rStandby,
+						rRx_TO_Rx, 		rStandby, 	
 						rSleep, 			rPMPD_ANAEN };
 
 	u32			MAC_backup[IQK_MAC_REG_NUM];
 	u32			MAC_REG[IQK_MAC_REG_NUM] = {
-						REG_TXPAUSE, 		REG_BCN_CTRL,
+						REG_TXPAUSE, 		REG_BCN_CTRL,	
 						REG_BCN_CTRL_1,	REG_GPIO_MUXCFG};
 
 	u32			APK_RF_init_value[PATH_NUM][APK_BB_REG_NUM] = {
 					{0x0852c, 0x1852c, 0x5852c, 0x1852c, 0x5852c},
 					{0x2852e, 0x0852e, 0x3852e, 0x0852e, 0x0852e}
-					};
+					};	
 
 	u32			APK_normal_RF_init_value[PATH_NUM][APK_BB_REG_NUM] = {
 					{0x0852c, 0x0a52c, 0x3a52c, 0x5a52c, 0x5a52c},	//path settings equal to path b settings
 					{0x0852c, 0x0a52c, 0x5a52c, 0x5a52c, 0x5a52c}
 					};
-
+	
 	u32			APK_RF_value_0[PATH_NUM][APK_BB_REG_NUM] = {
 					{0x52019, 0x52014, 0x52013, 0x5200f, 0x5208d},
 					{0x5201a, 0x52019, 0x52016, 0x52033, 0x52050}
@@ -4170,8 +4170,8 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 					};
 #if 0
 	u32			APK_RF_value_A[PATH_NUM][APK_BB_REG_NUM] = {
-					{0x1adb0, 0x1adb0, 0x1ada0, 0x1ad90, 0x1ad80},
-					{0x00fb0, 0x00fb0, 0x00fa0, 0x00f90, 0x00f80}
+					{0x1adb0, 0x1adb0, 0x1ada0, 0x1ad90, 0x1ad80},		
+					{0x00fb0, 0x00fb0, 0x00fa0, 0x00f90, 0x00f80}						
 					};
 #endif
 	u32			AFE_on_off[PATH_NUM] = {
@@ -4182,12 +4182,12 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 
 	u32			APK_normal_offset[PATH_NUM] = {
 					rConfig_Pmpd_AntA, rConfig_Pmpd_AntB};
-
+					
 	u32			APK_value[PATH_NUM] = {
-					0x92fc0000, 0x12fc0000};
+					0x92fc0000, 0x12fc0000};					
 
 	u32			APK_normal_value[PATH_NUM] = {
-					0x92680000, 0x12680000};
+					0x92680000, 0x12680000};					
 
 	char			APK_delta_mapping[APK_BB_REG_NUM][13] = {
 					{-4, -3, -2, -2, -1, -1, 0, 1, 2, 3, 4, 5, 6},
@@ -4196,7 +4196,7 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 					{-1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6},
 					{-11, -9, -7, -5, -3, -1, 0, 0, 0, 0, 0, 0, 0}
 					};
-
+	
 	u32			APK_normal_setting_value_1[13] = {
 					0x01017018, 0xf7ed8f84, 0x1b1a1816, 0x2522201e, 0x322e2b28,
 					0x433f3a36, 0x5b544e49, 0x7b726a62, 0xa69a8f84, 0xdfcfc0b3,
@@ -4209,7 +4209,7 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 					0x0017001b, 0x00110014, 0x000c000f, 0x0009000b, 0x00070008,
 					0x00050006
 					};
-
+	
 	u32			APK_result[PATH_NUM][APK_BB_REG_NUM];	//val_1_1a, val_1_2a, val_2a, val_3a, val_4a
 	//u32			AP_curve[PATH_NUM][APK_CURVE_REG_NUM];
 
@@ -4223,7 +4223,7 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 #endif
 
 	//RTPRINT(FINIT, INIT_IQK, ("==>PHY_APCalibrate() delta %d\n", delta));
-
+	
 	//RTPRINT(FINIT, INIT_IQK, ("AP Calibration for %s %s\n", (is2T ? "2T2R" : "1T1R"), (isNormal ? "Normal chip" : "Test chip")));
 
 	if(!is2T)
@@ -4259,15 +4259,15 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 
 	apkbound = 6;
 
-	//save BB default value
+	//save BB default value	
 	for(index = 0; index < APK_BB_REG_NUM ; index++)
 	{
-		if(index == 0)		//skip
-			continue;
+		if(index == 0)		//skip 
+			continue;				
 		BB_backup[index] = PHY_QueryBBReg(pAdapter, BB_REG[index], bMaskDWord);
 	}
 
-	//save MAC default value
+	//save MAC default value													
 	_PHY_SaveMACRegisters(pAdapter, MAC_REG, MAC_backup);
 
 	//save AFE default value
@@ -4279,97 +4279,97 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 		{
 			//path A APK
 			//load APK setting
-			//path-A
+			//path-A		
 			offset = rPdp_AntA;
-			for(index = 0; index < 11; index ++)
+			for(index = 0; index < 11; index ++)			
 			{
 				PHY_SetBBReg(pAdapter, offset, bMaskDWord, APK_normal_setting_value_1[index]);
-				//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0x%x value 0x%x\n", offset, PHY_QueryBBReg(pAdapter, offset, bMaskDWord)));
-
+				//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0x%x value 0x%x\n", offset, PHY_QueryBBReg(pAdapter, offset, bMaskDWord))); 	
+				
 				offset += 0x04;
 			}
-
+			
 			PHY_SetBBReg(pAdapter, rConfig_Pmpd_AntB, bMaskDWord, 0x12680000);
-
+			
 			offset = rConfig_AntA;
-			for(; index < 13; index ++)
+			for(; index < 13; index ++) 		
 			{
 				PHY_SetBBReg(pAdapter, offset, bMaskDWord, APK_normal_setting_value_1[index]);
-				//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0x%x value 0x%x\n", offset, PHY_QueryBBReg(pAdapter, offset, bMaskDWord)));
-
+				//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0x%x value 0x%x\n", offset, PHY_QueryBBReg(pAdapter, offset, bMaskDWord))); 	
+				
 				offset += 0x04;
-			}
-
+			}	
+			
 			//page-B1
 			PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x40000000);
-
+			
 			//path A
 			offset = rPdp_AntA;
 			for(index = 0; index < 16; index++)
 			{
-				PHY_SetBBReg(pAdapter, offset, bMaskDWord, APK_normal_setting_value_2[index]);
-				//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0x%x value 0x%x\n", offset, PHY_QueryBBReg(pAdapter, offset, bMaskDWord)));
-
+				PHY_SetBBReg(pAdapter, offset, bMaskDWord, APK_normal_setting_value_2[index]);		
+				//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0x%x value 0x%x\n", offset, PHY_QueryBBReg(pAdapter, offset, bMaskDWord))); 	
+				
 				offset += 0x04;
-			}
-			PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
+			}				
+			PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x00000000);							
 		}
 		else if(path == RF_PATH_B)
 		{
 			//path B APK
 			//load APK setting
-			//path-B
+			//path-B		
 			offset = rPdp_AntB;
-			for(index = 0; index < 10; index ++)
+			for(index = 0; index < 10; index ++)			
 			{
 				PHY_SetBBReg(pAdapter, offset, bMaskDWord, APK_normal_setting_value_1[index]);
-				//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0x%x value 0x%x\n", offset, PHY_QueryBBReg(pAdapter, offset, bMaskDWord)));
-
+				//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0x%x value 0x%x\n", offset, PHY_QueryBBReg(pAdapter, offset, bMaskDWord))); 	
+				
 				offset += 0x04;
 			}
 			PHY_SetBBReg(pAdapter, rConfig_Pmpd_AntA, bMaskDWord, 0x12680000);
-
+			
 			PHY_SetBBReg(pAdapter, rConfig_Pmpd_AntB, bMaskDWord, 0x12680000);
-
+			
 			offset = rConfig_AntA;
 			index = 11;
-			for(; index < 13; index ++) //offset 0xb68, 0xb6c
+			for(; index < 13; index ++) //offset 0xb68, 0xb6c		
 			{
 				PHY_SetBBReg(pAdapter, offset, bMaskDWord, APK_normal_setting_value_1[index]);
-				//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0x%x value 0x%x\n", offset, PHY_QueryBBReg(pAdapter, offset, bMaskDWord)));
-
+				//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0x%x value 0x%x\n", offset, PHY_QueryBBReg(pAdapter, offset, bMaskDWord))); 	
+				
 				offset += 0x04;
-			}
-
+			}	
+			
 			//page-B1
 			PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x40000000);
-
+			
 			//path B
 			offset = 0xb60;
 			for(index = 0; index < 16; index++)
 			{
-				PHY_SetBBReg(pAdapter, offset, bMaskDWord, APK_normal_setting_value_2[index]);
-				//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0x%x value 0x%x\n", offset, PHY_QueryBBReg(pAdapter, offset, bMaskDWord)));
-
+				PHY_SetBBReg(pAdapter, offset, bMaskDWord, APK_normal_setting_value_2[index]);		
+				//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0x%x value 0x%x\n", offset, PHY_QueryBBReg(pAdapter, offset, bMaskDWord))); 	
+				
 				offset += 0x04;
-			}
-			PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
-		}
+			}				
+			PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x00000000);							
+		}		
 
 		//save RF default value
 		regD[path] = PHY_QueryRFReg(pAdapter, (RF_RADIO_PATH_E)path, RF_TXBIAS_A, bRFRegOffsetMask);
-
+		
 		//Path A AFE all on, path B AFE All off or vise versa
 		for(index = 0; index < IQK_ADDA_REG_NUM ; index++)
 			PHY_SetBBReg(pAdapter, AFE_REG[index], bMaskDWord, AFE_on_off[path]);
-		//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0xe70 %x\n", PHY_QueryBBReg(pAdapter, 0xe70, bMaskDWord)));
+		//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0xe70 %x\n", PHY_QueryBBReg(pAdapter, 0xe70, bMaskDWord)));		
 
 		//BB to AP mode
 		if(path == 0)
 		{
 			for(index = 0; index < APK_BB_REG_NUM ; index++)
 			{
-				if(index == 0)		//skip
+				if(index == 0)		//skip 
 					continue;
 				else if (index < 5)
 					PHY_SetBBReg(pAdapter, BB_REG[index], bMaskDWord, BB_AP_MODE[index]);
@@ -4387,20 +4387,20 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 			PHY_SetBBReg(pAdapter, rRx_IQK_Tone_B, bMaskDWord, 0x01008c00);
 		}
 
-		//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0x800 %x\n", PHY_QueryBBReg(pAdapter, 0x800, bMaskDWord)));
+		//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0x800 %x\n", PHY_QueryBBReg(pAdapter, 0x800, bMaskDWord)));				
 
 		//MAC settings
 		_PHY_MACSettingCalibration(pAdapter, MAC_REG, MAC_backup);
 
 		if(path == RF_PATH_A)	//Path B to standby mode
 		{
-			PHY_SetRFReg(pAdapter, RF_PATH_B, RF_AC, bRFRegOffsetMask, 0x10000);
+			PHY_SetRFReg(pAdapter, RF_PATH_B, RF_AC, bRFRegOffsetMask, 0x10000);			
 		}
 		else			//Path A to standby mode
 		{
-			PHY_SetRFReg(pAdapter, RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x10000);
-			PHY_SetRFReg(pAdapter, RF_PATH_A, RF_MODE1, bRFRegOffsetMask, 0x1000f);
-			PHY_SetRFReg(pAdapter, RF_PATH_A, RF_MODE2, bRFRegOffsetMask, 0x20103);
+			PHY_SetRFReg(pAdapter, RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x10000);			
+			PHY_SetRFReg(pAdapter, RF_PATH_A, RF_MODE1, bRFRegOffsetMask, 0x1000f);			
+			PHY_SetRFReg(pAdapter, RF_PATH_A, RF_MODE2, bRFRegOffsetMask, 0x20103);						
 		}
 
 		delta_offset = ((delta+14)/2);
@@ -4408,15 +4408,15 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 			delta_offset = 0;
 		else if (delta_offset > 12)
 			delta_offset = 12;
-
+			
 		//AP calibration
 		for(index = 0; index < APK_BB_REG_NUM; index++)
 		{
 			if(index != 1)		//only DO PA11+PAD01001, AP RF setting
 				continue;
-
+					
 			tmpReg = APK_RF_init_value[path][index];
-#if 1
+#if 1			
 			if(!pdmpriv->bAPKThermalMeterIgnore)
 			{
 				BB_offset = (tmpReg & 0xF0000) >> 16;
@@ -4427,11 +4427,11 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 				}
 
 				delta_V = APK_delta_mapping[index][delta_offset];
-
+				
 				BB_offset += delta_V;
 
-				//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() APK num %d delta_V %d delta_offset %d\n", index, delta_V, delta_offset));
-
+				//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() APK num %d delta_V %d delta_offset %d\n", index, delta_V, delta_offset));		
+				
 				if(BB_offset < 0)
 				{
 					tmpReg = tmpReg & (~BIT15);
@@ -4453,19 +4453,19 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 				PHY_SetRFReg(pAdapter, (RF_RADIO_PATH_E)path, RF_IPA_A, bRFRegOffsetMask, 0x8992e);
 			//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0xc %x\n", PHY_QueryRFReg(pAdapter, (RF_RADIO_PATH_E)path, 0xc, bMaskDWord)));
 			PHY_SetRFReg(pAdapter, (RF_RADIO_PATH_E)path, RF_AC, bRFRegOffsetMask, APK_RF_value_0[path][index]);
-			//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0x0 %x\n", PHY_QueryRFReg(pAdapter, (RF_RADIO_PATH_E)path, 0x0, bMaskDWord)));
+			//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0x0 %x\n", PHY_QueryRFReg(pAdapter, (RF_RADIO_PATH_E)path, 0x0, bMaskDWord)));		
 			PHY_SetRFReg(pAdapter, (RF_RADIO_PATH_E)path, RF_TXBIAS_A, bRFRegOffsetMask, tmpReg);
 			//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0xd %x\n", PHY_QueryRFReg(pAdapter, (RF_RADIO_PATH_E)path, 0xd, bMaskDWord)));
 
-			// PA11+PAD01111, one shot
+			// PA11+PAD01111, one shot	
 			i = 0;
 			do
 			{
 				PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x80000000);
 				{
-					PHY_SetBBReg(pAdapter, APK_offset[path], bMaskDWord, APK_value[0]);
+					PHY_SetBBReg(pAdapter, APK_offset[path], bMaskDWord, APK_value[0]);		
 					//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0x%x value 0x%x\n", APK_offset[path], PHY_QueryBBReg(pAdapter, APK_offset[path], bMaskDWord)));
-					rtw_mdelay_os(3);
+					rtw_mdelay_os(3);				
 					PHY_SetBBReg(pAdapter, APK_offset[path], bMaskDWord, APK_value[1]);
 					//RTPRINT(FINIT, INIT_IQK, ("PHY_APCalibrate() offset 0x%x value 0x%x\n", APK_offset[path], PHY_QueryBBReg(pAdapter, APK_offset[path], bMaskDWord)));
 					#ifdef CONFIG_LONG_DELAY_ISSUE
@@ -4475,7 +4475,7 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 					#endif
 				}
 				PHY_SetBBReg(pAdapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
-
+				
 				if(path == RF_PATH_A)
 					tmpReg = PHY_QueryBBReg(pAdapter, rAPK, 0x03E00000);
 				else
@@ -4490,13 +4490,13 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 		}
 	}
 
-	//reload MAC default value
+	//reload MAC default value	
 	_PHY_ReloadMACRegisters(pAdapter, MAC_REG, MAC_backup);
 
-	//reload BB default value
+	//reload BB default value	
 	for(index = 0; index < APK_BB_REG_NUM ; index++)
 	{
-		if(index == 0)		//skip
+		if(index == 0)		//skip 
 			continue;
 		PHY_SetBBReg(pAdapter, BB_REG[index], bMaskDWord, BB_backup[index]);
 	}
@@ -4510,8 +4510,8 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 		PHY_SetRFReg(pAdapter, (RF_RADIO_PATH_E)path, RF_TXBIAS_A, bRFRegOffsetMask, regD[path]);
 		if(path == RF_PATH_B)
 		{
-			PHY_SetRFReg(pAdapter, RF_PATH_A, RF_MODE1, bRFRegOffsetMask, 0x1000f);
-			PHY_SetRFReg(pAdapter, RF_PATH_A, RF_MODE2, bRFRegOffsetMask, 0x20101);
+			PHY_SetRFReg(pAdapter, RF_PATH_A, RF_MODE1, bRFRegOffsetMask, 0x1000f);			
+			PHY_SetRFReg(pAdapter, RF_PATH_A, RF_MODE2, bRFRegOffsetMask, 0x20101);						
 		}
 
 		//note no index == 0
@@ -4521,19 +4521,19 @@ static void _PHY_SwChnl8192C(PADAPTER Adapter, u8 channel)
 	}
 
 	//RTPRINT(FINIT, INIT_IQK, ("\n"));
-
+	
 
 	for(path = 0; path < pathbound; path++)
 	{
-		PHY_SetRFReg(pAdapter, (RF_RADIO_PATH_E)path, RF_BS_PA_APSET_G1_G4, bRFRegOffsetMask,
+		PHY_SetRFReg(pAdapter, (RF_RADIO_PATH_E)path, RF_BS_PA_APSET_G1_G4, bRFRegOffsetMask, 
 		((APK_result[path][1] << 15) | (APK_result[path][1] << 10) | (APK_result[path][1] << 5) | APK_result[path][1]));
 		if(path == RF_PATH_A)
-			PHY_SetRFReg(pAdapter, (RF_RADIO_PATH_E)path, RF_BS_PA_APSET_G5_G8, bRFRegOffsetMask,
+			PHY_SetRFReg(pAdapter, (RF_RADIO_PATH_E)path, RF_BS_PA_APSET_G5_G8, bRFRegOffsetMask, 
 			((APK_result[path][1] << 15) | (APK_result[path][1] << 10) | (0x00 << 5) | 0x05));
 		else
-			PHY_SetRFReg(pAdapter, (RF_RADIO_PATH_E)path, RF_BS_PA_APSET_G5_G8, bRFRegOffsetMask,
+			PHY_SetRFReg(pAdapter, (RF_RADIO_PATH_E)path, RF_BS_PA_APSET_G5_G8, bRFRegOffsetMask, 
 			((APK_result[path][1] << 15) | (APK_result[path][1] << 10) | (0x02 << 5) | 0x05));
-		PHY_SetRFReg(pAdapter, (RF_RADIO_PATH_E)path, RF_BS_PA_APSET_G9_G11, bRFRegOffsetMask,
+		PHY_SetRFReg(pAdapter, (RF_RADIO_PATH_E)path, RF_BS_PA_APSET_G9_G11, bRFRegOffsetMask, 
 		((0x08 << 15) | (0x08 << 10) | (0x08 << 5) | 0x08));
 	}
 
@@ -4561,17 +4561,17 @@ static VOID _PHY_SetRFPathSwitch(
 	if(is2T)
 	{
 		if(bMain)
-			PHY_SetBBReg(pAdapter, rFPGA0_XB_RFInterfaceOE, BIT5|BIT6, 0x1);	//92C_Path_A
+			PHY_SetBBReg(pAdapter, rFPGA0_XB_RFInterfaceOE, BIT5|BIT6, 0x1);	//92C_Path_A			
 		else
-			PHY_SetBBReg(pAdapter, rFPGA0_XB_RFInterfaceOE, BIT5|BIT6, 0x2);	//BT
+			PHY_SetBBReg(pAdapter, rFPGA0_XB_RFInterfaceOE, BIT5|BIT6, 0x2);	//BT							
 	}
 	else
 	{
-
+	
 		if(bMain)
 			PHY_SetBBReg(pAdapter, rFPGA0_XA_RFInterfaceOE, 0x300, 0x2);	//Main
 		else
-			PHY_SetBBReg(pAdapter, rFPGA0_XA_RFInterfaceOE, 0x300, 0x1);	//Aux
+			PHY_SetBBReg(pAdapter, rFPGA0_XA_RFInterfaceOE, 0x300, 0x1);	//Aux		
 	}
 
 }
@@ -4585,7 +4585,7 @@ static BOOLEAN _PHY_QueryRFPathSwitch(
 {
 //	if(is2T)
 //		return _TRUE;
-
+	
 	if(!pAdapter->hw_init_completed)
 	{
 		PHY_SetBBReg(pAdapter, REG_LEDCFG0, BIT23, 0x01);
@@ -4620,20 +4620,20 @@ static BOOLEAN _PHY_QueryRFPathSwitch(
 	u8			i, final_candidate;
 	BOOLEAN		bPathAOK, bPathBOK;
 	s32			RegE94, RegE9C, RegEA4, RegEAC, RegEB4, RegEBC, RegEC4, RegECC, RegTmp = 0;
-	BOOLEAN		is12simular, is13simular, is23simular;
+	BOOLEAN		is12simular, is13simular, is23simular;	
 	BOOLEAN 	bStartContTx = _FALSE, bSingleTone = _FALSE, bCarrierSuppression = _FALSE;
 	u32			IQK_BB_REG_92C[IQK_BB_REG_NUM] = {
-					rOFDM0_XARxIQImbalance, 	rOFDM0_XBRxIQImbalance,
+					rOFDM0_XARxIQImbalance, 	rOFDM0_XBRxIQImbalance, 
 					rOFDM0_ECCAThreshold, 	rOFDM0_AGCRSSITable,
-					rOFDM0_XATxIQImbalance, 	rOFDM0_XBTxIQImbalance,
-					rOFDM0_XCTxAFE, 			rOFDM0_XDTxAFE,
+					rOFDM0_XATxIQImbalance, 	rOFDM0_XBTxIQImbalance, 
+					rOFDM0_XCTxAFE, 			rOFDM0_XDTxAFE, 
 					rOFDM0_RxIQExtAnta};
 
 
-#if MP_DRIVER == 1
+#if MP_DRIVER == 1	
 	bStartContTx = pAdapter->mppriv.MptCtx.bStartContTx;
 	bSingleTone = pAdapter->mppriv.MptCtx.bSingleTone;
-	bCarrierSuppression = pAdapter->mppriv.MptCtx.bCarrierSuppression;
+	bCarrierSuppression = pAdapter->mppriv.MptCtx.bCarrierSuppression;	
 #endif
 
 	//ignore IQK when continuous Tx
@@ -4667,14 +4667,14 @@ static BOOLEAN _PHY_QueryRFPathSwitch(
 
 	for (i=0; i<3; i++)
 	{
-		if(IS_92C_SERIAL( pHalData->VersionID)){
+	 	if(IS_92C_SERIAL( pHalData->VersionID)){
 			 _PHY_IQCalibrate(pAdapter, result, i, _TRUE);
-		}
-		else{
-			// For 88C 1T1R
-			_PHY_IQCalibrate(pAdapter, result, i, _FALSE);
-		}
-
+	 	}
+	 	else{
+	 		// For 88C 1T1R
+	 		_PHY_IQCalibrate(pAdapter, result, i, _FALSE);
+ 		}
+		
 		if(i == 1)
 		{
 			is12simular = _PHY_SimularityCompare(pAdapter, result, 0, 1);
@@ -4684,16 +4684,16 @@ static BOOLEAN _PHY_QueryRFPathSwitch(
 				break;
 			}
 		}
-
+		
 		if(i == 2)
 		{
 			is13simular = _PHY_SimularityCompare(pAdapter, result, 0, 2);
 			if(is13simular)
 			{
-				final_candidate = 0;
+				final_candidate = 0;			
 				break;
 			}
-
+			
 			is23simular = _PHY_SimularityCompare(pAdapter, result, 1, 2);
 			if(is23simular)
 				final_candidate = 1;
@@ -4703,7 +4703,7 @@ static BOOLEAN _PHY_QueryRFPathSwitch(
 					RegTmp += result[3][i];
 
 				if(RegTmp != 0)
-					final_candidate = 3;
+					final_candidate = 3;			
 				else
 					final_candidate = 0xFF;
 			}
@@ -4742,10 +4742,10 @@ static BOOLEAN _PHY_QueryRFPathSwitch(
 		RegE94 = RegEB4 = pdmpriv->RegE94 = pdmpriv->RegEB4 = 0x100;	//X default value
 		RegE9C = RegEBC = pdmpriv->RegE9C = pdmpriv->RegEBC = 0x0;		//Y default value
 	}
-
+	
 	if((RegE94 != 0)/*&&(RegEA4 != 0)*/)
 		_PHY_PathAFillIQKMatrix(pAdapter, bPathAOK, result, final_candidate, (RegEA4 == 0));
-
+	
 	if(IS_92C_SERIAL( pHalData->VersionID)){
 		if((RegEB4 != 0)/*&&(RegEC4 != 0)*/)
 		_PHY_PathBFillIQKMatrix(pAdapter, bPathBOK, result, final_candidate, (RegEC4 == 0));
@@ -4794,7 +4794,7 @@ static BOOLEAN _PHY_QueryRFPathSwitch(
 VOID
 rtl8192c_PHY_APCalibrate(
 	IN	PADAPTER	pAdapter,
-	IN	char 		delta
+	IN	char 		delta	
 	)
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
@@ -4838,3 +4838,4 @@ VOID rtl8192c_PHY_SetRFPathSwitch(
 		_PHY_SetRFPathSwitch(pAdapter, bMain, _FALSE);
 	}
 }
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_rf6052.c b/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_rf6052.c
old mode 100644
new mode 100755
index 7532c63..cf46969
--- a/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_rf6052.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_rf6052.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -18,25 +18,25 @@
  *
  ******************************************************************************/
 /******************************************************************************
- *
- *
+ * 
+ * 
  * Module:	rtl8192c_rf6052.c	( Source C File)
+ * 
+ * Note:	Provide RF 6052 series relative API.	 
  *
- * Note:	Provide RF 6052 series relative API.
- *
- * Function:
- *
- * Export:
- *
- * Abbrev:
- *
+ * Function:	
+ * 		 
+ * Export:	
+ * 
+ * Abbrev:	
+ * 
  * History:
  * Data			Who		Remark
- *
+ * 
  * 09/25/2008	MHC		Create initial version.
  * 11/05/2008 	MHC		Add API for tw power setting.
- *
- *
+ * 
+ * 	
 ******************************************************************************/
 
 #define _RTL8192C_RF6052_C_
@@ -93,54 +93,54 @@
  *						Firmwaer support the utility later.
  *
  *---------------------------------------------------------------------------*/
-void rtl8192c_RF_ChangeTxPath(	IN	PADAPTER	Adapter,
+void rtl8192c_RF_ChangeTxPath(	IN	PADAPTER	Adapter, 
 										IN	u16		DataRate)
 {
 // We do not support gain table change inACUT now !!!! Delete later !!!
 #if 0//(RTL92SE_FPGA_VERIFY == 0)
-	static	u1Byte	RF_Path_Type = 2;	// 1 = 1T 2= 2T
-	static	u4Byte	tx_gain_tbl1[6]
+	static	u1Byte	RF_Path_Type = 2;	// 1 = 1T 2= 2T			
+	static	u4Byte	tx_gain_tbl1[6] 
 			= {0x17f50, 0x11f40, 0x0cf30, 0x08720, 0x04310, 0x00100};
-	static	u4Byte	tx_gain_tbl2[6]
+	static	u4Byte	tx_gain_tbl2[6] 
 			= {0x15ea0, 0x10e90, 0x0c680, 0x08250, 0x04040, 0x00030};
 	u1Byte	i;
-
+	
 	if (RF_Path_Type == 2 && (DataRate&0xF) <= 0x7)
 	{
 		// Set TX SYNC power G2G3 loop filter
-		PHY_SetRFReg(Adapter, (RF_RADIO_PATH_E)RF_PATH_A,
+		PHY_SetRFReg(Adapter, (RF_RADIO_PATH_E)RF_PATH_A, 
 					RF_TXPA_G2, bRFRegOffsetMask, 0x0f000);
-		PHY_SetRFReg(Adapter, (RF_RADIO_PATH_E)RF_PATH_A,
+		PHY_SetRFReg(Adapter, (RF_RADIO_PATH_E)RF_PATH_A, 
 					RF_TXPA_G3, bRFRegOffsetMask, 0xeacf1);
 
 		// Change TX AGC gain table
-		for (i = 0; i < 6; i++)
-			PHY_SetRFReg(Adapter, (RF_RADIO_PATH_E)RF_PATH_A,
+		for (i = 0; i < 6; i++)					
+			PHY_SetRFReg(Adapter, (RF_RADIO_PATH_E)RF_PATH_A, 
 						RF_TX_AGC, bRFRegOffsetMask, tx_gain_tbl1[i]);
 
 		// Set PA to high value
-		PHY_SetRFReg(Adapter, (RF_RADIO_PATH_E)RF_PATH_A,
+		PHY_SetRFReg(Adapter, (RF_RADIO_PATH_E)RF_PATH_A, 
 					RF_TXPA_G2, bRFRegOffsetMask, 0x01e39);
 	}
 	else if (RF_Path_Type == 1 && (DataRate&0xF) >= 0x8)
 	{
 		// Set TX SYNC power G2G3 loop filter
-		PHY_SetRFReg(Adapter, (RF_RADIO_PATH_E)RF_PATH_A,
+		PHY_SetRFReg(Adapter, (RF_RADIO_PATH_E)RF_PATH_A, 
 					RF_TXPA_G2, bRFRegOffsetMask, 0x04440);
-		PHY_SetRFReg(Adapter, (RF_RADIO_PATH_E)RF_PATH_A,
+		PHY_SetRFReg(Adapter, (RF_RADIO_PATH_E)RF_PATH_A, 
 					RF_TXPA_G3, bRFRegOffsetMask, 0xea4f1);
 
 		// Change TX AGC gain table
 		for (i = 0; i < 6; i++)
-			PHY_SetRFReg(Adapter, (RF_RADIO_PATH_E)RF_PATH_A,
+			PHY_SetRFReg(Adapter, (RF_RADIO_PATH_E)RF_PATH_A, 
 						RF_TX_AGC, bRFRegOffsetMask, tx_gain_tbl2[i]);
 
 		// Set PA low gain
-		PHY_SetRFReg(Adapter, (RF_RADIO_PATH_E)RF_PATH_A,
+		PHY_SetRFReg(Adapter, (RF_RADIO_PATH_E)RF_PATH_A, 
 					RF_TXPA_G2, bRFRegOffsetMask, 0x01e19);
 	}
-#endif
-
+#endif	
+	
 }	/* RF_ChangeTxPath */
 
 
@@ -162,33 +162,33 @@ void rtl8192c_RF_ChangeTxPath(	IN	PADAPTER	Adapter,
 rtl8192c_PHY_RF6052SetBandwidth(
 	IN	PADAPTER				Adapter,
 	IN	HT_CHANNEL_WIDTH		Bandwidth)	//20M or 40M
-{
+{	
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-
+	
 	switch(Bandwidth)
 	{
 		case HT_CHANNEL_WIDTH_20:
 			pHalData->RfRegChnlVal[0] = ((pHalData->RfRegChnlVal[0] & 0xfffff3ff) | 0x0400);
 			PHY_SetRFReg(Adapter, RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask, pHalData->RfRegChnlVal[0]);
 			break;
-
+				
 		case HT_CHANNEL_WIDTH_40:
 			pHalData->RfRegChnlVal[0] = ((pHalData->RfRegChnlVal[0] & 0xfffff3ff));
-			PHY_SetRFReg(Adapter, RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask, pHalData->RfRegChnlVal[0]);
+			PHY_SetRFReg(Adapter, RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask, pHalData->RfRegChnlVal[0]);			
 			break;
-
+				
 		default:
 			//RT_TRACE(COMP_DBG, DBG_LOUD, ("PHY_SetRF8225Bandwidth(): unknown Bandwidth: %#X\n",Bandwidth ));
-			break;
+			break;			
 	}
-
+	
 }
 
 
 /*-----------------------------------------------------------------------------
  * Function:	PHY_RF6052SetCckTxPower
  *
- * Overview:
+ * Overview:	
  *
  * Input:       NONE
  *
@@ -211,13 +211,13 @@ void rtl8192c_RF_ChangeTxPath(	IN	PADAPTER	Adapter,
 	struct mlme_priv	*pmlmepriv = &Adapter->mlmepriv;
 	struct dm_priv		*pdmpriv = &pHalData->dmpriv;
 	struct mlme_ext_priv 		*pmlmeext = &Adapter->mlmeextpriv;
-	//PMGNT_INFO		pMgntInfo=&Adapter->MgntInfo;
+	//PMGNT_INFO		pMgntInfo=&Adapter->MgntInfo;	
 	u32			TxAGC[2]={0, 0}, tmpval=0;
 	BOOLEAN		TurboScanOff = _FALSE;
 	u8			idx1, idx2;
 	u8*			ptr;
 
-	// 2010/10/18 MH Accorsing to SD3 eechou's suggestion, we need to disable turbo scan for RU.
+	// 2010/10/18 MH Accorsing to SD3 eechou's suggestion, we need to disable turbo scan for RU.	
 	// Otherwise, external PA will be broken if power index > 0x20.
 #ifdef CONFIG_USB_HCI
 	if (pHalData->EEPROMRegulatory != 0 || pHalData->ExternalPA)
@@ -235,12 +235,12 @@ void rtl8192c_RF_ChangeTxPath(	IN	PADAPTER	Adapter,
 		TxAGC[RF_PATH_B] = 0x3f3f3f3f;
 
 		TurboScanOff = _TRUE;//disable turbo scan
-
+		
 		if(TurboScanOff)
 		{
 			for(idx1=RF_PATH_A; idx1<=RF_PATH_B; idx1++)
 			{
-				TxAGC[idx1] =
+				TxAGC[idx1] = 
 					pPowerlevel[idx1] | (pPowerlevel[idx1]<<8) |
 					(pPowerlevel[idx1]<<16) | (pPowerlevel[idx1]<<24);
 #ifdef CONFIG_USB_HCI
@@ -257,12 +257,12 @@ void rtl8192c_RF_ChangeTxPath(	IN	PADAPTER	Adapter,
 // Currently, we cannot fully disable driver dynamic tx power mechanism because it is referenced by BT coexist mechanism.
 // In the future, two mechanism shall be separated from each other and maintained independantly. Thanks for Lanhsin's reminder.
 		if(pdmpriv->DynamicTxHighPowerLvl == TxHighPwrLevel_Level1)
-		{
+		{	
 			TxAGC[RF_PATH_A] = 0x10101010;
 			TxAGC[RF_PATH_B] = 0x10101010;
 		}
 		else if(pdmpriv->DynamicTxHighPowerLvl == TxHighPwrLevel_Level2)
-		{
+		{	
 			TxAGC[RF_PATH_A] = 0x00000000;
 			TxAGC[RF_PATH_B] = 0x00000000;
 		}
@@ -270,18 +270,18 @@ void rtl8192c_RF_ChangeTxPath(	IN	PADAPTER	Adapter,
 		{
 			for(idx1=RF_PATH_A; idx1<=RF_PATH_B; idx1++)
 			{
-				TxAGC[idx1] =
+				TxAGC[idx1] = 
 					pPowerlevel[idx1] | (pPowerlevel[idx1]<<8) |
 					(pPowerlevel[idx1]<<16) | (pPowerlevel[idx1]<<24);
 			}
 
 			if(pHalData->EEPROMRegulatory==0)
 			{
-				tmpval = (pHalData->MCSTxPowerLevelOriginalOffset[0][6]) +
+				tmpval = (pHalData->MCSTxPowerLevelOriginalOffset[0][6]) + 
 						(pHalData->MCSTxPowerLevelOriginalOffset[0][7]<<8);
 				TxAGC[RF_PATH_A] += tmpval;
-
-				tmpval = (pHalData->MCSTxPowerLevelOriginalOffset[0][14]) +
+				
+				tmpval = (pHalData->MCSTxPowerLevelOriginalOffset[0][14]) + 
 						(pHalData->MCSTxPowerLevelOriginalOffset[0][15]<<24);
 				TxAGC[RF_PATH_B] += tmpval;
 			}
@@ -313,9 +313,9 @@ void rtl8192c_RF_ChangeTxPath(	IN	PADAPTER	Adapter,
 	//RTPRINT(FPHY, PHY_TXPWR, ("CCK PWR 11M (rf-B) = 0x%x (reg 0x%x)\n", tmpval, rTxAGC_B_CCK11_A_CCK2_11));
 	tmpval = TxAGC[RF_PATH_B]&0x00ffffff;
 	PHY_SetBBReg(Adapter, rTxAGC_B_CCK1_55_Mcs32, 0xffffff00, tmpval);
-	//RTPRINT(FPHY, PHY_TXPWR, ("CCK PWR 1~5.5M (rf-B) = 0x%x (reg 0x%x)\n",
+	//RTPRINT(FPHY, PHY_TXPWR, ("CCK PWR 1~5.5M (rf-B) = 0x%x (reg 0x%x)\n", 
 	//	tmpval, rTxAGC_B_CCK1_55_Mcs32));
-
+	
 }	/* PHY_RF6052SetCckTxPower */
 
 //
@@ -339,8 +339,8 @@ static void getPowerBase(
 	for(i=0; i<2; i++)
 	{
 		powerlevel[i] = pPowerLevel[i];
-		Legacy_pwrdiff = pHalData->TxPwrLegacyHtDiff[i][Channel-1];
-		powerBase0 = powerlevel[i] + Legacy_pwrdiff;
+		Legacy_pwrdiff = pHalData->TxPwrLegacyHtDiff[i][Channel-1];			
+		powerBase0 = powerlevel[i] + Legacy_pwrdiff; 
 
 		powerBase0 = (powerBase0<<24) | (powerBase0<<16) |(powerBase0<<8) |powerBase0;
 		*(OfdmBase+i) = powerBase0;
@@ -373,9 +373,9 @@ static void getTxPowerWriteValByRegulatory(
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
-	u8	i, chnlGroup = 0, pwr_diff_limit[4];
+	u8	i, chnlGroup, pwr_diff_limit[4];
 	u32 	writeVal, customer_limit, rf;
-
+	
 	//
 	// Index 0 & 1= legacy OFDM, 2-5=HT_MCS rate
 	//
@@ -386,9 +386,9 @@ static void getTxPowerWriteValByRegulatory(
 			case 0:	// Realtek better performance
 					// increase power diff defined by Realtek for large power
 				chnlGroup = 0;
-				//RTPRINT(FPHY, PHY_TXPWR, ("MCSTxPowerLevelOriginalOffset[%d][%d] = 0x%x\n",
+				//RTPRINT(FPHY, PHY_TXPWR, ("MCSTxPowerLevelOriginalOffset[%d][%d] = 0x%x\n", 
 				//	chnlGroup, index, pHalData->MCSTxPowerLevelOriginalOffset[chnlGroup][index+(rf?8:0)]));
-				writeVal = pHalData->MCSTxPowerLevelOriginalOffset[chnlGroup][index+(rf?8:0)] +
+				writeVal = pHalData->MCSTxPowerLevelOriginalOffset[chnlGroup][index+(rf?8:0)] + 
 					((index<2)?powerBase0[rf]:powerBase1[rf]);
 				//RTPRINT(FPHY, PHY_TXPWR, ("RTK better performance, writeVal(%c) = 0x%x\n", ((rf==0)?'A':'B'), writeVal));
 				break;
@@ -411,9 +411,9 @@ static void getTxPowerWriteValByRegulatory(
 						else
 							chnlGroup+=4;
 					}
-					//RTPRINT(FPHY, PHY_TXPWR, ("MCSTxPowerLevelOriginalOffset[%d][%d] = 0x%x\n",
+					//RTPRINT(FPHY, PHY_TXPWR, ("MCSTxPowerLevelOriginalOffset[%d][%d] = 0x%x\n", 
 					//chnlGroup, index, pHalData->MCSTxPowerLevelOriginalOffset[chnlGroup][index+(rf?8:0)]));
-					writeVal = pHalData->MCSTxPowerLevelOriginalOffset[chnlGroup][index+(rf?8:0)] +
+					writeVal = pHalData->MCSTxPowerLevelOriginalOffset[chnlGroup][index+(rf?8:0)] + 
 							((index<2)?powerBase0[rf]:powerBase1[rf]);
 					//RTPRINT(FPHY, PHY_TXPWR, ("Realtek regulatory, 20MHz, writeVal(%c) = 0x%x\n", ((rf==0)?'A':'B'), writeVal));
 				}
@@ -426,17 +426,17 @@ static void getTxPowerWriteValByRegulatory(
 			case 3:	// Customer defined power diff.
 					// increase power diff defined by customer.
 				chnlGroup = 0;
-				//RTPRINT(FPHY, PHY_TXPWR, ("MCSTxPowerLevelOriginalOffset[%d][%d] = 0x%x\n",
+				//RTPRINT(FPHY, PHY_TXPWR, ("MCSTxPowerLevelOriginalOffset[%d][%d] = 0x%x\n", 
 				//	chnlGroup, index, pHalData->MCSTxPowerLevelOriginalOffset[chnlGroup][index+(rf?8:0)]));
 
 				if (pHalData->CurrentChannelBW == HT_CHANNEL_WIDTH_40)
 				{
-					//RTPRINT(FPHY, PHY_TXPWR, ("customer's limit, 40MHz rf(%c) = 0x%x\n",
+					//RTPRINT(FPHY, PHY_TXPWR, ("customer's limit, 40MHz rf(%c) = 0x%x\n", 
 					//	((rf==0)?'A':'B'), pHalData->PwrGroupHT40[rf][Channel-1]));
 				}
 				else
 				{
-					//RTPRINT(FPHY, PHY_TXPWR, ("customer's limit, 20MHz rf(%c) = 0x%x\n",
+					//RTPRINT(FPHY, PHY_TXPWR, ("customer's limit, 20MHz rf(%c) = 0x%x\n", 
 					//	((rf==0)?'A':'B'), pHalData->PwrGroupHT20[rf][Channel-1]));
 				}
 				for (i=0; i<4; i++)
@@ -462,7 +462,7 @@ static void getTxPowerWriteValByRegulatory(
 				break;
 			default:
 				chnlGroup = 0;
-				writeVal = pHalData->MCSTxPowerLevelOriginalOffset[chnlGroup][index+(rf?8:0)] +
+				writeVal = pHalData->MCSTxPowerLevelOriginalOffset[chnlGroup][index+(rf?8:0)] + 
 						((index<2)?powerBase0[rf]:powerBase1[rf]);
 				//RTPRINT(FPHY, PHY_TXPWR, ("RTK better performance, writeVal rf(%c) = 0x%x\n", ((rf==0)?'A':'B'), writeVal));
 				break;
@@ -501,10 +501,10 @@ static void writeOFDMPowerReg(
 	)
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	u16 RegOffset_A[6] = {	rTxAGC_A_Rate18_06, rTxAGC_A_Rate54_24,
-							rTxAGC_A_Mcs03_Mcs00, rTxAGC_A_Mcs07_Mcs04,
+	u16 RegOffset_A[6] = {	rTxAGC_A_Rate18_06, rTxAGC_A_Rate54_24, 
+							rTxAGC_A_Mcs03_Mcs00, rTxAGC_A_Mcs07_Mcs04, 
 							rTxAGC_A_Mcs11_Mcs08, rTxAGC_A_Mcs15_Mcs12};
-	u16 RegOffset_B[6] = {	rTxAGC_B_Rate18_06, rTxAGC_B_Rate54_24,
+	u16 RegOffset_B[6] = {	rTxAGC_B_Rate18_06, rTxAGC_B_Rate54_24, 
 							rTxAGC_B_Mcs03_Mcs00, rTxAGC_B_Mcs07_Mcs04,
 							rTxAGC_B_Mcs11_Mcs08, rTxAGC_B_Mcs15_Mcs12};
 	u8 i, rf, pwr_val[4];
@@ -526,14 +526,14 @@ static void writeOFDMPowerReg(
 			RegOffset = RegOffset_A[index];
 		else
 			RegOffset = RegOffset_B[index];
-
+		
 		PHY_SetBBReg(Adapter, RegOffset, bMaskDWord, writeVal);
 		//RTPRINT(FPHY, PHY_TXPWR, ("Set 0x%x = %08x\n", RegOffset, writeVal));
 
 		// 201005115 Joseph: Set Tx Power diff for Tx power training mechanism.
-		if(((pHalData->rf_type == RF_2T2R) &&
+		if(((pHalData->rf_type == RF_2T2R) && 
 				(RegOffset == rTxAGC_A_Mcs15_Mcs12 || RegOffset == rTxAGC_B_Mcs15_Mcs12))||
-		     ((pHalData->rf_type != RF_2T2R) &&
+		     ((pHalData->rf_type != RF_2T2R) && 
 				(RegOffset == rTxAGC_A_Mcs07_Mcs04 || RegOffset == rTxAGC_B_Mcs07_Mcs04))	)
 		{
 			writeVal = pwr_val[3];
@@ -555,7 +555,7 @@ static void writeOFDMPowerReg(
 /*-----------------------------------------------------------------------------
  * Function:	PHY_RF6052SetOFDMTxPower
  *
- * Overview:	For legacy and HY OFDM, we must read EEPROM TX power index for
+ * Overview:	For legacy and HY OFDM, we must read EEPROM TX power index for 
  *			different channel and read original value in TX power register area from
  *			0xe00. We increase offset and original value to be correct tx pwr.
  *
@@ -574,7 +574,7 @@ static void writeOFDMPowerReg(
  * 01/22/2009	MHC		Support new EPRO format from SD3.
  *
  *---------------------------------------------------------------------------*/
-VOID
+VOID 
 rtl8192c_PHY_RF6052SetOFDMTxPower(
 	IN	PADAPTER	Adapter,
 	IN	u8*		pPowerLevel,
@@ -588,12 +588,12 @@ static void writeOFDMPowerReg(
 
 	for(index=0; index<6; index++)
 	{
-		getTxPowerWriteValByRegulatory(Adapter, Channel, index,
+		getTxPowerWriteValByRegulatory(Adapter, Channel, index, 
 			&powerBase0[0], &powerBase1[0], &writeVal[0]);
 
 		writeOFDMPowerReg(Adapter, index, &writeVal[0]);
 	}
-
+	
 }
 
 
@@ -602,12 +602,12 @@ static void writeOFDMPowerReg(
 	IN	PADAPTER		Adapter
 	)
 {
-
+	
 	// Set Default Bandwidth to 20M
 	//Adapter->HalFunc	.SetBWModeHandler(Adapter, HT_CHANNEL_WIDTH_20);
 
 	// TODO: Set Default Channel to channel one for RTL8225
-
+	
 }
 
 static int
@@ -615,24 +615,24 @@ static void writeOFDMPowerReg(
 	IN	PADAPTER		Adapter
 	)
 {
-	u32					u4RegValue=0;
-	u8					eRFPath;
-	BB_REGISTER_DEFINITION_T	*pPhyReg;
+	u32					u4RegValue;
+	u8					eRFPath;		
+	BB_REGISTER_DEFINITION_T	*pPhyReg;	
 
 	int					rtStatus = _SUCCESS;
 	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
-	static char			sz88CRadioAFile[] = RTL8188C_PHY_RADIO_A;
+	static char			sz88CRadioAFile[] = RTL8188C_PHY_RADIO_A;	
 	static char			sz88CRadioBFile[] = RTL8188C_PHY_RADIO_B;
 #ifdef CONFIG_USB_HCI
-	static char			sz88CRadioAFile_mCard[] = RTL8188C_PHY_RADIO_A_mCard;
+	static char			sz88CRadioAFile_mCard[] = RTL8188C_PHY_RADIO_A_mCard;	
 	static char			sz88CRadioBFile_mCard[] = RTL8188C_PHY_RADIO_B_mCard;
-	static char			sz88CRadioAFile_HP[] = RTL8188C_PHY_RADIO_A_HP;
+	static char			sz88CRadioAFile_HP[] = RTL8188C_PHY_RADIO_A_HP;	
 #endif
-	static char			sz92CRadioAFile[] = RTL8192C_PHY_RADIO_A;
+	static char			sz92CRadioAFile[] = RTL8192C_PHY_RADIO_A;	
 	static char			sz92CRadioBFile[] = RTL8192C_PHY_RADIO_B;
-	static char			sz8723RadioAFile[] = RTL8723_PHY_RADIO_A;
+	static char			sz8723RadioAFile[] = RTL8723_PHY_RADIO_A;	
 	static char			sz8723RadioBFile[] = RTL8723_PHY_RADIO_B;
-	char					*pszRadioAFile, *pszRadioBFile;
+	char					*pszRadioAFile, *pszRadioBFile;	
 
 
 	if(IS_HARDWARE_TYPE_8192C(Adapter))
@@ -656,13 +656,13 @@ static void writeOFDMPowerReg(
 			{
 				pszRadioAFile = sz88CRadioAFile_HP;
 			}
-#endif
+#endif	
 		}
 	}
 	else if(IS_HARDWARE_TYPE_8723A(Adapter))
 	{
 		pszRadioAFile = sz8723RadioAFile;
-		pszRadioBFile = sz8723RadioBFile;
+		pszRadioBFile = sz8723RadioBFile;	
 	}
 
 	//3//-----------------------------------------------------------------
@@ -673,8 +673,8 @@ static void writeOFDMPowerReg(
 	{
 
 		pPhyReg = &pHalData->PHYRegDef[eRFPath];
-
-		/*----Store original RFENV control type----*/
+		
+		/*----Store original RFENV control type----*/		
 		switch(eRFPath)
 		{
 		case RF_PATH_A:
@@ -687,10 +687,10 @@ static void writeOFDMPowerReg(
 			break;
 		}
 
-		/*----Set RF_ENV enable----*/
+		/*----Set RF_ENV enable----*/		
 		PHY_SetBBReg(Adapter, pPhyReg->rfintfe, bRFSI_RFENV<<16, 0x1);
 		rtw_udelay_os(1);//PlatformStallExecution(1);
-
+		
 		/*----Set RF_ENV output high----*/
 		PHY_SetBBReg(Adapter, pPhyReg->rfintfo, bRFSI_RFENV, 0x1);
 		rtw_udelay_os(1);//PlatformStallExecution(1);
@@ -715,7 +715,7 @@ static void writeOFDMPowerReg(
 		case RF_PATH_B:
 #ifdef CONFIG_EMBEDDED_FWIMG
 			rtStatus = rtl8192c_PHY_ConfigRFWithHeaderFile(Adapter,(RF_RADIO_PATH_E)eRFPath);
-#else
+#else			
 			rtStatus = rtl8192c_PHY_ConfigRFWithParaFile(Adapter, pszRadioBFile, (RF_RADIO_PATH_E)eRFPath);
 #endif
 			break;
@@ -747,8 +747,8 @@ static void writeOFDMPowerReg(
 
 	//RT_TRACE(COMP_INIT, DBG_LOUD, ("<---phy_RF6052_Config_ParaFile()\n"));
 	return rtStatus;
-
-phy_RF6052_Config_ParaFile_Fail:
+	
+phy_RF6052_Config_ParaFile_Fail:	
 	return rtStatus;
 }
 
@@ -758,8 +758,8 @@ static void writeOFDMPowerReg(
 	IN	PADAPTER		Adapter)
 {
 	HAL_DATA_TYPE				*pHalData = GET_HAL_DATA(Adapter);
-	int					rtStatus = _SUCCESS;
-
+	int					rtStatus = _SUCCESS;	
+	
 	//
 	// Initialize general global value
 	//
@@ -773,7 +773,7 @@ static void writeOFDMPowerReg(
 	// Config BB and RF
 	//
 	rtStatus = phy_RF6052_Config_ParaFile(Adapter);
-#if 0
+#if 0	
 	switch( Adapter->MgntInfo.bRegHwParaFile )
 	{
 		case 0:
@@ -785,7 +785,7 @@ static void writeOFDMPowerReg(
 			break;
 
 		case 2:
-			// Partial Modify.
+			// Partial Modify. 
 			phy_RF6052_Config_HardCode(Adapter);
 			phy_RF6052_Config_ParaFile(Adapter);
 			break;
@@ -794,9 +794,9 @@ static void writeOFDMPowerReg(
 			phy_RF6052_Config_HardCode(Adapter);
 			break;
 	}
-#endif
+#endif	
 	return rtStatus;
-
+		
 }
 
 
@@ -835,7 +835,7 @@ static void writeOFDMPowerReg(
 	IN	u32				Offset)
 {
 	return	RF_Shadow[eRFPath][Offset].Value;
-
+	
 }	/* PHY_RFShadowRead */
 
 
@@ -848,7 +848,7 @@ static void writeOFDMPowerReg(
 {
 	RF_Shadow[eRFPath][Offset].Value = (Data & bRFRegOffsetMask);
 	RF_Shadow[eRFPath][Offset].Driver_Write = _TRUE;
-
+	
 }	/* PHY_RFShadowWrite */
 
 
@@ -868,8 +868,8 @@ static void writeOFDMPowerReg(
 		{
 			// Locate error position.
 			RF_Shadow[eRFPath][Offset].ErrorOrNot = _TRUE;
-			//RT_TRACE(COMP_INIT, DBG_LOUD,
-			//("PHY_RFShadowCompare RF-%d Addr%02lx Err = %05lx\n",
+			//RT_TRACE(COMP_INIT, DBG_LOUD, 
+			//("PHY_RFShadowCompare RF-%d Addr%02lx Err = %05lx\n", 
 			//eRFPath, Offset, reg));
 		}
 		return RF_Shadow[eRFPath][Offset].ErrorOrNot ;
@@ -890,14 +890,14 @@ static void writeOFDMPowerReg(
 		// Check if we need to recorver the register.
 		if (RF_Shadow[eRFPath][Offset].Recorver == _TRUE)
 		{
-			PHY_SetRFReg(Adapter, eRFPath, Offset, bRFRegOffsetMask,
+			PHY_SetRFReg(Adapter, eRFPath, Offset, bRFRegOffsetMask, 
 							RF_Shadow[eRFPath][Offset].Value);
-			//RT_TRACE(COMP_INIT, DBG_LOUD,
-			//("PHY_RFShadowRecorver RF-%d Addr%02lx=%05lx",
+			//RT_TRACE(COMP_INIT, DBG_LOUD, 
+			//("PHY_RFShadowRecorver RF-%d Addr%02lx=%05lx", 
 			//eRFPath, Offset, RF_Shadow[eRFPath][Offset].Value));
 		}
 	}
-
+	
 }	/* PHY_RFShadowRecorver */
 
 
@@ -915,7 +915,7 @@ static void writeOFDMPowerReg(
 			PHY_RFShadowCompare(Adapter, (RF_RADIO_PATH_E)eRFPath, Offset);
 		}
 	}
-
+	
 }	/* PHY_RFShadowCompareAll */
 
 
@@ -933,7 +933,7 @@ static void writeOFDMPowerReg(
 			PHY_RFShadowRecorver(Adapter, (RF_RADIO_PATH_E)eRFPath, Offset);
 		}
 	}
-
+	
 }	/* PHY_RFShadowRecorverAll */
 
 
@@ -946,7 +946,7 @@ static void writeOFDMPowerReg(
 {
 	// Set True or False!!!
 	RF_Shadow[eRFPath][Offset].Compare = Type;
-
+		
 }	/* PHY_RFShadowCompareFlagSet */
 
 
@@ -959,7 +959,7 @@ static void writeOFDMPowerReg(
 {
 	// Set True or False!!!
 	RF_Shadow[eRFPath][Offset].Recorver= Type;
-
+		
 }	/* PHY_RFShadowRecorverFlagSet */
 
 
@@ -981,7 +981,7 @@ static void writeOFDMPowerReg(
 				PHY_RFShadowCompareFlagSet(Adapter, (RF_RADIO_PATH_E)eRFPath, Offset, _TRUE);
 		}
 	}
-
+		
 }	/* PHY_RFShadowCompareFlagSetAll */
 
 
@@ -1003,7 +1003,7 @@ static void writeOFDMPowerReg(
 				PHY_RFShadowRecorverFlagSet(Adapter, (RF_RADIO_PATH_E)eRFPath, Offset, _TRUE);
 		}
 	}
-
+		
 }	/* PHY_RFShadowCompareFlagSetAll */
 
 VOID
@@ -1015,7 +1015,7 @@ static void writeOFDMPowerReg(
 
 	for (eRFPath = 0; eRFPath < RF6052_MAX_PATH; eRFPath++)
 	{
-		for (Offset = 0; Offset < RF6052_MAX_REG; Offset++)
+		for (Offset = 0; Offset <= RF6052_MAX_REG; Offset++)
 		{
 			RF_Shadow[eRFPath][Offset].Value = 0;
 			RF_Shadow[eRFPath][Offset].Compare = _FALSE;
@@ -1024,7 +1024,8 @@ static void writeOFDMPowerReg(
 			RF_Shadow[eRFPath][Offset].Driver_Write = _FALSE;
 		}
 	}
-
+	
 }	/* PHY_RFShadowRead */
 
 /* End of HalRf6052.c */
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_rxdesc.c b/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_rxdesc.c
old mode 100644
new mode 100755
index 1b102c6..3e0d795e
--- a/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_rxdesc.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_rxdesc.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -214,7 +214,7 @@ static void query_rx_phy_status(union recv_frame *prframe, struct phy_stat *pphy
 
 #ifdef CONFIG_HW_ANTENNA_DIVERSITY
 	PHY_RX_DRIVER_INFO_8192CD *pDrvInfo = ((PHY_RX_DRIVER_INFO_8192CD *)pphy_stat);
-	u8 	bant1_sel = (pDrvInfo->ANTSEL == 1)?_TRUE:_FALSE;
+	u8 	bant1_sel = (pDrvInfo->ANTSEL == 1)?_TRUE:_FALSE;	
 #endif
 
 	// Record it for next packet processing
@@ -223,12 +223,12 @@ static void query_rx_phy_status(union recv_frame *prframe, struct phy_stat *pphy
 	if(bcck_rate) //CCK
 	{
 		u8 report;
-#ifdef CONFIG_HW_ANTENNA_DIVERSITY
+#ifdef CONFIG_HW_ANTENNA_DIVERSITY		
 		if(bant1_sel == _TRUE)
 			pHalData->CCK_Ant1_Cnt++;
 		else
 			pHalData->CCK_Ant2_Cnt++;
-#endif
+#endif		
 
 		// CCK Driver info Structure is not the same as OFDM packet.
 		pCck_buf = (PHY_STS_CCK_8192CD_T *)pphy_stat;
@@ -361,7 +361,7 @@ static void query_rx_phy_status(union recv_frame *prframe, struct phy_stat *pphy
 	}
 	else //OFDM/HT
 	{
-#ifdef CONFIG_HW_ANTENNA_DIVERSITY
+#ifdef CONFIG_HW_ANTENNA_DIVERSITY	
 		if(bant1_sel == _TRUE)
 			pHalData->OFDM_Ant1_Cnt++;
 		else
@@ -370,7 +370,7 @@ static void query_rx_phy_status(union recv_frame *prframe, struct phy_stat *pphy
 		pdmpriv->OFDM_Pkt_Cnt++;
 
 		pOfdm_buf = (PHY_STS_OFDM_8192CD_T *)pphy_stat;
-
+	
 		//
 		// (1)Get RSSI per-path
 		//
@@ -509,7 +509,7 @@ static void process_rssi(_adapter *padapter,union recv_frame *prframe)
 	//DBG_8192C("process_rssi=> pattrib->rssil(%d) signal_strength(%d)\n ",pattrib->RecvSignalPower,pattrib->signal_strength);
 	//if(pRfd->Status.bPacketToSelf || pRfd->Status.bPacketBeacon)
 	{
-
+	
 	#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
 		if(signal_stat->update_req) {
 			signal_stat->total_num = 0;
@@ -519,9 +519,9 @@ static void process_rssi(_adapter *padapter,union recv_frame *prframe)
 
 		signal_stat->total_num++;
 		signal_stat->total_val  += pattrib->signal_strength;
-		signal_stat->avg_val = signal_stat->total_val / signal_stat->total_num;
+		signal_stat->avg_val = signal_stat->total_val / signal_stat->total_num;		
 	#else //CONFIG_NEW_SIGNAL_STAT_PROCESS
-
+	
 		//Adapter->RxStats.RssiCalculateCnt++;	//For antenna Test
 		if(padapter->recvpriv.signal_strength_data.total_num++ >= PHY_RSSI_SLID_WIN_MAX)
 		{
@@ -537,7 +537,7 @@ static void process_rssi(_adapter *padapter,union recv_frame *prframe)
 
 
 		tmp_val = padapter->recvpriv.signal_strength_data.total_val/padapter->recvpriv.signal_strength_data.total_num;
-
+		
 		if(padapter->recvpriv.is_signal_dbg) {
 			padapter->recvpriv.signal_strength= padapter->recvpriv.signal_strength_dbg;
 			padapter->recvpriv.rssi=(s8)translate2dbm((u8)padapter->recvpriv.signal_strength_dbg);
@@ -623,8 +623,8 @@ static void process_PWDB(_adapter *padapter, union recv_frame *prframe)
 					(pattrib->RxPWDBAll)) /(Rx_Smooth_Factor);
 		}
 	}
-
-
+	
+	
 	if(psta)
 	{
 		//psta->UndecoratedSmoothedPWDB = UndecoratedSmoothedPWDB;//todo:
@@ -637,7 +637,7 @@ static void process_PWDB(_adapter *padapter, union recv_frame *prframe)
 			psta->rssi_stat.UndecoratedSmoothedPWDB = UndecoratedSmoothedCCK;
 		}
 		else{
-			if(UndecoratedSmoothedPWDB <0 )
+			if(UndecoratedSmoothedPWDB <0 ) 
 				pdmpriv->UndecoratedSmoothedPWDB = UndecoratedSmoothedCCK;
 			else
 				pdmpriv->UndecoratedSmoothedPWDB = UndecoratedSmoothedPWDB;
@@ -655,11 +655,11 @@ static void process_PWDB(_adapter *padapter, union recv_frame *prframe)
 			pdmpriv->UndecoratedSmoothedPWDB = UndecoratedSmoothedCCK;
 		}
 		else	{
-			if(UndecoratedSmoothedPWDB <0 )
+			if(UndecoratedSmoothedPWDB <0 ) 
 				pdmpriv->UndecoratedSmoothedPWDB = UndecoratedSmoothedCCK;
 			else
 				pdmpriv->UndecoratedSmoothedPWDB = UndecoratedSmoothedPWDB;
-
+			
 		}
 		pdmpriv->UndecoratedSmoothedCCK = UndecoratedSmoothedCCK;
 	}
@@ -672,7 +672,7 @@ static void process_PWDB(_adapter *padapter, union recv_frame *prframe)
 static void process_link_qual(_adapter *padapter,union recv_frame *prframe)
 {
 	u32	last_evm=0, tmpVal;
-	struct rx_pkt_attrib *pattrib;
+ 	struct rx_pkt_attrib *pattrib;
 #ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
 	struct signal_stat * signal_stat;
 #endif //CONFIG_NEW_SIGNAL_STAT_PROCESS
@@ -698,7 +698,7 @@ static void process_link_qual(_adapter *padapter,union recv_frame *prframe)
 	signal_stat->total_num++;
 	signal_stat->total_val  += pattrib->signal_qual;
 	signal_stat->avg_val = signal_stat->total_val / signal_stat->total_num;
-
+	
 #else //CONFIG_NEW_SIGNAL_STAT_PROCESS
 	if(pattrib->signal_qual != 0)
 	{
@@ -738,8 +738,8 @@ static void process_phy_info(_adapter *padapter, union recv_frame *prframe)
 	union recv_frame *precvframe = (union recv_frame *)prframe;
 
 #ifdef CONFIG_SW_ANTENNA_DIVERSITY
-	// If we switch to the antenna for testing, the signal strength
-	// of the packets in this time shall not be counted into total receiving power.
+	// If we switch to the antenna for testing, the signal strength 
+	// of the packets in this time shall not be counted into total receiving power. 
 	// This prevents error counting Rx signal strength and affecting other dynamic mechanism.
 
 	// Select the packets to do RSSI checking for antenna switching.
@@ -755,7 +755,7 @@ static void process_phy_info(_adapter *padapter, union recv_frame *prframe)
 	//
 	// Check PWDB.
 	//
-	process_PWDB(padapter, precvframe);
+	process_PWDB(padapter, precvframe); 
 	//
 	// Check EVM
 	//
@@ -776,7 +776,7 @@ void rtl8192c_translate_rx_signal_stuff(union recv_frame *precvframe, struct phy
 	{
 		bPacketMatchBSSID = ((!IsFrameTypeCtrl(precvframe->u.hdr.rx_data)) && !(pattrib->icv_err) && !(pattrib->crc_err) &&
 			_rtw_memcmp(get_hdr_bssid(precvframe->u.hdr.rx_data), get_my_bssid(&padapter->mlmeextpriv.mlmext_info.network), ETH_ALEN));
-
+			
 
 		bPacketToSelf = bPacketMatchBSSID &&  (_rtw_memcmp(get_da(precvframe->u.hdr.rx_data), myid(&padapter->eeprompriv), ETH_ALEN));
 
@@ -790,7 +790,7 @@ void rtl8192c_translate_rx_signal_stuff(union recv_frame *precvframe, struct phy
 			u8 *sa;
 			struct sta_info *psta=NULL;
 			struct sta_priv *pstapriv = &padapter->stapriv;
-
+			
 			sa = get_sa(precvframe->u.hdr.rx_data);
 
 			psta = rtw_get_stainfo(pstapriv, sa);
@@ -807,16 +807,16 @@ void rtl8192c_translate_rx_signal_stuff(union recv_frame *precvframe, struct phy
 				u8 *sa;
 				struct sta_info *psta=NULL;
 				struct sta_priv *pstapriv = &padapter->stapriv;
-
+			
 				sa = get_sa(precvframe->u.hdr.rx_data);
 
 				psta = rtw_get_stainfo(pstapriv, sa);
 				if(psta)
 				{
 					precvframe->u.hdr.psta = psta;
-				}
+				}				
 			}
-
+					
 			process_phy_info(padapter, precvframe);
 		}
 	}
@@ -872,3 +872,5 @@ void rtl8192c_query_rx_desc_status(union recv_frame *precvframe, struct recv_sta
 	//Offset 20
 
 }
+
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_sreset.c b/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_sreset.c
old mode 100644
new mode 100755
index 6275894..1368d66
--- a/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_sreset.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_sreset.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -22,18 +22,18 @@
 #ifdef DBG_CONFIG_ERROR_DETECT
 void rtl8192c_sreset_xmit_status_check(_adapter *padapter)
 {
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
-	struct sreset_priv *psrtpriv = &pHalData->srestpriv;
-
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);	
+	struct sreset_priv *psrtpriv = &pHalData->srestpriv;	
+	
 	unsigned long current_time;
 	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
 	unsigned int diff_time;
 	u32 txdma_status;
 	if( (txdma_status=rtw_read32(padapter, REG_TXDMA_STATUS)) !=0x00){
 		DBG_871X("%s REG_TXDMA_STATUS:0x%08x\n", __FUNCTION__, txdma_status);
-		rtw_hal_sreset_reset(padapter);
+		rtw_hal_sreset_reset(padapter);						
 	}
-
+	
 	//total xmit irp = 4
 	//DBG_8192C("==>%s free_xmitbuf_cnt(%d),txirp_cnt(%d)\n",__FUNCTION__,pxmitpriv->free_xmitbuf_cnt,pxmitpriv->txirp_cnt);
 	//if(pxmitpriv->txirp_cnt == NR_XMITBUFF+1)
@@ -73,7 +73,7 @@ void rtl8192c_sreset_linked_status_check(_adapter *padapter)
 	regc50 = rtw_read32(padapter,0xc50);
 	regc58 = rtw_read32(padapter,0xc58);
 	reg824 = rtw_read32(padapter,0x824);
-	reg800 = rtw_read32(padapter,0x800);
+	reg800 = rtw_read32(padapter,0x800);	
 	if(	((regc50&0xFFFFFF00)!= 0x69543400)||
 		((regc58&0xFFFFFF00)!= 0x69543400)||
 		(((reg824&0xFFFFFF00)!= 0x00390000)&&(((reg824&0xFFFFFF00)!= 0x80390000)))||
@@ -81,7 +81,7 @@ void rtl8192c_sreset_linked_status_check(_adapter *padapter)
 	{
 		DBG_8192C("%s regc50:0x%08x, regc58:0x%08x, reg824:0x%08x, reg800:0x%08x,\n", __FUNCTION__,
 			regc50, regc58, reg824, reg800);
-		rtw_hal_sreset_reset(padapter);
+		rtw_hal_sreset_reset(padapter);	
 	}
 
 	if (psrtpriv->dbg_trigger_point == SRESET_TGP_LINK_STATUS) {
@@ -91,3 +91,4 @@ void rtl8192c_sreset_linked_status_check(_adapter *padapter)
 	}
 }
 #endif
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_xmit.c b/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_xmit.c
old mode 100644
new mode 100755
index e958164..2cfd851
--- a/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_xmit.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/rtl8192c_xmit.c
@@ -27,7 +27,7 @@
 #ifdef CONFIG_XMIT_ACK
 void dump_txrpt_ccx_8192c(void *buf)
 {
-	struct txrpt_ccx_8192c *txrpt_ccx = buf;
+	struct txrpt_ccx_8192c *txrpt_ccx = buf; 
 
 	DBG_871X("%s:\n"
 		"retry_cnt:%u, rsvd_0:%u, rts_retry_cnt:%u, rsvd_1:%u\n"
@@ -46,7 +46,7 @@ void dump_txrpt_ccx_8192c(void *buf)
 
 void handle_txrpt_ccx_8192c(_adapter *adapter, void *buf)
 {
-	struct txrpt_ccx_8192c *txrpt_ccx = buf;
+	struct txrpt_ccx_8192c *txrpt_ccx = buf; 
 
 	#ifdef DBG_CCX
 	dump_txrpt_ccx_8192c(buf);
@@ -60,3 +60,4 @@ void handle_txrpt_ccx_8192c(_adapter *adapter, void *buf)
 	}
 }
 #endif //CONFIG_XMIT_ACK
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/Hal8192CUHWImg.c b/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/Hal8192CUHWImg.c
old mode 100644
new mode 100755
index 9faa8c1..b49486b
--- a/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/Hal8192CUHWImg.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/Hal8192CUHWImg.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -8755,3 +8755,4 @@
 0xc78,0x621e001e,
 0xc78,0x621f001e,
 };
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/Hal8192CUHWImg_wowlan.c b/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/Hal8192CUHWImg_wowlan.c
old mode 100644
new mode 100755
index 5554813..66970f1
--- a/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/Hal8192CUHWImg_wowlan.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/Hal8192CUHWImg_wowlan.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -2555,3 +2555,10 @@
 0x94,0x01,0x40,0x1e,0x90,0xfd,0x11,0xe0,0xb5,0x05,0x14,0x90,0x01,0x17,0xe0,0xb5,
 0x05,0x07,0x90,0xfd,0x11,0xe4,0xf0,0x80,0x06,0xed,0x04,0x90,0xfd,0x11,0xf0,0xe4,
 0x2f,0xff,0x22,0x00,0x18,0x58,};
+
+
+
+
+
+
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/rtl8192cu_led.c b/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/rtl8192cu_led.c
old mode 100644
new mode 100755
index 382b978..4d4a395c
--- a/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/rtl8192cu_led.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/rtl8192cu_led.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -48,15 +48,13 @@
 //================================================================================
 
 
-static void
-BlinkTimerCallback(
-	unsigned long data
-	);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+void BlinkTimerCallback(void *data);
+#else
+void BlinkTimerCallback(struct timer_list *t);
+#endif
 
-static void
-BlinkWorkItemCallback(
-	struct work_struct *work
-	);
+static void BlinkWorkItemCallback(struct work_struct *work);
 
 //
 //	Description:
@@ -66,7 +64,7 @@
 ResetLedStatus(PLED_871x	pLed) {
 	pLed->CurrLedState = RTW_LED_OFF; // Current LED state.
 	pLed->bLedOn = _FALSE; // true if LED is ON, false if LED is OFF.
-
+	
 	pLed->bLedBlinkInProgress = _FALSE; // true if it is blinking, false o.w..
 	pLed->bLedNoLinkBlinkInProgress = _FALSE;
 	pLed->bLedLinkBlinkInProgress = _FALSE;
@@ -78,7 +76,7 @@
 }
 
 //================================================================================
-// LED_819xUsb routines.
+// LED_819xUsb routines. 
 //================================================================================
 
 //
@@ -97,7 +95,11 @@
 
 	ResetLedStatus(pLed);
 
-	_init_timer(&(pLed->BlinkTimer), padapter->pnetdev, BlinkTimerCallback, pLed);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+        _init_timer(&(pLed->BlinkTimer), padapter->pnetdev, BlinkTimerCallback, pLed);
+#else
+        timer_setup(&pLed->BlinkTimer, BlinkTimerCallback, 0);
+#endif
 	_init_workitem(&(pLed->BlinkWorkItem), BlinkWorkItemCallback, pLed);
 }
 
@@ -111,14 +113,14 @@
 	PLED_871x			pLed
 	)
 {
-	//call _cancel_workitem_sync(&(pLed->BlinkWorkItem))
-    //before _cancel_timer_ex(&(pLed->BlinkTimer)) to
+	//call _cancel_workitem_sync(&(pLed->BlinkWorkItem)) 
+    //before _cancel_timer_ex(&(pLed->BlinkTimer)) to 
     //avoid led timer restarting when driver is removed
 
 	_cancel_workitem_sync(&(pLed->BlinkWorkItem));
-
+	
 	_cancel_timer_ex(&(pLed->BlinkTimer));
-
+	
 	// We should reset bLedBlinkInProgress if we cancel the LedControlTimer, 2005.03.10, by rcnjko.
 	ResetLedStatus(pLed);
 }
@@ -129,7 +131,7 @@
 //
 static void
 SwLedOn(
-	_adapter			*padapter,
+	_adapter			*padapter, 
 	PLED_871x		pLed
 )
 {
@@ -147,7 +149,7 @@
 	{
 		LedCfg = rtw_read8(padapter, REG_LEDCFG2);
 		switch(pLed->LedPin)
-		{
+		{	
 			case LED_PIN_GPIO0:
 				break;
 
@@ -161,11 +163,11 @@
 
 			default:
 				break;
-
+	
 		}
 	}
 	else
-	{
+	{	
 		switch(pLed->LedPin)
 		{
 			case LED_PIN_GPIO0:
@@ -192,7 +194,7 @@
 				LedCfg = rtw_read8(padapter,(REG_LEDCFG1));
 				rtw_write8(padapter,(REG_LEDCFG1), LedCfg&0x70); // SW control led1 on.
 				//RT_TRACE(COMP_LED, DBG_LOUD, ("SwLedOn LED1 0x%lx\n", PlatformEFIORead4Byte(Adapter, REG_LEDCFG0)));
-
+			
 				break;
 
 			default:
@@ -200,7 +202,7 @@
 		}
 	}
 	pLed->bLedOn = _TRUE;
-
+	
 }
 
 
@@ -210,14 +212,14 @@
 //
 static void
 SwLedOff(
-	_adapter			*padapter,
+	_adapter			*padapter, 
 	PLED_871x		pLed
 )
 {
 	u8	LedCfg;
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
 
-	if((padapter->bSurpriseRemoved == _TRUE) || ( padapter->bDriverStopped == _TRUE))
+	if((padapter->bSurpriseRemoved == _TRUE) || ( padapter->bDriverStopped == _TRUE))	
 	{
 		goto exit;
 	}
@@ -237,11 +239,11 @@
 			case LED_PIN_LED0:
 				if(BOARD_USB_COMBO == pHalData->BoardType)
 				{
-					LedCfg &= 0x90; // Set to software control.
-					rtw_write8(padapter, REG_LEDCFG2, (LedCfg|BIT3));
+					LedCfg &= 0x90; // Set to software control.				
+					rtw_write8(padapter, REG_LEDCFG2, (LedCfg|BIT3));				
 					LedCfg = rtw_read8(padapter, REG_MAC_PINMUX_CFG);
 					LedCfg &= 0xFE;
-					rtw_write8(padapter, REG_MAC_PINMUX_CFG, LedCfg);
+					rtw_write8(padapter, REG_MAC_PINMUX_CFG, LedCfg);									
 				}
 				else
 				{
@@ -274,7 +276,7 @@
 				if(pHalData->AntDivCfg)
 				{
 					LedCfg = rtw_read8(padapter, REG_LEDCFG2);
-					LedCfg &= 0xe0; // Set to software control.
+					LedCfg &= 0xe0; // Set to software control. 			
 					rtw_write8(padapter, REG_LEDCFG2, (LedCfg|BIT3|BIT7|BIT6|BIT5));
 					//RT_TRACE(COMP_LED, DBG_LOUD, ("SwLedOff LED0 0x%x\n", PlatformEFIORead4Byte(Adapter, REG_LEDCFG2)));
 				}
@@ -282,7 +284,7 @@
 #endif
 				{
 					LedCfg = rtw_read8(padapter, REG_LEDCFG0);
-					LedCfg &= 0x70; // Set to software control.
+					LedCfg &= 0x70; // Set to software control. 			
 					rtw_write8(padapter, REG_LEDCFG0, (LedCfg|BIT3));
 					//RT_TRACE(COMP_LED, DBG_LOUD, ("SwLedOff LED0 0x%lx\n", PlatformEFIORead4Byte(Adapter, REG_LEDCFG0)));
 				}
@@ -302,7 +304,7 @@
 
 exit:
 	pLed->bLedOn = _FALSE;
-
+	
 }
 
 //================================================================================
@@ -325,12 +327,12 @@
 	u8				bStopBlinking = _FALSE;
 
 	// Change LED according to BlinkingLedState specified.
-	if( pLed->BlinkingLedState == RTW_LED_ON )
+	if( pLed->BlinkingLedState == RTW_LED_ON ) 
 	{
 		SwLedOn(padapter, pLed);
 		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
 	}
-	else
+	else 
 	{
 		SwLedOff(padapter, pLed);
 		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,( "Blinktimes (%d): turn off\n", pLed->BlinkTimes));
@@ -341,13 +343,13 @@
 	switch(pLed->CurrLedState)
 	{
 
-	case LED_BLINK_NORMAL:
+	case LED_BLINK_NORMAL: 
 		if(pLed->BlinkTimes == 0)
 		{
 			bStopBlinking = _TRUE;
 		}
 		break;
-
+		
 	case LED_BLINK_StartToBlink:
 		if( check_fwstate(pmlmepriv, _FW_LINKED) && check_fwstate(pmlmepriv, WIFI_STATION_STATE) )
 		{
@@ -375,9 +377,9 @@
 	default:
 		bStopBlinking = _TRUE;
 		break;
-
+			
 	}
-
+	
 	if(bStopBlinking)
 	{
 		//if( padapter->pwrctrlpriv.cpwm >= PS_STATE_S2)
@@ -400,18 +402,18 @@
 	else
 	{
 		// Assign LED state to toggle.
-		if( pLed->BlinkingLedState == RTW_LED_ON )
+		if( pLed->BlinkingLedState == RTW_LED_ON ) 
 			pLed->BlinkingLedState = RTW_LED_OFF;
-		else
+		else 
 			pLed->BlinkingLedState = RTW_LED_ON;
 
-		// Schedule a timer to toggle LED state.
+		// Schedule a timer to toggle LED state. 
 		switch( pLed->CurrLedState )
 		{
 		case LED_BLINK_NORMAL:
 			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
 			break;
-
+		
 		case LED_BLINK_SLOWLY:
 		case LED_BLINK_StartToBlink:
 			_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
@@ -443,19 +445,19 @@
 	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(padapter);
 	struct led_priv		*ledpriv = &(padapter->ledpriv);
 	struct mlme_priv		*pmlmepriv = &(padapter->mlmepriv);
-	PLED_871x 			pLed1 = &(ledpriv->SwLed1);
+	PLED_871x 			pLed1 = &(ledpriv->SwLed1);	
 	u8					bStopBlinking = _FALSE;
 
 	if(pHalData->EEPROMCustomerID == RT_CID_819x_CAMEO)
-		pLed = &(ledpriv->SwLed1);
+		pLed = &(ledpriv->SwLed1);	
 
 	// Change LED according to BlinkingLedState specified.
-	if( pLed->BlinkingLedState == RTW_LED_ON )
+	if( pLed->BlinkingLedState == RTW_LED_ON ) 
 	{
 		SwLedOn(padapter, pLed);
 		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,( "Blinktimes (%d): turn on\n", pLed->BlinkTimes));
 	}
-	else
+	else 
 	{
 		SwLedOff(padapter, pLed);
 		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
@@ -468,14 +470,14 @@
 		{
 			if(!pLed1->bSWLedCtrl)
 			{
-				SwLedOn(padapter, pLed1);
+				SwLedOn(padapter, pLed1); 	
 				pLed1->bSWLedCtrl = _TRUE;
 			}
-			else if(!pLed1->bLedOn)
+			else if(!pLed1->bLedOn)	
 				SwLedOn(padapter, pLed1);
 			RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (): turn on pLed1\n"));
 		}
-		else
+		else 
 		{
 			if(!pLed1->bSWLedCtrl)
 			{
@@ -484,7 +486,7 @@
 			}
 			else if(pLed1->bLedOn)
 				SwLedOff(padapter, pLed1);
-			RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (): turn off pLed1\n"));
+			RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (): turn off pLed1\n"));		
 		}
 	}
 
@@ -495,13 +497,13 @@
 		ResetLedStatus(pLed);
 		return;
 	}
-
+				
 
 	switch(pLed->CurrLedState)
 	{
-		case LED_BLINK_SLOWLY:
+		case LED_BLINK_SLOWLY:			
 			if( pLed->bLedOn )
-				pLed->BlinkingLedState = RTW_LED_OFF;
+				pLed->BlinkingLedState = RTW_LED_OFF; 
 			else
 				pLed->BlinkingLedState = RTW_LED_ON;
 			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
@@ -509,19 +511,19 @@
 
 		case LED_BLINK_NORMAL:
 			if( pLed->bLedOn )
-				pLed->BlinkingLedState = RTW_LED_OFF;
+				pLed->BlinkingLedState = RTW_LED_OFF; 
 			else
 				pLed->BlinkingLedState = RTW_LED_ON;
 			_set_timer(&(pLed->BlinkTimer), LED_BLINK_LINK_INTERVAL_ALPHA);
 			break;
-
+			
 		case LED_SCAN_BLINK:
 			pLed->BlinkTimes--;
 			if( pLed->BlinkTimes == 0 )
 			{
 				bStopBlinking = _TRUE;
 			}
-
+			
 			if(bStopBlinking)
 			{
 				if(check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE)
@@ -529,23 +531,23 @@
 					pLed->bLedLinkBlinkInProgress = _TRUE;
 					pLed->CurrLedState = LED_BLINK_NORMAL;
 					if( pLed->bLedOn )
-						pLed->BlinkingLedState = RTW_LED_OFF;
+						pLed->BlinkingLedState = RTW_LED_OFF; 
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
 					_set_timer(&(pLed->BlinkTimer), LED_BLINK_LINK_INTERVAL_ALPHA);
 					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
-
+					
 				}
 				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _FALSE)
 				{
 					pLed->bLedNoLinkBlinkInProgress = _TRUE;
 					pLed->CurrLedState = LED_BLINK_SLOWLY;
 					if( pLed->bLedOn )
-						pLed->BlinkingLedState = RTW_LED_OFF;
+						pLed->BlinkingLedState = RTW_LED_OFF; 
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
 					_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
-					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));					
 				}
 				pLed->bLedScanBlinkInProgress = _FALSE;
 			}
@@ -576,26 +578,26 @@
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
 					_set_timer(&(pLed->BlinkTimer), LED_BLINK_LINK_INTERVAL_ALPHA);
-					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));					
 				}
 				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _FALSE)
 				{
 					pLed->bLedNoLinkBlinkInProgress = _TRUE;
 					pLed->CurrLedState = LED_BLINK_SLOWLY;
 					if( pLed->bLedOn )
-						pLed->BlinkingLedState = RTW_LED_OFF;
+						pLed->BlinkingLedState = RTW_LED_OFF; 
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
 					_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
-					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));					
 				}
 				pLed->BlinkTimes = 0;
-				pLed->bLedBlinkInProgress = _FALSE;
+				pLed->bLedBlinkInProgress = _FALSE;	
 			}
 			else
 			{
 				if( pLed->bLedOn )
-					pLed->BlinkingLedState = RTW_LED_OFF;
+					pLed->BlinkingLedState = RTW_LED_OFF; 
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
 				_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
@@ -604,7 +606,7 @@
 
 		case LED_BLINK_WPS:
 			if( pLed->bLedOn )
-				pLed->BlinkingLedState = RTW_LED_OFF;
+				pLed->BlinkingLedState = RTW_LED_OFF; 
 			else
 				pLed->BlinkingLedState = RTW_LED_ON;
 			_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
@@ -614,20 +616,20 @@
 			if(pLed->BlinkingLedState == RTW_LED_ON)
 				bStopBlinking = _FALSE;
 			else
-				bStopBlinking = _TRUE;
+				bStopBlinking = _TRUE;				
 
 			if(bStopBlinking)
 			{
 				pLed->bLedLinkBlinkInProgress = _TRUE;
 				pLed->CurrLedState = LED_BLINK_NORMAL;
 				if( pLed->bLedOn )
-					pLed->BlinkingLedState = RTW_LED_OFF;
+					pLed->BlinkingLedState = RTW_LED_OFF; 
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
 				_set_timer(&(pLed->BlinkTimer), LED_BLINK_LINK_INTERVAL_ALPHA);
 				RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
-
-				pLed->bLedWPSBlinkInProgress = _FALSE;
+					
+				pLed->bLedWPSBlinkInProgress = _FALSE;	
 			}
 			else
 			{
@@ -635,7 +637,7 @@
 				_set_timer(&(pLed->BlinkTimer), LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA);
 			}
 			break;
-
+					
 		default:
 			break;
 	}
@@ -652,26 +654,26 @@
 	u8					bStopBlinking = _FALSE;
 
 	// Change LED according to BlinkingLedState specified.
-	if( pLed->BlinkingLedState == RTW_LED_ON)
+	if( pLed->BlinkingLedState == RTW_LED_ON) 
 	{
 		SwLedOn(padapter, pLed);
 		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
 	}
-	else
+	else 
 	{
 		SwLedOff(padapter, pLed);
 		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
 	}
 
 	switch(pLed->CurrLedState)
-	{
+	{	
 		case LED_SCAN_BLINK:
 			pLed->BlinkTimes--;
 			if( pLed->BlinkTimes == 0 )
 			{
 				bStopBlinking = _TRUE;
 			}
-
+			
 			if(bStopBlinking)
 			{
 				if( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
@@ -681,17 +683,17 @@
 				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE)
 				{
 					pLed->CurrLedState = RTW_LED_ON;
-					pLed->BlinkingLedState = RTW_LED_ON;
+					pLed->BlinkingLedState = RTW_LED_ON; 
 					SwLedOn(padapter, pLed);
 					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("stop scan blink CurrLedState %d\n", pLed->CurrLedState));
-
+					
 				}
 				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _FALSE)
 				{
 					pLed->CurrLedState = RTW_LED_OFF;
-					pLed->BlinkingLedState = RTW_LED_OFF;
+					pLed->BlinkingLedState = RTW_LED_OFF; 
 					SwLedOff(padapter, pLed);
-					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("stop scan blink CurrLedState %d\n", pLed->CurrLedState));
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("stop scan blink CurrLedState %d\n", pLed->CurrLedState));					
 				}
 				pLed->bLedScanBlinkInProgress = _FALSE;
 			}
@@ -704,7 +706,7 @@
 				else
 				{
 					 if( pLed->bLedOn )
-						pLed->BlinkingLedState = RTW_LED_OFF;
+						pLed->BlinkingLedState = RTW_LED_OFF; 
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
 					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
@@ -727,17 +729,17 @@
 				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE)
 				{
 					pLed->CurrLedState = RTW_LED_ON;
-					pLed->BlinkingLedState = RTW_LED_ON;
+					pLed->BlinkingLedState = RTW_LED_ON; 
 					SwLedOn(padapter, pLed);
 					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("stop CurrLedState %d\n", pLed->CurrLedState));
-
+					
 				}
 				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _FALSE)
 				{
 					pLed->CurrLedState = RTW_LED_OFF;
-					pLed->BlinkingLedState = RTW_LED_OFF;
+					pLed->BlinkingLedState = RTW_LED_OFF; 
 					SwLedOff(padapter, pLed);
-					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("stop CurrLedState %d\n", pLed->CurrLedState));
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("stop CurrLedState %d\n", pLed->CurrLedState));					
 				}
 				pLed->bLedBlinkInProgress = _FALSE;
 			}
@@ -750,14 +752,14 @@
 				else
 				{
 					 if( pLed->bLedOn )
-						pLed->BlinkingLedState = RTW_LED_OFF;
+						pLed->BlinkingLedState = RTW_LED_OFF; 
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
 					_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
 				}
 			}
 			break;
-
+					
 		default:
 			break;
 	}
@@ -774,27 +776,27 @@
 	u8				bStopBlinking = _FALSE;
 
 	// Change LED according to BlinkingLedState specified.
-	if( pLed->BlinkingLedState == RTW_LED_ON )
+	if( pLed->BlinkingLedState == RTW_LED_ON ) 
 	{
 		SwLedOn(padapter, pLed);
 		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
 	}
-	else
+	else 
 	{
 		if(pLed->CurrLedState != LED_BLINK_WPS_STOP)
 			SwLedOff(padapter, pLed);
 		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
-	}
+	}	
 
 	switch(pLed->CurrLedState)
-	{
+	{			
 		case LED_SCAN_BLINK:
 			pLed->BlinkTimes--;
 			if( pLed->BlinkTimes == 0 )
 			{
 				bStopBlinking = _TRUE;
 			}
-
+			
 			if(bStopBlinking)
 			{
 				if( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
@@ -804,20 +806,20 @@
 				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE)
 				{
 					pLed->CurrLedState = RTW_LED_ON;
-					pLed->BlinkingLedState = RTW_LED_ON;
+					pLed->BlinkingLedState = RTW_LED_ON;				
 					if( !pLed->bLedOn )
 						SwLedOn(padapter, pLed);
 
-					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));					
 				}
 				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _FALSE)
 				{
 					pLed->CurrLedState = RTW_LED_OFF;
-					pLed->BlinkingLedState = RTW_LED_OFF;
+					pLed->BlinkingLedState = RTW_LED_OFF;									
 					if( pLed->bLedOn )
 						SwLedOff(padapter, pLed);
 
-					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));					
 				}
 				pLed->bLedScanBlinkInProgress = _FALSE;
 			}
@@ -829,8 +831,8 @@
 				}
 				else
 				{
-					if( pLed->bLedOn )
-						pLed->BlinkingLedState = RTW_LED_OFF;
+				 	if( pLed->bLedOn )
+						pLed->BlinkingLedState = RTW_LED_OFF; 
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
 					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
@@ -854,24 +856,24 @@
 				{
 					pLed->CurrLedState = RTW_LED_ON;
 					pLed->BlinkingLedState = RTW_LED_ON;
-
+				
 					if( !pLed->bLedOn )
 						SwLedOn(padapter, pLed);
 
-					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));					
 				}
 				else if(check_fwstate(pmlmepriv, _FW_LINKED)== _FALSE)
 				{
 					pLed->CurrLedState = RTW_LED_OFF;
-					pLed->BlinkingLedState = RTW_LED_OFF;
-
+					pLed->BlinkingLedState = RTW_LED_OFF;					
+				
 					if( pLed->bLedOn )
 						SwLedOff(padapter, pLed);
 
 
-					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));					
 				}
-				pLed->bLedBlinkInProgress = _FALSE;
+				pLed->bLedBlinkInProgress = _FALSE;	
 			}
 			else
 			{
@@ -882,7 +884,7 @@
 				else
 				{
 					if( pLed->bLedOn )
-						pLed->BlinkingLedState = RTW_LED_OFF;
+						pLed->BlinkingLedState = RTW_LED_OFF; 
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
 					_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
@@ -892,7 +894,7 @@
 
 		case LED_BLINK_WPS:
 			if( pLed->bLedOn )
-				pLed->BlinkingLedState = RTW_LED_OFF;
+				pLed->BlinkingLedState = RTW_LED_OFF; 
 			else
 				pLed->BlinkingLedState = RTW_LED_ON;
 			_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
@@ -907,27 +909,27 @@
 			}
 			else
 			{
-				bStopBlinking = _TRUE;
+				bStopBlinking = _TRUE;				
 			}
-
+			
 			if(bStopBlinking)
 			{
 				if( padapter->pwrctrlpriv.rf_pwrstate != rf_on )
 				{
 					SwLedOff(padapter, pLed);
 				}
-				else
+				else 
 				{
 					pLed->CurrLedState = RTW_LED_ON;
-					pLed->BlinkingLedState = RTW_LED_ON;
+					pLed->BlinkingLedState = RTW_LED_ON; 
 					SwLedOn(padapter, pLed);
-					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));					
 				}
-				pLed->bLedWPSBlinkInProgress = _FALSE;
-			}
+				pLed->bLedWPSBlinkInProgress = _FALSE;	
+			}		
 			break;
-
-
+			
+					
 		default:
 			break;
 	}
@@ -943,33 +945,33 @@
 	_adapter			*padapter = pLed->padapter;
 	struct led_priv	*ledpriv = &(padapter->ledpriv);
 	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
-	PLED_871x 		pLed1 = &(ledpriv->SwLed1);
+	PLED_871x 		pLed1 = &(ledpriv->SwLed1);	
 	u8				bStopBlinking = _FALSE;
 
 	// Change LED according to BlinkingLedState specified.
-	if( pLed->BlinkingLedState == RTW_LED_ON )
+	if( pLed->BlinkingLedState == RTW_LED_ON ) 
 	{
 		SwLedOn(padapter, pLed);
 		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
 	}
-	else
+	else 
 	{
 		SwLedOff(padapter, pLed);
 		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
-	}
+	}	
 
 	if(!pLed1->bLedWPSBlinkInProgress && pLed1->BlinkingLedState == LED_UNKNOWN)
 	{
 		pLed1->BlinkingLedState = RTW_LED_OFF;
 		pLed1->CurrLedState = RTW_LED_OFF;
 		SwLedOff(padapter, pLed1);
-	}
+	}	
 
 	switch(pLed->CurrLedState)
 	{
-		case LED_BLINK_SLOWLY:
+		case LED_BLINK_SLOWLY:			
 			if( pLed->bLedOn )
-				pLed->BlinkingLedState = RTW_LED_OFF;
+				pLed->BlinkingLedState = RTW_LED_OFF; 
 			else
 				pLed->BlinkingLedState = RTW_LED_ON;
 			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
@@ -986,27 +988,27 @@
 				pLed->BlinkingLedState = RTW_LED_ON;
 				_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
 			}
-			break;
-
+			break;			
+			
 		case LED_SCAN_BLINK:
 			pLed->BlinkTimes--;
 			if( pLed->BlinkTimes == 0 )
 			{
 				bStopBlinking = _FALSE;
 			}
-
+			
 			if(bStopBlinking)
 			{
 				if( padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
 				{
 					SwLedOff(padapter, pLed);
 				}
-				else
+				else 
 				{
 					pLed->bLedNoLinkBlinkInProgress = _FALSE;
 					pLed->CurrLedState = LED_BLINK_SLOWLY;
 					if( pLed->bLedOn )
-						pLed->BlinkingLedState = RTW_LED_OFF;
+						pLed->BlinkingLedState = RTW_LED_OFF; 
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
 					_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
@@ -1022,7 +1024,7 @@
 				else
 				{
 					 if( pLed->bLedOn )
-						pLed->BlinkingLedState = RTW_LED_OFF;
+						pLed->BlinkingLedState = RTW_LED_OFF; 
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
 					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
@@ -1042,17 +1044,17 @@
 				{
 					SwLedOff(padapter, pLed);
 				}
-				else
+				else 
 				{
 					pLed->bLedNoLinkBlinkInProgress = _TRUE;
 					pLed->CurrLedState = LED_BLINK_SLOWLY;
 					if( pLed->bLedOn )
-						pLed->BlinkingLedState = RTW_LED_OFF;
+						pLed->BlinkingLedState = RTW_LED_OFF; 
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
 					_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
 				}
-				pLed->bLedBlinkInProgress = _FALSE;
+				pLed->bLedBlinkInProgress = _FALSE;	
 			}
 			else
 			{
@@ -1063,7 +1065,7 @@
 				else
 				{
 					 if( pLed->bLedOn )
-						pLed->BlinkingLedState = RTW_LED_OFF;
+						pLed->BlinkingLedState = RTW_LED_OFF; 
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
 					_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
@@ -1085,21 +1087,21 @@
 			break;
 
 		case LED_BLINK_WPS_STOP:	//WPS authentication fail
-			if( pLed->bLedOn )
-				pLed->BlinkingLedState = RTW_LED_OFF;
-			else
+			if( pLed->bLedOn )			
+				pLed->BlinkingLedState = RTW_LED_OFF; 			
+			else			
 				pLed->BlinkingLedState = RTW_LED_ON;
 
 			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
 			break;
 
-		case LED_BLINK_WPS_STOP_OVERLAP:	//WPS session overlap
+		case LED_BLINK_WPS_STOP_OVERLAP:	//WPS session overlap		
 			pLed->BlinkTimes--;
 			if(pLed->BlinkTimes == 0)
 			{
 				if(pLed->bLedOn)
 				{
-					pLed->BlinkTimes = 1;
+					pLed->BlinkTimes = 1;							
 				}
 				else
 				{
@@ -1108,23 +1110,23 @@
 			}
 
 			if(bStopBlinking)
-			{
-				pLed->BlinkTimes = 10;
+			{				
+				pLed->BlinkTimes = 10;			
 				pLed->BlinkingLedState = RTW_LED_ON;
 				_set_timer(&(pLed->BlinkTimer), LED_BLINK_LINK_INTERVAL_ALPHA);
 			}
 			else
 			{
-				if( pLed->bLedOn )
-					pLed->BlinkingLedState = RTW_LED_OFF;
-				else
+				if( pLed->bLedOn )			
+					pLed->BlinkingLedState = RTW_LED_OFF;			
+				else			
 					pLed->BlinkingLedState = RTW_LED_ON;
 
 				_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
 			}
 			break;
 
-
+					
 		default:
 			break;
 	}
@@ -1144,12 +1146,12 @@
 	u8				bStopBlinking = _FALSE;
 
 	// Change LED according to BlinkingLedState specified.
-	if( pLed->BlinkingLedState == RTW_LED_ON )
+	if( pLed->BlinkingLedState == RTW_LED_ON ) 
 	{
 		SwLedOn(padapter, pLed);
 		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
 	}
-	else
+	else 
 	{
 		SwLedOff(padapter, pLed);
 		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
@@ -1163,19 +1165,19 @@
 			{
 				bStopBlinking = _TRUE;
 			}
-
+			
 			if(bStopBlinking)
 			{
 				if( padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
 				{
 					pLed->CurrLedState = RTW_LED_OFF;
-					pLed->BlinkingLedState = RTW_LED_OFF;
-					if(pLed->bLedOn)
+					pLed->BlinkingLedState = RTW_LED_OFF; 									
+					if(pLed->bLedOn)				
 						SwLedOff(padapter, pLed);
 				}
-				else
+				else 
 				{		pLed->CurrLedState = RTW_LED_ON;
-						pLed->BlinkingLedState = RTW_LED_ON;
+						pLed->BlinkingLedState = RTW_LED_ON;					
 						if(!pLed->bLedOn)
 							_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
 				}
@@ -1191,7 +1193,7 @@
 				else
 				{
 					if( pLed->bLedOn )
-						pLed->BlinkingLedState = RTW_LED_OFF;
+						pLed->BlinkingLedState = RTW_LED_OFF; 
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
 					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
@@ -1199,32 +1201,32 @@
 			}
 			break;
 
-
+	
 		case LED_TXRX_BLINK:
 			pLed->BlinkTimes--;
 			if( pLed->BlinkTimes == 0 )
 			{
 				bStopBlinking = _TRUE;
 			}
-
+			
 			if(bStopBlinking)
 			{
 				if( padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
 				{
 					pLed->CurrLedState = RTW_LED_OFF;
-					pLed->BlinkingLedState = RTW_LED_OFF;
+					pLed->BlinkingLedState = RTW_LED_OFF; 									
 					if(pLed->bLedOn)
 						SwLedOff(padapter, pLed);
 				}
 				else
 				{
 					pLed->CurrLedState = RTW_LED_ON;
-					pLed->BlinkingLedState = RTW_LED_ON;
+					pLed->BlinkingLedState = RTW_LED_ON; 					
 					if(!pLed->bLedOn)
 						_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
 				}
 
-				pLed->bLedBlinkInProgress = _FALSE;
+				pLed->bLedBlinkInProgress = _FALSE;	
 			}
 			else
 			{
@@ -1235,14 +1237,14 @@
 				else
 				{
 					 if( pLed->bLedOn )
-						pLed->BlinkingLedState = RTW_LED_OFF;
+						pLed->BlinkingLedState = RTW_LED_OFF; 
 					else
 						pLed->BlinkingLedState = RTW_LED_ON;
 					_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
 				}
 			}
 			break;
-
+					
 		default:
 			break;
 	}
@@ -1262,12 +1264,12 @@
 	u8				bStopBlinking = _FALSE;
 
 	// Change LED according to BlinkingLedState specified.
-	if( pLed->BlinkingLedState == RTW_LED_ON )
+	if( pLed->BlinkingLedState == RTW_LED_ON ) 
 	{
 		SwLedOn(padapter, pLed);
 		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
 	}
-	else
+	else 
 	{
 		SwLedOff(padapter, pLed);
 		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
@@ -1279,20 +1281,23 @@
 
 //
 //	Description:
-//		Callback function of LED BlinkTimer,
+//		Callback function of LED BlinkTimer, 
 //		it just schedules to corresponding BlinkWorkItem.
 //
-static void
-BlinkTimerCallback(
-	unsigned long data
-	)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+void BlinkTimerCallback(void * data)
+{
+        PLED_871x         pLed = (PLED_871x)data;
+#else
+void BlinkTimerCallback(struct timer_list *t)
 {
-	PLED_871x	 pLed = (PLED_871x)data;
+        PLED_871x         pLed = from_timer(pLed, t, BlinkTimer);
+#endif
 	_adapter		*padapter = pLed->padapter;
 
 	//DBG_871X("%s\n", __FUNCTION__);
 
-	if( (padapter->bSurpriseRemoved == _TRUE) || ( padapter->bDriverStopped == _TRUE))
+	if( (padapter->bSurpriseRemoved == _TRUE) || ( padapter->bDriverStopped == _TRUE))	
 	{
 		//DBG_871X("%s bSurpriseRemoved:%d, bDriverStopped:%d\n", __FUNCTION__, padapter->bSurpriseRemoved, padapter->bDriverStopped);
 		return;
@@ -1317,7 +1322,7 @@ void BlinkHandler(PLED_871x	 pLed)
 
 	//DBG_871X("%s (%s:%d)\n",__FUNCTION__, current->comm, current->pid);
 
-	if( (padapter->bSurpriseRemoved == _TRUE) || ( padapter->bDriverStopped == _TRUE))
+	if( (padapter->bSurpriseRemoved == _TRUE) || ( padapter->bDriverStopped == _TRUE))	
 	{
 		//DBG_871X("%s bSurpriseRemoved:%d, bDriverStopped:%d\n", __FUNCTION__, padapter->bSurpriseRemoved, padapter->bDriverStopped);
 		return;
@@ -1328,22 +1333,22 @@ void BlinkHandler(PLED_871x	 pLed)
 		case SW_LED_MODE0:
 			SwLedBlink(pLed);
 			break;
-
+		
 		case SW_LED_MODE1:
 			SwLedBlink1(pLed);
 			break;
-
+		
 		case SW_LED_MODE2:
 			SwLedBlink2(pLed);
 			break;
-
+			
 		case SW_LED_MODE3:
 			SwLedBlink3(pLed);
 			break;
 
 		case SW_LED_MODE4:
 			SwLedBlink4(pLed);
-			break;
+			break;			
 
 		case SW_LED_MODE5:
 			SwLedBlink5(pLed);
@@ -1378,7 +1383,7 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 //================================================================================
 
 //
-//	Description:
+//	Description:	
 //		Implement each led action for SW_LED_MODE0.
 //		This is default strategy.
 //
@@ -1404,7 +1409,7 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 			pLed->BlinkTimes = 2;
 
 			if( pLed->bLedOn )
-				pLed->BlinkingLedState = RTW_LED_OFF;
+				pLed->BlinkingLedState = RTW_LED_OFF; 
 			else
 				pLed->BlinkingLedState = RTW_LED_ON;
 			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
@@ -1420,7 +1425,7 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 			pLed->BlinkTimes = 24;
 
 			if( pLed->bLedOn )
-				pLed->BlinkingLedState = RTW_LED_OFF;
+				pLed->BlinkingLedState = RTW_LED_OFF; 
 			else
 				pLed->BlinkingLedState = RTW_LED_ON;
 			_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
@@ -1428,9 +1433,9 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 		else
 		{
 			pLed->CurrLedState = LED_BLINK_StartToBlink;
-		}
+		}	
 		break;
-
+		
 	case LED_CTL_LINK:
 		pLed->CurrLedState = RTW_LED_ON;
 		if( pLed->bLedBlinkInProgress == _FALSE )
@@ -1446,7 +1451,7 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 			SwLedOff(padapter, pLed);
 		}
 		break;
-
+	
 	case LED_CTL_POWER_OFF:
 		pLed->CurrLedState = RTW_LED_OFF;
 		if(pLed->bLedBlinkInProgress)
@@ -1486,14 +1491,14 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 			pLed->bLedBlinkInProgress = _FALSE;
 		}
 		break;
-
+		
 
 	default:
 		break;
 	}
-
+	
 	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Led %d\n", pLed->CurrLedState));
-
+	
 }
 
  //ALPHA, added by chiyoko, 20090106
@@ -1510,11 +1515,11 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 
 	if(pHalData->EEPROMCustomerID == RT_CID_819x_CAMEO)
 		pLed = &(ledpriv->SwLed1);
-
+	
 	switch(LedAction)
-	{
+	{		
 		case LED_CTL_POWER_ON:
-		case LED_CTL_START_TO_LINK:
+		case LED_CTL_START_TO_LINK:	
 		case LED_CTL_NO_LINK:
 			if( pLed->bLedNoLinkBlinkInProgress == _FALSE )
 			{
@@ -1527,21 +1532,21 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedLinkBlinkInProgress = _FALSE;
 				}
-				if(pLed->bLedBlinkInProgress ==_TRUE)
-				{
+	 			if(pLed->bLedBlinkInProgress ==_TRUE)
+				{	
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedBlinkInProgress = _FALSE;
-				}
-
+	 			}
+				
 				pLed->bLedNoLinkBlinkInProgress = _TRUE;
 				pLed->CurrLedState = LED_BLINK_SLOWLY;
 				if( pLed->bLedOn )
-					pLed->BlinkingLedState = RTW_LED_OFF;
+					pLed->BlinkingLedState = RTW_LED_OFF; 
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
 				_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
 			}
-			break;
+			break;		
 
 		case LED_CTL_LINK:
 			if( pLed->bLedLinkBlinkInProgress == _FALSE )
@@ -1556,14 +1561,14 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 					pLed->bLedNoLinkBlinkInProgress = _FALSE;
 				}
 				if(pLed->bLedBlinkInProgress ==_TRUE)
-				{
+				{	
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedBlinkInProgress = _FALSE;
-				}
+	 			}
 				pLed->bLedLinkBlinkInProgress = _TRUE;
 				pLed->CurrLedState = LED_BLINK_NORMAL;
 				if( pLed->bLedOn )
-					pLed->BlinkingLedState = RTW_LED_OFF;
+					pLed->BlinkingLedState = RTW_LED_OFF; 
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
 				_set_timer(&(pLed->BlinkTimer), LED_BLINK_LINK_INTERVAL_ALPHA);
@@ -1572,13 +1577,13 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 
 		case LED_CTL_SITE_SURVEY:
 			 if((pmlmepriv->LinkDetectInfo.bBusyTraffic) && (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE))
-				;
+			 	;
 			 else if(pLed->bLedScanBlinkInProgress ==_FALSE)
 			 {
-				if(IS_LED_WPS_BLINKING(pLed))
+			 	if(IS_LED_WPS_BLINKING(pLed))
 					return;
-
-				if(pLed->bLedNoLinkBlinkInProgress == _TRUE)
+				
+	  			if(pLed->bLedNoLinkBlinkInProgress == _TRUE)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedNoLinkBlinkInProgress = _FALSE;
@@ -1588,7 +1593,7 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					 pLed->bLedLinkBlinkInProgress = _FALSE;
 				}
-				if(pLed->bLedBlinkInProgress ==_TRUE)
+	 			if(pLed->bLedBlinkInProgress ==_TRUE)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedBlinkInProgress = _FALSE;
@@ -1597,13 +1602,13 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 				pLed->CurrLedState = LED_SCAN_BLINK;
 				pLed->BlinkTimes = 24;
 				if( pLed->bLedOn )
-					pLed->BlinkingLedState = RTW_LED_OFF;
+					pLed->BlinkingLedState = RTW_LED_OFF; 
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
 				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
 			 }
 			break;
-
+		
 		case LED_CTL_TX:
 		case LED_CTL_RX:
 			if(pLed->bLedBlinkInProgress ==_FALSE)
@@ -1626,7 +1631,7 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 				pLed->CurrLedState = LED_TXRX_BLINK;
 				pLed->BlinkTimes = 2;
 				if( pLed->bLedOn )
-					pLed->BlinkingLedState = RTW_LED_OFF;
+					pLed->BlinkingLedState = RTW_LED_OFF; 
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
 				_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
@@ -1656,18 +1661,18 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedScanBlinkInProgress = _FALSE;
-				}
+				}				
 				pLed->bLedWPSBlinkInProgress = _TRUE;
 				pLed->CurrLedState = LED_BLINK_WPS;
 				if( pLed->bLedOn )
-					pLed->BlinkingLedState = RTW_LED_OFF;
+					pLed->BlinkingLedState = RTW_LED_OFF; 
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
 				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
 			 }
 			break;
 
-
+		
 		case LED_CTL_STOP_WPS:
 			if(pLed->bLedNoLinkBlinkInProgress == _TRUE)
 			{
@@ -1688,7 +1693,7 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedScanBlinkInProgress = _FALSE;
-			}
+			}			
 			if(pLed->bLedWPSBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
@@ -1697,7 +1702,7 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 			{
 				pLed->bLedWPSBlinkInProgress = _TRUE;
 			}
-
+			
 			pLed->CurrLedState = LED_BLINK_WPS_STOP;
 			if(pLed->bLedOn)
 			{
@@ -1708,15 +1713,15 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 			{
 				pLed->BlinkingLedState = RTW_LED_ON;
 				_set_timer(&(pLed->BlinkTimer), 0);
-			}
-			break;
+			}					
+			break;		
 
-		case LED_CTL_STOP_WPS_FAIL:
+		case LED_CTL_STOP_WPS_FAIL:			
 			if(pLed->bLedWPSBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedWPSBlinkInProgress = _FALSE;
-			}
+				pLed->bLedWPSBlinkInProgress = _FALSE;				
+			}			
 
 			pLed->bLedNoLinkBlinkInProgress = _TRUE;
 			pLed->CurrLedState = LED_BLINK_SLOWLY;
@@ -1725,11 +1730,11 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 			else
 				pLed->BlinkingLedState = RTW_LED_ON;
 			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
-			break;
+			break;				
 
 		case LED_CTL_POWER_OFF:
 			pLed->CurrLedState = RTW_LED_OFF;
-			pLed->BlinkingLedState = RTW_LED_OFF;
+			pLed->BlinkingLedState = RTW_LED_OFF; 
 			if( pLed->bLedNoLinkBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
@@ -1754,11 +1759,11 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedScanBlinkInProgress = _FALSE;
-			}
+			}			
 
 			SwLedOff(padapter, pLed);
 			break;
-
+			
 		default:
 			break;
 
@@ -1777,18 +1782,18 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 	struct led_priv	*ledpriv = &(padapter->ledpriv);
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 	PLED_871x 		pLed = &(ledpriv->SwLed0);
-
+	
 	switch(LedAction)
-	{
+	{		
 		case LED_CTL_SITE_SURVEY:
 			 if(pmlmepriv->LinkDetectInfo.bBusyTraffic)
-				;
+			 	;		 
 			 else if(pLed->bLedScanBlinkInProgress ==_FALSE)
 			 {
-				if(IS_LED_WPS_BLINKING(pLed))
+			 	if(IS_LED_WPS_BLINKING(pLed))
 					return;
-
-				if(pLed->bLedBlinkInProgress ==_TRUE)
+			 
+	 			if(pLed->bLedBlinkInProgress ==_TRUE)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedBlinkInProgress = _FALSE;
@@ -1797,18 +1802,18 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 				pLed->CurrLedState = LED_SCAN_BLINK;
 				pLed->BlinkTimes = 24;
 				if( pLed->bLedOn )
-					pLed->BlinkingLedState = RTW_LED_OFF;
+					pLed->BlinkingLedState = RTW_LED_OFF; 
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
 				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
 			 }
 			break;
-
+		
 		case LED_CTL_TX:
 		case LED_CTL_RX:
-			if((pLed->bLedBlinkInProgress ==_FALSE) && (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE))
-			{
-				if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+	 		if((pLed->bLedBlinkInProgress ==_FALSE) && (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE))
+	  		{
+	  		  	if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
 				{
 					return;
 				}
@@ -1817,7 +1822,7 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 				pLed->CurrLedState = LED_TXRX_BLINK;
 				pLed->BlinkTimes = 2;
 				if( pLed->bLedOn )
-					pLed->BlinkingLedState = RTW_LED_OFF;
+					pLed->BlinkingLedState = RTW_LED_OFF; 
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
 				_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
@@ -1836,13 +1841,13 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedScanBlinkInProgress = _FALSE;
-			}
+			}			
 
 			_set_timer(&(pLed->BlinkTimer), 0);
-			break;
+			break;			
 
 		case LED_CTL_START_WPS: //wait until xinpin finish
-		case LED_CTL_START_WPS_BOTTON:
+		case LED_CTL_START_WPS_BOTTON:		
 			if(pLed->bLedWPSBlinkInProgress ==_FALSE)
 			{
 				if(pLed->bLedBlinkInProgress ==_TRUE)
@@ -1854,14 +1859,14 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedScanBlinkInProgress = _FALSE;
-				}
+				}				
 				pLed->bLedWPSBlinkInProgress = _TRUE;
 				pLed->CurrLedState = RTW_LED_ON;
 				pLed->BlinkingLedState = RTW_LED_ON;
 				_set_timer(&(pLed->BlinkTimer), 0);
-			 }
+			 }			
 			break;
-
+			
 		case LED_CTL_STOP_WPS:
 			pLed->bLedWPSBlinkInProgress = _FALSE;
 			if(padapter->pwrctrlpriv.rf_pwrstate != rf_on)
@@ -1876,23 +1881,23 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 				RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
 			}
 			break;
-
-		case LED_CTL_STOP_WPS_FAIL:
-			pLed->bLedWPSBlinkInProgress = _FALSE;
+			
+		case LED_CTL_STOP_WPS_FAIL:			
+			pLed->bLedWPSBlinkInProgress = _FALSE;			
 			if(padapter->pwrctrlpriv.rf_pwrstate != rf_on)
 			{
 				SwLedOff(padapter, pLed);
 			}
-			else
+			else 
 			{
 				pLed->CurrLedState = RTW_LED_OFF;
 				pLed->BlinkingLedState = RTW_LED_OFF;
 				_set_timer(&(pLed->BlinkTimer), 0);
-				RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
-			}
-			break;
+				RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState)); 				
+			}	
+			break;				
 
-		case LED_CTL_START_TO_LINK:
+		case LED_CTL_START_TO_LINK: 
 		case LED_CTL_NO_LINK:
 			if(!IS_LED_BLINKING(pLed))
 			{
@@ -1901,7 +1906,7 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 				_set_timer(&(pLed->BlinkTimer), 0);
 			}
 			break;
-
+			
 		case LED_CTL_POWER_OFF:
 			pLed->CurrLedState = RTW_LED_OFF;
 			pLed->BlinkingLedState = RTW_LED_OFF;
@@ -1914,7 +1919,7 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedScanBlinkInProgress = _FALSE;
-			}
+			}			
 			if( pLed->bLedWPSBlinkInProgress )
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
@@ -1923,7 +1928,7 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 
 			_set_timer(&(pLed->BlinkTimer), 0);
 			break;
-
+			
 		default:
 			break;
 
@@ -1942,12 +1947,12 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 	struct led_priv	*ledpriv = &(padapter->ledpriv);
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 	PLED_871x		pLed = &(ledpriv->SwLed0);
-
+	
 	switch(LedAction)
-	{
+	{		
 		case LED_CTL_SITE_SURVEY:
 			if(pmlmepriv->LinkDetectInfo.bBusyTraffic)
-				;
+				;		 
 			else if(pLed->bLedScanBlinkInProgress ==_FALSE)
 			{
 				if(IS_LED_WPS_BLINKING(pLed))
@@ -1962,18 +1967,18 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 				pLed->CurrLedState = LED_SCAN_BLINK;
 				pLed->BlinkTimes = 24;
 				if( pLed->bLedOn )
-					pLed->BlinkingLedState = RTW_LED_OFF;
+					pLed->BlinkingLedState = RTW_LED_OFF; 
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
 				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
 			}
 			break;
-
+		
 		case LED_CTL_TX:
 		case LED_CTL_RX:
-			if((pLed->bLedBlinkInProgress ==_FALSE) && (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE))
-			{
-				if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+	 		if((pLed->bLedBlinkInProgress ==_FALSE) && (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE))
+	  		{
+	  		  	if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
 				{
 					return;
 				}
@@ -1982,7 +1987,7 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 				pLed->CurrLedState = LED_TXRX_BLINK;
 				pLed->BlinkTimes = 2;
 				if( pLed->bLedOn )
-					pLed->BlinkingLedState = RTW_LED_OFF;
+					pLed->BlinkingLedState = RTW_LED_OFF; 
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
 				_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
@@ -1992,7 +1997,7 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 		case LED_CTL_LINK:
 			if(IS_LED_WPS_BLINKING(pLed))
 				return;
-
+			
 			pLed->CurrLedState = RTW_LED_ON;
 			pLed->BlinkingLedState = RTW_LED_ON;
 			if( pLed->bLedBlinkInProgress)
@@ -2004,13 +2009,13 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedScanBlinkInProgress = _FALSE;
-			}
+			}			
 
 			_set_timer(&(pLed->BlinkTimer), 0);
-			break;
+			break;			
 
 		case LED_CTL_START_WPS: //wait until xinpin finish
-		case LED_CTL_START_WPS_BOTTON:
+		case LED_CTL_START_WPS_BOTTON:		
 			if(pLed->bLedWPSBlinkInProgress ==_FALSE)
 			{
 				if(pLed->bLedBlinkInProgress ==_TRUE)
@@ -2022,28 +2027,28 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedScanBlinkInProgress = _FALSE;
-				}
+				}				
 				pLed->bLedWPSBlinkInProgress = _TRUE;
 				pLed->CurrLedState = LED_BLINK_WPS;
 				if( pLed->bLedOn )
-					pLed->BlinkingLedState = RTW_LED_OFF;
+					pLed->BlinkingLedState = RTW_LED_OFF; 
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
 				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
-			}
+			}			
 			break;
-
-		case LED_CTL_STOP_WPS:
+			
+		case LED_CTL_STOP_WPS:			
 			if(pLed->bLedWPSBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedWPSBlinkInProgress = _FALSE;
-			}
+				pLed->bLedWPSBlinkInProgress = _FALSE;				
+			}						
 			else
 			{
 				pLed->bLedWPSBlinkInProgress = _TRUE;
 			}
-
+				
 			pLed->CurrLedState = LED_BLINK_WPS_STOP;
 			if(pLed->bLedOn)
 			{
@@ -2054,23 +2059,23 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 			{
 				pLed->BlinkingLedState = RTW_LED_ON;
 				_set_timer(&(pLed->BlinkTimer), 0);
-			}
+			}					
 
 			break;
-
-		case LED_CTL_STOP_WPS_FAIL:
+			
+		case LED_CTL_STOP_WPS_FAIL:			
 			if(pLed->bLedWPSBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedWPSBlinkInProgress = _FALSE;
-			}
+				pLed->bLedWPSBlinkInProgress = _FALSE;				
+			}			
 
 			pLed->CurrLedState = RTW_LED_OFF;
 			pLed->BlinkingLedState = RTW_LED_OFF;
 			_set_timer(&(pLed->BlinkTimer), 0);
-			break;
+			break;				
 
-		case LED_CTL_START_TO_LINK:
+		case LED_CTL_START_TO_LINK: 
 		case LED_CTL_NO_LINK:
 			if(!IS_LED_BLINKING(pLed))
 			{
@@ -2079,7 +2084,7 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 				_set_timer(&(pLed->BlinkTimer), 0);
 			}
 			break;
-
+			
 		case LED_CTL_POWER_OFF:
 			pLed->CurrLedState = RTW_LED_OFF;
 			pLed->BlinkingLedState = RTW_LED_OFF;
@@ -2092,7 +2097,7 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedScanBlinkInProgress = _FALSE;
-			}
+			}			
 			if( pLed->bLedWPSBlinkInProgress )
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
@@ -2101,7 +2106,7 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 
 			_set_timer(&(pLed->BlinkTimer), 0);
 			break;
-
+			
 		default:
 			break;
 
@@ -2122,39 +2127,39 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 	PLED_871x		pLed = &(ledpriv->SwLed0);
 	PLED_871x		pLed1 = &(ledpriv->SwLed1);
-
+	
 	switch(LedAction)
-	{
-		case LED_CTL_START_TO_LINK:
+	{		
+		case LED_CTL_START_TO_LINK:	
 			if(pLed1->bLedWPSBlinkInProgress)
 			{
 				pLed1->bLedWPSBlinkInProgress = _FALSE;
 				_cancel_timer_ex(&(pLed1->BlinkTimer));
-
+		
 				pLed1->BlinkingLedState = RTW_LED_OFF;
 				pLed1->CurrLedState = RTW_LED_OFF;
 
 				if(pLed1->bLedOn)
 					_set_timer(&(pLed->BlinkTimer), 0);
 			}
-
+				
 			if( pLed->bLedStartToLinkBlinkInProgress == _FALSE )
 			{
 				if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
 				{
 					return;
 				}
-				if(pLed->bLedBlinkInProgress ==_TRUE)
+	 			if(pLed->bLedBlinkInProgress ==_TRUE)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedBlinkInProgress = _FALSE;
-				}
-				if(pLed->bLedNoLinkBlinkInProgress ==_TRUE)
-				{
+	 			}
+	 			if(pLed->bLedNoLinkBlinkInProgress ==_TRUE)
+				{	
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedNoLinkBlinkInProgress = _FALSE;
-				}
-
+	 			}				
+				
 				pLed->bLedStartToLinkBlinkInProgress = _TRUE;
 				pLed->CurrLedState = LED_BLINK_StartToBlink;
 				if( pLed->bLedOn )
@@ -2168,9 +2173,9 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 					_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
 				}
 			}
-			break;
+			break;		
 
-		case LED_CTL_LINK:
+		case LED_CTL_LINK:			
 		case LED_CTL_NO_LINK:
 			//LED1 settings
 			if(LedAction == LED_CTL_LINK)
@@ -2179,40 +2184,40 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 				{
 					pLed1->bLedWPSBlinkInProgress = _FALSE;
 					_cancel_timer_ex(&(pLed1->BlinkTimer));
-
+			
 					pLed1->BlinkingLedState = RTW_LED_OFF;
 					pLed1->CurrLedState = RTW_LED_OFF;
 
 					if(pLed1->bLedOn)
 						_set_timer(&(pLed->BlinkTimer), 0);
-				}
+				}				
 			}
-
+			
 			if( pLed->bLedNoLinkBlinkInProgress == _FALSE )
 			{
 				if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
 				{
 					return;
 				}
-				if(pLed->bLedBlinkInProgress ==_TRUE)
+	 			if(pLed->bLedBlinkInProgress ==_TRUE)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedBlinkInProgress = _FALSE;
-				}
-
+	 			}
+				
 				pLed->bLedNoLinkBlinkInProgress = _TRUE;
 				pLed->CurrLedState = LED_BLINK_SLOWLY;
 				if( pLed->bLedOn )
-					pLed->BlinkingLedState = RTW_LED_OFF;
+					pLed->BlinkingLedState = RTW_LED_OFF; 
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
 				_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
 			}
-			break;
+			break;		
 
 		case LED_CTL_SITE_SURVEY:
 			if((pmlmepriv->LinkDetectInfo.bBusyTraffic) && (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE))
-				;
+				;		 
 			else if(pLed->bLedScanBlinkInProgress ==_FALSE)
 			{
 				if(IS_LED_WPS_BLINKING(pLed))
@@ -2232,22 +2237,22 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 				pLed->CurrLedState = LED_SCAN_BLINK;
 				pLed->BlinkTimes = 24;
 				if( pLed->bLedOn )
-					pLed->BlinkingLedState = RTW_LED_OFF;
+					pLed->BlinkingLedState = RTW_LED_OFF; 
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
 				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
 			}
 			break;
-
+		
 		case LED_CTL_TX:
 		case LED_CTL_RX:
-			if(pLed->bLedBlinkInProgress ==_FALSE)
-			{
-				if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+	 		if(pLed->bLedBlinkInProgress ==_FALSE)
+	  		{
+	  		  	if(pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
 				{
 					return;
 				}
-				if(pLed->bLedNoLinkBlinkInProgress == _TRUE)
+	  		  	if(pLed->bLedNoLinkBlinkInProgress == _TRUE)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedNoLinkBlinkInProgress = _FALSE;
@@ -2256,7 +2261,7 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 				pLed->CurrLedState = LED_TXRX_BLINK;
 				pLed->BlinkTimes = 2;
 				if( pLed->bLedOn )
-					pLed->BlinkingLedState = RTW_LED_OFF;
+					pLed->BlinkingLedState = RTW_LED_OFF; 
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
 				_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
@@ -2269,14 +2274,14 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 			{
 				pLed1->bLedWPSBlinkInProgress = _FALSE;
 				_cancel_timer_ex(&(pLed1->BlinkTimer));
-
+			
 				pLed1->BlinkingLedState = RTW_LED_OFF;
 				pLed1->CurrLedState = RTW_LED_OFF;
 
 				if(pLed1->bLedOn)
 					_set_timer(&(pLed->BlinkTimer), 0);
 			}
-
+				
 			if(pLed->bLedWPSBlinkInProgress ==_FALSE)
 			{
 				if(pLed->bLedNoLinkBlinkInProgress == _TRUE)
@@ -2293,7 +2298,7 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
 					pLed->bLedScanBlinkInProgress = _FALSE;
-				}
+				}				
 				pLed->bLedWPSBlinkInProgress = _TRUE;
 				pLed->CurrLedState = LED_BLINK_WPS;
 				if( pLed->bLedOn )
@@ -2308,35 +2313,35 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 				}
 			}
 			break;
-
-		case LED_CTL_STOP_WPS:	//WPS connect success
+		
+		case LED_CTL_STOP_WPS:	//WPS connect success		
 			if(pLed->bLedWPSBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedWPSBlinkInProgress = _FALSE;
+				pLed->bLedWPSBlinkInProgress = _FALSE;								
 			}
 
 			pLed->bLedNoLinkBlinkInProgress = _TRUE;
 			pLed->CurrLedState = LED_BLINK_SLOWLY;
 			if( pLed->bLedOn )
-				pLed->BlinkingLedState = RTW_LED_OFF;
+				pLed->BlinkingLedState = RTW_LED_OFF; 
 			else
 				pLed->BlinkingLedState = RTW_LED_ON;
 			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
 
-			break;
+			break;		
 
-		case LED_CTL_STOP_WPS_FAIL:		//WPS authentication fail
+		case LED_CTL_STOP_WPS_FAIL:		//WPS authentication fail			
 			if(pLed->bLedWPSBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedWPSBlinkInProgress = _FALSE;
-			}
+				pLed->bLedWPSBlinkInProgress = _FALSE;				
+			}			
 
 			pLed->bLedNoLinkBlinkInProgress = _TRUE;
 			pLed->CurrLedState = LED_BLINK_SLOWLY;
 			if( pLed->bLedOn )
-				pLed->BlinkingLedState = RTW_LED_OFF;
+				pLed->BlinkingLedState = RTW_LED_OFF; 
 			else
 				pLed->BlinkingLedState = RTW_LED_ON;
 			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
@@ -2344,29 +2349,29 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 			//LED1 settings
 			if(pLed1->bLedWPSBlinkInProgress)
 				_cancel_timer_ex(&(pLed1->BlinkTimer));
-			else
-				pLed1->bLedWPSBlinkInProgress = _TRUE;
+			else	
+				pLed1->bLedWPSBlinkInProgress = _TRUE;				
 
 			pLed1->CurrLedState = LED_BLINK_WPS_STOP;
 			if( pLed1->bLedOn )
-				pLed1->BlinkingLedState = RTW_LED_OFF;
+				pLed1->BlinkingLedState = RTW_LED_OFF; 
 			else
 				pLed1->BlinkingLedState = RTW_LED_ON;
 			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
 
-			break;
+			break;				
 
-		case LED_CTL_STOP_WPS_FAIL_OVERLAP:	//WPS session overlap
+		case LED_CTL_STOP_WPS_FAIL_OVERLAP:	//WPS session overlap		
 			if(pLed->bLedWPSBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
-				pLed->bLedWPSBlinkInProgress = _FALSE;
+				pLed->bLedWPSBlinkInProgress = _FALSE;								
 			}
-
+			
 			pLed->bLedNoLinkBlinkInProgress = _TRUE;
 			pLed->CurrLedState = LED_BLINK_SLOWLY;
 			if( pLed->bLedOn )
-				pLed->BlinkingLedState = RTW_LED_OFF;
+				pLed->BlinkingLedState = RTW_LED_OFF; 
 			else
 				pLed->BlinkingLedState = RTW_LED_ON;
 			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
@@ -2374,23 +2379,23 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 			//LED1 settings
 			if(pLed1->bLedWPSBlinkInProgress)
 				_cancel_timer_ex(&(pLed1->BlinkTimer));
-			else
-				pLed1->bLedWPSBlinkInProgress = _TRUE;
+			else	
+				pLed1->bLedWPSBlinkInProgress = _TRUE;				
 
 			pLed1->CurrLedState = LED_BLINK_WPS_STOP_OVERLAP;
 			pLed1->BlinkTimes = 10;
 			if( pLed1->bLedOn )
-				pLed1->BlinkingLedState = RTW_LED_OFF;
+				pLed1->BlinkingLedState = RTW_LED_OFF; 
 			else
 				pLed1->BlinkingLedState = RTW_LED_ON;
 			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
-
+			
 			break;
 
 		case LED_CTL_POWER_OFF:
 			pLed->CurrLedState = RTW_LED_OFF;
-			pLed->BlinkingLedState = RTW_LED_OFF;
-
+			pLed->BlinkingLedState = RTW_LED_OFF; 
+			
 			if( pLed->bLedNoLinkBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
@@ -2415,12 +2420,12 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedScanBlinkInProgress = _FALSE;
-			}
+			}	
 			if( pLed->bLedStartToLinkBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedStartToLinkBlinkInProgress = _FALSE;
-			}
+			}			
 
 			if( pLed1->bLedWPSBlinkInProgress )
 			{
@@ -2428,11 +2433,11 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 				pLed1->bLedWPSBlinkInProgress = _FALSE;
 			}
 
-			pLed1->BlinkingLedState = LED_UNKNOWN;
+			pLed1->BlinkingLedState = LED_UNKNOWN;				
 			SwLedOff(padapter, pLed);
-			SwLedOff(padapter, pLed1);
+			SwLedOff(padapter, pLed1);			
 			break;
-
+			
 		default:
 			break;
 
@@ -2457,23 +2462,23 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 
 	if(pHalData->EEPROMCustomerID == RT_CID_819x_CAMEO)
 		pLed = &(ledpriv->SwLed1);
-
+	
 	switch(LedAction)
-	{
+	{		
 		case LED_CTL_POWER_ON:
 		case LED_CTL_NO_LINK:
 		case LED_CTL_LINK: 	//solid blue
 			pLed->CurrLedState = RTW_LED_ON;
-			pLed->BlinkingLedState = RTW_LED_ON;
+			pLed->BlinkingLedState = RTW_LED_ON; 
 
 			_set_timer(&(pLed->BlinkTimer), 0);
 			break;
 
 		case LED_CTL_SITE_SURVEY:
 			if((pmlmepriv->LinkDetectInfo.bBusyTraffic) && (check_fwstate(pmlmepriv, _FW_LINKED)== _TRUE))
-				;
+				;		 
 			else if(pLed->bLedScanBlinkInProgress ==_FALSE)
-			{
+			{				
 				if(pLed->bLedBlinkInProgress ==_TRUE)
 				{
 					_cancel_timer_ex(&(pLed->BlinkTimer));
@@ -2483,45 +2488,45 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 				pLed->CurrLedState = LED_SCAN_BLINK;
 				pLed->BlinkTimes = 24;
 				if( pLed->bLedOn )
-					pLed->BlinkingLedState = RTW_LED_OFF;
+					pLed->BlinkingLedState = RTW_LED_OFF; 
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
 				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
 			}
 			break;
-
+		
 		case LED_CTL_TX:
 		case LED_CTL_RX:
-			if(pLed->bLedBlinkInProgress ==_FALSE)
-			{
-				if(pLed->CurrLedState == LED_SCAN_BLINK)
+	 		if(pLed->bLedBlinkInProgress ==_FALSE)
+	  		{
+	  		  	if(pLed->CurrLedState == LED_SCAN_BLINK)
 				{
 					return;
-				}
+				}			
 				pLed->bLedBlinkInProgress = _TRUE;
 				pLed->CurrLedState = LED_TXRX_BLINK;
 				pLed->BlinkTimes = 2;
 				if( pLed->bLedOn )
-					pLed->BlinkingLedState = RTW_LED_OFF;
+					pLed->BlinkingLedState = RTW_LED_OFF; 
 				else
 					pLed->BlinkingLedState = RTW_LED_ON;
 				_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
 			}
-			break;
+			break;				
 
 		case LED_CTL_POWER_OFF:
 			pLed->CurrLedState = RTW_LED_OFF;
-			pLed->BlinkingLedState = RTW_LED_OFF;
+			pLed->BlinkingLedState = RTW_LED_OFF; 
 
 			if( pLed->bLedBlinkInProgress)
 			{
 				_cancel_timer_ex(&(pLed->BlinkTimer));
 				pLed->bLedBlinkInProgress = _FALSE;
-			}
-
+			}			
+				
 			SwLedOff(padapter, pLed);
 			break;
-
+			
 		default:
 			break;
 
@@ -2540,7 +2545,7 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 	struct led_priv	*ledpriv = &(padapter->ledpriv);
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 	PLED_871x pLed0 = &(ledpriv->SwLed0);
-
+	
 	switch(LedAction)
 	{
 		case LED_CTL_POWER_ON:
@@ -2565,8 +2570,8 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 
 
 //
-//	Description:
-//		Dispatch LED action according to pHalData->LedStrategy.
+//	Description:	
+//		Dispatch LED action according to pHalData->LedStrategy. 
 //
 static void
 LedControl871x(
@@ -2576,8 +2581,8 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 {
 	struct led_priv	*ledpriv = &(padapter->ledpriv);
 
-       if( (padapter->bSurpriseRemoved == _TRUE) || ( padapter->bDriverStopped == _TRUE)
-		||(padapter->hw_init_completed == _FALSE) )
+       if( (padapter->bSurpriseRemoved == _TRUE) || ( padapter->bDriverStopped == _TRUE) 
+	   	||(padapter->hw_init_completed == _FALSE) )	
        {
              return;
        }
@@ -2594,15 +2599,15 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 
 	if( (padapter->pwrctrlpriv.rf_pwrstate != rf_on &&
 		padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS) &&
-		(LedAction == LED_CTL_TX || LedAction == LED_CTL_RX ||
-		 LedAction == LED_CTL_SITE_SURVEY ||
-		 LedAction == LED_CTL_LINK ||
+		(LedAction == LED_CTL_TX || LedAction == LED_CTL_RX || 
+		 LedAction == LED_CTL_SITE_SURVEY || 
+		 LedAction == LED_CTL_LINK || 
 		 LedAction == LED_CTL_NO_LINK ||
 		 LedAction == LED_CTL_POWER_ON) )
 	{
 		return;
 	}
-
+	
 	switch(ledpriv->LedStrategy)
 	{
 		case SW_LED_MODE0:
@@ -2614,15 +2619,15 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 			break;
 		case SW_LED_MODE2:
 			SwLedControlMode2(padapter, LedAction);
-			break;
+                	break;
 
 		case SW_LED_MODE3:
 			SwLedControlMode3(padapter, LedAction);
-			break;
+			break;	
 
 		case SW_LED_MODE4:
 			SwLedControlMode4(padapter, LedAction);
-			break;
+			break;			
 
 		case SW_LED_MODE5:
 			SwLedControlMode5(padapter, LedAction);
@@ -2635,7 +2640,7 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 		default:
 			break;
 	}
-
+	
 	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("LedStrategy:%d, LedAction %d\n", ledpriv->LedStrategy,LedAction));
 }
 
@@ -2672,3 +2677,4 @@ static void BlinkWorkItemCallback(struct work_struct *work)
 	DeInitLed871x( &(ledpriv->SwLed0) );
 	DeInitLed871x( &(ledpriv->SwLed1) );
 }
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/rtl8192cu_recv.c b/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/rtl8192cu_recv.c
old mode 100644
new mode 100755
index dd4383f..1119cf8
--- a/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/rtl8192cu_recv.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/rtl8192cu_recv.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -64,7 +64,7 @@ int	rtl8192cu_init_recv_priv(_adapter *padapter)
 	int	i, res = _SUCCESS;
 	struct recv_buf *precvbuf;
 
-#ifdef CONFIG_RECV_THREAD_MODE
+#ifdef CONFIG_RECV_THREAD_MODE	
 	_rtw_init_sema(&precvpriv->recv_sema, 0);//will be removed
 	_rtw_init_sema(&precvpriv->terminate_recvthread_sema, 0);//will be removed
 #endif
@@ -225,3 +225,5 @@ void rtl8192cu_free_recv_priv (_adapter *padapter)
 #endif
 
 }
+
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/rtl8192cu_xmit.c b/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/rtl8192cu_xmit.c
old mode 100644
new mode 100755
index c7bcae7..3a4137b
--- a/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/rtl8192cu_xmit.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/rtl8192cu_xmit.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -52,22 +52,22 @@ void	rtl8192cu_free_xmit_priv(_adapter *padapter)
 u32 rtw_get_ff_hwaddr(struct xmit_frame	*pxmitframe)
 {
 	u32 addr;
-	struct pkt_attrib *pattrib = &pxmitframe->attrib;
-
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;	
+	
 	switch(pattrib->qsel)
 	{
 		case 0:
 		case 3:
 			addr = BE_QUEUE_INX;
-			break;
+		 	break;
 		case 1:
 		case 2:
 			addr = BK_QUEUE_INX;
-			break;
+			break;				
 		case 4:
 		case 5:
 			addr = VI_QUEUE_INX;
-			break;
+			break;		
 		case 6:
 		case 7:
 			addr = VO_QUEUE_INX;
@@ -83,8 +83,8 @@ u32 rtw_get_ff_hwaddr(struct xmit_frame	*pxmitframe)
 			break;
 		default:
 			addr = BE_QUEUE_INX;
-			break;
-
+			break;		
+			
 	}
 
 	return addr;
@@ -94,7 +94,7 @@ u32 rtw_get_ff_hwaddr(struct xmit_frame	*pxmitframe)
 int urb_zero_packet_chk(_adapter *padapter, int sz)
 {
 	int blnSetTxDescOffset;
-	struct dvobj_priv	*pdvobj = adapter_to_dvobj(padapter);
+	struct dvobj_priv	*pdvobj = adapter_to_dvobj(padapter);	
 
 	if ( pdvobj->ishighspeed )
 	{
@@ -112,9 +112,9 @@ int urb_zero_packet_chk(_adapter *padapter, int sz)
 			blnSetTxDescOffset = 0;
 		}
 	}
-
+	
 	return blnSetTxDescOffset;
-
+	
 }
 
 void rtl8192cu_cal_txdesc_chksum(struct tx_desc	*ptxdesc)
@@ -126,12 +126,12 @@ void rtl8192cu_cal_txdesc_chksum(struct tx_desc	*ptxdesc)
 
 		//Clear first
 		ptxdesc->txdw7 &= cpu_to_le32(0xffff0000);
-
+	
 		for(index = 0 ; index < count ; index++){
 			checksum = checksum ^ le16_to_cpu(*(usPtr + index));
 		}
 
-		ptxdesc->txdw7 |= cpu_to_le32(0x0000ffff&checksum);
+		ptxdesc->txdw7 |= cpu_to_le32(0x0000ffff&checksum);	
 
 }
 
@@ -140,14 +140,14 @@ void fill_txdesc_sectype(struct pkt_attrib *pattrib, struct tx_desc *ptxdesc)
 	if ((pattrib->encrypt > 0) && !pattrib->bswenc)
 	{
 		switch (pattrib->encrypt)
-		{
+		{	
 			//SEC_TYPE
 			case _WEP40_:
 			case _WEP104_:
 					ptxdesc->txdw1 |= cpu_to_le32((0x01<<22)&0x00c00000);
-					break;
+					break;				
 			case _TKIP_:
-			case _TKIP_WTMIC_:
+			case _TKIP_WTMIC_:	
 					//ptxdesc->txdw1 |= cpu_to_le32((0x02<<22)&0x00c00000);
 					ptxdesc->txdw1 |= cpu_to_le32((0x01<<22)&0x00c00000);
 					break;
@@ -157,16 +157,16 @@ void fill_txdesc_sectype(struct pkt_attrib *pattrib, struct tx_desc *ptxdesc)
 			case _NO_PRIVACY_:
 			default:
 					break;
-
+		
 		}
-
+		
 	}
 
 }
 
 static void fill_txdesc_vcs(struct pkt_attrib *pattrib, u32 *pdw)
 {
-	//DBG_8192C("cvs_mode=%d\n", pattrib->vcs_mode);
+	//DBG_8192C("cvs_mode=%d\n", pattrib->vcs_mode);	
 
 	switch(pattrib->vcs_mode)
 	{
@@ -178,7 +178,7 @@ static void fill_txdesc_vcs(struct pkt_attrib *pattrib, u32 *pdw)
 			break;
 		case NONE_VCS:
 		default:
-			break;
+			break;		
 	}
 
 	if(pattrib->vcs_mode) {
@@ -225,7 +225,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz, u8 bag
 	int	pull=0;
 	uint	qsel;
 	_adapter			*padapter = pxmitframe->padapter;
-	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;		
 	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
 	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
@@ -251,7 +251,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz, u8 bag
 
 	if((pxmitframe->frame_tag&0x0f) == DATA_FRAMETAG)
 	{
-		//DBG_8192C("pxmitframe->frame_tag == DATA_FRAMETAG\n");
+		//DBG_8192C("pxmitframe->frame_tag == DATA_FRAMETAG\n");			
 
 		//offset 4
 		ptxdesc->txdw1 |= cpu_to_le32(pattrib->mac_id&0x1f);
@@ -267,7 +267,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz, u8 bag
 			ptxdesc->txdw1 |= cpu_to_le32(BIT(5));//AGG EN
 		else
 			ptxdesc->txdw1 |= cpu_to_le32(BIT(6));//AGG BK
-
+		
 		//offset 8
 
 
@@ -281,8 +281,8 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz, u8 bag
 
 		if ((pattrib->ether_type != 0x888e) && (pattrib->ether_type != 0x0806) && (pattrib->dhcp_pkt != 1))
 		{
-		//Non EAP & ARP & DHCP type data packet
-
+              	//Non EAP & ARP & DHCP type data packet
+              	
 			fill_txdesc_vcs(pattrib, &ptxdesc->txdw4);
 			fill_txdesc_phy(pattrib, &ptxdesc->txdw4);
 
@@ -293,10 +293,10 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz, u8 bag
 			//use REG_INIDATA_RATE_SEL value
 			ptxdesc->txdw5 |= cpu_to_le32(pdmpriv->INIDATA_RATE[pattrib->mac_id]);
 
-		if(0)//for driver dbg
+              	if(0)//for driver dbg
 			{
 				ptxdesc->txdw4 |= cpu_to_le32(BIT(8));//driver uses rate
-
+				
 				if(pattrib->ht_en)
 					ptxdesc->txdw5 |= cpu_to_le32(BIT(6));//SGI
 
@@ -311,15 +311,15 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz, u8 bag
 			// This will maybe make the handshake smooth.
 
 			ptxdesc->txdw1 |= cpu_to_le32(BIT(6));//AGG BK
-
-			ptxdesc->txdw4 |= cpu_to_le32(BIT(8));//driver uses rate
+			
+		   	ptxdesc->txdw4 |= cpu_to_le32(BIT(8));//driver uses rate
 
 			if (pmlmeinfo->preamble_mode == PREAMBLE_SHORT)
 				ptxdesc->txdw4 |= cpu_to_le32(BIT(24));// DATA_SHORT
 
 			ptxdesc->txdw5 |= cpu_to_le32(MRateToHwRate(pmlmeext->tx_rate));
 		}
-
+		
 		//offset 24
 #ifdef CONFIG_TCP_CSUM_OFFLOAD_TX
 		if ( pattrib->hw_tcp_csum == 1 ) {
@@ -332,19 +332,19 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz, u8 bag
 	}
 	else if((pxmitframe->frame_tag&0x0f)== MGNT_FRAMETAG)
 	{
-		//DBG_8192C("pxmitframe->frame_tag == MGNT_FRAMETAG\n");
-
-		//offset 4
+		//DBG_8192C("pxmitframe->frame_tag == MGNT_FRAMETAG\n");	
+		
+		//offset 4		
 		ptxdesc->txdw1 |= cpu_to_le32(pattrib->mac_id&0x1f);
-
+		
 		qsel = (uint)(pattrib->qsel&0x0000001f);
 		ptxdesc->txdw1 |= cpu_to_le32((qsel<<QSEL_SHT)&0x00001f00);
 
 		ptxdesc->txdw1 |= cpu_to_le32((pattrib->raid<< 16) & 0x000f0000);
-
+		
 		//fill_txdesc_sectype(pattrib, ptxdesc);
-
-		//offset 8
+		
+		//offset 8		
 #ifdef CONFIG_XMIT_ACK
 		//CCX-TXRPT ack for xmit mgmt frames.
 		if (pxmitframe->ack_report) {
@@ -357,10 +357,10 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz, u8 bag
 
 		//offset 12
 		ptxdesc->txdw3 |= cpu_to_le32((pattrib->seqnum<<16)&0xffff0000);
-
+		
 		//offset 16
 		ptxdesc->txdw4 |= cpu_to_le32(BIT(8));//driver uses rate
-
+		
 		//offset 20
 		ptxdesc->txdw5 |= cpu_to_le32(BIT(17));//retry limit enable
 		if(pattrib->retry_ctrl == _TRUE)
@@ -377,7 +377,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz, u8 bag
 			}
 			else
 #endif //CONFIG_P2P
-				ptxdesc->txdw5 |= cpu_to_le32(0x00180000);//retry limit = 6
+				ptxdesc->txdw5 |= cpu_to_le32(0x00180000);//retry limit = 6			
 		}
 		else
 			ptxdesc->txdw5 |= cpu_to_le32(0x00300000);//retry limit = 12
@@ -406,20 +406,20 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz, u8 bag
 	else
 	{
 		DBG_8192C("pxmitframe->frame_tag = %d\n", pxmitframe->frame_tag);
-
-		//offset 4
+		
+		//offset 4	
 		ptxdesc->txdw1 |= cpu_to_le32((4)&0x1f);//CAM_ID(MAC_ID)
-
+		
 		ptxdesc->txdw1 |= cpu_to_le32((6<< 16) & 0x000f0000);//raid
-
-		//offset 8
+		
+		//offset 8		
 
 		//offset 12
 		ptxdesc->txdw3 |= cpu_to_le32((pattrib->seqnum<<16)&0xffff0000);
-
+		
 		//offset 16
 		ptxdesc->txdw4 |= cpu_to_le32(BIT(8));//driver uses rate
-
+		
 		//offset 20
 		ptxdesc->txdw5 |= cpu_to_le32(MRateToHwRate(pmlmeext->tx_rate));
 	}
@@ -433,7 +433,7 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz, u8 bag
 	// (3) Use HW Qos SEQ to control the seq num of Ext port non-Qos packets.
 	// 2010.06.23. Added by tynli.
 	if(!pattrib->qos_en)
-	{
+	{		
 		ptxdesc->txdw4 |= cpu_to_le32(BIT(7)); // Hw set sequence number
 		ptxdesc->txdw3 |= cpu_to_le32((8 <<28)); //set bit3 to 1. Suugested by TimChen. 2009.12.29.
 	}
@@ -443,10 +443,10 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz, u8 bag
 	ptxdesc->txdw0 |= cpu_to_le32(OWN | FSG | LSG);
 	ptxdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE+OFFSET_SZ)<<OFFSET_SHT)&0x00ff0000);//32 bytes for TX Desc
 
-	if(bmcst)
+	if(bmcst)	
 	{
 		ptxdesc->txdw0 |= cpu_to_le32(BIT(24));
-	}
+	}	
 
 	RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("offset0-txdesc=0x%x\n", ptxdesc->txdw0));
 
@@ -461,9 +461,9 @@ static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz, u8 bag
 #endif
 
 	rtl8192cu_cal_txdesc_chksum(ptxdesc);
-
+		
 	return pull;
-
+		
 }
 
 static s32 rtw_dump_xframe(_adapter *padapter, struct xmit_frame *pxmitframe)
@@ -485,11 +485,11 @@ static s32 rtw_dump_xframe(_adapter *padapter, struct xmit_frame *pxmitframe)
 	{
 		rtw_issue_addbareq_cmd(padapter, pxmitframe);
 	}
-
+	
 	mem_addr = pxmitframe->buf_addr;
 
        RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("rtw_dump_xframe()\n"));
-
+	
 	for (t = 0; t < pattrib->nr_frags; t++)
 	{
 		if (inner_ret != _SUCCESS && ret == _SUCCESS)
@@ -500,7 +500,7 @@ static s32 rtw_dump_xframe(_adapter *padapter, struct xmit_frame *pxmitframe)
 			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("pattrib->nr_frags=%d\n", pattrib->nr_frags));
 
 			sz = pxmitpriv->frag_len;
-			sz = sz - 4 - (psecuritypriv->sw_encrypt ? 0 : pattrib->icv_len);
+			sz = sz - 4 - (psecuritypriv->sw_encrypt ? 0 : pattrib->icv_len);					
 		}
 		else //no frag
 		{
@@ -508,12 +508,12 @@ static s32 rtw_dump_xframe(_adapter *padapter, struct xmit_frame *pxmitframe)
 		}
 
 		pull = update_txdesc(pxmitframe, mem_addr, sz, _FALSE);
-
+		
 		if(pull)
 		{
 			mem_addr += PACKET_OFFSET_SZ; //pull txdesc head
-
-			//pxmitbuf ->pbuf = mem_addr;
+			
+			//pxmitbuf ->pbuf = mem_addr;			
 			pxmitframe->buf_addr = mem_addr;
 
 			w_sz = sz + TXDESC_SIZE;
@@ -521,24 +521,24 @@ static s32 rtw_dump_xframe(_adapter *padapter, struct xmit_frame *pxmitframe)
 		else
 		{
 			w_sz = sz + TXDESC_SIZE + PACKET_OFFSET_SZ;
-		}
+		}	
 
 		ff_hwaddr = rtw_get_ff_hwaddr(pxmitframe);
-
+		
 		inner_ret = rtw_write_port(padapter, ff_hwaddr, w_sz, (unsigned char*)pxmitbuf);
 
 		rtw_count_tx_stats(padapter, pxmitframe, sz);
 
 
 		RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("rtw_write_port, w_sz=%d\n", w_sz));
-		//DBG_8192C("rtw_write_port, w_sz=%d, sz=%d, txdesc_sz=%d, tid=%d\n", w_sz, sz, w_sz-sz, pattrib->priority);
+		//DBG_8192C("rtw_write_port, w_sz=%d, sz=%d, txdesc_sz=%d, tid=%d\n", w_sz, sz, w_sz-sz, pattrib->priority);      
 
 		mem_addr += w_sz;
 
 		mem_addr = (u8 *)RND4(((SIZE_PTR)(mem_addr)));
 
 	}
-
+	
 	rtw_free_xmitframe(pxmitpriv, pxmitframe);
 
 	if  (ret != _SUCCESS)
@@ -609,7 +609,7 @@ s32 rtl8192cu_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv
 	//3 1. pick up first frame
 	do {
 		rtw_free_xmitframe(pxmitpriv, pxmitframe);
-
+			
 		pxmitframe = rtw_dequeue_xframe(pxmitpriv, pxmitpriv->hwxmits, pxmitpriv->hwxmit_entry);
 		if (pxmitframe == NULL) {
 			// no more xmit frame, release xmit buffer
@@ -811,7 +811,7 @@ s32 rtl8192cu_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv
 	//3 5. update statisitc
 	pbuf_tail -= (pfirstframe->agg_num * TXDESC_SIZE);
 	if (pfirstframe->pkt_offset == 1) pbuf_tail -= PACKET_OFFSET_SZ;
-
+	
 	rtw_count_tx_stats(padapter, pfirstframe, pbuf_tail);
 
 	rtw_free_xmitframe(pxmitpriv, pfirstframe);
@@ -822,11 +822,11 @@ s32 rtl8192cu_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv
 #else
 
 s32 rtl8192cu_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf)
-{
+{		
 
 	struct hw_xmit *phwxmits;
 	sint hwentry;
-	struct xmit_frame *pxmitframe=NULL;
+	struct xmit_frame *pxmitframe=NULL;	
 	int res=_SUCCESS, xcnt = 0;
 
 	phwxmits = pxmitpriv->hwxmits;
@@ -836,40 +836,40 @@ s32 rtl8192cu_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv
 
 	if(pxmitbuf==NULL)
 	{
-		pxmitbuf = rtw_alloc_xmitbuf(pxmitpriv);
+		pxmitbuf = rtw_alloc_xmitbuf(pxmitpriv);		
 		if(!pxmitbuf)
 		{
 			return _FALSE;
-		}
-	}
+		}			
+	}	
 
 
 	do
-	{
+	{		
 		pxmitframe =  rtw_dequeue_xframe(pxmitpriv, phwxmits, hwentry);
-
+		
 		if(pxmitframe)
 		{
-			pxmitframe->pxmitbuf = pxmitbuf;
+			pxmitframe->pxmitbuf = pxmitbuf;				
 
 			pxmitframe->buf_addr = pxmitbuf->pbuf;
 
-			pxmitbuf->priv_data = pxmitframe;
+			pxmitbuf->priv_data = pxmitframe;	
 
 			if((pxmitframe->frame_tag&0x0f) == DATA_FRAMETAG)
-			{
+			{	
 				if(pxmitframe->attrib.priority<=15)//TID0~15
 				{
 					res = rtw_xmitframe_coalesce(padapter, pxmitframe->pkt, pxmitframe);
-				}
-
-				rtw_os_xmit_complete(padapter, pxmitframe);//always return ndis_packet after rtw_xmitframe_coalesce
+				}	
+							
+				rtw_os_xmit_complete(padapter, pxmitframe);//always return ndis_packet after rtw_xmitframe_coalesce 			
 			}
 
-
+				
 			RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("xmitframe_complete(): rtw_dump_xframe\n"));
 
-
+			
 			if(res == _SUCCESS)
 			{
 				rtw_dump_xframe(padapter, pxmitframe);
@@ -877,24 +877,24 @@ s32 rtl8192cu_xmitframe_complete(_adapter *padapter, struct xmit_priv *pxmitpriv
 			else
 			{
 				rtw_free_xmitbuf(pxmitpriv, pxmitbuf);
-				rtw_free_xmitframe(pxmitpriv, pxmitframe);
+				rtw_free_xmitframe(pxmitpriv, pxmitframe);	
 			}
-
+	 			 		
 			xcnt++;
-
+			
 		}
 		else
-		{
+		{			
 			rtw_free_xmitbuf(pxmitpriv, pxmitbuf);
 			return _FALSE;
 		}
 
 		break;
-
+		
 	}while(0/*xcnt < (NR_XMITFRAME >> 3)*/);
 
 	return _TRUE;
-
+	
 }
 #endif
 
@@ -926,8 +926,8 @@ static s32 pre_xmitframe(_adapter *padapter, struct xmit_frame *pxmitframe)
 	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
 	struct pkt_attrib *pattrib = &pxmitframe->attrib;
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-
-
+	
+	
 	_enter_critical_bh(&pxmitpriv->lock, &irqL);
 
 
@@ -938,7 +938,7 @@ static s32 pre_xmitframe(_adapter *padapter, struct xmit_frame *pxmitframe)
 	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE)
 		goto enqueue;
 
-#ifdef CONFIG_CONCURRENT_MODE
+#ifdef CONFIG_CONCURRENT_MODE	
 	if (check_buddy_fwstate(padapter, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE)
 		goto enqueue;
 #endif
@@ -996,14 +996,14 @@ s32	 rtl8192cu_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmi
 {
 	struct xmit_priv 	*pxmitpriv = &padapter->xmitpriv;
 	s32 err;
-
-	if ((err=rtw_xmitframe_enqueue(padapter, pxmitframe)) != _SUCCESS)
+	
+	if ((err=rtw_xmitframe_enqueue(padapter, pxmitframe)) != _SUCCESS) 
 	{
 		rtw_free_xmitframe(pxmitpriv, pxmitframe);
 
 		// Trick, make the statistics correct
 		pxmitpriv->tx_pkts--;
-		pxmitpriv->tx_drop++;
+		pxmitpriv->tx_drop++;					
 	}
 	else
 	{
@@ -1011,45 +1011,45 @@ s32	 rtl8192cu_hal_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmi
 		tasklet_hi_schedule(&pxmitpriv->xmit_tasklet);
 #endif
 	}
-
+	
 	return err;
-
+	
 }
 
 #ifdef  CONFIG_HOSTAPD_MLME
 
 static void rtl8192cu_hostap_mgnt_xmit_cb(struct urb *urb)
-{
+{	
 #ifdef PLATFORM_LINUX
 	struct sk_buff *skb = (struct sk_buff *)urb->context;
 
 	//DBG_8192C("%s\n", __FUNCTION__);
 
 	rtw_skb_free(skb);
-#endif
+#endif	
 }
 
 s32 rtl8192cu_hostap_mgnt_xmit_entry(_adapter *padapter, _pkt *pkt)
 {
 #ifdef PLATFORM_LINUX
 	u16 fc;
-	int rc, len, pipe;
+	int rc, len, pipe;	
 	unsigned int bmcst, tid, qsel;
 	struct sk_buff *skb, *pxmit_skb;
 	struct urb *urb;
 	unsigned char *pxmitbuf;
 	struct tx_desc *ptxdesc;
 	struct rtw_ieee80211_hdr *tx_hdr;
-	struct hostapd_priv *phostapdpriv = padapter->phostapdpriv;
+	struct hostapd_priv *phostapdpriv = padapter->phostapdpriv;	
 	struct net_device *pnetdev = padapter->pnetdev;
 	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(padapter);
-	struct dvobj_priv *pdvobj = adapter_to_dvobj(padapter);
-
+	struct dvobj_priv *pdvobj = adapter_to_dvobj(padapter);	
 
+	
 	//DBG_8192C("%s\n", __FUNCTION__);
 
 	skb = pkt;
-
+	
 	len = skb->len;
 	tx_hdr = (struct rtw_ieee80211_hdr *)(skb->data);
 	fc = le16_to_cpu(tx_hdr->frame_ctl);
@@ -1070,42 +1070,42 @@ s32 rtl8192cu_hostap_mgnt_xmit_entry(_adapter *padapter, _pkt *pkt)
 		goto _exit;
 	}
 
-	// ----- fill tx desc -----
-	ptxdesc = (struct tx_desc *)pxmitbuf;
+	// ----- fill tx desc -----	
+	ptxdesc = (struct tx_desc *)pxmitbuf;	
 	_rtw_memset(ptxdesc, 0, sizeof(*ptxdesc));
-
-	//offset 0
-	ptxdesc->txdw0 |= cpu_to_le32(len&0x0000ffff);
+		
+	//offset 0	
+	ptxdesc->txdw0 |= cpu_to_le32(len&0x0000ffff); 
 	ptxdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE+OFFSET_SZ)<<OFFSET_SHT)&0x00ff0000);//default = 32 bytes for TX Desc
 	ptxdesc->txdw0 |= cpu_to_le32(OWN | FSG | LSG);
 
-	if(bmcst)
+	if(bmcst)	
 	{
 		ptxdesc->txdw0 |= cpu_to_le32(BIT(24));
-	}
+	}	
 
-	//offset 4
+	//offset 4	
 	ptxdesc->txdw1 |= cpu_to_le32(0x00);//MAC_ID
 
 	ptxdesc->txdw1 |= cpu_to_le32((0x12<<QSEL_SHT)&0x00001f00);
 
 	ptxdesc->txdw1 |= cpu_to_le32((0x06<< 16) & 0x000f0000);//b mode
 
-	//offset 8
+	//offset 8			
 
-	//offset 12
+	//offset 12		
 	ptxdesc->txdw3 |= cpu_to_le32((le16_to_cpu(tx_hdr->seq_ctl)<<16)&0xffff0000);
 
-	//offset 16
+	//offset 16		
 	ptxdesc->txdw4 |= cpu_to_le32(BIT(8));//driver uses rate
-
+		
 	//offset 20
 
 
 	//HW append seq
 	ptxdesc->txdw4 |= cpu_to_le32(BIT(7)); // Hw set sequence number
 	ptxdesc->txdw3 |= cpu_to_le32((8 <<28)); //set bit3 to 1. Suugested by TimChen. 2009.12.29.
-
+	
 
 	rtl8192cu_cal_txdesc_chksum(ptxdesc);
 	// ----- end of fill tx desc -----
@@ -1119,14 +1119,14 @@ s32 rtl8192cu_hostap_mgnt_xmit_entry(_adapter *padapter, _pkt *pkt)
 
 
 	// ----- prepare urb for submit -----
-
+	
 	//translate DMA FIFO addr to pipehandle
 	//pipe = ffaddr2pipehdl(pdvobj, MGT_QUEUE_INX);
 	pipe = usb_sndbulkpipe(pdvobj->pusbdev, pHalData->Queue2EPNum[(u8)MGT_QUEUE_INX]&0x0f);
-
+	
 	usb_fill_bulk_urb(urb, pdvobj->pusbdev, pipe,
 			  pxmit_skb->data, pxmit_skb->len, rtl8192cu_hostap_mgnt_xmit_cb, pxmit_skb);
-
+	
 	urb->transfer_flags |= URB_ZERO_PACKET;
 	usb_anchor_urb(urb, &phostapdpriv->anchored);
 	rc = usb_submit_urb(urb, GFP_ATOMIC);
@@ -1136,9 +1136,9 @@ s32 rtl8192cu_hostap_mgnt_xmit_entry(_adapter *padapter, _pkt *pkt)
 	}
 	usb_free_urb(urb);
 
-
-_exit:
-
+	
+_exit:	
+	
 	rtw_skb_free(skb);
 
 #endif
@@ -1147,3 +1147,4 @@ s32 rtl8192cu_hostap_mgnt_xmit_entry(_adapter *padapter, _pkt *pkt)
 
 }
 #endif
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/usb_halinit.c b/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/usb_halinit.c
old mode 100644
new mode 100755
index edb72c1..ff89473
--- a/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/usb_halinit.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/usb_halinit.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -80,7 +80,7 @@
 	pHalData->Queue2EPNum[1] = pHalData->RtBulkOutPipe[0];//VI
 	pHalData->Queue2EPNum[2] = pHalData->RtBulkOutPipe[0];//BE
 	pHalData->Queue2EPNum[3] = pHalData->RtBulkOutPipe[0];//BK
-
+	
 	pHalData->Queue2EPNum[4] = pHalData->RtBulkOutPipe[0];//BCN
 	pHalData->Queue2EPNum[5] = pHalData->RtBulkOutPipe[0];//MGT
 	pHalData->Queue2EPNum[6] = pHalData->RtBulkOutPipe[0];//HIGH
@@ -106,8 +106,8 @@
 #define TXCMD_QUEUE_INX	7
 */
 	if(bWIFICfg){ // Normal chip && wmm
-
-		//	BK, 	BE, 	VI, 	VO, 	BCN,	CMD,MGT,HIGH,HCCA
+		
+		//	BK, 	BE, 	VI, 	VO, 	BCN,	CMD,MGT,HIGH,HCCA 
 		//{  0, 	1, 	0, 	1, 	0, 	0, 	0, 	0, 		0	};
 		//0:H(end_number=0x02), 1:L (end_number=0x03)
 
@@ -115,29 +115,29 @@
 		pHalData->Queue2EPNum[1] = pHalData->RtBulkOutPipe[0];//VI
 		pHalData->Queue2EPNum[2] = pHalData->RtBulkOutPipe[1];//BE
 		pHalData->Queue2EPNum[3] = pHalData->RtBulkOutPipe[0];//BK
-
+		
 		pHalData->Queue2EPNum[4] = pHalData->RtBulkOutPipe[0];//BCN
 		pHalData->Queue2EPNum[5] = pHalData->RtBulkOutPipe[0];//MGT
 		pHalData->Queue2EPNum[6] = pHalData->RtBulkOutPipe[0];//HIGH
 		pHalData->Queue2EPNum[7] = pHalData->RtBulkOutPipe[0];//TXCMD
 	}
 	else{//typical setting
-
-		//BK, 	BE, 	VI, 	VO, 	BCN,	CMD,MGT,HIGH,HCCA
-		//{  1, 	1, 	0, 	0, 	0, 	0, 	0, 	0, 		0	};
+		
+		//BK, 	BE, 	VI, 	VO, 	BCN,	CMD,MGT,HIGH,HCCA 
+		//{  1, 	1, 	0, 	0, 	0, 	0, 	0, 	0, 		0	};			
 		//0:H(end_number=0x02), 1:L (end_number=0x03)
 
 		pHalData->Queue2EPNum[0] = pHalData->RtBulkOutPipe[0];//VO
 		pHalData->Queue2EPNum[1] = pHalData->RtBulkOutPipe[0];//VI
 		pHalData->Queue2EPNum[2] = pHalData->RtBulkOutPipe[1];//BE
 		pHalData->Queue2EPNum[3] = pHalData->RtBulkOutPipe[1];//BK
-
+		
 		pHalData->Queue2EPNum[4] = pHalData->RtBulkOutPipe[0];//BCN
 		pHalData->Queue2EPNum[5] = pHalData->RtBulkOutPipe[0];//MGT
 		pHalData->Queue2EPNum[6] = pHalData->RtBulkOutPipe[0];//HIGH
 		pHalData->Queue2EPNum[7] = pHalData->RtBulkOutPipe[0];//TXCMD
 	}
-
+	
 }
 
 
@@ -148,7 +148,7 @@ static VOID _ThreeOutEpMapping(
 {
 	if(bWIFICfg){//for WMM
 
-		//	BK, 	BE, 	VI, 	VO, 	BCN,	CMD,MGT,HIGH,HCCA
+		//	BK, 	BE, 	VI, 	VO, 	BCN,	CMD,MGT,HIGH,HCCA 
 		//{  1, 	2, 	1, 	0, 	0, 	0, 	0, 	0, 		0	};
 		//0:H(end_number=0x02), 1:N(end_number=0x03), 2:L (end_number=0x05)
 
@@ -156,7 +156,7 @@ static VOID _ThreeOutEpMapping(
 		pHalData->Queue2EPNum[1] = pHalData->RtBulkOutPipe[1];//VI
 		pHalData->Queue2EPNum[2] = pHalData->RtBulkOutPipe[2];//BE
 		pHalData->Queue2EPNum[3] = pHalData->RtBulkOutPipe[1];//BK
-
+		
 		pHalData->Queue2EPNum[4] = pHalData->RtBulkOutPipe[0];//BCN
 		pHalData->Queue2EPNum[5] = pHalData->RtBulkOutPipe[0];//MGT
 		pHalData->Queue2EPNum[6] = pHalData->RtBulkOutPipe[0];//HIGH
@@ -164,14 +164,14 @@ static VOID _ThreeOutEpMapping(
 	}
 	else{//typical setting
 
-		//	BK, 	BE, 	VI, 	VO, 	BCN,	CMD,MGT,HIGH,HCCA
-		//{  2, 	2, 	1, 	0, 	0, 	0, 	0, 	0, 		0	};
+		//	BK, 	BE, 	VI, 	VO, 	BCN,	CMD,MGT,HIGH,HCCA 
+		//{  2, 	2, 	1, 	0, 	0, 	0, 	0, 	0, 		0	};			
 		//0:H(end_number=0x02), 1:N(end_number=0x03), 2:L (end_number=0x05)
 		pHalData->Queue2EPNum[0] = pHalData->RtBulkOutPipe[0];//VO
 		pHalData->Queue2EPNum[1] = pHalData->RtBulkOutPipe[1];//VI
 		pHalData->Queue2EPNum[2] = pHalData->RtBulkOutPipe[2];//BE
 		pHalData->Queue2EPNum[3] = pHalData->RtBulkOutPipe[2];//BK
-
+		
 		pHalData->Queue2EPNum[4] = pHalData->RtBulkOutPipe[0];//BCN
 		pHalData->Queue2EPNum[5] = pHalData->RtBulkOutPipe[0];//MGT
 		pHalData->Queue2EPNum[6] = pHalData->RtBulkOutPipe[0];//HIGH
@@ -185,12 +185,12 @@ static VOID _ThreeOutEpMapping(
 	IN	PADAPTER	pAdapter,
 	IN	u8		NumOutPipe
 	)
-{
+{		
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(pAdapter);
 	struct registry_priv *pregistrypriv = &pAdapter->registrypriv;
 
 	BOOLEAN	 bWIFICfg = (pregistrypriv->wifi_spec) ?_TRUE:_FALSE;
-
+	
 	BOOLEAN result = _TRUE;
 
 	switch(NumOutPipe)
@@ -198,7 +198,7 @@ static VOID _ThreeOutEpMapping(
 		case 2:
 			_TwoOutEpMapping(pHalData, bWIFICfg);
 			break;
-		case 3:
+		case 3:		
 			_ThreeOutEpMapping(pHalData, bWIFICfg);
 			break;
 		case 1:
@@ -210,7 +210,7 @@ static VOID _ThreeOutEpMapping(
 	}
 
 	return result;
-
+	
 }
 
 static VOID
@@ -224,10 +224,10 @@ static VOID _ThreeOutEpMapping(
 
 	pHalData->OutEpQueueSel = 0;
 	pHalData->OutEpNumber	= 0;
-
+		
 	// Normal and High queue
 	value8 = rtw_read8(pAdapter, (REG_NORMAL_SIE_EP + 1));
-
+	
 	if(value8 & USB_NORMAL_SIE_EP_MASK){
 		pHalData->OutEpQueueSel |= TX_SELE_HQ;
 		pHalData->OutEpNumber++;
@@ -236,12 +236,12 @@ static VOID _ThreeOutEpMapping(
 #ifdef CONFIG_USB_ONE_OUT_EP
 		return;
 #endif
-
+		
 	if((value8 >> USB_NORMAL_SIE_EP_SHIFT) & USB_NORMAL_SIE_EP_MASK){
 		pHalData->OutEpQueueSel |= TX_SELE_NQ;
 		pHalData->OutEpNumber++;
 	}
-
+	
 	// Low queue
 	value8 = rtw_read8(pAdapter, (REG_NORMAL_SIE_EP + 2));
 	if(value8 & USB_NORMAL_SIE_EP_MASK){
@@ -274,7 +274,7 @@ static BOOLEAN HalUsbSetQueuePipeMapping8192CUsb(
 	}
 	#endif
 	result = _MappingOutEP(pAdapter, NumOutPipe);
-
+	
 	return result;
 
 }
@@ -345,35 +345,35 @@ static u8 _InitPowerOn(_adapter *padapter)
 			//RT_TRACE(COMP_INIT,DBG_SERIOUS,("Failed to polling REG_APS_FSMCO[PFM_ALDN] done!\n"));
 			return _FAIL;
 		}
-
+				
 	}while(_TRUE);
 
 
 //	For hardware power on sequence.
 
 	//0.	RSV_CTRL 0x1C[7:0] = 0x00			// unlock ISO/CLK/Power control register
-	rtw_write8(padapter, REG_RSV_CTRL, 0x0);
+	rtw_write8(padapter, REG_RSV_CTRL, 0x0);	
 	// Power on when re-enter from IPS/Radio off/card disable
 	rtw_write8(padapter, REG_SPS0_CTRL, 0x2b);//enable SPS into PWM mode
 /*
 	value16 = PlatformIORead2Byte(Adapter, REG_AFE_XTAL_CTRL);//enable AFE clock
 	value16 &=  (~XTAL_GATE_AFE);
-	PlatformIOWrite2Byte(Adapter,REG_AFE_XTAL_CTRL, value16 );
+	PlatformIOWrite2Byte(Adapter,REG_AFE_XTAL_CTRL, value16 );		
 */
-
+	
 	rtw_udelay_os(100);//PlatformSleepUs(150);//this is not necessary when initially power on
 
-	value8 = rtw_read8(padapter, REG_LDOV12D_CTRL);
+	value8 = rtw_read8(padapter, REG_LDOV12D_CTRL);	
 	if(0== (value8 & LDV12_EN) ){
 		value8 |= LDV12_EN;
-		rtw_write8(padapter, REG_LDOV12D_CTRL, value8);
+		rtw_write8(padapter, REG_LDOV12D_CTRL, value8);	
 		//RT_TRACE(COMP_INIT, DBG_LOUD, (" power-on :REG_LDOV12D_CTRL Reg0x21:0x%02x.\n",value8));
 		rtw_udelay_os(100);//PlatformSleepUs(100);//this is not necessary when initially power on
 		value8 = rtw_read8(padapter, REG_SYS_ISO_CTRL);
 		value8 &= ~ISO_MD2PP;
-		rtw_write8(padapter, REG_SYS_ISO_CTRL, value8);
-	}
-
+		rtw_write8(padapter, REG_SYS_ISO_CTRL, value8);			
+	}	
+	
 	// auto enable WLAN
 	pollingCount = 0;
 	value16 = rtw_read16(padapter, REG_APS_FSMCO);
@@ -391,7 +391,7 @@ static u8 _InitPowerOn(_adapter *padapter)
 			//RT_TRACE(COMP_INIT,DBG_SERIOUS,("Failed to polling REG_APS_FSMCO[APFM_ONMAC] done!\n"));
 			return _FAIL;
 		}
-
+				
 	}while(_TRUE);
 
 	//Enable Radio ,GPIO ,and LED function
@@ -403,9 +403,9 @@ static u8 _InitPowerOn(_adapter *padapter)
 	{
 		value32 =  rtw_read32(padapter, REG_APS_FSMCO);
 		value32 |= (SOP_ABG|SOP_AMB|XOP_BTCK);
-		rtw_write32(padapter, REG_APS_FSMCO, value32);
+		rtw_write32(padapter, REG_APS_FSMCO, value32);		
 	}
-#endif
+#endif	
 
 	// release RF digital isolation
 	value16 = rtw_read16(padapter, REG_SYS_ISO_CTRL);
@@ -417,7 +417,7 @@ static u8 _InitPowerOn(_adapter *padapter)
 	value16 |= (HCI_TXDMA_EN | HCI_RXDMA_EN | TXDMA_EN | RXDMA_EN
 				| PROTOCOL_EN | SCHEDULE_EN | MACTXEN | MACRXEN | ENSEC);
 	rtw_write16(padapter, REG_CR, value16);
-
+	
 	//tynli_test for suspend mode.
 	{
 		rtw_write8(padapter,  0xfe10, 0x19);
@@ -430,7 +430,7 @@ static u8 _InitPowerOn(_adapter *padapter)
 		{
 			DBG_8192C("SlimComboDbg == TRUE\n");
 
-			// 1. SIC?Test Mode , Debug Ports | Enable, H Driver W,
+			// 1. SIC?Test Mode , Debug Ports | Enable, H Driver W, 
 			//	n]w 0x 00[7] -> "1", N Disable.   effect if not: power consumption increase
 			rtw_write8(padapter, REG_SYS_ISO_CTRL, rtw_read8(padapter, REG_SYS_ISO_CTRL)|BIT7);
 
@@ -441,17 +441,17 @@ static u8 _InitPowerOn(_adapter *padapter)
 			// 3. SIC Test Mode , EESK, EECS | report?Host Clock status, H Driver W, ]w? 0x40[4] -> "1" N EEPROM  Pin (autoload still from Efuse)
 			//  effect if not:power consumption increase
 			value8 = rtw_read8(padapter, REG_GPIO_MUXCFG)|BIT4 ;
-		#ifdef CONFIG_BT_COEXIST
+		#ifdef CONFIG_BT_COEXIST	
 			// 2011/01/26 MH UMB-B cut bug. We need to support the modification.
 			if (IS_81xxC_VENDOR_UMC_B_CUT(pHalData->VersionID) &&
 				pHalData->bt_coexist.BT_Coexist)
 			{
-				value8 |= (BIT5);
+				value8 |= (BIT5);	
 			}
 		#endif
 			rtw_write8(padapter, REG_GPIO_MUXCFG,value8 );
-
-
+			
+			
 			// 4. SIC Test Mode ,?SIC Debug ports | Enable , H Driver WW, ]w? 0x40[15:11] -> 0x00, NDisable
 			//  4.1Two Steps setting for safety: 0x40[15,13,12, 11] -> "0", then ?0x40[14] -> "0"
 			// effect if not: Host could not transfer packets, and GPIO-3,2 will occupied by SIC then Co-exist could not work.
@@ -490,7 +490,7 @@ static void _InitPABias(_adapter *padapter)
 	HAL_DATA_TYPE		*pHalData	= GET_HAL_DATA(padapter);
 	u8			pa_setting;
 	BOOLEAN		is92C = IS_92C_SERIAL(pHalData->VersionID);
-
+	
 	//FIXED PA current issue
 	//efuse_one_byte_read(padapter, 0x1FA, &pa_setting);
 	pa_setting = EFUSE_Read1Byte(padapter, 0x1FA);
@@ -500,26 +500,26 @@ static void _InitPABias(_adapter *padapter)
 	if(!(pa_setting & BIT0))
 	{
 		PHY_SetRFReg(padapter, RF_PATH_A, 0x15, 0x0FFFFF, 0x0F406);
-		PHY_SetRFReg(padapter, RF_PATH_A, 0x15, 0x0FFFFF, 0x4F406);
-		PHY_SetRFReg(padapter, RF_PATH_A, 0x15, 0x0FFFFF, 0x8F406);
-		PHY_SetRFReg(padapter, RF_PATH_A, 0x15, 0x0FFFFF, 0xCF406);
+		PHY_SetRFReg(padapter, RF_PATH_A, 0x15, 0x0FFFFF, 0x4F406);		
+		PHY_SetRFReg(padapter, RF_PATH_A, 0x15, 0x0FFFFF, 0x8F406);		
+		PHY_SetRFReg(padapter, RF_PATH_A, 0x15, 0x0FFFFF, 0xCF406);		
 		//RT_TRACE(COMP_INIT, DBG_LOUD, ("PA BIAS path A\n"));
-	}
+	}	
 
 	if(!(pa_setting & BIT1) && is92C)
 	{
 		PHY_SetRFReg(padapter,RF_PATH_B, 0x15, 0x0FFFFF, 0x0F406);
-		PHY_SetRFReg(padapter,RF_PATH_B, 0x15, 0x0FFFFF, 0x4F406);
-		PHY_SetRFReg(padapter,RF_PATH_B, 0x15, 0x0FFFFF, 0x8F406);
+		PHY_SetRFReg(padapter,RF_PATH_B, 0x15, 0x0FFFFF, 0x4F406);		
+		PHY_SetRFReg(padapter,RF_PATH_B, 0x15, 0x0FFFFF, 0x8F406);		
 		PHY_SetRFReg(padapter,RF_PATH_B, 0x15, 0x0FFFFF, 0xCF406);
-		//RT_TRACE(COMP_INIT, DBG_LOUD, ("PA BIAS path B\n"));
+		//RT_TRACE(COMP_INIT, DBG_LOUD, ("PA BIAS path B\n"));	
 	}
 
 	if(!(pa_setting & BIT4))
 	{
 		pa_setting = rtw_read8(padapter, 0x16);
 		pa_setting &= 0x0F;
-		rtw_write8(padapter, 0x16, pa_setting | 0x90);
+		rtw_write8(padapter, 0x16, pa_setting | 0x90);		
 	}
 }
 #ifdef CONFIG_BT_COEXIST
@@ -538,19 +538,19 @@ static void _InitBTCoexist(_adapter *padapter)
 			rtw_write8( padapter,REG_GPIO_MUXCFG, 0xa0);
 			DBG_8192C("BT write 0x%x = 0x%x\n", REG_GPIO_MUXCFG, 0xa0);
 		}
-#endif
+#endif		
 
 		u1Tmp = rtw_read8(padapter, 0x4fd) & BIT0;
-		u1Tmp = u1Tmp |
-				((pbtpriv->BT_Ant_isolation==1)?0:BIT1) |
+		u1Tmp = u1Tmp | 
+				((pbtpriv->BT_Ant_isolation==1)?0:BIT1) | 
 				((pbtpriv->BT_Service==BT_SCO)?0:BIT2);
 		rtw_write8( padapter, 0x4fd, u1Tmp);
 		DBG_8192C("BT write 0x%x = 0x%x for non-isolation\n", 0x4fd, u1Tmp);
-
-
+		
+		
 		rtw_write32(padapter, REG_BT_COEX_TABLE+4, 0xaaaa9aaa);
 		DBG_8192C("BT write 0x%x = 0x%x\n", REG_BT_COEX_TABLE+4, 0xaaaa9aaa);
-
+		
 		rtw_write32(padapter, REG_BT_COEX_TABLE+8, 0xffbd0040);
 		DBG_8192C("BT write 0x%x = 0x%x\n", REG_BT_COEX_TABLE+8, 0xffbd0040);
 
@@ -562,7 +562,7 @@ static void _InitBTCoexist(_adapter *padapter)
 		u1Tmp &= ~(BIT1);
 		rtw_write8( padapter, rOFDM0_TRxPathEnable, u1Tmp);
 		DBG_8192C("BT write 0xC04 = 0x%x\n", u1Tmp);
-
+			
 		u1Tmp = rtw_read8(padapter, rOFDM1_TRxPathEnable);
 		u1Tmp &= ~(BIT1);
 		rtw_write8( padapter, rOFDM1_TRxPathEnable, u1Tmp);
@@ -588,15 +588,15 @@ static u8 _LLTWrite(
 	u32 		value = _LLT_INIT_ADDR(address) | _LLT_INIT_DATA(data) | _LLT_OP(_LLT_WRITE_ACCESS);
 
 	rtw_write32(Adapter, REG_LLT_INIT, value);
-
+	
 	//polling
 	do{
-
+		
 		value = rtw_read32(Adapter, REG_LLT_INIT);
 		if(_LLT_NO_ACTIVE == _LLT_OP_VALUE(value)){
 			break;
 		}
-
+		
 		if(count > POLLING_LLT_THRESHOLD){
 			//RT_TRACE(COMP_INIT,DBG_SERIOUS,("Failed to polling write LLT done at address %d!\n", address));
 			status = _FAIL;
@@ -605,7 +605,7 @@ static u8 _LLTWrite(
 	}while(count++);
 
 	return status;
-
+	
 }
 
 
@@ -621,12 +621,12 @@ static u8 _LLTRead(
 
 	//polling and get value
 	do{
-
+		
 		value = rtw_read32(Adapter, REG_LLT_INIT);
 		if(_LLT_NO_ACTIVE == _LLT_OP_VALUE(value)){
 			return (u8)value;
 		}
-
+		
 		if(count > POLLING_LLT_THRESHOLD){
 			//RT_TRACE(COMP_INIT,DBG_SERIOUS,("Failed to polling read LLT done at address %d!\n", address));
 			break;
@@ -667,21 +667,21 @@ static u8 InitLLTTable(
 		}
 
 		// end of list
-		status = _LLTWrite(Adapter, (boundary - 1), 0xFF);
+		status = _LLTWrite(Adapter, (boundary - 1), 0xFF); 
 		if(_SUCCESS != status){
 			return status;
 		}
 
 		// Make the other pages as ring buffer
 		// This ring buffer is used as beacon buffer if we config this MAC as two MAC transfer.
-		// Otherwise used as local loopback buffer.
+		// Otherwise used as local loopback buffer. 
 		for(i = boundary ; i < LAST_ENTRY_OF_TX_PKT_BUFFER ; i++){
-			status = _LLTWrite(Adapter, i, (i + 1));
+			status = _LLTWrite(Adapter, i, (i + 1)); 
 			if(_SUCCESS != status){
 				return status;
 			}
 		}
-
+		
 		// Let last entry point to the start entry of ring buffer
 		status = _LLTWrite(Adapter, LAST_ENTRY_OF_TX_PKT_BUFFER, boundary);
 		if(_SUCCESS != status){
@@ -690,7 +690,7 @@ static u8 InitLLTTable(
 	}
 
 	return status;
-
+	
 }
 
 
@@ -706,11 +706,11 @@ static u8 InitLLTTable(
 {
 	u32 i;
 	for(i=0 ; i< MAC_ADDR_LEN ; i++){
-#ifdef  CONFIG_CONCURRENT_MODE
+#ifdef  CONFIG_CONCURRENT_MODE		
 		if(Adapter->iface_type == IFACE_PORT1)
 			rtw_write32(Adapter, REG_MACID1+i, MacID[i]);
 		else
-#endif
+#endif			
 		rtw_write32(Adapter, REG_MACID+i, MacID[i]);
 	}
 }
@@ -722,11 +722,11 @@ static u8 InitLLTTable(
 {
 	u32 i;
 	for(i=0 ; i< MAC_ADDR_LEN ; i++){
-#ifdef  CONFIG_CONCURRENT_MODE
+#ifdef  CONFIG_CONCURRENT_MODE		
 		if(Adapter->iface_type == IFACE_PORT1)
 			rtw_write32(Adapter, REG_BSSID1+i, BSSID[i]);
 		else
-#endif
+#endif			
 		rtw_write32(Adapter, REG_BSSID+i, BSSID[i]);
 	}
 }
@@ -756,7 +756,7 @@ static u8 InitLLTTable(
 {
 	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(Adapter);
 	struct registry_priv *pregistrypriv = &Adapter->registrypriv;
-
+	
 	u32			outEPNum	= (u32)pHalData->OutEpNumber;
 	u32			numHQ		= 0;
 	u32			numLQ		= 0;
@@ -767,7 +767,7 @@ static u8 InitLLTTable(
 	BOOLEAN		bWiFiConfig	= pregistrypriv->wifi_spec;
 	//u32			txQPageNum, txQPageUnit,txQRemainPage;
 
-	{ //for WMM
+	{ //for WMM 
 		//RT_ASSERT((outEPNum>=2), ("for WMM ,number of out-ep must more than or equal to 2!\n"));
 
 		if(pHalData->OutEpQueueSel & TX_SELE_HQ){
@@ -777,7 +777,7 @@ static u8 InitLLTTable(
 		if(pHalData->OutEpQueueSel & TX_SELE_LQ){
 			numLQ = (bWiFiConfig)?WMM_NORMAL_PAGE_NUM_LPQ:NORMAL_PAGE_NUM_LPQ;
 		}
-		// NOTE: This step shall be proceed before writting REG_RQPN.
+		// NOTE: This step shall be proceed before writting REG_RQPN.	
 		if(pHalData->OutEpQueueSel & TX_SELE_NQ){
 			numNQ = (bWiFiConfig)?WMM_NORMAL_PAGE_NUM_NPQ:NORMAL_PAGE_NUM_NPQ;
 		}
@@ -791,19 +791,19 @@ static u8 InitLLTTable(
 	}
 
 	// TX DMA
-	value32 = _HPQ(numHQ) | _LPQ(numLQ) | _PUBQ(numPubQ) | LD_RQPN;
-	rtw_write32(Adapter, REG_RQPN, value32);
+	value32 = _HPQ(numHQ) | _LPQ(numLQ) | _PUBQ(numPubQ) | LD_RQPN;	
+	rtw_write32(Adapter, REG_RQPN, value32);	
 }
 
 static VOID
 _InitTxBufferBoundary(
 	IN  PADAPTER Adapter
 	)
-{
+{	
 	struct registry_priv *pregistrypriv = &Adapter->registrypriv;
 	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(Adapter);
 
-	u8	txpktbuf_bndy;
+	u8	txpktbuf_bndy; 
 
 	if(!pregistrypriv->wifi_spec){
 		txpktbuf_bndy = TX_PAGE_BOUNDARY;
@@ -815,7 +815,7 @@ static u8 InitLLTTable(
 	rtw_write8(Adapter, REG_TXPKTBUF_BCNQ_BDNY, txpktbuf_bndy);
 	rtw_write8(Adapter, REG_TXPKTBUF_MGQ_BDNY, txpktbuf_bndy);
 	rtw_write8(Adapter, REG_TXPKTBUF_WMAC_LBK_BF_HD, txpktbuf_bndy);
-	rtw_write8(Adapter, REG_TRXFF_BNDY, txpktbuf_bndy);
+	rtw_write8(Adapter, REG_TRXFF_BNDY, txpktbuf_bndy);	
 #if 1
 	rtw_write8(Adapter, REG_TDECTRL+1, txpktbuf_bndy);
 #else
@@ -857,7 +857,7 @@ static u8 InitLLTTable(
 	value16 |=	_TXDMA_BEQ_MAP(beQ) 	| _TXDMA_BKQ_MAP(bkQ) |
 				_TXDMA_VIQ_MAP(viQ) 	| _TXDMA_VOQ_MAP(voQ) |
 				_TXDMA_MGQ_MAP(mgtQ)| _TXDMA_HIQ_MAP(hiQ);
-
+	
 	rtw_write16(Adapter, REG_TRXDMA_CTRL, value16);
 }
 
@@ -884,7 +884,7 @@ static u8 InitLLTTable(
 			//RT_ASSERT(FALSE,("Shall not reach here!\n"));
 			break;
 	}
-
+	
 	_InitNormalChipRegPriority(Adapter,
 								value,
 								value,
@@ -904,11 +904,11 @@ static u8 InitLLTTable(
 	HAL_DATA_TYPE	*pHalData	= GET_HAL_DATA(Adapter);
 	struct registry_priv *pregistrypriv = &Adapter->registrypriv;
 	u16			beQ,bkQ,viQ,voQ,mgtQ,hiQ;
-
+	
 
 	u16	valueHi = 0;
 	u16	valueLow = 0;
-
+	
 	switch(pHalData->OutEpQueueSel)
 	{
 		case (TX_SELE_HQ | TX_SELE_LQ):
@@ -933,18 +933,18 @@ static u8 InitLLTTable(
 		bkQ		= valueLow;
 		viQ		= valueHi;
 		voQ		= valueHi;
-		mgtQ	= valueHi;
-		hiQ		= valueHi;
+		mgtQ	= valueHi; 
+		hiQ		= valueHi;								
 	}
 	else{//for WMM ,CONFIG_OUT_EP_WIFI_MODE
 		beQ		= valueLow;
-		bkQ		= valueHi;
+		bkQ		= valueHi;		
 		viQ		= valueHi;
 		voQ		= valueLow;
 		mgtQ	= valueHi;
-		hiQ		= valueHi;
+		hiQ		= valueHi;							
 	}
-
+	
 	_InitNormalChipRegPriority(Adapter,beQ,bkQ,viQ,voQ,mgtQ,hiQ);
 
 }
@@ -963,7 +963,7 @@ static u8 InitLLTTable(
 		viQ 		= QUEUE_NORMAL;
 		voQ 		= QUEUE_HIGH;
 		mgtQ 	= QUEUE_HIGH;
-		hiQ 		= QUEUE_HIGH;
+		hiQ 		= QUEUE_HIGH;			
 	}
 	else{// for WMM
 		beQ		= QUEUE_LOW;
@@ -971,7 +971,7 @@ static u8 InitLLTTable(
 		viQ 		= QUEUE_NORMAL;
 		voQ 		= QUEUE_HIGH;
 		mgtQ 	= QUEUE_HIGH;
-		hiQ 		= QUEUE_HIGH;
+		hiQ 		= QUEUE_HIGH;			
 	}
 	_InitNormalChipRegPriority(Adapter,beQ,bkQ,viQ,voQ,mgtQ,hiQ);
 }
@@ -1045,7 +1045,7 @@ static u8 InitLLTTable(
 	)
 {
 	// Tx page size is always 128.
-
+	
 	u8	value8;
 	value8 = _PSRX(PBP_128) | _PSTX(PBP_128);
 	rtw_write8(Adapter, REG_PBP, value8);
@@ -1073,7 +1073,7 @@ static u8 InitLLTTable(
 	//pHalData->ReceiveConfig = RCR_AAP | RCR_APM | RCR_AM | RCR_AB |RCR_CBSSID_DATA| RCR_CBSSID_BCN| RCR_APP_ICV | RCR_AMF | RCR_HTC_LOC_CTRL | RCR_APP_MIC | RCR_APP_PHYSTS;
 	// don't turn on AAP, it will allow all packets to driver
 	pHalData->ReceiveConfig = RCR_APM | RCR_AM | RCR_AB |RCR_CBSSID_DATA| RCR_CBSSID_BCN| RCR_APP_ICV | RCR_AMF | RCR_HTC_LOC_CTRL | RCR_APP_MIC | RCR_APP_PHYSTS;
-
+	
 #if (0 == RTL8192C_RX_PACKET_NO_INCLUDE_CRC)
 	pHalData->ReceiveConfig |= ACRC32;
 #endif
@@ -1101,7 +1101,7 @@ static u8 InitLLTTable(
 	//rtw_write16(Adapter, REG_RXFLTMAP0, value16);
 
 	//enable RX_SHIFT bits
-	//rtw_write8(Adapter, REG_TRXDMA_CTRL, rtw_read8(Adapter, REG_TRXDMA_CTRL)|BIT(1));
+	//rtw_write8(Adapter, REG_TRXDMA_CTRL, rtw_read8(Adapter, REG_TRXDMA_CTRL)|BIT(1));	
 
 }
 
@@ -1129,7 +1129,7 @@ static u8 InitLLTTable(
 	// Retry Limit
 	value16 = _LRL(0x30) | _SRL(0x30);
 	rtw_write16(Adapter, REG_RL, value16);
-
+	
 }
 
 static VOID
@@ -1158,10 +1158,10 @@ static u8 InitLLTTable(
     //REG514:SIFS_CCK_CTX
     //REG515:SIFS_OFDM_CTX
 	//REG516:SIFS_CCK_TRX
-    //REG517:SIFS_OFDM_TRX
+    //REG517:SIFS_OFDM_TRX    
 
 	// Set SIFS for CCK_CTS and OFDM_CTX
-	rtw_write16(Adapter,REG_SIFS_CTX, 0x100a);
+	rtw_write16(Adapter,REG_SIFS_CTX, 0x100a);	
 
 	// Set SIFS for CCK_TRX and OFDM_TRX
 	rtw_write16(Adapter,REG_SIFS_TRX, 0x100a);
@@ -1181,9 +1181,9 @@ static u8 InitLLTTable(
 	)
 {
 #ifdef RTL8192CU_ADHOC_WORKAROUND_SETTING
-	rtw_write8(Adapter, REG_BCN_MAX_ERR, 0xFF);
+	rtw_write8(Adapter, REG_BCN_MAX_ERR, 0xFF);	
 #else
-	//rtw_write8(Adapter, REG_BCN_MAX_ERR, (InfraMode ? 0xFF : 0x10));
+	//rtw_write8(Adapter, REG_BCN_MAX_ERR, (InfraMode ? 0xFF : 0x10));	
 #endif
 }
 
@@ -1192,12 +1192,12 @@ static u8 InitLLTTable(
 static void _InitHWLed(PADAPTER Adapter)
 {
 	struct led_priv *pledpriv = &(Adapter->ledpriv);
-
+	
 	if( pledpriv->LedStrategy != HW_LED)
 		return;
-
+	
 // HW led control
-// to do ....
+// to do .... 
 //must consider cases of antenna diversity/ commbo card/solo card/mini card
 
 }
@@ -1228,7 +1228,7 @@ static void _InitHWLed(PADAPTER Adapter)
 	)
 {
 	u8	value8;
-
+	
 	value8 = rtw_read8(Adapter, REG_FWHW_TXQ_CTRL);
 	value8 |= EN_AMPDU_RTY_NEW;
 	rtw_write8(Adapter, REG_FWHW_TXQ_CTRL, value8);
@@ -1240,7 +1240,7 @@ static void _InitHWLed(PADAPTER Adapter)
 /*-----------------------------------------------------------------------------
  * Function:	usb_AggSettingTxUpdate()
  *
- * Overview:	Seperate TX/RX parameters update independent for TP detection and
+ * Overview:	Seperate TX/RX parameters update independent for TP detection and 
  *			dynamic TX/RX aggreagtion parameters update.
  *
  * Input:			PADAPTER
@@ -1259,7 +1259,7 @@ static void _InitHWLed(PADAPTER Adapter)
 {
 #ifdef CONFIG_USB_TX_AGGREGATION
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	//PMGNT_INFO		pMgntInfo = &(Adapter->MgntInfo);
+	//PMGNT_INFO		pMgntInfo = &(Adapter->MgntInfo);	
 	u32			value32;
 
 	if(Adapter->registrypriv.wifi_spec)
@@ -1269,10 +1269,10 @@ static void _InitHWLed(PADAPTER Adapter)
 		value32 = rtw_read32(Adapter, REG_TDECTRL);
 		value32 = value32 & ~(BLK_DESC_NUM_MASK << BLK_DESC_NUM_SHIFT);
 		value32 |= ((pHalData->UsbTxAggDescNum & BLK_DESC_NUM_MASK) << BLK_DESC_NUM_SHIFT);
-
+		
 		rtw_write32(Adapter, REG_TDECTRL, value32);
 	}
-
+	
 #endif
 }	// usb_AggSettingTxUpdate
 
@@ -1280,7 +1280,7 @@ static void _InitHWLed(PADAPTER Adapter)
 /*-----------------------------------------------------------------------------
  * Function:	usb_AggSettingRxUpdate()
  *
- * Overview:	Seperate TX/RX parameters update independent for TP detection and
+ * Overview:	Seperate TX/RX parameters update independent for TP detection and 
  *			dynamic TX/RX aggreagtion parameters update.
  *
  * Input:			PADAPTER
@@ -1348,7 +1348,7 @@ static void _InitHWLed(PADAPTER Adapter)
 			break;
 		case USB_RX_AGG_DISABLE:
 		default:
-			// TODO:
+			// TODO: 
 			break;
 	}
 
@@ -1409,7 +1409,7 @@ static void _InitHWLed(PADAPTER Adapter)
  *
  * Revised History:
  *	When		Who		Remark
- *	12/10/2010	MHC		Create Version 0.
+ *	12/10/2010	MHC		Create Version 0.  
  *
  *---------------------------------------------------------------------------*/
 VOID
@@ -1422,20 +1422,20 @@ static void _InitHWLed(PADAPTER Adapter)
 	struct mlme_priv	*pmlmepriv = &(Adapter->mlmepriv);
 
 	//pHalData->UsbRxHighSpeedMode = FALSE;
-	// How to measure the RX speed? We assume that when traffic is more than
+	// How to measure the RX speed? We assume that when traffic is more than 
 	if (pMgntInfo->bRegAggDMEnable == _FALSE)
 	{
 		return;	// Inf not support.
 	}
-
-
-	if (pmlmepriv->LinkDetectInfo.bHigherBusyTraffic == _TRUE &&
+	
+	
+	if (pmlmepriv->LinkDetectInfo.bHigherBusyTraffic == _TRUE && 
 		pHalData->UsbRxHighSpeedMode == _FALSE)
 	{
 		pHalData->UsbRxHighSpeedMode = _TRUE;
 		DBG_8192C("UsbAggModeSwitchCheck to HIGH\n");
 	}
-	else if (pmlmepriv->LinkDetectInfo.bHigherBusyTraffic == _FALSE &&
+	else if (pmlmepriv->LinkDetectInfo.bHigherBusyTraffic == _FALSE && 
 		pHalData->UsbRxHighSpeedMode == _TRUE)
 	{
 		pHalData->UsbRxHighSpeedMode = _FALSE;
@@ -1443,19 +1443,19 @@ static void _InitHWLed(PADAPTER Adapter)
 	}
 	else
 	{
-		return;
+		return; 
 	}
-
-	// 2010/12/10 MH Add for USB Aggregation judgement we need to
+	
+	// 2010/12/10 MH Add for USB Aggregation judgement we need to 
 	//if( pMgntInfo->LinkDetectInfo.NumRxOkInPeriod > 4000 ||
 		//			pMgntInfo->LinkDetectInfo.NumTxOkInPeriod > 4000 )
 
 #ifdef CONFIG_USB_TX_AGGREGATION
 	//usb_AggSettingTxUpdate(Adapter);
 #endif
-
+		
 #ifdef CONFIG_USB_RX_AGGREGATION
-	if (pHalData->UsbRxHighSpeedMode == _TRUE)
+	if (pHalData->UsbRxHighSpeedMode == _TRUE)	
 	{
 		// 2010/12/10 MH The parameter is tested by SD1 engineer and SD3 channel emulator.
 		// USB mode
@@ -1463,17 +1463,17 @@ static void _InitHWLed(PADAPTER Adapter)
 		pHalData->UsbRxAggBlockTimeout	= 5;
 		// Mix mode
 		pHalData->UsbRxAggPageCount		= 72;
-		pHalData->UsbRxAggPageTimeout	= 6;
+		pHalData->UsbRxAggPageTimeout	= 6;		
 	}
 	else
 	{
 		// USB mode
 		pHalData->UsbRxAggBlockCount		= pMgntInfo->RegUsbRxAggBlockCount;
-		pHalData->UsbRxAggBlockTimeout	= pMgntInfo->RegUsbRxAggBlockTimeout;
+		pHalData->UsbRxAggBlockTimeout	= pMgntInfo->RegUsbRxAggBlockTimeout;	
 		// Mix mode
 		pHalData->UsbRxAggPageCount		= pMgntInfo->RegUsbRxAggPageCount;
-		pHalData->UsbRxAggPageTimeout	= pMgntInfo->RegUsbRxAggPageTimeout;
-	}
+		pHalData->UsbRxAggPageTimeout	= pMgntInfo->RegUsbRxAggPageTimeout;	
+	}	
 #endif
 #endif
 }	// USB_AggModeSwitch
@@ -1554,15 +1554,15 @@ static void _InitHWLed(PADAPTER Adapter)
 		case RF_1T2R:
 		case RF_1T1R:
 			RT_TRACE(COMP_INIT, DBG_LOUD, ("Initializeadapter: RF_Type%s\n", (pHalData->RF_Type==RF_1T1R? "(1T1R)":"(1T2R)")));
-			Adapter->MgntInfo.MinSpaceCfg = (MAX_MSS_DENSITY_1T<<3);
+			Adapter->MgntInfo.MinSpaceCfg = (MAX_MSS_DENSITY_1T<<3);						
 			break;
 		case RF_2T2R:
 		case RF_2T2R_GREEN:
 			RT_TRACE(COMP_INIT, DBG_LOUD, ("Initializeadapter:RF_Type(2T2R)\n"));
-			Adapter->MgntInfo.MinSpaceCfg = (MAX_MSS_DENSITY_2T<<3);
+			Adapter->MgntInfo.MinSpaceCfg = (MAX_MSS_DENSITY_2T<<3);			
 			break;
 	}
-
+	
 	PlatformEFIOWrite1Byte(Adapter, REG_AMPDU_MIN_SPACE, Adapter->MgntInfo.MinSpaceCfg);
 #endif
 }
@@ -1620,12 +1620,12 @@ static void _InitHWLed(PADAPTER Adapter)
 static VOID _InitAdhocWorkaroundParams(IN PADAPTER Adapter)
 {
 #if RTL8192CU_ADHOC_WORKAROUND_SETTING
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);	
 	pHalData->RegBcnCtrlVal = rtw_read8(Adapter, REG_BCN_CTRL);
-	pHalData->RegTxPause = rtw_read8(Adapter, REG_TXPAUSE);
+	pHalData->RegTxPause = rtw_read8(Adapter, REG_TXPAUSE); 
 	pHalData->RegFwHwTxQCtrl = rtw_read8(Adapter, REG_FWHW_TXQ_CTRL+2);
 	pHalData->RegReg542 = rtw_read8(Adapter, REG_TBTT_PROHIBIT+2);
-#endif
+#endif	
 }
 
 static VOID
@@ -1637,9 +1637,9 @@ static VOID _InitAdhocWorkaroundParams(IN PADAPTER Adapter)
 {
 	rtw_write8(Adapter, REG_BCN_CTRL, (BIT4 | BIT3 | BIT1));
 	//SetBcnCtrlReg(Adapter, (BIT4 | BIT3 | BIT1), 0x00);
-	//RT_TRACE(COMP_BEACON, DBG_LOUD, ("_BeaconFunctionEnable 0x550 0x%x\n", PlatformEFIORead1Byte(Adapter, 0x550)));
+	//RT_TRACE(COMP_BEACON, DBG_LOUD, ("_BeaconFunctionEnable 0x550 0x%x\n", PlatformEFIORead1Byte(Adapter, 0x550)));			
 
-	rtw_write8(Adapter, REG_RD_CTRL+1, 0x6F);
+	rtw_write8(Adapter, REG_RD_CTRL+1, 0x6F);	
 }
 
 
@@ -1682,7 +1682,7 @@ static VOID _RfPowerSave(
 	}
 	else{
 		pHalData->eRFPowerState = eRfOn;
-		pMgntInfo->RfOffReason = 0;
+		pMgntInfo->RfOffReason = 0; 
 		if(Adapter->bInSetPower || Adapter->bResetInProgress)
 			PlatformUsbEnableInPipes(Adapter);
 		RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("InitializeAdapter8192CUsb(): RF is on.\n"));
@@ -1692,7 +1692,7 @@ static VOID _RfPowerSave(
 
 enum {
 	Antenna_Lfet = 1,
-	Antenna_Right = 2,
+	Antenna_Right = 2,	
 };
 
 static VOID
@@ -1704,18 +1704,18 @@ enum {
 	if(pHalData->AntDivCfg==0)
 		return;
 	DBG_8192C("==>  %s ....\n",__FUNCTION__);
-
+	
 	if((RF_1T1R == pHalData->rf_type))
-	{
-		rtw_write32(Adapter, REG_LEDCFG0, rtw_read32(Adapter, REG_LEDCFG0)|BIT23);
+	{	
+		rtw_write32(Adapter, REG_LEDCFG0, rtw_read32(Adapter, REG_LEDCFG0)|BIT23);	
 		PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, BIT13, 0x01);
-
+		
 		if(PHY_QueryBBReg(Adapter, rFPGA0_XA_RFInterfaceOE, 0x300) == Antenna_A)
 			pHalData->CurAntenna = Antenna_A;
 		else
 			pHalData->CurAntenna = Antenna_B;
 		DBG_8192C("%s,Cur_ant:(%x)%s\n",__FUNCTION__,pHalData->CurAntenna,(pHalData->CurAntenna == Antenna_A)?"Antenna_A":"Antenna_B");
-
+			
 }
 
 
@@ -1731,7 +1731,7 @@ enum {
 	u8	tmpvalue;
 	HAL_DATA_TYPE		*pHalData	= GET_HAL_DATA(Adapter);
 	struct pwrctrl_priv		*pwrctrlpriv = &Adapter->pwrctrlpriv;
-
+	
 	EFUSE_ShadowRead(Adapter, 1, EEPROM_RF_OPT3, (u32 *)&tmpvalue);
 
 	// 2010/08/25 MH INF priority > PDN Efuse value.
@@ -1746,7 +1746,7 @@ enum {
 
 	DBG_8192C("HalDetectPwrDownMode(): PDN=%d\n", pHalData->pwrdown);
 	return pHalData->pwrdown;
-
+		
 }	// HalDetectPwrDownMode
 
 
@@ -1764,9 +1764,9 @@ enum {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	struct dvobj_priv	*pdvobjpriv = adapter_to_dvobj(Adapter);
 
-	// If support HW radio detect, we need to enable WOL ability, otherwise, we
+	// If support HW radio detect, we need to enable WOL ability, otherwise, we 
 	// can not use FW to notify host the power state switch.
-
+	
 	EFUSE_ShadowRead(Adapter, 1, EEPROM_USB_OPTIONAL1, (u32 *)&tmpvalue);
 
 	DBG_8192C("HalDetectSelectiveSuspendMode(): SS ");
@@ -1785,7 +1785,7 @@ enum {
 	{
 		//PMGNT_INFO				pMgntInfo = &(Adapter->MgntInfo);
 
-		//if (!pMgntInfo->bRegDongleSS)
+		//if (!pMgntInfo->bRegDongleSS)	
 		//{
 		//	RT_TRACE(COMP_INIT, DBG_LOUD, ("Dongle disable SS\n"));
 			pdvobjpriv->RegUsbSS = _FALSE;
@@ -1807,14 +1807,14 @@ enum {
  *	When		Who		Remark
  *	08/23/2010	MHC		HW suspend mode switch test..
  *---------------------------------------------------------------------------*/
-static VOID
+static VOID 
 HwSuspendModeEnable92Cu(
 	IN	PADAPTER	pAdapter,
 	IN	u8			Type
 	)
 {
 	//PRT_USB_DEVICE 		pDevice = GET_RT_USB_DEVICE(pAdapter);
-	u16	reg = rtw_read16(pAdapter, REG_GPIO_MUXCFG);
+	u16	reg = rtw_read16(pAdapter, REG_GPIO_MUXCFG);	
 
 	//if (!pDevice->RegUsbSS)
 	{
@@ -1823,11 +1823,11 @@ enum {
 
 	//
 	// 2010/08/23 MH According to Alfred's suggestion, we need to to prevent HW
-	// to enter suspend mode automatically. Otherwise, it will shut down major power
+	// to enter suspend mode automatically. Otherwise, it will shut down major power 
 	// domain and 8051 will stop. When we try to enter selective suspend mode, we
 	// need to prevent HW to enter D2 mode aumotmatically. Another way, Host will
 	// issue a S10 signal to power domain. Then it will cleat SIC setting(from Yngli).
-	// We need to enable HW suspend mode when enter S3/S4 or disable. We need
+	// We need to enable HW suspend mode when enter S3/S4 or disable. We need 
 	// to disable HW suspend mode for IPS/radio_off.
 	//
 	//RT_TRACE(COMP_RF, DBG_LOUD, ("HwSuspendModeEnable92Cu = %d\n", Type));
@@ -1847,7 +1847,7 @@ enum {
 		reg &= (~BIT14);
 		rtw_write16(pAdapter, REG_GPIO_MUXCFG, reg);
 	}
-
+	
 }	// HwSuspendModeEnable92Cu
 rt_rf_power_state RfOnOffDetect(IN	PADAPTER pAdapter )
 {
@@ -1859,14 +1859,14 @@ rt_rf_power_state RfOnOffDetect(IN	PADAPTER pAdapter )
 	{
 		val8 = rtw_read8(pAdapter, REG_HSISR);
 		DBG_8192C("pwrdown, 0x5c(BIT7)=%02x\n", val8);
-		rfpowerstate = (val8 & BIT7) ? rf_off: rf_on;
+		rfpowerstate = (val8 & BIT7) ? rf_off: rf_on;				
 	}
 	else // rf on/off
 	{
 		rtw_write8(	pAdapter, REG_MAC_PINMUX_CFG,rtw_read8(pAdapter, REG_MAC_PINMUX_CFG)&~(BIT3));
 		val8 = rtw_read8(pAdapter, REG_GPIO_IO_SEL);
 		DBG_8192C("GPIO_IN=%02x\n", val8);
-		rfpowerstate = (val8 & BIT3) ? rf_on : rf_off;
+		rfpowerstate = (val8 & BIT3) ? rf_on : rf_off;	
 	}
 	return rfpowerstate;
 }	// HalDetectPwrDownMode
@@ -1988,9 +1988,9 @@ u32 rtl8192cu_hal_init(PADAPTER Adapter)
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC01);
 	_InitQueueReservedPage(Adapter);
-	_InitTxBufferBoundary(Adapter);
+	_InitTxBufferBoundary(Adapter);		
 	_InitQueuePriority(Adapter);
-	_InitPageBoundary(Adapter);
+	_InitPageBoundary(Adapter);	
 	_InitTransferPageSize(Adapter);
 
 
@@ -2015,12 +2015,12 @@ u32 rtl8192cu_hal_init(PADAPTER Adapter)
 		pHalData->fw_ractrl = _FALSE;
 		DBG_8192C("fw download fail!\n");
 		goto exit;
-	}
+	}	
 	else
 	{
 		Adapter->bFWReady = _TRUE;
 		pHalData->fw_ractrl = _TRUE;
-		DBG_8192C("fw download ok!\n");
+		DBG_8192C("fw download ok!\n");	
 	}
 #endif
 
@@ -2036,7 +2036,7 @@ u32 rtl8192cu_hal_init(PADAPTER Adapter)
 	// 2010/08/26 MH If Efuse does not support sective suspend then disable the function.
 	//HalDetectSelectiveSuspendMode(Adapter);
 
-	// Set RF type for BB/RF configuration
+	// Set RF type for BB/RF configuration	
 	_InitRFType(Adapter);//->_ReadRFType()
 
 	// Save target channel
@@ -2049,7 +2049,7 @@ u32 rtl8192cu_hal_init(PADAPTER Adapter)
 	}
 	else{// for WMM
 		boundary = WMM_NORMAL_TX_PAGE_BOUNDARY;
-	}
+	}															
 	status =  InitLLTTable(Adapter, boundary);
 	if(status == _FAIL){
 		RT_TRACE(_module_hci_hal_init_c_, _drv_err_, ("Failed to init LLT table\n"));
@@ -2071,7 +2071,7 @@ u32 rtl8192cu_hal_init(PADAPTER Adapter)
 
 	_InitInterrupt(Adapter);
 	hal_init_macaddr(Adapter);//set mac_address
-	_InitNetworkType(Adapter);//set msr
+	_InitNetworkType(Adapter);//set msr	
 	_InitWMACSetting(Adapter);
 	_InitAdaptiveCtrl(Adapter);
 	_InitEDCA(Adapter);
@@ -2097,7 +2097,7 @@ u32 rtl8192cu_hal_init(PADAPTER Adapter)
 	rtw_write16(Adapter, REG_PKT_BE_BK_LIFE_TIME, 0x3000);	// unit: 256us. 3s
 #endif	// CONFIG_TX_MCAST2UNI
 #endif	// CONFIG_CONCURRENT_MODE || CONFIG_TX_MCAST2UNI
-
+	
 
 #ifdef CONFIG_LED
 	_InitHWLed(Adapter);
@@ -2121,7 +2121,7 @@ u32 rtl8192cu_hal_init(PADAPTER Adapter)
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_RF);
 #if (HAL_RF_ENABLE == 1)
-	status = PHY_RFConfig8192C(Adapter);
+	status = PHY_RFConfig8192C(Adapter);	
 	if(status == _FAIL)
 	{
 		goto exit;
@@ -2130,7 +2130,7 @@ u32 rtl8192cu_hal_init(PADAPTER Adapter)
 	if(IS_VENDOR_UMC_A_CUT(pHalData->VersionID) && !IS_92C_SERIAL(pHalData->VersionID))
 	{
 		PHY_SetRFReg(Adapter, RF_PATH_A, RF_RX_G1, bMaskDWord, 0x30255);
-		PHY_SetRFReg(Adapter, RF_PATH_A, RF_RX_G2, bMaskDWord, 0x50a00);
+		PHY_SetRFReg(Adapter, RF_PATH_A, RF_RX_G2, bMaskDWord, 0x50a00);		
 	}
 #endif
 
@@ -2151,7 +2151,7 @@ u32 rtl8192cu_hal_init(PADAPTER Adapter)
 	// 2010/12/17 MH We need to set TX power according to EFUSE content at first.
 	PHY_SetTxPowerLevel8192C(Adapter, pHalData->CurrentChannel);
 
-// Move by Neo for USB SS to below setp
+// Move by Neo for USB SS to below setp	
 //_RfPowerSave(Adapter);
 
 	if (!IS_92C_SERIAL( pHalData->VersionID) && (pHalData->AntDivCfg!=0))
@@ -2160,7 +2160,7 @@ u32 rtl8192cu_hal_init(PADAPTER Adapter)
 	}
 
 
-	//
+	// 
 	// Disable BAR, suggested by Scott
 	// 2010.04.09 add by hpfan
 	//
@@ -2168,7 +2168,7 @@ u32 rtl8192cu_hal_init(PADAPTER Adapter)
 
 	// HW SEQ CTRL
 	//set 0x0 to 0xFF by tynli. Default enable HW SEQ NUM.
-	rtw_write8(Adapter,REG_HWSEQ_CTRL, 0xFF);
+	rtw_write8(Adapter,REG_HWSEQ_CTRL, 0xFF); 
 
 	if(pregistrypriv->wifi_spec)
 		rtw_write16(Adapter,REG_FAST_EDCA_CTRL ,0);
@@ -2182,11 +2182,11 @@ u32 rtl8192cu_hal_init(PADAPTER Adapter)
 #else
 	//
 	// 2010/08/11 MH Merge from 8192SE for Minicard init. We need to confirm current radio status
-	// and then decide to enable RF or not.!!!??? For Selective suspend mode. We may not
+	// and then decide to enable RF or not.!!!??? For Selective suspend mode. We may not 
 	// call init_adapter. May cause some problem??
 	//
-	// Fix the bug that Hw/Sw radio off before S3/S4, the RF off action will not be executed
-	// in MgntActSet_RF_State() after wake up, because the value of pHalData->eRFPowerState
+	// Fix the bug that Hw/Sw radio off before S3/S4, the RF off action will not be executed 
+	// in MgntActSet_RF_State() after wake up, because the value of pHalData->eRFPowerState 
 	// is the same as eRfOff, we should change it to eRfOn after we config RF parameters.
 	// Added by tynli. 2010.03.30.
 	pwrctrlpriv->rf_pwrstate = rf_on;
@@ -2205,12 +2205,12 @@ u32 rtl8192cu_hal_init(PADAPTER Adapter)
 		pwrctrlpriv->b_hw_radio_off = _TRUE;
 
 	DBG_8192C("eRfPowerStateToSet=%d\n", eRfPowerStateToSet);
-
+	
 	if(pwrctrlpriv->reg_rfoff == _TRUE)
 	{	// User disable RF via registry.
 		DBG_8192C("InitializeAdapter8192CU(): Turn off RF for RegRfOff.\n");
 		//MgntActSet_RF_State(Adapter, rf_off, RF_CHANGE_BY_SW, _TRUE);
-
+		
 		// Those action will be discard in MgntActSet_RF_State because off the same state
 		//for(eRFPath = 0; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
 			//PHY_SetRFReg(Adapter, (RF_RADIO_PATH_E)eRFPath, 0x4, 0xC00, 0x0);
@@ -2229,26 +2229,26 @@ u32 rtl8192cu_hal_init(PADAPTER Adapter)
 		{
 			DBG_8192C("InitializeAdapter8192CU(): RF=%d \n", eRfPowerStateToSet);
 			if (eRfPowerStateToSet == rf_off)
-			{
+			{				
 				//MgntActSet_RF_State(Adapter, rf_off, RF_CHANGE_BY_HW, _TRUE);
-				pwrctrlpriv->b_hw_radio_off = _TRUE;
+				pwrctrlpriv->b_hw_radio_off = _TRUE;	
 			}
 			else
 			{
 				pwrctrlpriv->rf_pwrstate = rf_off;
-				pwrctrlpriv->rfoff_reason = RF_CHANGE_BY_INIT;
-				pwrctrlpriv->b_hw_radio_off = _FALSE;
+				pwrctrlpriv->rfoff_reason = RF_CHANGE_BY_INIT; 
+				pwrctrlpriv->b_hw_radio_off = _FALSE;					
 				//MgntActSet_RF_State(Adapter, rf_on, pwrctrlpriv->rfoff_reason, _TRUE);
 			}
-		}
+		}	
 		else
 		{
 			pwrctrlpriv->rf_pwrstate = rf_off;
-			pwrctrlpriv->rfoff_reason = RF_CHANGE_BY_INIT;
+			pwrctrlpriv->rfoff_reason = RF_CHANGE_BY_INIT; 			
 			//MgntActSet_RF_State(Adapter, rf_on, pwrctrlpriv->rfoff_reason, _TRUE);
 		}
-
-		pwrctrlpriv->rfoff_reason = 0;
+	
+		pwrctrlpriv->rfoff_reason = 0; 
 		pwrctrlpriv->b_hw_radio_off = _FALSE;
 		pwrctrlpriv->rf_pwrstate = rf_on;
 		rtw_led_control(Adapter, LED_CTL_POWER_ON);
@@ -2268,7 +2268,7 @@ u32 rtl8192cu_hal_init(PADAPTER Adapter)
 		// 2010.10.06.
 		//
 		//if(IS_HARDWARE_TYPE_8723AU(Adapter))
-		//{
+		//{			
 		//	u1bTmp = rtw_read8(Adapter, REG_MULTI_FUNC_CTRL);
 		//	rtw_write8(Adapter, REG_MULTI_FUNC_CTRL, (u1bTmp|WL_HWPDN_EN));
 		//}
@@ -2293,7 +2293,7 @@ u32 rtl8192cu_hal_init(PADAPTER Adapter)
 			rtl8192c_PHY_IQCalibrate(Adapter,_FALSE);
 			pHalData->bIQKInitialized = _TRUE;
 		}
-
+		
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_PW_TRACK);
 		rtl8192c_dm_CheckTXPowerTracking(Adapter);
 
@@ -2318,11 +2318,11 @@ u32 rtl8192cu_hal_init(PADAPTER Adapter)
 #if 1
 	//2011/01/07 ,suggest by Johnny,for solved the problem that too many protocol error on USB bus
 	if(!IS_VENDOR_UMC_A_CUT(pHalData->VersionID) )//&& !IS_92C_SERIAL(pHalData->VersionID))// TSMC , 8188
-	{
-		// 0xE6=0x94
-		rtw_write8(Adapter, 0xFE40, 0xE6);
+	{		
+	    	// 0xE6=0x94
+	    	rtw_write8(Adapter, 0xFE40, 0xE6);
 		rtw_write8(Adapter, 0xFE41, 0x94);
-		rtw_write8(Adapter, 0xFE42, 0x80);
+		rtw_write8(Adapter, 0xFE42, 0x80); 
 
 		// 0xE0=0x19
 		rtw_write8(Adapter, 0xFE40, 0xE0);
@@ -2332,13 +2332,13 @@ u32 rtl8192cu_hal_init(PADAPTER Adapter)
 		// 0xE5=0x91
 		rtw_write8(Adapter, 0xFE40, 0xE5);
 		rtw_write8(Adapter, 0xFE41, 0x91);
-		rtw_write8(Adapter, 0xFE42, 0x80);
+		rtw_write8(Adapter, 0xFE42, 0x80); 
 
 		// 0xE2=0x81
 		rtw_write8(Adapter, 0xFE40, 0xE2);
 		rtw_write8(Adapter, 0xFE41, 0x81);
-		rtw_write8(Adapter, 0xFE42, 0x80);
-
+		rtw_write8(Adapter, 0xFE42, 0x80);    
+	
 	}
 
 #endif
@@ -2361,8 +2361,8 @@ u32 rtl8192cu_hal_init(PADAPTER Adapter)
 
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC31);
 	rtw_write8(Adapter, 0x15, 0xe9);//suggest by Johnny for lower temperature
-
-        rtw_write8(Adapter, 0xc87, 0x50);//suggest by Jackson for CCA
+        
+        rtw_write8(Adapter, 0xc87, 0x50);//suggest by Jackson for CCA  
 
 	//_dbg_dump_macreg(padapter);
 
@@ -2390,7 +2390,7 @@ u32 rtl8192cu_hal_init(PADAPTER Adapter)
 			, (hal_init_stages_timestamp[hal_init_profiling_i+1]-hal_init_stages_timestamp[hal_init_profiling_i])
 			, rtw_get_time_interval_ms(hal_init_stages_timestamp[hal_init_profiling_i], hal_init_stages_timestamp[hal_init_profiling_i+1])
 		);
-	}
+	}	
 	#endif
 
 
@@ -2412,32 +2412,32 @@ u32 rtl8192cu_hal_init(PADAPTER Adapter)
 {
 	HAL_DATA_TYPE		*pHalData = GET_HAL_DATA(Adapter);
 	u8				value8;
-
+	
 	switch( eRFPowerState )
 	{
-		case rf_on:
+		case rf_on:								
 			if (bRegSSPwrLvl == 1)
 			{
 				// 1. Enable MAC Clock. Can not be enabled now.
 				//WriteXBYTE(REG_SYS_CLKR+1, ReadXBYTE(REG_SYS_CLKR+1) | BIT(3));
-
+				
 				// 2. Force PWM, Enable SPS18_LDO_Marco_Block
-				rtw_write8(Adapter, REG_SPS0_CTRL,
+				rtw_write8(Adapter, REG_SPS0_CTRL, 
 				rtw_read8(Adapter, REG_SPS0_CTRL) | (BIT0|BIT3));
 
 				// 3. restore BB, AFE control register.
 				//RF
 				if (pHalData->rf_type ==  RF_2T2R)
-					PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, 0x380038, 1);
-				else
-					PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, 0x38, 1);
+					PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, 0x380038, 1);							
+				else								
+					PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, 0x38, 1);							
 				PHY_SetBBReg(Adapter, rOFDM0_TRxPathEnable, 0xf0, 1);
 				PHY_SetBBReg(Adapter, rFPGA0_RFMOD, BIT1, 0);
 
 				//AFE
 				//DbgPrint("0x0e70 = %x\n", Adapter->PS_BBRegBackup[PSBBREG_AFE0]);
 				//PHY_SetBBReg(Adapter, 0x0e70, bMaskDWord ,Adapter->PS_BBRegBackup[PSBBREG_AFE0] );
-				//PHY_SetBBReg(Adapter, 0x0e70, bMaskDWord ,0x631B25A0 );
+				//PHY_SetBBReg(Adapter, 0x0e70, bMaskDWord ,0x631B25A0 );				
 				if (pHalData->rf_type ==  RF_2T2R)
 					PHY_SetBBReg(Adapter, rRx_Wait_CCA, bMaskDWord ,0x63DB25A0 );
 				else if (pHalData->rf_type ==  RF_1T1R)
@@ -2450,29 +2450,29 @@ u32 rtl8192cu_hal_init(PADAPTER Adapter)
 				{
 					PHY_SetRFReg(Adapter,RF_PATH_B, 0, bRFRegOffsetMask,0x32D95);
 				}
-			}
+			}	
 			else		// Level 2 or others.
 			{
 				//h.	AFE_PLL_CTRL 0x28[7:0] = 0x80			//disable AFE PLL
 				rtw_write8(Adapter, REG_AFE_PLL_CTRL, 0x81);
-
+				
 				// i.	AFE_XTAL_CTRL 0x24[15:0] = 0x880F		//gated AFE DIG_CLOCK
 				rtw_write16(Adapter, REG_AFE_XTAL_CTRL, 0x800F);
 				rtw_mdelay_os(1);
-
+				
 				// 1. Enable MAC Clock. Can not be enabled now.
 				//WriteXBYTE(REG_SYS_CLKR+1, ReadXBYTE(REG_SYS_CLKR+1) | BIT(3));
-
+				
 				// 2. Force PWM, Enable SPS18_LDO_Marco_Block
-				rtw_write8(Adapter, REG_SPS0_CTRL,
+				rtw_write8(Adapter, REG_SPS0_CTRL, 
 				rtw_read8(Adapter, REG_SPS0_CTRL) | (BIT0|BIT3));
 
 				// 3. restore BB, AFE control register.
 				//RF
 				if (pHalData->rf_type ==  RF_2T2R)
-					PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, 0x380038, 1);
-				else
-					PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, 0x38, 1);
+					PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, 0x380038, 1);							
+				else								
+					PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, 0x38, 1);							
 				PHY_SetBBReg(Adapter, rOFDM0_TRxPathEnable, 0xf0, 1);
 				PHY_SetBBReg(Adapter, rFPGA0_RFMOD, BIT1, 0);
 
@@ -2498,17 +2498,17 @@ u32 rtl8192cu_hal_init(PADAPTER Adapter)
 					//u8 			eRFPath = RF_PATH_A,value8 = 0, retry = 0;
 					u8		bytetmp;
 					//PHY_SetRFReg(Adapter, (RF_RADIO_PATH_E)eRFPath, 0x0, bMaskByte0, 0x0);
-					// 2010/08/12 MH Add for B path under SS test.
+					// 2010/08/12 MH Add for B path under SS test. 
 					//if (pHalData->RF_Type ==  RF_2T2R)
 						//PHY_SetRFReg(Adapter, RF_PATH_B, 0x0, bMaskByte0, 0x0);
 
 					bytetmp = rtw_read8(Adapter, REG_APSD_CTRL);
 					rtw_write8(Adapter, REG_APSD_CTRL, bytetmp & ~BIT6);
-
+				
 					rtw_mdelay_os(10);
 
 					// Set BB reset at first
-					rtw_write8(Adapter, REG_SYS_FUNC_EN, 0x17 );//0x16
+					rtw_write8(Adapter, REG_SYS_FUNC_EN, 0x17 );//0x16		
 					//undo clock gated
 					rtw_write32(Adapter, rFPGA0_XCD_RFParameter, rtw_read32(Adapter, rFPGA0_XCD_RFParameter)&(~BIT31));
 					// Enable TX
@@ -2519,7 +2519,7 @@ u32 rtl8192cu_hal_init(PADAPTER Adapter)
 			}
 
 			break;
-
+	   
 		case rf_sleep:
 		case rf_off:
 				value8 = rtw_read8(Adapter, REG_SPS0_CTRL) ;
@@ -2531,7 +2531,7 @@ u32 rtl8192cu_hal_init(PADAPTER Adapter)
 				{
 					//RT_TRACE(COMP_POWER, DBG_LOUD, ("SS LVL1\n"));
 					// Disable RF and BB only for SelectSuspend.
-
+					
 					// 1. Set BB/RF to shutdown.
 					//	(1) Reg878[5:3]= 0 	// RF rx_code for preamble power saving
 					//	(2)Reg878[21:19]= 0	//Turn off RF-B
@@ -2542,22 +2542,22 @@ u32 rtl8192cu_hal_init(PADAPTER Adapter)
 					Adapter->pwrctrlpriv.PS_BBRegBackup[PSBBREG_RF2] = PHY_QueryBBReg(Adapter, rFPGA0_RFMOD, bMaskDWord);
 					if (pHalData->rf_type ==  RF_2T2R)
 					{
-						PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, 0x380038, 0);
+						PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, 0x380038, 0);							
 					}
 					else if (pHalData->rf_type ==  RF_1T1R)
 					{
-						PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, 0x38, 0);
+						PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, 0x38, 0);							
 					}
-					PHY_SetBBReg(Adapter, rOFDM0_TRxPathEnable, 0xf0, 0);
+					PHY_SetBBReg(Adapter, rOFDM0_TRxPathEnable, 0xf0, 0);						
 					PHY_SetBBReg(Adapter, rFPGA0_RFMOD, BIT1,1);
-
+					
 					// 2 .AFE control register to power down. bit[30:22]
-					Adapter->pwrctrlpriv.PS_BBRegBackup[PSBBREG_AFE0] = PHY_QueryBBReg(Adapter, rRx_Wait_CCA, bMaskDWord);
+					Adapter->pwrctrlpriv.PS_BBRegBackup[PSBBREG_AFE0] = PHY_QueryBBReg(Adapter, rRx_Wait_CCA, bMaskDWord);	
 					if (pHalData->rf_type ==  RF_2T2R)
 						PHY_SetBBReg(Adapter, rRx_Wait_CCA, bMaskDWord ,0x00DB25A0);
 					else if (pHalData->rf_type ==  RF_1T1R)
 						PHY_SetBBReg(Adapter, rRx_Wait_CCA, bMaskDWord ,0x001B25A0);
-
+					
 					// 3. issue 3-wire command that RF set to power down.
 					PHY_SetRFReg(Adapter,RF_PATH_A, 0, bRFRegOffsetMask,0);
 					if (pHalData->rf_type ==  RF_2T2R)
@@ -2565,7 +2565,7 @@ u32 rtl8192cu_hal_init(PADAPTER Adapter)
 						PHY_SetRFReg(Adapter,RF_PATH_B, 0, bRFRegOffsetMask,0);
 					}
 
-					// 4. Force PFM , disable SPS18_LDO_Marco_Block
+					// 4. Force PFM , disable SPS18_LDO_Marco_Block					
 					rtw_write8(Adapter, REG_SPS0_CTRL, value8);
 
 					// 5. gated MAC Clock
@@ -2578,7 +2578,7 @@ u32 rtl8192cu_hal_init(PADAPTER Adapter)
 						u8 			eRFPath = RF_PATH_A,value8 = 0;
 						rtw_write8(Adapter, REG_TXPAUSE, 0xFF);
 						PHY_SetRFReg(Adapter, (RF_RADIO_PATH_E)eRFPath, 0x0, bMaskByte0, 0x0);
-						// 2010/08/12 MH Add for B path under SS test.
+						// 2010/08/12 MH Add for B path under SS test. 
 						//if (pHalData->RF_Type ==  RF_2T2R)
 							//PHY_SetRFReg(Adapter, RF_PATH_B, 0x0, bMaskByte0, 0x0);
 
@@ -2590,9 +2590,9 @@ u32 rtl8192cu_hal_init(PADAPTER Adapter)
 						//before BB reset should do clock gated
 						rtw_write32(Adapter, rFPGA0_XCD_RFParameter, rtw_read32(Adapter, rFPGA0_XCD_RFParameter)|(BIT31));
 						// Set BB reset at first
-						value8 = 0 ;
+						value8 = 0 ; 
 						value8 |=( FEN_USBD | FEN_USBA | FEN_BB_GLB_RSTn);
-						rtw_write8(Adapter, REG_SYS_FUNC_EN,value8 );//0x16
+						rtw_write8(Adapter, REG_SYS_FUNC_EN,value8 );//0x16			
 					}
 
 					// Disable RF and BB only for SelectSuspend.
@@ -2607,22 +2607,22 @@ u32 rtl8192cu_hal_init(PADAPTER Adapter)
 					Adapter->pwrctrlpriv.PS_BBRegBackup[PSBBREG_RF2] = PHY_QueryBBReg(Adapter, rFPGA0_RFMOD, bMaskDWord);
 					if (pHalData->rf_type ==  RF_2T2R)
 					{
-						PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, 0x380038, 0);
+						PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, 0x380038, 0);							
 					}
 					else if (pHalData->rf_type ==  RF_1T1R)
 					{
-						PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, 0x38, 0);
+						PHY_SetBBReg(Adapter, rFPGA0_XAB_RFParameter, 0x38, 0);							
 					}
-					PHY_SetBBReg(Adapter, rOFDM0_TRxPathEnable, 0xf0, 0);
+					PHY_SetBBReg(Adapter, rOFDM0_TRxPathEnable, 0xf0, 0);						
 					PHY_SetBBReg(Adapter, rFPGA0_RFMOD, BIT1,1);
-
+					
 					// 2 .AFE control register to power down. bit[30:22]
-					Adapter->pwrctrlpriv.PS_BBRegBackup[PSBBREG_AFE0] = PHY_QueryBBReg(Adapter, rRx_Wait_CCA, bMaskDWord);
+					Adapter->pwrctrlpriv.PS_BBRegBackup[PSBBREG_AFE0] = PHY_QueryBBReg(Adapter, rRx_Wait_CCA, bMaskDWord);	
 					if (pHalData->rf_type ==  RF_2T2R)
 						PHY_SetBBReg(Adapter, rRx_Wait_CCA, bMaskDWord ,0x00DB25A0);
 					else if (pHalData->rf_type ==  RF_1T1R)
 						PHY_SetBBReg(Adapter, rRx_Wait_CCA, bMaskDWord ,0x001B25A0);
-
+					
 					// 3. issue 3-wire command that RF set to power down.
 					PHY_SetRFReg(Adapter,RF_PATH_A, 0, bRFRegOffsetMask,0);
 					if (pHalData->rf_type ==  RF_2T2R)
@@ -2644,7 +2644,7 @@ u32 rtl8192cu_hal_init(PADAPTER Adapter)
 					// 5. gated MAC Clock
 					//WriteXBYTE(REG_SYS_CLKR+1, ReadXBYTE(REG_SYS_CLKR+1) & ~(BIT(3)));
 					//PlatformEFIOWrite1Byte(Adapter, REG_SYS_CLKR+1, PlatformEFIORead1Byte(Adapter, REG_SYS_CLKR+1)& ~(BIT3))
-
+					
 					//CardSelectiveSuspendEnter(Adapter);
 				}
 
@@ -2652,8 +2652,8 @@ u32 rtl8192cu_hal_init(PADAPTER Adapter)
 
 		default:
 			break;
-	}
-
+	} 
+	
 }	// phy_PowerSwitch92CU
 
 void _ps_open_RF(_adapter *padapter) {
@@ -2669,13 +2669,13 @@ void _ps_close_RF(_adapter *padapter){
 
 
 
-static VOID
+static VOID 
 _DisableGPIO(
 	IN	PADAPTER	Adapter
 	)
 {
 /***************************************
-j. GPIO_PIN_CTRL 0x44[31:0]=0x000		//
+j. GPIO_PIN_CTRL 0x44[31:0]=0x000		// 
 k. Value = GPIO_PIN_CTRL[7:0]
 l.  GPIO_PIN_CTRL 0x44[31:0] = 0x00FF0000 | (value <<8); //write external PIN level
 m. GPIO_MUXCFG 0x42 [15:0] = 0x0780
@@ -2687,14 +2687,14 @@ void _ps_close_RF(_adapter *padapter){
 
 	//1. Disable GPIO[7:0]
 	rtw_write16(Adapter, REG_GPIO_PIN_CTRL+2, 0x0000);
-	value32 = rtw_read32(Adapter, REG_GPIO_PIN_CTRL) & 0xFFFF00FF;
+    	value32 = rtw_read32(Adapter, REG_GPIO_PIN_CTRL) & 0xFFFF00FF;  
 	value8 = (u8) (value32&0x000000FF);
 	value32 |= ((value8<<8) | 0x00FF0000);
 	rtw_write32(Adapter, REG_GPIO_PIN_CTRL, value32);
-
-	//2. Disable GPIO[10:8]
+	      
+	//2. Disable GPIO[10:8]          
 	rtw_write8(Adapter, REG_GPIO_MUXCFG+3, 0x00);
-	    value16 = rtw_read16(Adapter, REG_GPIO_MUXCFG+2) & 0xFF0F;
+	    value16 = rtw_read16(Adapter, REG_GPIO_MUXCFG+2) & 0xFF0F;  
 	value8 = (u8) (value16&0x000F);
 	value16 |= ((value8<<4) | 0x0780);
 	rtw_write16(Adapter, REG_GPIO_MUXCFG+2, value16);
@@ -2703,7 +2703,7 @@ void _ps_close_RF(_adapter *padapter){
 	rtw_write16(Adapter, REG_LEDCFG0, 0x8080);
 
 	//RT_TRACE(COMP_INIT, DBG_LOUD, ("======> Disable GPIO and LED.\n"));
-
+ 
 } //end of _DisableGPIO()
 
 static VOID
@@ -2728,7 +2728,7 @@ void _ps_close_RF(_adapter *padapter){
 	int		rtStatus = _SUCCESS;
 	u32			pollingCount = 0;
 	u8			value8;
-
+	
 	//disable RF/ AFE AD/DA
 	value8 = APSDOFF;
 	rtw_write8(Adapter, REG_APSD_CTRL, value8);
@@ -2747,9 +2747,9 @@ void _ps_close_RF(_adapter *padapter){
 			//RT_TRACE(COMP_INIT, DBG_SERIOUS, ("Failed to polling APSDOFF_STATUS done!\n"));
 			return _FAIL;
 		}
-
+				
 	}while(_TRUE);
-
+	
 #endif
 
 	//RT_TRACE(COMP_INIT, DBG_LOUD, ("Disable RF, AFE,AD, DA.\n"));
@@ -2763,7 +2763,7 @@ void _ps_close_RF(_adapter *padapter){
 	)
 {
 	u16	value16;
-
+	
 	//before BB reset should do clock gated
 	rtw_write32(Adapter, rFPGA0_XCD_RFParameter, rtw_read32(Adapter, rFPGA0_XCD_RFParameter)|(BIT31));
 	//reset BB
@@ -2779,7 +2779,7 @@ void _ps_close_RF(_adapter *padapter){
 	)
 {
 	u16	value16;
-
+	
 	// reset MCU
 	value16 = rtw_read16(Adapter, REG_SYS_FUNC_EN);
 	value16 &= ~FEN_CPUEN;
@@ -2793,12 +2793,12 @@ void _ps_close_RF(_adapter *padapter){
 	)
 {
 	u32	value32;
-
+	
 	//disable MAC/ AFE PLL
 	value32 = rtw_read32(Adapter, REG_APS_FSMCO);
 	value32 |= APDM_MAC;
 	rtw_write32(Adapter, REG_APS_FSMCO, value32);
-
+	
 	value32 |= APFM_OFF;
 	rtw_write32(Adapter, REG_APS_FSMCO, value32);
 	//RT_TRACE(COMP_INIT, DBG_LOUD, ("Disable MAC, AFE PLL.\n"));
@@ -2812,8 +2812,8 @@ void _ps_close_RF(_adapter *padapter){
 	u32			value32;
 	rtw_write8(Adapter, REG_SPS0_CTRL, 0x22);
 
-	value32 = rtw_read32(Adapter, REG_APS_FSMCO);
-
+	value32 = rtw_read32(Adapter, REG_APS_FSMCO);	
+	
 	value32 |= APDM_HOST;//card disable
 	rtw_write32(Adapter, REG_APS_FSMCO, value32);
 	//RT_TRACE(COMP_INIT, DBG_LOUD, ("Auto Power Down to Host-off state.\n"));
@@ -2833,14 +2833,14 @@ void _ps_close_RF(_adapter *padapter){
 	u32			value32;
 
 	value32 = rtw_read32(Adapter, REG_APS_FSMCO);
-
+	
 	// set USB suspend
 	value32 |= AFSM_HSUS;
 	rtw_write32(Adapter, REG_APS_FSMCO, value32);
 
 	//RT_ASSERT(0 == (rtw_read32(Adapter, REG_APS_FSMCO) & BIT(12)),(""));
 	//RT_TRACE(COMP_INIT, DBG_LOUD, ("Set USB suspend.\n"));
-
+	
 }
 
 static VOID
@@ -2863,20 +2863,20 @@ void _ps_close_RF(_adapter *padapter){
 	rtw_write8(Adapter, REG_APSD_CTRL, value8);//0x40
 	//before BB reset should do clock gated
 	rtw_write32(Adapter, rFPGA0_XCD_RFParameter, rtw_read32(Adapter, rFPGA0_XCD_RFParameter)|(BIT31));
-	value8 = 0 ;
+	value8 = 0 ; 
 	value8 |=( FEN_USBD | FEN_USBA | FEN_BB_GLB_RSTn);
-	rtw_write8(Adapter, REG_SYS_FUNC_EN,value8 );//0x16
-
+	rtw_write8(Adapter, REG_SYS_FUNC_EN,value8 );//0x16		
+	
 	value8 &=( ~FEN_BB_GLB_RSTn );
-	rtw_write8(Adapter, REG_SYS_FUNC_EN, value8); //0x14
-
+	rtw_write8(Adapter, REG_SYS_FUNC_EN, value8); //0x14		
+	
 	//RT_TRACE(COMP_INIT, DBG_LOUD, ("======> RF off and reset BB.\n"));
 }
 
 static VOID
 _ResetDigitalProcedure1(
 	IN 	PADAPTER			Adapter,
-	IN	BOOLEAN				bWithoutHWSM
+	IN	BOOLEAN				bWithoutHWSM	
 	)
 {
 
@@ -2890,7 +2890,7 @@ void _ps_close_RF(_adapter *padapter){
 		******************************/
 		u4Byte	value32 = 0;
 		PlatformIOWrite1Byte(Adapter, REG_SYS_FUNC_EN+1, 0x54);
-		PlatformIOWrite1Byte(Adapter, REG_MCUFWDL, 0);
+		PlatformIOWrite1Byte(Adapter, REG_MCUFWDL, 0);	
 		#else
 		/*****************************
 		f.	MCUFWDL 0x80[7:0]=0				// reset MCU ready status
@@ -2901,12 +2901,12 @@ void _ps_close_RF(_adapter *padapter){
 			u16 valu16 = 0;
 			rtw_write8(Adapter, REG_MCUFWDL, 0);
 
-			valu16 = rtw_read16(Adapter, REG_SYS_FUNC_EN);
+			valu16 = rtw_read16(Adapter, REG_SYS_FUNC_EN);	
 			rtw_write16(Adapter, REG_SYS_FUNC_EN, (valu16 & (~FEN_CPUEN)));//reset MCU ,8051
 
-			valu16 = rtw_read16(Adapter, REG_SYS_FUNC_EN)&0x0FFF;
+			valu16 = rtw_read16(Adapter, REG_SYS_FUNC_EN)&0x0FFF;	
 			rtw_write16(Adapter, REG_SYS_FUNC_EN, (valu16 |(FEN_HWPDN|FEN_ELDR)));//reset MAC
-
+			
 			#ifdef DBG_SHOW_MCUFWDL_BEFORE_51_ENABLE
 			{
 				u8 val;
@@ -2915,37 +2915,37 @@ void _ps_close_RF(_adapter *padapter){
 			}
 			#endif
 
+			
+			valu16 = rtw_read16(Adapter, REG_SYS_FUNC_EN);	
+			rtw_write16(Adapter, REG_SYS_FUNC_EN, (valu16 | FEN_CPUEN));//enable MCU ,8051	
 
-			valu16 = rtw_read16(Adapter, REG_SYS_FUNC_EN);
-			rtw_write16(Adapter, REG_SYS_FUNC_EN, (valu16 | FEN_CPUEN));//enable MCU ,8051
-
-
+		
 		#endif
 	}
 	else{
-		u8 retry_cnts = 0;
-
+		u8 retry_cnts = 0;	
+		
 		if(rtw_read8(Adapter, REG_MCUFWDL) & BIT1)
-		{ //IF fw in RAM code, do reset
+		{ //IF fw in RAM code, do reset 
 
 			rtw_write8(Adapter, REG_MCUFWDL, 0);
 			if(Adapter->bFWReady){
 				// 2010/08/25 MH Accordign to RD alfred's suggestion, we need to disable other
 				// HRCV INT to influence 8051 reset.
 				rtw_write8(Adapter, REG_FWIMR, 0x20);
-
+				
 				rtw_write8(Adapter, REG_HMETFR+3, 0x20);//8051 reset by self
 
 				while( (retry_cnts++ <100) && (FEN_CPUEN &rtw_read16(Adapter, REG_SYS_FUNC_EN)))
-				{
+				{					
 					rtw_udelay_os(50);//PlatformStallExecution(50);//us
 				}
 
 				if(retry_cnts >= 100){
 					DBG_8192C("%s #####=> 8051 reset failed!.........................\n", __FUNCTION__);
 					// if 8051 reset fail we trigger GPIO 0 for LA
-					//PlatformEFIOWrite4Byte(	Adapter,
-					//						REG_GPIO_PIN_CTRL,
+					//PlatformEFIOWrite4Byte(	Adapter, 
+					//						REG_GPIO_PIN_CTRL, 
 					//						0x00010100);
 					// 2010/08/31 MH According to Filen's info, if 8051 reset fail, reset MAC directly.
 					rtw_write8(Adapter, REG_SYS_FUNC_EN+1, 0x50);	//Reset MAC and Enable 8051
@@ -2956,13 +2956,13 @@ void _ps_close_RF(_adapter *padapter){
 				}
 			}
 			else {
-				DBG_871X("%s =====> 8051 in RAM but !Adapter->bFWReady\n", __FUNCTION__);
+				DBG_871X("%s =====> 8051 in RAM but !Adapter->bFWReady\n", __FUNCTION__);	
 			}
 		}
 		else{
 			//DBG_871X("%s =====> 8051 in ROM.\n", __FUNCTION__);
-		}
-
+		}	
+		
 		#ifdef DBG_SHOW_MCUFWDL_BEFORE_51_ENABLE
 		{
 			u8 val;
@@ -2970,7 +2970,7 @@ void _ps_close_RF(_adapter *padapter){
 				DBG_871X("DBG_SHOW_MCUFWDL_BEFORE_51_ENABLE %s:%d REG_MCUFWDL:0x%02x\n", __FUNCTION__, __LINE__, val);
 		}
 		#endif
-
+		
 		rtw_write8(Adapter, REG_SYS_FUNC_EN+1, 0x54);	//Reset MAC and Enable 8051
 	}
 
@@ -2984,16 +2984,16 @@ void _ps_close_RF(_adapter *padapter){
 	h.	AFE_PLL_CTRL 0x28[7:0] = 0x80			//disable AFE PLL
 	i.	AFE_XTAL_CTRL 0x24[15:0] = 0x880F		//gated AFE DIG_CLOCK
 	j.	SYS_ISO_CTRL 0x00[7:0] = 0xF9			// isolated digital to PON
-	******************************/
+	******************************/	
 		//rtw_write16(Adapter, REG_SYS_CLKR, 0x30A3);
 		rtw_write16(Adapter, REG_SYS_CLKR, 0x70A3);//modify to 0x70A3 by Scott.
-		rtw_write8(Adapter, REG_AFE_PLL_CTRL, 0x80);
+		rtw_write8(Adapter, REG_AFE_PLL_CTRL, 0x80);		
 		rtw_write16(Adapter, REG_AFE_XTAL_CTRL, 0x880F);
-		rtw_write8(Adapter, REG_SYS_ISO_CTRL, 0xF9);
+		rtw_write8(Adapter, REG_SYS_ISO_CTRL, 0xF9);		
 	}
 	else
-	{
-		// Disable all RF/BB power
+	{		
+		// Disable all RF/BB power 
 		rtw_write8(Adapter, REG_RF_CTRL, 0x00);
 	}
 	//RT_TRACE(COMP_INIT, DBG_LOUD, ("======> Reset Digital.\n"));
@@ -3014,40 +3014,40 @@ void _ps_close_RF(_adapter *padapter){
 	//rtw_write16(Adapter, REG_SYS_CLKR, 0x3083);
 	//rtw_write8(Adapter, REG_SYS_ISO_CTRL+1, 0x83);
 
-	rtw_write16(Adapter, REG_SYS_CLKR, 0x70a3); //modify to 0x70a3 by Scott.
-	rtw_write8(Adapter, REG_SYS_ISO_CTRL+1, 0x82); //modify to 0x82 by Scott.
+ 	rtw_write16(Adapter, REG_SYS_CLKR, 0x70a3); //modify to 0x70a3 by Scott.
+ 	rtw_write8(Adapter, REG_SYS_ISO_CTRL+1, 0x82); //modify to 0x82 by Scott.
 }
 
 static VOID
 _DisableAnalog(
 	IN PADAPTER			Adapter,
-	IN BOOLEAN			bWithoutHWSM
+	IN BOOLEAN			bWithoutHWSM	
 	)
 {
 	u16 value16 = 0;
 	u8 value8=0;
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-
+	
 	if(bWithoutHWSM){
 	/*****************************
 	n.	LDOA15_CTRL 0x20[7:0] = 0x04		// disable A15 power
 	o.	LDOV12D_CTRL 0x21[7:0] = 0x54		// disable digital core power
-	r.	When driver call disable, the ASIC will turn off remaining clock automatically
+	r.	When driver call disable, the ASIC will turn off remaining clock automatically 
 	******************************/
-
+	
 		rtw_write8(Adapter, REG_LDOA15_CTRL, 0x04);
-		//PlatformIOWrite1Byte(Adapter, REG_LDOV12D_CTRL, 0x54);
-
-		value8 = rtw_read8(Adapter, REG_LDOV12D_CTRL);
+		//PlatformIOWrite1Byte(Adapter, REG_LDOV12D_CTRL, 0x54);		
+		
+		value8 = rtw_read8(Adapter, REG_LDOV12D_CTRL);		
 		value8 &= (~LDV12_EN);
-		rtw_write8(Adapter, REG_LDOV12D_CTRL, value8);
+		rtw_write8(Adapter, REG_LDOV12D_CTRL, value8);	
 		//RT_TRACE(COMP_INIT, DBG_LOUD, (" REG_LDOV12D_CTRL Reg0x21:0x%02x.\n",value8));
 	}
-
+	
 /*****************************
 h.	SPS0_CTRL 0x11[7:0] = 0x23			//enter PFM mode
-i.	APS_FSMCO 0x04[15:0] = 0x4802		// set USB suspend
-******************************/
+i.	APS_FSMCO 0x04[15:0] = 0x4802		// set USB suspend 
+******************************/	
 
 
 	value8 = 0x23;
@@ -3058,32 +3058,32 @@ void _ps_close_RF(_adapter *padapter){
 
 
 	if(bWithoutHWSM)
-	{
+	{			
 		//value16 |= (APDM_HOST | /*AFSM_HSUS |*/PFM_ALDN);
 		// 2010/08/31 According to Filen description, we need to use HW to shut down 8051 automatically.
 		// Becasue suspend operatione need the asistance of 8051 to wait for 3ms.
 		value16 |= (APDM_HOST | AFSM_HSUS |PFM_ALDN);
 	}
 	else
-	{
+	{			
 		value16 |= (APDM_HOST | AFSM_HSUS |PFM_ALDN);
 	}
 
-	rtw_write16(Adapter, REG_APS_FSMCO,value16 );//0x4802
+	rtw_write16(Adapter, REG_APS_FSMCO,value16 );//0x4802 
 
 	rtw_write8(Adapter, REG_RSV_CTRL, 0x0e);
 
  #if 0
-	//tynli_test for suspend mode.
+ 	//tynli_test for suspend mode.
 	if(!bWithoutHWSM){
-		rtw_write8(Adapter, 0xfe10, 0x19);
-	}
+ 		rtw_write8(Adapter, 0xfe10, 0x19);
+	} 
 #endif
 
 	//RT_TRACE(COMP_INIT, DBG_LOUD, ("======> Disable Analog Reg0x04:0x%04x.\n",value16));
 }
 
-static int
+static int	
 CardDisableHWSM( // HW Auto state machine
 	IN	PADAPTER		Adapter,
 	IN	BOOLEAN			resetMCU
@@ -3099,7 +3099,7 @@ void _ps_close_RF(_adapter *padapter){
 
 	//  ==== Reset digital sequence   ======
 	_ResetDigitalProcedure1(Adapter, _FALSE);
-
+	
 	//  ==== Pull GPIO PIN to balance level and LED control ======
 	_DisableGPIO(Adapter);
 
@@ -3109,7 +3109,7 @@ void _ps_close_RF(_adapter *padapter){
 	RT_TRACE(_module_hci_hal_init_c_, _drv_info_, ("======> Card disable finished.\n"));
 #else
 	_DisableGPIO(Adapter);
-
+	
 	//reset FW download register
 	_ResetFWDownloadRegister(Adapter);
 
@@ -3128,17 +3128,17 @@ void _ps_close_RF(_adapter *padapter){
 
 	_AutoPowerDownToHostOff(Adapter);
 	//_DisableMAC_AFE_PLL(Adapter);
-
+	
 	_SetUsbSuspend(Adapter);
 Exit:
 #endif
 	return rtStatus;
-
+	
 }
 
-static int
+static int	
 CardDisableWithoutHWSM( // without HW Auto state machine
-	IN	PADAPTER		Adapter
+	IN	PADAPTER		Adapter	
 	)
 {
 	int		rtStatus = _SUCCESS;
@@ -3169,9 +3169,9 @@ static void rtl8192cu_hw_power_down(_adapter *padapter)
 {
 	// 2010/-8/09 MH For power down module, we need to enable register block contrl reg at 0x1c.
 	// Then enable power down control bit of register 0x04 BIT4 and BIT15 as 1.
-
+		
 	// Enable register area 0x0-0xc.
-	rtw_write8(padapter,REG_RSV_CTRL, 0x0);
+	rtw_write8(padapter,REG_RSV_CTRL, 0x0);			
 	rtw_write16(padapter, REG_APS_FSMCO, 0x8812);
 }
 
@@ -3179,7 +3179,7 @@ u32 rtl8192cu_hal_deinit(PADAPTER Adapter)
  {
 
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
-	DBG_8192C("==> %s \n",__FUNCTION__);
+   	DBG_8192C("==> %s \n",__FUNCTION__);
 	// 2011/02/18 To Fix RU LNA  power leakage problem. We need to execute below below in
 	// Adapter init and halt sequence. Accordingto EEchou's opinion, we can enable the ability for all
 	// IC. Accord to johnny's opinion, only RU need the support.
@@ -3187,13 +3187,13 @@ u32 rtl8192cu_hal_deinit(PADAPTER Adapter)
 		rtw_write32(Adapter, rFPGA0_XCD_RFParameter, rtw_read32(Adapter, rFPGA0_XCD_RFParameter)|BIT1);
 
  #ifdef SUPPORT_HW_RFOFF_DETECTED
-	DBG_8192C("bkeepfwalive(%x)\n",Adapter->pwrctrlpriv.bkeepfwalive);
-	if(Adapter->pwrctrlpriv.bkeepfwalive)
-	{
-		_ps_close_RF(Adapter);
-		if((Adapter->pwrctrlpriv.bHWPwrPindetect) && (Adapter->pwrctrlpriv.bHWPowerdown))
+ 	DBG_8192C("bkeepfwalive(%x)\n",Adapter->pwrctrlpriv.bkeepfwalive);
+ 	if(Adapter->pwrctrlpriv.bkeepfwalive)
+ 	{
+		_ps_close_RF(Adapter);		
+		if((Adapter->pwrctrlpriv.bHWPwrPindetect) && (Adapter->pwrctrlpriv.bHWPowerdown))		
 			rtl8192cu_hw_power_down(Adapter);
-	}
+ 	}
 	else
 #endif
 	{
@@ -3205,20 +3205,20 @@ u32 rtl8192cu_hal_deinit(PADAPTER Adapter)
 		else
 		{
 			DBG_8192C("card disble without HWSM...........\n");
-			CardDisableWithoutHWSM(Adapter); // without HW Auto state machine
+			CardDisableWithoutHWSM(Adapter); // without HW Auto state machine		
 
-			if((Adapter->pwrctrlpriv.bHWPwrPindetect ) && (Adapter->pwrctrlpriv.bHWPowerdown))
+			if((Adapter->pwrctrlpriv.bHWPwrPindetect ) && (Adapter->pwrctrlpriv.bHWPowerdown))		
 				rtl8192cu_hw_power_down(Adapter);
 		}
 	}
-
+	
 	return _SUCCESS;
  }
 
 
 unsigned int rtl8192cu_inirp_init(PADAPTER Adapter)
-{
-	u8 i;
+{	
+	u8 i;	
 	struct recv_buf *precvbuf;
 	uint	status;
 	struct dvobj_priv *pdev = adapter_to_dvobj(Adapter);
@@ -3235,12 +3235,12 @@ unsigned int rtl8192cu_inirp_init(PADAPTER Adapter)
 
 	status = _SUCCESS;
 
-	RT_TRACE(_module_hci_hal_init_c_,_drv_info_,("===> usb_inirp_init \n"));
-
+	RT_TRACE(_module_hci_hal_init_c_,_drv_info_,("===> usb_inirp_init \n"));	
+		
 	precvpriv->ff_hwaddr = RECV_BULK_IN_ADDR;
 
-	//issue Rx irp to receive data
-	precvbuf = (struct recv_buf *)precvpriv->precv_buf;
+	//issue Rx irp to receive data	
+	precvbuf = (struct recv_buf *)precvpriv->precv_buf;	
 	for(i=0; i<NR_RECVBUFF; i++)
 	{
 		if(_read_port(pintfhdl, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf) == _FALSE )
@@ -3249,8 +3249,8 @@ unsigned int rtl8192cu_inirp_init(PADAPTER Adapter)
 			status = _FAIL;
 			goto exit;
 		}
-
-		precvbuf++;
+		
+		precvbuf++;		
 		precvpriv->free_recv_buf_queue_cnt--;
 	}
 
@@ -3264,7 +3264,7 @@ unsigned int rtl8192cu_inirp_init(PADAPTER Adapter)
 #endif
 
 exit:
-
+	
 	RT_TRACE(_module_hci_hal_init_c_,_drv_info_,("<=== usb_inirp_init \n"));
 
 _func_exit_;
@@ -3274,9 +3274,9 @@ unsigned int rtl8192cu_inirp_init(PADAPTER Adapter)
 }
 
 unsigned int rtl8192cu_inirp_deinit(PADAPTER Adapter)
-{
+{	
 	RT_TRACE(_module_hci_hal_init_c_,_drv_info_,("\n ===> usb_rx_deinit \n"));
-
+	
 	rtw_read_port_cancel(Adapter);
 
 	RT_TRACE(_module_hci_hal_init_c_,_drv_info_,("\n <=== usb_rx_deinit \n"));
@@ -3302,25 +3302,25 @@ unsigned int rtl8192cu_inirp_deinit(PADAPTER Adapter)
 
 	_rtw_memset(pwrInfo, 0, sizeof(TxPowerInfo));
 
-	if(AutoLoadFail){
+	if(AutoLoadFail){		
 		for(group = 0 ; group < CHANNEL_GROUP_MAX ; group++){
 			for(rfPath = 0 ; rfPath < RF_PATH_MAX ; rfPath++){
-				pwrInfo->CCKIndex[rfPath][group]		= EEPROM_Default_TxPowerLevel;
+				pwrInfo->CCKIndex[rfPath][group]		= EEPROM_Default_TxPowerLevel;	
 				pwrInfo->HT40_1SIndex[rfPath][group]	= EEPROM_Default_TxPowerLevel;
 				pwrInfo->HT40_2SIndexDiff[rfPath][group]= EEPROM_Default_HT40_2SDiff;
 				pwrInfo->HT20IndexDiff[rfPath][group]	= EEPROM_Default_HT20_Diff;
 				pwrInfo->OFDMIndexDiff[rfPath][group]	= EEPROM_Default_LegacyHTTxPowerDiff;
-				pwrInfo->HT40MaxOffset[rfPath][group]	= EEPROM_Default_HT40_PwrMaxOffset;
+				pwrInfo->HT40MaxOffset[rfPath][group]	= EEPROM_Default_HT40_PwrMaxOffset;		
 				pwrInfo->HT20MaxOffset[rfPath][group]	= EEPROM_Default_HT20_PwrMaxOffset;
 			}
 		}
 
 		pwrInfo->TSSI_A = EEPROM_Default_TSSI;
 		pwrInfo->TSSI_B = EEPROM_Default_TSSI;
-
+		
 		return;
 	}
-
+	
 	for(rfPath = 0 ; rfPath < RF_PATH_MAX ; rfPath++){
 		for(group = 0 ; group < CHANNEL_GROUP_MAX ; group++){
 			eeAddr = EEPROM_CCK_TX_PWR_INX + (rfPath * 3) + group;
@@ -3333,7 +3333,7 @@ unsigned int rtl8192cu_inirp_deinit(PADAPTER Adapter)
 
 	for(group = 0 ; group < CHANNEL_GROUP_MAX ; group++){
 		for(rfPath = 0 ; rfPath < RF_PATH_MAX ; rfPath++){
-			pwrInfo->HT40_2SIndexDiff[rfPath][group] =
+			pwrInfo->HT40_2SIndexDiff[rfPath][group] = 
 			(PROMContent[EEPROM_HT40_2S_TX_PWR_INX_DIFF + group] >> (rfPath * 4)) & 0xF;
 
 #if 1
@@ -3377,7 +3377,7 @@ unsigned int rtl8192cu_inirp_deinit(PADAPTER Adapter)
 		return 1;
 	}
 
-	return 2;				// Channel 10~14
+	return 2;				// Channel 10~14	
 }
 
 
@@ -3421,10 +3421,10 @@ unsigned int rtl8192cu_inirp_deinit(PADAPTER Adapter)
 
 	for(rfPath = 0 ; rfPath < RF_PATH_MAX ; rfPath++){
 		for(ch = 0 ; ch < CHANNEL_MAX_NUMBER ; ch++){
-			RTPRINT(FINIT, INIT_TxPower,
-				("RF(%d)-Ch(%d) [CCK / HT40_1S / HT40_2S] = [0x%x / 0x%x / 0x%x]\n",
-				rfPath, ch, pHalData->TxPwrLevelCck[rfPath][ch],
-				pHalData->TxPwrLevelHT40_1S[rfPath][ch],
+			RTPRINT(FINIT, INIT_TxPower, 
+				("RF(%d)-Ch(%d) [CCK / HT40_1S / HT40_2S] = [0x%x / 0x%x / 0x%x]\n", 
+				rfPath, ch, pHalData->TxPwrLevelCck[rfPath][ch], 
+				pHalData->TxPwrLevelHT40_1S[rfPath][ch], 
 				pHalData->TxPwrLevelHT40_2S[rfPath][ch]));
 
 		}
@@ -3437,15 +3437,15 @@ unsigned int rtl8192cu_inirp_deinit(PADAPTER Adapter)
 	for(ch = 0 ; ch < CHANNEL_MAX_NUMBER ; ch++){
 		RTPRINT(FINIT, INIT_TxPower, ("RF-A Legacy to Ht40 Diff[%d] = 0x%x\n", ch, pHalData->TxPwrLegacyHtDiff[RF_PATH_A][ch]));
 	}
-
+	
 	for(ch = 0 ; ch < CHANNEL_MAX_NUMBER ; ch++){
 		RTPRINT(FINIT, INIT_TxPower, ("RF-B Ht20 to HT40 Diff[%d] = 0x%x\n", ch, pHalData->TxPwrHt20Diff[RF_PATH_B][ch]));
 	}
-
+	
 	for(ch = 0 ; ch < CHANNEL_MAX_NUMBER ; ch++){
 		RTPRINT(FINIT, INIT_TxPower, ("RF-B Legacy to HT40 Diff[%d] = 0x%x\n", ch, pHalData->TxPwrLegacyHtDiff[RF_PATH_B][ch]));
 	}
-
+	
 #endif
 	// 2010/10/19 MH Add Regulator recognize for CU.
 	if(!AutoLoadFail)
@@ -3476,11 +3476,11 @@ unsigned int rtl8192cu_inirp_deinit(PADAPTER Adapter)
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 
 	if(_FALSE == AutoloadFail){
-		// VID, PID
+		// VID, PID 
 		pHalData->EEPROMVID = le16_to_cpu( *(u16 *)&PROMContent[EEPROM_VID]);
 		pHalData->EEPROMPID = le16_to_cpu( *(u16 *)&PROMContent[EEPROM_PID]);
-
-		// Customer ID, 0x00 and 0xff are reserved for Realtek.
+		
+		// Customer ID, 0x00 and 0xff are reserved for Realtek. 		
 		pHalData->EEPROMCustomerID = *(u8 *)&PROMContent[EEPROM_CUSTOMER_ID];
 		pHalData->EEPROMSubCustomerID = *(u8 *)&PROMContent[EEPROM_SUBCUSTOMER_ID];
 
@@ -3489,7 +3489,7 @@ unsigned int rtl8192cu_inirp_deinit(PADAPTER Adapter)
 		pHalData->EEPROMVID	 = EEPROM_Default_VID;
 		pHalData->EEPROMPID	 = EEPROM_Default_PID;
 
-		// Customer ID, 0x00 and 0xff are reserved for Realtek.
+		// Customer ID, 0x00 and 0xff are reserved for Realtek. 		
 		pHalData->EEPROMCustomerID	= EEPROM_Default_CustomerID;
 		pHalData->EEPROMSubCustomerID = EEPROM_Default_SubCustomerID;
 
@@ -3511,7 +3511,7 @@ unsigned int rtl8192cu_inirp_deinit(PADAPTER Adapter)
 				pHalData->CustomerID = RT_CID_DLINK;
 			break;
 		case EEPROM_CID_WHQL:
-/*
+/*			
 			Adapter->bInHctTest = TRUE;
 
 			pMgntInfo->bSupportTurboMode = FALSE;
@@ -3520,16 +3520,16 @@ unsigned int rtl8192cu_inirp_deinit(PADAPTER Adapter)
 			pMgntInfo->PowerSaveControl.bInactivePs = FALSE;
 			pMgntInfo->PowerSaveControl.bIPSModeBackup = FALSE;
 			pMgntInfo->PowerSaveControl.bLeisurePs = FALSE;
-
+				
 			pMgntInfo->keepAliveLevel = 0;
 
 			Adapter->bUnloadDriverwhenS3S4 = FALSE;
-*/
+*/				
 			break;
 		default:
 			pHalData->CustomerID = RT_CID_DEFAULT;
 			break;
-
+			
 	}
 
 	MSG_8192C("EEPROMVID = 0x%04x\n", pHalData->EEPROMVID);
@@ -3544,7 +3544,7 @@ unsigned int rtl8192cu_inirp_deinit(PADAPTER Adapter)
 
 static VOID
 _ReadMACAddress(
-	IN	PADAPTER	Adapter,
+	IN	PADAPTER	Adapter,	
 	IN	u8*		PROMContent,
 	IN	BOOLEAN		AutoloadFail
 	)
@@ -3553,13 +3553,13 @@ unsigned int rtl8192cu_inirp_deinit(PADAPTER Adapter)
 
 	if(_FALSE == AutoloadFail){
 		//Read Permanent MAC address and set value to hardware
-		_rtw_memcpy(pEEPROM->mac_addr, &PROMContent[EEPROM_MAC_ADDR], ETH_ALEN);
+		_rtw_memcpy(pEEPROM->mac_addr, &PROMContent[EEPROM_MAC_ADDR], ETH_ALEN);		
 	}
 	else{
 		//Random assigh MAC address
 		u8 sMacAddr[MAC_ADDR_LEN] = {0x00, 0xE0, 0x4C, 0x81, 0x92, 0x00};
-		//sMacAddr[5] = (u8)GetRandomNumber(1, 254);
-		_rtw_memcpy(pEEPROM->mac_addr, sMacAddr, ETH_ALEN);
+		//sMacAddr[5] = (u8)GetRandomNumber(1, 254);		
+		_rtw_memcpy(pEEPROM->mac_addr, sMacAddr, ETH_ALEN);	
 	}
 	DBG_8192C("%s MAC Address from EFUSE = "MAC_FMT"\n",__FUNCTION__, MAC_ARG(pEEPROM->mac_addr));
 	//NicIFSetMacAddress(Adapter, Adapter->PermanentAddress);
@@ -3569,7 +3569,7 @@ unsigned int rtl8192cu_inirp_deinit(PADAPTER Adapter)
 
 static VOID
 _ReadBoardType(
-	IN	PADAPTER	Adapter,
+	IN	PADAPTER	Adapter,	
 	IN	u8*		PROMContent,
 	IN	BOOLEAN		AutoloadFail
 	)
@@ -3603,7 +3603,7 @@ unsigned int rtl8192cu_inirp_deinit(PADAPTER Adapter)
 
 static VOID
 _ReadLEDSetting(
-	IN	PADAPTER	Adapter,
+	IN	PADAPTER	Adapter,	
 	IN	u8*		PROMContent,
 	IN	BOOLEAN		AutoloadFail
 	)
@@ -3644,7 +3644,7 @@ unsigned int rtl8192cu_inirp_deinit(PADAPTER Adapter)
 
 static VOID
 _ReadThermalMeter(
-	IN	PADAPTER	Adapter,
+	IN	PADAPTER	Adapter,	
 	IN	u8* 	PROMContent,
 	IN	BOOLEAN 	AutoloadFail
 	)
@@ -3656,11 +3656,11 @@ unsigned int rtl8192cu_inirp_deinit(PADAPTER Adapter)
 	//
 	// ThermalMeter from EEPROM
 	//
-	if(!AutoloadFail)
+	if(!AutoloadFail)	
 		tempval = PROMContent[EEPROM_THERMAL_METER];
 	else
 		tempval = EEPROM_Default_ThermalMeter;
-
+	
 	pHalData->EEPROMThermalMeter = (tempval&0x1f);	//[4:0]
 
 	if(pHalData->EEPROMThermalMeter == 0x1f || AutoloadFail)
@@ -3672,14 +3672,14 @@ unsigned int rtl8192cu_inirp_deinit(PADAPTER Adapter)
 #endif
 
 	pdmpriv->ThermalMeter[0] = pHalData->EEPROMThermalMeter;
-
+	
 	//RTPRINT(FINIT, INIT_TxPower, ("ThermalMeter = 0x%x\n", pHalData->EEPROMThermalMeter));
-
+	
 }
 
 static VOID
 _ReadRFSetting(
-	IN	PADAPTER	Adapter,
+	IN	PADAPTER	Adapter,	
 	IN	u8* 	PROMContent,
 	IN	BOOLEAN 	AutoloadFail
 	)
@@ -3688,7 +3688,7 @@ unsigned int rtl8192cu_inirp_deinit(PADAPTER Adapter)
 
 static void
 _ReadPROMVersion(
-	IN	PADAPTER	Adapter,
+	IN	PADAPTER	Adapter,	
 	IN	u8* 	PROMContent,
 	IN	BOOLEAN 	AutoloadFail
 	)
@@ -3696,7 +3696,7 @@ unsigned int rtl8192cu_inirp_deinit(PADAPTER Adapter)
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 
 	if(AutoloadFail){
-		pHalData->EEPROMVersion = EEPROM_Default_Version;
+		pHalData->EEPROMVersion = EEPROM_Default_Version;		
 	}
 	else{
 		pHalData->EEPROMVersion = *(u8 *)&PROMContent[EEPROM_VERSION];
@@ -3716,13 +3716,13 @@ unsigned int rtl8192cu_inirp_deinit(PADAPTER Adapter)
 
 	if(!AutoLoadFail)
 	{
-		// Antenna Diversity setting.
+		// Antenna Diversity setting. 
 		if(registry_par->antdiv_cfg == 2) // 2: From Efuse
 			pHalData->AntDivCfg = (hwinfo[EEPROM_RF_OPT1]&0x18)>>3;
 		else
 			pHalData->AntDivCfg = registry_par->antdiv_cfg ;  // 0:OFF , 1:ON,
 
-		DBG_8192C("### AntDivCfg(%x)\n",pHalData->AntDivCfg);
+		DBG_8192C("### AntDivCfg(%x)\n",pHalData->AntDivCfg);	
 
 		//if(pHalData->EEPROMBluetoothCoexist!=0 && pHalData->EEPROMBluetoothAntNum==Ant_x1)
 		//	pHalData->AntDivCfg = 0;
@@ -3753,7 +3753,7 @@ unsigned int rtl8192cu_inirp_deinit(PADAPTER Adapter)
 			for(i = 0; i < HWSET_MAX_SIZE; i += 2)
 			{
 				//value16 = EF2Byte(ReadEEprom(pAdapter, (u2Byte) (i>>1)));
-				//*((u16 *)(&PROMContent[i])) = value16;
+				//*((u16 *)(&PROMContent[i])) = value16; 				
 			}
 		}
 		else
@@ -3765,14 +3765,14 @@ unsigned int rtl8192cu_inirp_deinit(PADAPTER Adapter)
 	}
 	else
 	{//autoload fail
-		//RT_TRACE(COMP_INIT, DBG_LOUD, ("AutoLoad Fail reported from CR9346!!\n"));
+		//RT_TRACE(COMP_INIT, DBG_LOUD, ("AutoLoad Fail reported from CR9346!!\n")); 
 		pEEPROM->bautoload_fail_flag = _TRUE;
 		//update to default value 0xFF
-		if (_FALSE == pEEPROM->EepromOrEfuse)
-		EFUSE_ShadowMapUpdate(pAdapter, EFUSE_WIFI, _FALSE);
+		if (_FALSE == pEEPROM->EepromOrEfuse)		
+		EFUSE_ShadowMapUpdate(pAdapter, EFUSE_WIFI, _FALSE);	
 	}
 }
-// Read HW power down mode selection
+// Read HW power down mode selection 
 static void _ReadPSSetting(IN PADAPTER Adapter,IN u8*PROMContent,IN u8	AutoloadFail)
 {
 	if(AutoloadFail){
@@ -3784,30 +3784,30 @@ static void _ReadPSSetting(IN PADAPTER Adapter,IN u8*PROMContent,IN u8	AutoloadF
 			Adapter->pwrctrlpriv.bHWPwrPindetect = Adapter->registrypriv.hwpwrp_detect;
 		//else
 			//Adapter->pwrctrlpriv.bHWPwrPindetect = _FALSE;//dongle not support new
-
-
+			
+			
 		//hw power down mode selection , 0:rf-off / 1:power down
 
 		if(Adapter->registrypriv.hwpdn_mode==2)
 			Adapter->pwrctrlpriv.bHWPowerdown = (PROMContent[EEPROM_RF_OPT3] & BIT4);
 		else
 			Adapter->pwrctrlpriv.bHWPowerdown = Adapter->registrypriv.hwpdn_mode;
-#ifdef CONFIG_WOWLAN
+#ifdef CONFIG_WOWLAN			
 		// decide hw if support remote wakeup function
 		// if hw supported, 8051 (SIE) will generate WeakUP signal( D+/D- toggle) when autoresume
 		Adapter->pwrctrlpriv.bSupportRemoteWakeup = (PROMContent[EEPROM_TEST_USB_OPT] & BIT1)?_TRUE :_FALSE;
 #endif //CONFIG_WOWLAN
 
-		//if(SUPPORT_HW_RADIO_DETECT(Adapter))
+		//if(SUPPORT_HW_RADIO_DETECT(Adapter))	
 			//Adapter->registrypriv.usbss_enable = Adapter->pwrctrlpriv.bSupportRemoteWakeup ;
-
+		
 		DBG_8192C("%s...bHWPwrPindetect(%x)-bHWPowerdown(%x) ,bSupportRemoteWakeup(%x)\n",__FUNCTION__,
 		Adapter->pwrctrlpriv.bHWPwrPindetect,Adapter->pwrctrlpriv.bHWPowerdown ,Adapter->pwrctrlpriv.bSupportRemoteWakeup);
 
 		DBG_8192C("### PS params=>  power_mgnt(%x),usbss_enable(%x) ###\n",Adapter->registrypriv.power_mgnt,Adapter->registrypriv.usbss_enable);
-
+		
 	}
-
+	
 }
 
 static VOID
@@ -3821,10 +3821,10 @@ static void _ReadPSSetting(IN PADAPTER Adapter,IN u8*PROMContent,IN u8	AutoloadF
 
 	hal_InitPGData(Adapter, PROMContent);
 	rtl8192c_EfuseParseIDCode(Adapter, PROMContent);
-
+	
 	_ReadPROMVersion(Adapter, PROMContent, pEEPROM->bautoload_fail_flag);
 	_ReadIDs(Adapter, PROMContent, pEEPROM->bautoload_fail_flag);
-	_ReadMACAddress(Adapter, PROMContent, pEEPROM->bautoload_fail_flag);
+	_ReadMACAddress(Adapter, PROMContent, pEEPROM->bautoload_fail_flag);	
 	ReadTxPowerInfo(Adapter, PROMContent, pEEPROM->bautoload_fail_flag);
 	_ReadBoardType(Adapter, PROMContent, pEEPROM->bautoload_fail_flag);
 
@@ -3834,10 +3834,10 @@ static void _ReadPSSetting(IN PADAPTER Adapter,IN u8*PROMContent,IN u8	AutoloadF
 	//
 	rtl8192c_ReadBluetoothCoexistInfo(Adapter, PROMContent, pEEPROM->bautoload_fail_flag);
 #endif
-
+	
 	rtl8192c_EfuseParseChnlPlan(Adapter, PROMContent, pEEPROM->bautoload_fail_flag);
 	_ReadThermalMeter(Adapter, PROMContent, pEEPROM->bautoload_fail_flag);
-	_ReadLEDSetting(Adapter, PROMContent, pEEPROM->bautoload_fail_flag);
+	_ReadLEDSetting(Adapter, PROMContent, pEEPROM->bautoload_fail_flag);	
 	_ReadRFSetting(Adapter, PROMContent, pEEPROM->bautoload_fail_flag);
 	_ReadPSSetting(Adapter, PROMContent, pEEPROM->bautoload_fail_flag);
 	readAntennaDiversity(Adapter, PROMContent, pEEPROM->bautoload_fail_flag);
@@ -3846,7 +3846,7 @@ static void _ReadPSSetting(IN PADAPTER Adapter,IN u8*PROMContent,IN u8	AutoloadF
 
 	Adapter->bDongle = (PROMContent[EEPROM_EASY_REPLACEMENT] == 1)? 0: 1;
 	DBG_8192C("%s(): REPLACEMENT = %x\n",__FUNCTION__,Adapter->bDongle);
-#ifdef CONFIG_INTEL_PROXIM
+#ifdef CONFIG_INTEL_PROXIM	
 		/* for intel proximity */
 	if (pHalData->rf_type== RF_1T1R) {
 		Adapter->proximity.proxim_support = _TRUE;
@@ -3857,13 +3857,13 @@ static void _ReadPSSetting(IN PADAPTER Adapter,IN u8*PROMContent,IN u8	AutoloadF
 	} else {
 		Adapter->proximity.proxim_support = _FALSE;
 	}
-#endif //CONFIG_INTEL_PROXIM
+#endif //CONFIG_INTEL_PROXIM		
 }
 
 static void _ReadPROMContent(
 	IN PADAPTER 		Adapter
 	)
-{
+{	
 	EEPROM_EFUSE_PRIV *pEEPROM = GET_EEPROM_EFUSE_PRIV(Adapter);
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	u8			PROMContent[HWSET_MAX_SIZE]={0};
@@ -3894,7 +3894,7 @@ static void _ReadPROMContent(
 	IN PADAPTER 		Adapter
 	)
 {
-	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);	
 
 
 	//if(Adapter->bInHctTest){
@@ -3937,9 +3937,9 @@ void _ReadSilmComboMode(PADAPTER Adapter)
 	pHalData->SlimComboDbg = _FALSE;	// Default is not debug mode.
 
 	// 2010/11/22 MH We need to enter debug mode for TSMA and UMC A cut
-	if ((Adapter->chip_type == RTL8188C_8192C) &&
+	if ((Adapter->chip_type == RTL8188C_8192C) && 
 		(pHalData->BoardType == BOARD_USB_COMBO))
-	{
+	{			
 		switch (pHalData->VersionID)
 		{
 			case	VERSION_NORMAL_TSMC_CHIP_88C:
@@ -3950,7 +3950,7 @@ void _ReadSilmComboMode(PADAPTER Adapter)
 			case	VERSION_NORMAL_UMC_CHIP_92C_1T2R_A_CUT:
 				if ((rtw_read8(Adapter, REG_SYS_CFG+3) &0xF0) == 0x20)
 					pHalData->SlimComboDbg = _TRUE;
-
+				
 				break;
 
 			case	VERSION_NORMAL_UMC_CHIP_88C_B_CUT:
@@ -3960,19 +3960,19 @@ void _ReadSilmComboMode(PADAPTER Adapter)
 				if ((rtw_read8(Adapter, REG_SYS_CFG+3) &0xF0) == 0x20)
 					pHalData->SlimComboDbg = _TRUE;
 				break;
-
+				
 			default:
 				break;
-		}
-
+		}		
+		
 	}
-
+	
 }
 static int _ReadAdapterInfo8192CU(PADAPTER	Adapter)
 {
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	u32 start=rtw_get_current_time();
-
+	
 	MSG_8192C("====> ReadAdapterInfo8192C\n");
 
 	//Efuse_InitSomeVar(Adapter);
@@ -4001,7 +4001,7 @@ static void ReadAdapterInfo8192CU(PADAPTER Adapter)
 	// Read EEPROM size before call any EEPROM function
 	//Adapter->EepromAddressSize=Adapter->HalFunc.GetEEPROMSizeHandler(Adapter);
 	Adapter->EepromAddressSize = GetEEPROMSize8192C(Adapter);
-
+	
 	_ReadAdapterInfo8192CU(Adapter);
 }
 
@@ -4024,13 +4024,13 @@ static void rtl8192cu_trigger_gpio_0(_adapter *padapter)
 
 static void ResumeTxBeacon(_adapter *padapter)
 {
-	HAL_DATA_TYPE*	pHalData = GET_HAL_DATA(padapter);
+	HAL_DATA_TYPE*	pHalData = GET_HAL_DATA(padapter);	
 
 	// 2010.03.01. Marked by tynli. No need to call workitem beacause we record the value
 	// which should be read from register to a global variable.
 
 	rtw_write8(padapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl) | BIT6);
-	pHalData->RegFwHwTxQCtrl |= BIT6;
+	pHalData->RegFwHwTxQCtrl |= BIT6;	 
 }
 
 static void StopTxBeacon(_adapter *padapter)
@@ -4059,14 +4059,14 @@ u16 CRC16(u8 data,u16 CRC)
 		DataBit  =(data&(BIT0<<index) ? 1:0);
 		shift_in=CRC_BIT15^DataBit;
 		//printf("CRC_BIT15=%d, DataBit=%d, shift_in=%d \n",CRC_BIT15,DataBit,shift_in);
-
+		
 		CRC_Result=CRC<<1;
-		//set BIT0
+		//set BIT0 
 		//	printf("CRC =%x\n",CRC_Result);
 		//CRC bit 0 =shift_in,
 		if(shift_in==0)
 		{
-			CRC_Result&=(~BIT0);
+			CRC_Result&=(~BIT0); 
 		}
 		else
 		{
@@ -4077,7 +4077,7 @@ u16 CRC16(u8 data,u16 CRC)
 		CRC_BIT11 = ((CRC&BIT11) ? 1:0)^shift_in;
 		if(CRC_BIT11==0)
 		{
-			CRC_Result&=(~BIT12);
+			CRC_Result&=(~BIT12); 
 		}
 		else
 		{
@@ -4088,7 +4088,7 @@ u16 CRC16(u8 data,u16 CRC)
 		CRC_BIT4 = ((CRC&BIT4) ? 1:0)^shift_in;
 		if(CRC_BIT4==0)
 		{
-			CRC_Result&=(~BIT5);
+			CRC_Result&=(~BIT5); 
 		}
 		else
 		{
@@ -4100,7 +4100,7 @@ u16 CRC16(u8 data,u16 CRC)
 	}
 
 	return CRC;
-
+	
 }
 
 
@@ -4116,7 +4116,7 @@ u16 calc_crc(u8 * pdata,int length)
 //    unsigned char data[2]={0xC6,0xAA};
 	u16 CRC=0xffff;
 	int i;
-
+	
 	for(i=0;i<length;i++)
 	{
 		CRC=CRC16(pdata[i],CRC);
@@ -4138,24 +4138,24 @@ static void hw_var_set_opmode(PADAPTER Adapter, u8 variable, u8* val)
 	{
 		// disable Port1 TSF update
 		rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(4));
-
+		
 		// set net_type
 		val8 = rtw_read8(Adapter, MSR)&0x03;
 		val8 |= (mode<<2);
 		rtw_write8(Adapter, MSR, val8);
-
-		//reset TSF1
+		
+		//reset TSF1	
 		rtw_write8(Adapter, REG_DUAL_TSF_RST, BIT(1));
-
+		
 		DBG_871X("%s()-%d mode = %d\n", __FUNCTION__, __LINE__, mode);
-
+	
 		if((mode == _HW_STATE_STATION_) || (mode == _HW_STATE_NOLINK_))
 		{
-			if(!check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE))
+			if(!check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE))			
 			{
 				StopTxBeacon(Adapter);
 			}
-
+			
 			rtw_write8(Adapter,REG_BCN_CTRL_1, 0x19);//disable atim wnd
 			//rtw_write8(Adapter,REG_BCN_CTRL_1, 0x18);
 		}
@@ -4167,43 +4167,43 @@ static void hw_var_set_opmode(PADAPTER Adapter, u8 variable, u8* val)
 		else if(mode == _HW_STATE_AP_)
 		{
 			ResumeTxBeacon(Adapter);
-
+					
 			rtw_write8(Adapter, REG_BCN_CTRL_1, 0x12);
-
+					
 			//Set RCR
 			//rtw_write32(padapter, REG_RCR, 0x70002a8e);//CBSSID_DATA must set to 0
 			rtw_write32(Adapter, REG_RCR, 0x7000228e);//CBSSID_DATA must set to 0
-			//enable to rx data frame
+			//enable to rx data frame				
 			rtw_write16(Adapter, REG_RXFLTMAP2, 0xFFFF);
 			//enable to rx ps-poll
 			rtw_write16(Adapter, REG_RXFLTMAP1, 0x0400);
 
-			//Beacon Control related register for first time
-			rtw_write8(Adapter, REG_BCNDMATIM, 0x02); // 2ms
+			//Beacon Control related register for first time 
+			rtw_write8(Adapter, REG_BCNDMATIM, 0x02); // 2ms		
 			rtw_write8(Adapter, REG_DRVERLYINT, 0x05);// 5ms
 			//rtw_write8(Adapter, REG_BCN_MAX_ERR, 0xFF);
 			rtw_write8(Adapter, REG_ATIMWND_1, 0x0a); // 10ms for port1
 			rtw_write16(Adapter, REG_BCNTCFG, 0x00);
 			rtw_write16(Adapter, REG_TBTT_PROHIBIT, 0xff04);
 			rtw_write16(Adapter, REG_TSFTR_SYN_OFFSET, 0x7fff);// +32767 (~32ms)
+	
 
-
-			//enable BCN1 Function for if2
+		       	//enable BCN1 Function for if2
 			//don't enable update TSF1 for if2 (due to TSF update when beacon/probe rsp are received)
 			rtw_write8(Adapter, REG_BCN_CTRL_1, (DIS_TSF_UDT0_NORMAL_CHIP|EN_BCN_FUNCTION | EN_TXBCN_RPT|BIT(1)));
 
 #ifdef CONFIG_CONCURRENT_MODE
 			if(check_buddy_fwstate(Adapter, WIFI_FW_NULL_STATE))
-				rtw_write8(Adapter, REG_BCN_CTRL,
+				rtw_write8(Adapter, REG_BCN_CTRL, 
 					rtw_read8(Adapter, REG_BCN_CTRL) & ~EN_BCN_FUNCTION);
 #endif
 
 			DBG_871X("%s()-%d: REG_BCN_CTRL_1 = %02x\n", __FUNCTION__, __LINE__, rtw_read8(Adapter, REG_BCN_CTRL_1));
-
+			
                         //BCN1 TSF will sync to BCN0 TSF with offset(0x518) if if1_sta linked
 			//rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(5));
 			//rtw_write8(Adapter, REG_DUAL_TSF_RST, BIT(3));
-
+					
 			//dis BCN0 ATIM  WND if if1 is station
 			rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(0));
 #ifdef CONFIG_TSF_RESET_OFFLOAD
@@ -4222,29 +4222,29 @@ static void hw_var_set_opmode(PADAPTER Adapter, u8 variable, u8* val)
 	{
 		// disable Port0 TSF update
 		rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(4));
-
+		
 		// set net_type
 		val8 = rtw_read8(Adapter, MSR)&0x0c;
 		val8 |= mode;
 		rtw_write8(Adapter, MSR, val8);
-
-		//reset TSF0
+		
+		//reset TSF0	
 		rtw_write8(Adapter, REG_DUAL_TSF_RST, BIT(0));
 
 		DBG_871X("%s()-%d mode = %d\n", __FUNCTION__, __LINE__, mode);
-
+		
 		if((mode == _HW_STATE_STATION_) || (mode == _HW_STATE_NOLINK_))
 		{
 #ifdef CONFIG_CONCURRENT_MODE
-			if(!check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE))
+			if(!check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE))		
 #endif //CONFIG_CONCURRENT_MODE
 			{
 				StopTxBeacon(Adapter);
 			}
-
+			
 			rtw_write8(Adapter,REG_BCN_CTRL, 0x19);//disable atim wnd
 			//rtw_write8(Adapter,REG_BCN_CTRL, 0x18);
-		}
+		}		
 		else if((mode == _HW_STATE_ADHOC_) /*|| (mode == _HW_STATE_AP_)*/)
 		{
 			ResumeTxBeacon(Adapter);
@@ -4253,20 +4253,20 @@ static void hw_var_set_opmode(PADAPTER Adapter, u8 variable, u8* val)
 		else if(mode == _HW_STATE_AP_)
 		{
 			ResumeTxBeacon(Adapter);
-
+					
 			rtw_write8(Adapter, REG_BCN_CTRL, 0x12);
-
+					
 			//Set RCR
 			//write32(padapter, REG_RCR, 0x70002a8e);//CBSSID_DATA must set to 0
 			rtw_write32(Adapter, REG_RCR, 0x7000228e);//CBSSID_DATA must set to 0
-			//enable to rx data frame
+			//enable to rx data frame				
 			rtw_write16(Adapter, REG_RXFLTMAP2, 0xFFFF);
 			//enable to rx ps-poll
 			rtw_write16(Adapter, REG_RXFLTMAP1, 0x0400);
 
-			//Beacon Control related register for first time
+			//Beacon Control related register for first time 
 
-			rtw_write8(Adapter, REG_BCNDMATIM, 0x02); // 2ms
+			rtw_write8(Adapter, REG_BCNDMATIM, 0x02); // 2ms		
 			rtw_write8(Adapter, REG_DRVERLYINT, 0x05);// 5ms
 
 			//write8(Adapter, REG_BCN_MAX_ERR, 0xFF);
@@ -4274,21 +4274,21 @@ static void hw_var_set_opmode(PADAPTER Adapter, u8 variable, u8* val)
 			rtw_write16(Adapter, REG_BCNTCFG, 0x00);
 			rtw_write16(Adapter, REG_TBTT_PROHIBIT, 0xff04);
 			rtw_write16(Adapter, REG_TSFTR_SYN_OFFSET, 0x7fff);// +32767 (~32ms)
-
+	
 		        //enable BCN0 Function for if1
 			//don't enable update TSF0 for if1 (due to TSF update when beacon/probe rsp are received)
 			rtw_write8(Adapter, REG_BCN_CTRL, (DIS_TSF_UDT0_NORMAL_CHIP|EN_BCN_FUNCTION | EN_TXBCN_RPT|BIT(1)));
-
+					
 #ifdef CONFIG_CONCURRENT_MODE
 			if(check_buddy_fwstate(Adapter, WIFI_FW_NULL_STATE))
-				rtw_write8(Adapter, REG_BCN_CTRL_1,
+				rtw_write8(Adapter, REG_BCN_CTRL_1, 
 					rtw_read8(Adapter, REG_BCN_CTRL_1) & ~EN_BCN_FUNCTION);
 #endif
 			//BCN1 TSF will sync to BCN0 TSF with offset(0x518) if if1_sta linked
 			//only interface 2 as AP MODE need to sync
 			//rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(5));
-
-
+			
+							
 			//dis BCN1 ATIM  WND if if2 is station
 			rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(0));
 #ifdef CONFIG_TSF_RESET_OFFLOAD
@@ -4298,8 +4298,8 @@ static void hw_var_set_opmode(PADAPTER Adapter, u8 variable, u8* val)
 					DBG_871X("ERROR! %s()-%d: Reset port0 TSF fail\n",
 						__FUNCTION__, __LINE__);
 			}
-#endif	// CONFIG_TSF_RESET_OFFLOAD
-
+#endif	// CONFIG_TSF_RESET_OFFLOAD			
+					
 		}
 
 
@@ -4327,7 +4327,7 @@ static void hw_var_set_macaddr(PADAPTER Adapter, u8 variable, u8* val)
 	{
 		rtw_write8(Adapter, (reg_macid+idx), val[idx]);
 	}
-
+	
 }
 
 static void hw_var_set_bssid(PADAPTER Adapter, u8 variable, u8* val)
@@ -4370,10 +4370,10 @@ static void hw_var_set_bcn_func(PADAPTER Adapter, u8 variable, u8* val)
 		{
 			rtw_write8(Adapter, bcn_ctrl_reg, rtw_read8(Adapter, bcn_ctrl_reg)&(~(EN_BCN_FUNCTION | EN_TXBCN_RPT)));
 		}
-	}
+	}	
 	else
-#endif
-	{
+#endif		
+	{		
 		bcn_ctrl_reg = REG_BCN_CTRL;
 		if(*((u8 *)val))
 		{
@@ -4385,7 +4385,7 @@ static void hw_var_set_bcn_func(PADAPTER Adapter, u8 variable, u8* val)
 			rtw_write8(Adapter, bcn_ctrl_reg, (rtw_read8(Adapter, bcn_ctrl_reg)&(~(EN_TXBCN_RPT))) | DIS_TSF_UDT0_NORMAL_CHIP);
 		}
 	}
-
+	
 
 }
 
@@ -4414,7 +4414,7 @@ static int rtw_wowlan_set_pattern(_adapter *padapter ,u8* pbuf){
 	if(pattern_len>=4){
 		content=pdata[1];
 	}
-	else{
+	else{	
 		content=0;
 	}
 	DBG_8192C("\nrtw_wowlan_set_pattern offset[0]  content  0x%x  [cpu_to_le32  0x%x]\n", content,__cpu_to_le32(content));
@@ -4426,7 +4426,7 @@ static int rtw_wowlan_set_pattern(_adapter *padapter ,u8* pbuf){
 	if(pattern_len>=8){
 		content=pdata[2];
 	}
-	else{
+	else{	
 		content=0;
 	}
 	DBG_8192C("rtw_wowlan_set_pattern offset[4]  content  0x%x  [cpu_to_le32  0x%x]\n", content,__cpu_to_le32(content));
@@ -4439,7 +4439,7 @@ static int rtw_wowlan_set_pattern(_adapter *padapter ,u8* pbuf){
 	if(pattern_len>=12){
 		content=pdata[3];
 	}
-	else{
+	else{	
 		content=0;
 	}
 	DBG_8192C("rtw_wowlan_set_pattern offset[8]  content  0x%x  [cpu_to_le32  0x%x]\n", content,__cpu_to_le32(content));
@@ -4451,7 +4451,7 @@ static int rtw_wowlan_set_pattern(_adapter *padapter ,u8* pbuf){
 	if(pattern_len>=16){
 		content=pdata[4];
 	}
-	else{
+	else{	
 		content=0;
 	}
 	DBG_8192C("rtw_wowlan_set_pattern offset[12]  content  0x%x  [cpu_to_le32  0x%x]\n", content,__cpu_to_le32(content));
@@ -4491,7 +4491,7 @@ static int rtw_wowlan_set_pattern(_adapter *padapter ,u8* pbuf){
 	//cmd=BIT(31)|BIT(16)|(idx+4);
 	//rtw_write32(padapter, REG_WKFMCAM_CMD, cmd);
 	pwrpriv->wowlan_pattern_idx|=BIT(idx);
-
+	
 _rtw_wowlan_set_pattern_exit:
 	return res;
 }
@@ -4543,7 +4543,7 @@ void rtw_wowlan_reload_pattern(_adapter *padapter){
 		printk("print WOWCAM  offset[2]  =%x\n",rtw_read32(padapter, REG_WKFMCAM_RWD));
 		cmd=BIT(31)|(idx+3);
 		rtw_write32(padapter, REG_WKFMCAM_CMD, cmd);
-		printk("print WOWCAM  offset[3]  =%x\n",rtw_read32(padapter, REG_WKFMCAM_RWD));
+		printk("print WOWCAM  offset[3]  =%x\n",rtw_read32(padapter, REG_WKFMCAM_RWD));		
 		cmd=BIT(31)|(idx+4);
 		rtw_write32(padapter, REG_WKFMCAM_CMD, cmd);
 		printk("print WOWCAM  offset[4]  =%x\n",rtw_read32(padapter, REG_WKFMCAM_RWD));
@@ -4564,7 +4564,7 @@ static void hw_var_set_correct_tsf(PADAPTER Adapter, u8 variable, u8* val)
 	tsf = pmlmeext->TSFValue - rtw_modular64(pmlmeext->TSFValue, (pmlmeinfo->bcn_interval*1024)) -1024; //us
 
 	if(((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
-	{
+	{				
 		//pHalData->RegTxPause |= STOP_BCNQ;BIT(6)
 		//rtw_write8(Adapter, REG_TXPAUSE, (rtw_read8(Adapter, REG_TXPAUSE)|BIT(6)));
 		StopTxBeacon(Adapter);
@@ -4574,7 +4574,7 @@ static void hw_var_set_correct_tsf(PADAPTER Adapter, u8 variable, u8* val)
 	{
 		//disable related TSF function
 		rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)&(~BIT(3)));
-
+							
 		rtw_write32(Adapter, REG_TSFTR1, tsf);
 		rtw_write32(Adapter, REG_TSFTR1+4, tsf>>32);
 
@@ -4585,7 +4585,7 @@ static void hw_var_set_correct_tsf(PADAPTER Adapter, u8 variable, u8* val)
 #ifdef CONFIG_TSF_RESET_OFFLOAD
 		// Update buddy port's TSF(TBTT) if it is SoftAP for beacon TX issue!
 		if ( (pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE
-			&& check_buddy_fwstate(Adapter, WIFI_AP_STATE) ) {
+			&& check_buddy_fwstate(Adapter, WIFI_AP_STATE) ) { 
 			if (reset_tsf(Adapter, IFACE_PORT0) == _FALSE)
 				DBG_871X("ERROR! %s()-%d: Reset port0 TSF fail\n",
 					__FUNCTION__, __LINE__);
@@ -4599,18 +4599,18 @@ static void hw_var_set_correct_tsf(PADAPTER Adapter, u8 variable, u8* val)
 		rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(3)));
 		// disable TSF update instead! May induce burst beacon TX
 		//rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(4));
-
+							
 		rtw_write32(Adapter, REG_TSFTR, tsf);
 		rtw_write32(Adapter, REG_TSFTR+4, tsf>>32);
 
 		//enable related TSF function
 		rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(3));
-		//rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(4)));
-
+		//rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(4)));		
+		
 		// Update buddy port's TSF if it is SoftAP for beacon TX issue!
 		if ( (pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE
 			&& check_buddy_fwstate(Adapter, WIFI_AP_STATE)
-		) {
+		) { 
 			//disable related TSF function
 			rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)&(~BIT(3)));
 			// disable TSF update instead!
@@ -4622,7 +4622,7 @@ static void hw_var_set_correct_tsf(PADAPTER Adapter, u8 variable, u8* val)
 			//enable related TSF function
 			rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)|BIT(3));
 			//rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL_1)&(~BIT(4)));
-		}
+		}		
 #ifdef CONFIG_TSF_RESET_OFFLOAD
 		// Update buddy port's TSF if it is SoftAP for beacon TX issue!
 		if ( (pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE
@@ -4649,17 +4649,17 @@ static void hw_var_set_mlme_disconnect(PADAPTER Adapter, u8 variable, u8* val)
 	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(Adapter);
 	PADAPTER pbuddy_adapter = Adapter->pbuddy_adapter;
 
-
-	if(check_buddy_mlmeinfo_state(Adapter, _HW_STATE_NOLINK_))
+				
+	if(check_buddy_mlmeinfo_state(Adapter, _HW_STATE_NOLINK_))	
 		rtw_write16(Adapter, REG_RXFLTMAP2, 0x00);
-
+	
 
 	if(Adapter->iface_type == IFACE_PORT1)
 	{
 		int i;
 		u8 reg_bcn_ctrl_1;
 
-		// a.Driver set 0x422 bit 6 =0
+	   	// a.Driver set 0x422 bit 6 =0
 		rtw_write8(Adapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl) & (~BIT6));
 		pHalData->RegFwHwTxQCtrl &= (~BIT6);
 
@@ -4667,16 +4667,16 @@ static void hw_var_set_mlme_disconnect(PADAPTER Adapter, u8 variable, u8* val)
 #ifdef CONFIG_BEACON_DISABLE_OFFLOAD
 		u8 reg_bcn_disable_cnt = rtw_read8(Adapter, REG_FW_BCN_DIS_CNT);
 		DBG_871X("%s()-%d: reg_bcn_disable_cnt=%02x\n", __FUNCTION__, __LINE__, reg_bcn_disable_cnt);
-
-		reg_bcn_ctrl_1 = rtw_read8(Adapter, REG_BCN_CTRL_1);
+	   	
+		reg_bcn_ctrl_1 = rtw_read8(Adapter, REG_BCN_CTRL_1); 
 		DBG_871X("%s()-%d: reg_bcn_ctrl_1=%02x\n", __FUNCTION__, __LINE__, reg_bcn_ctrl_1);
 
-		// b. driver set h2c cmd
-		rtl8192c_dis_beacon_fun_cmd(Adapter);
-
+	   	// b. driver set h2c cmd
+	   	rtl8192c_dis_beacon_fun_cmd(Adapter);	   
+	 
 		/*
 			// FW Job for port 0
-
+			
 		   c. 8051 set nettype to ap
 		   d. 8051 check dma_int
 		   e. 8051 set nettype to no_link
@@ -4685,13 +4685,13 @@ static void hw_var_set_mlme_disconnect(PADAPTER Adapter, u8 variable, u8* val)
 		   h.8051 disable beacon function   0x550  bit3
 		   i. 8051 sent ready to driver
 
-		*/
-
-		// The worst case is 100 + 15 ms
+	 	*/
+	 	
+	 	// The worst case is 100 + 15 ms
 		rtw_msleep_os(120);
-
+		
 		for (i=0; i< 10; i++) {
-			reg_bcn_ctrl_1 = rtw_read8(Adapter, REG_BCN_CTRL_1);
+			reg_bcn_ctrl_1 = rtw_read8(Adapter, REG_BCN_CTRL_1); 
 			if ( (reg_bcn_ctrl_1 & BIT(3)) == 0 ) {
 				//DBG_871X("%s()-%d: BEACON_DISABLE_OFFLOAD finished! reg=%02x\n", __FUNCTION__, __LINE__, reg);
 				break;
@@ -4717,15 +4717,15 @@ static void hw_var_set_mlme_disconnect(PADAPTER Adapter, u8 variable, u8* val)
 		rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)&(~BIT(3)));
 
 #endif  // CONFIG_BEACON_DISABLE_OFFLOAD
-
+	 	
 		// j, Driver set 0x422 bit 6 =1
 		rtw_write8(Adapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl) | BIT6);
 		pHalData->RegFwHwTxQCtrl |= BIT6;
 
-		// k. re_download beacon pkt
-		if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE))
+		// k. re_download beacon pkt 
+		if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE))	
 			set_tx_beacon_cmd(pbuddy_adapter);
-
+		   
 
 	}
 	else	// (Adapter->iface_type == IFACE_PORT1)
@@ -4832,7 +4832,7 @@ static void hw_var_set_mlme_sitesurvey(PADAPTER Adapter, u8 variable, u8* val)
 		if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
 			check_buddy_fwstate(Adapter, _FW_LINKED))
 		{
-			ResumeTxBeacon(Adapter);
+			ResumeTxBeacon(Adapter);			
 		}
 #endif
 	}
@@ -4847,13 +4847,13 @@ static void hw_var_set_mlme_join(PADAPTER Adapter, u8 variable, u8* val)
 	struct mlme_priv	*pmlmepriv = &Adapter->mlmepriv;
 
 	if(type == 0) // prepare to join
-	{
+	{		
 		if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
-			check_buddy_fwstate(Adapter, _FW_LINKED))
+			check_buddy_fwstate(Adapter, _FW_LINKED))		
 		{
 			StopTxBeacon(Adapter);
 		}
-
+	
 		//enable to rx data frame.Accept all data frame
 		//rtw_write32(padapter, REG_RCR, rtw_read32(padapter, REG_RCR)|RCR_ADF);
 		rtw_write16(Adapter, REG_RXFLTMAP2,0xFFFF);
@@ -4873,30 +4873,30 @@ static void hw_var_set_mlme_join(PADAPTER Adapter, u8 variable, u8* val)
 		}
 	}
 	else if(type == 1) //joinbss_event call back when join res < 0
-	{
-		if(check_buddy_mlmeinfo_state(Adapter, _HW_STATE_NOLINK_))
+	{		
+		if(check_buddy_mlmeinfo_state(Adapter, _HW_STATE_NOLINK_))		
 			rtw_write16(Adapter, REG_RXFLTMAP2,0x00);
 
 		if(check_buddy_mlmeinfo_state(Adapter, WIFI_FW_AP_STATE) &&
 			check_buddy_fwstate(Adapter, _FW_LINKED))
 		{
-			ResumeTxBeacon(Adapter);
-
+			ResumeTxBeacon(Adapter);			
+			
 			//reset TSF 1/2 after ResumeTxBeacon
-			//rtw_write8(Adapter, REG_DUAL_TSF_RST, BIT(1)|BIT(0));
-
+			//rtw_write8(Adapter, REG_DUAL_TSF_RST, BIT(1)|BIT(0));	
+			
 		}
 	}
 	else if(type == 2) //sta add event call back
 	{
-
+	 
 		//enable update TSF
 		if(Adapter->iface_type == IFACE_PORT1)
 			rtw_write8(Adapter, REG_BCN_CTRL_1, rtw_read8(Adapter, REG_BCN_CTRL_1)&(~BIT(4)));
 		else
 			rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(4)));
-
-
+		 
+	
 		if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE))
 		{
 			//fixed beacon issue for 8191su...........
@@ -4909,15 +4909,15 @@ static void hw_var_set_mlme_join(PADAPTER Adapter, u8 variable, u8* val)
 			check_buddy_fwstate(Adapter, _FW_LINKED))
 		{
 			ResumeTxBeacon(Adapter);
-
+			
 			//reset TSF 1/2 after ResumeTxBeacon
 			//rtw_write8(Adapter, REG_DUAL_TSF_RST, BIT(1)|BIT(0));
 		}
-
+		
 	}
 
 	rtw_write16(Adapter, REG_RL, RetryLimit << RETRY_LIMIT_SHORT_SHIFT | RetryLimit << RETRY_LIMIT_LONG_SHIFT);
-
+	
 #endif
 }
 
@@ -4942,7 +4942,7 @@ void SetHwReg8192CU(PADAPTER Adapter, u8 variable, u8* val)
 		case HW_VAR_MEDIA_STATUS1:
 			{
 				u8 val8;
-
+				
 				val8 = rtw_read8(Adapter, MSR)&0x03;
 				val8 |= *((u8 *)val) <<2;
 				rtw_write8(Adapter, MSR, val8);
@@ -4952,7 +4952,7 @@ void SetHwReg8192CU(PADAPTER Adapter, u8 variable, u8* val)
 			hw_var_set_opmode(Adapter, variable, val);
 			break;
 		case HW_VAR_MAC_ADDR:
-			hw_var_set_macaddr(Adapter, variable, val);
+			hw_var_set_macaddr(Adapter, variable, val);			
 			break;
 		case HW_VAR_BSSID:
 			hw_var_set_bssid(Adapter, variable, val);
@@ -4961,7 +4961,7 @@ void SetHwReg8192CU(PADAPTER Adapter, u8 variable, u8* val)
 			{
 				u16			BrateCfg = 0;
 				u8			RateIndex = 0;
-
+				
 				// 2007.01.16, by Emily
 				// Select RRSR (in Legacy-OFDM and CCK)
 				// For 8190, we select only 24M, 12M, 6M, 11M, 5.5M, 2M, and 1M from the Basic rate.
@@ -4978,7 +4978,7 @@ void SetHwReg8192CU(PADAPTER Adapter, u8 variable, u8* val)
 				BrateCfg |= 0x01; // default enable 1M ACK rate
 
 				DBG_8192C("HW_VAR_BASIC_RATE: BrateCfg(%#x)\n", BrateCfg);
-
+				
 				// Set RRSR rate table.
 				rtw_write8(Adapter, REG_RRSR, BrateCfg&0xff);
 				rtw_write8(Adapter, REG_RRSR+1, (BrateCfg>>8)&0xff);
@@ -4995,7 +4995,7 @@ void SetHwReg8192CU(PADAPTER Adapter, u8 variable, u8* val)
 			}
 			break;
 		case HW_VAR_TXPAUSE:
-			rtw_write8(Adapter, REG_TXPAUSE, *((u8 *)val));
+			rtw_write8(Adapter, REG_TXPAUSE, *((u8 *)val));	
 			break;
 		case HW_VAR_BCN_FUNC:
 			hw_var_set_bcn_func(Adapter, variable, val);
@@ -5003,7 +5003,7 @@ void SetHwReg8192CU(PADAPTER Adapter, u8 variable, u8* val)
 		case HW_VAR_CORRECT_TSF:
 #ifdef CONFIG_CONCURRENT_MODE
 			hw_var_set_correct_tsf(Adapter, variable, val);
-#else
+#else			
 			{
 				u64	tsf;
 				struct mlme_ext_priv	*pmlmeext = &Adapter->mlmeextpriv;
@@ -5013,7 +5013,7 @@ void SetHwReg8192CU(PADAPTER Adapter, u8 variable, u8* val)
 				tsf = pmlmeext->TSFValue - rtw_modular64(pmlmeext->TSFValue, (pmlmeinfo->bcn_interval*1024)) -1024; //us
 
 				if(((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
-				{
+				{				
 					//pHalData->RegTxPause |= STOP_BCNQ;BIT(6)
 					//rtw_write8(Adapter, REG_TXPAUSE, (rtw_read8(Adapter, REG_TXPAUSE)|BIT(6)));
 					StopTxBeacon(Adapter);
@@ -5021,14 +5021,14 @@ void SetHwReg8192CU(PADAPTER Adapter, u8 variable, u8* val)
 
 				//disable related TSF function
 				rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)&(~BIT(3)));
-
+							
 				rtw_write32(Adapter, REG_TSFTR, tsf);
 				rtw_write32(Adapter, REG_TSFTR+4, tsf>>32);
 
 				//enable related TSF function
 				rtw_write8(Adapter, REG_BCN_CTRL, rtw_read8(Adapter, REG_BCN_CTRL)|BIT(3));
-
-
+				
+							
 				if(((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
 				{
 					//pHalData->RegTxPause  &= (~STOP_BCNQ);
@@ -5071,7 +5071,7 @@ void SetHwReg8192CU(PADAPTER Adapter, u8 variable, u8* val)
 #endif
 			break;
 		case HW_VAR_MLME_SITESURVEY:
-			hw_var_set_mlme_sitesurvey(Adapter, variable,  val);
+			hw_var_set_mlme_sitesurvey(Adapter, variable,  val);	
 			break;
 		case HW_VAR_MLME_JOIN:
 #ifdef CONFIG_CONCURRENT_MODE
@@ -5138,7 +5138,7 @@ void SetHwReg8192CU(PADAPTER Adapter, u8 variable, u8* val)
 				u8	u1bAIFS, aSifsTime;
 				struct mlme_ext_priv	*pmlmeext = &Adapter->mlmeextpriv;
 				struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-
+				
 				rtw_write8(Adapter, REG_SLOT, val[0]);
 
 				if(pmlmeinfo->WMM_enable == 0)
@@ -5147,9 +5147,9 @@ void SetHwReg8192CU(PADAPTER Adapter, u8 variable, u8* val)
 						aSifsTime = 10;
 					else
 						aSifsTime = 16;
-
+					
 					u1bAIFS = aSifsTime + (2 * pmlmeinfo->slotTime);
-
+					
 					// <Roger_EXP> Temporary removed, 2008.06.20.
 					rtw_write8(Adapter, REG_EDCA_VO_PARAM, u1bAIFS);
 					rtw_write8(Adapter, REG_EDCA_VI_PARAM, u1bAIFS);
@@ -5160,12 +5160,12 @@ void SetHwReg8192CU(PADAPTER Adapter, u8 variable, u8* val)
 			break;
 		case HW_VAR_RESP_SIFS:
 			{
-#if 0
+#if 0			
 				// SIFS for OFDM Data ACK
 				rtw_write8(Adapter, REG_SIFS_CTX+1, val[0]);
 				// SIFS for OFDM consecutive tx like CTS data!
 				rtw_write8(Adapter, REG_SIFS_TRX+1, val[1]);
-
+				
 				rtw_write8(Adapter,REG_SPEC_SIFS+1, val[0]);
 				rtw_write8(Adapter,REG_MAC_SPEC_SIFS+1, val[0]);
 
@@ -5198,7 +5198,7 @@ void SetHwReg8192CU(PADAPTER Adapter, u8 variable, u8* val)
 			break;
 		case HW_VAR_SEC_CFG:
 #ifdef CONFIG_CONCURRENT_MODE
-			rtw_write8(Adapter, REG_SECCFG, 0x0c|BIT(5));// enable tx enc and rx dec engine, and no key search for MC/BC
+			rtw_write8(Adapter, REG_SECCFG, 0x0c|BIT(5));// enable tx enc and rx dec engine, and no key search for MC/BC				
 #else
 			rtw_write8(Adapter, REG_SECCFG, *((u8 *)val));
 #endif
@@ -5261,7 +5261,7 @@ void SetHwReg8192CU(PADAPTER Adapter, u8 variable, u8* val)
 				u32	cmd;
 				u32	*cam_val = (u32 *)val;
 				rtw_write32(Adapter, WCAMI, cam_val[0]);
-
+				
 				cmd = CAM_POLLINIG | CAM_WRITE | cam_val[1];
 				rtw_write32(Adapter, RWCAM, cmd);
 			}
@@ -5368,10 +5368,10 @@ void SetHwReg8192CU(PADAPTER Adapter, u8 variable, u8* val)
 					{
 						if((pRegToSet[index] & 0xf0) > (FactorToSet<<4))
 							pRegToSet[index] = (pRegToSet[index] & 0x0f) | (FactorToSet<<4);
-
+					
 						if((pRegToSet[index] & 0x0f) > FactorToSet)
 							pRegToSet[index] = (pRegToSet[index] & 0xf0) | (FactorToSet);
-
+						
 						rtw_write8(Adapter, (REG_AGGLEN_LMT+index), pRegToSet[index]);
 					}
 
@@ -5397,7 +5397,7 @@ void SetHwReg8192CU(PADAPTER Adapter, u8 variable, u8* val)
 		case HW_VAR_H2C_FW_PWRMODE:
 			{
 				u8	psmode = (*(u8 *)val);
-
+			
 				// Forece leave RF low power mode for 1T1R to prevent conficting setting in Fw power
 				// saving sequence. 2010.06.07. Added by tynli. Suggested by SD3 yschang.
 				if( (psmode != PS_MODE_ACTIVE) && (!IS_92C_SERIAL(pHalData->VersionID)))
@@ -5447,7 +5447,7 @@ void SetHwReg8192CU(PADAPTER Adapter, u8 variable, u8* val)
 #endif //CONFIG_TDLS
 		case HW_VAR_INITIAL_GAIN:
 			{
-				DIG_T	*pDigTable = &pdmpriv->DM_DigTable;
+				DIG_T	*pDigTable = &pdmpriv->DM_DigTable;					
 				u32 		rx_gain = ((u32 *)(val))[0];
 
 				if(rx_gain == 0xff){//restore rx gain
@@ -5492,7 +5492,7 @@ void SetHwReg8192CU(PADAPTER Adapter, u8 variable, u8* val)
 				u8	Optimum_antenna = (*(u8 *)val);
 				//switch antenna to Optimum_antenna
 		//		DBG_8192C("==> HW_VAR_ANTENNA_DIVERSITY_SELECT , Ant_(%s)\n",(Optimum_antenna==2)?"A":"B");
-				if(pHalData->CurAntenna !=  Optimum_antenna)
+				if(pHalData->CurAntenna !=  Optimum_antenna)		
 				{
 					PHY_SetBBReg(Adapter, rFPGA0_XA_RFInterfaceOE, 0x300, Optimum_antenna);
 					pHalData->CurAntenna = Optimum_antenna ;
@@ -5502,19 +5502,19 @@ void SetHwReg8192CU(PADAPTER Adapter, u8 variable, u8* val)
 			break;
 #endif
 		case HW_VAR_EFUSE_BYTES: // To set EFUE total used bytes, added by Roger, 2008.12.22.
-			pHalData->EfuseUsedBytes = *((u16 *)val);
+			pHalData->EfuseUsedBytes = *((u16 *)val);			
 			break;
 		case HW_VAR_FIFO_CLEARN_UP:
 			{
 				#define RW_RELEASE_EN		BIT18
 				#define RXDMA_IDLE			BIT17
-
+				
 				struct pwrctrl_priv *pwrpriv = &Adapter->pwrctrlpriv;
-				u8 trycnt = 100;
-
+				u8 trycnt = 100;	
+				
 				//pause tx
 				rtw_write8(Adapter,REG_TXPAUSE,0xff);
-
+			
 				//keep sn
 				Adapter->xmitpriv.nqos_ssn = rtw_read16(Adapter,REG_NQOS_SEQ);
 
@@ -5537,7 +5537,7 @@ void SetHwReg8192CU(PADAPTER Adapter, u8 variable, u8* val)
 			}
 			break;
 			case HW_VAR_WOWLAN:
-#ifdef CONFIG_WOWLAN
+#ifdef CONFIG_WOWLAN			
 			{
 				struct wowlan_ioctl_param *poidparam;
 
@@ -5550,12 +5550,12 @@ void SetHwReg8192CU(PADAPTER Adapter, u8 variable, u8* val)
 						DBG_8192C("\n PATTERN_MATCH poidparam->subcode_value=%d\n",poidparam->subcode_value);
 						if(poidparam->subcode_value==1){
 							//rtw_write8(Adapter, REG_WOW_CTRL, (rtw_read8(Adapter, REG_WOW_CTRL)|BIT(1)));
-							Adapter->pwrctrlpriv.wowlan_pattern=_TRUE;
-							DBG_8192C("%s Adapter->pwrctrlpriv.wowlan_pattern=%x\n",__FUNCTION__,Adapter->pwrctrlpriv.wowlan_pattern);
+							Adapter->pwrctrlpriv.wowlan_pattern=_TRUE; 
+							DBG_8192C("%s Adapter->pwrctrlpriv.wowlan_pattern=%x\n",__FUNCTION__,Adapter->pwrctrlpriv.wowlan_pattern); 
 						}
 						else{
 							//rtw_write8(Adapter, REG_WOW_CTRL, (rtw_read8(Adapter, REG_WOW_CTRL)&~BIT(1)));
-							Adapter->pwrctrlpriv.wowlan_pattern=_FALSE;
+							Adapter->pwrctrlpriv.wowlan_pattern=_FALSE; 
 						}
 						break;
 					case WOWLAN_MAGIC_PACKET:
@@ -5563,24 +5563,24 @@ void SetHwReg8192CU(PADAPTER Adapter, u8 variable, u8* val)
 						DBG_8192C("\n MAGIC_PACKET poidparam->subcode_value=%d\n",poidparam->subcode_value);
 						if(poidparam->subcode_value==1){
 							//rtw_write8(Adapter, REG_WOW_CTRL, (rtw_read8(Adapter, REG_WOW_CTRL)|BIT(2)));
-							Adapter->pwrctrlpriv.wowlan_magic=_TRUE;
-							DBG_8192C("%s Adapter->pwrctrlpriv.wowlan_magic=%x\n",__FUNCTION__,Adapter->pwrctrlpriv.wowlan_magic);
+							Adapter->pwrctrlpriv.wowlan_magic=_TRUE; 
+							DBG_8192C("%s Adapter->pwrctrlpriv.wowlan_magic=%x\n",__FUNCTION__,Adapter->pwrctrlpriv.wowlan_magic); 
 						}
 						else{
 							//rtw_write8(Adapter, REG_WOW_CTRL, (rtw_read8(Adapter, REG_WOW_CTRL)&~BIT(2)));
-							Adapter->pwrctrlpriv.wowlan_magic=_FALSE;
+							Adapter->pwrctrlpriv.wowlan_magic=_FALSE; 
 						}
 						break;
 					case WOWLAN_UNICAST:
 						//Turn on the Unicast wakeup feature
 						if(poidparam->subcode_value==1){
 							//rtw_write8(Adapter, REG_WOW_CTRL, (rtw_read8(Adapter, REG_WOW_CTRL)|BIT(3)));
-							Adapter->pwrctrlpriv.wowlan_unicast=_TRUE;
+							Adapter->pwrctrlpriv.wowlan_unicast=_TRUE; 
 						}
 						else{
 							//rtw_write8(Adapter, REG_WOW_CTRL, (rtw_read8(Adapter, REG_WOW_CTRL)&~BIT(3)));
-							Adapter->pwrctrlpriv.wowlan_unicast=_FALSE;
-							DBG_8192C("%s Adapter->pwrctrlpriv.wowlan_unicast=%x\n",__FUNCTION__,Adapter->pwrctrlpriv.wowlan_unicast);
+							Adapter->pwrctrlpriv.wowlan_unicast=_FALSE; 
+							DBG_8192C("%s Adapter->pwrctrlpriv.wowlan_unicast=%x\n",__FUNCTION__,Adapter->pwrctrlpriv.wowlan_unicast); 
 						}
 						break;
 					case WOWLAN_SET_PATTERN:
@@ -5601,7 +5601,7 @@ void SetHwReg8192CU(PADAPTER Adapter, u8 variable, u8* val)
 								DBG_8192C("offset[%d]=MSB 0x%x:0x%x:0x%x:0x%x  ",offset,rtw_read8(Adapter, REG_WKFMCAM_RWD+3),rtw_read8(Adapter, REG_WKFMCAM_RWD+2),rtw_read8(Adapter, REG_WKFMCAM_RWD+1),rtw_read8(Adapter, REG_WKFMCAM_RWD));
 							}
 						}*/
-
+					
 						break;
 					case WOWLAN_ENABLE:
 						SetFwRelatedForWoWLAN8192CU(Adapter, _TRUE);
@@ -5616,18 +5616,18 @@ void SetHwReg8192CU(PADAPTER Adapter, u8 variable, u8* val)
 //							rtw_write8(Adapter, REG_WOW_CTRL, (rtw_read8(Adapter, REG_WOW_CTRL)|BIT(1)|BIT(2)|BIT(3)));
 						//DBG_8192C(" \n REG_WOW_CTRL=0x%x \n",rtw_read8(Adapter, REG_WOW_CTRL));
 						break;
-
+	
 					case WOWLAN_DISABLE:
 						Adapter->pwrctrlpriv.wowlan_mode=_FALSE;
 						rtl8192c_set_wowlan_cmd(Adapter);
 						rtw_msleep_os(10);
 						break;
-
+					
 					case WOWLAN_STATUS:
 						poidparam->wakeup_reason = rtw_read8(Adapter, REG_WOWLAN_REASON);
 						DBG_8192C("wake on wlan reason 0x%02x\n", poidparam->wakeup_reason);
 						break;
-
+	
 					default:
 						break;
 				}
@@ -5640,14 +5640,14 @@ void SetHwReg8192CU(PADAPTER Adapter, u8 variable, u8* val)
 			break;
 #endif //CONFIG_WOWLAN
 		case HW_VAR_CHECK_TXBUF:
-#ifdef CONFIG_CONCURRENT_MODE
+#ifdef CONFIG_CONCURRENT_MODE				
 			{
 				int i;
 				u8	RetryLimit = 0x01;
-
+				
 				//rtw_write16(Adapter, REG_RL,0x0101);
 				rtw_write16(Adapter, REG_RL, RetryLimit << RETRY_LIMIT_SHORT_SHIFT | RetryLimit << RETRY_LIMIT_LONG_SHIFT);
-
+		
 				for(i=0;i<1000;i++)
 				{
 					if(rtw_read32(Adapter, 0x200) != rtw_read32(Adapter, 0x204))
@@ -5662,15 +5662,15 @@ void SetHwReg8192CU(PADAPTER Adapter, u8 variable, u8* val)
 					}
 				}
 
-				RetryLimit = 0x30;
+				RetryLimit = 0x30;	
 				rtw_write16(Adapter, REG_RL, RetryLimit << RETRY_LIMIT_SHORT_SHIFT | RetryLimit << RETRY_LIMIT_LONG_SHIFT);
-
+		
 			}
 #endif
 			break;
 		case HW_VAR_BCN_VALID:
 			//BCN_VALID, BIT16 of REG_TDECTRL = BIT0 of REG_TDECTRL+2, write 1 to clear, Clear by sw
-			rtw_write8(Adapter, REG_TDECTRL+2, rtw_read8(Adapter, REG_TDECTRL+2) | BIT0);
+			rtw_write8(Adapter, REG_TDECTRL+2, rtw_read8(Adapter, REG_TDECTRL+2) | BIT0); 
 			break;
 		case HW_VAR_USB_RXAGG_PAGE_TO:
 			rtw_write8(Adapter, REG_USB_DMA_AGG_TO, *((u8 *)val));
@@ -5709,7 +5709,7 @@ void GetHwReg8192CU(PADAPTER Adapter, u8 variable, u8* val)
 			{
 				//When we halt NIC, we should check if FW LPS is leave.
 				u32	valRCR;
-
+				
 				if(Adapter->pwrctrlpriv.rf_pwrstate == rf_off)
 				{
 					// If it is in HW/SW Radio OFF or IPS state, we do not check Fw LPS Leave,
@@ -5733,7 +5733,7 @@ void GetHwReg8192CU(PADAPTER Adapter, u8 variable, u8* val)
 			break;
 #endif
 		case HW_VAR_EFUSE_BYTES: // To get EFUE total used bytes, added by Roger, 2008.12.22.
-			*((u16 *)(val)) = pHalData->EfuseUsedBytes;
+			*((u16 *)(val)) = pHalData->EfuseUsedBytes;	
 			break;
 		case HW_VAR_VID:
 			*((u16 *)(val)) = pHalData->EEPROMVID;
@@ -5749,7 +5749,7 @@ void GetHwReg8192CU(PADAPTER Adapter, u8 variable, u8* val)
 }
 
 //
-//	Description:
+//	Description: 
 //		Query setting of specified variable.
 //
 u8
@@ -5773,7 +5773,7 @@ void GetHwReg8192CU(PADAPTER Adapter, u8 variable, u8* val)
 				psta = rtw_get_stainfo(pstapriv, pmlmepriv->cur_network.network.MacAddress);
 				if(psta)
 				{
-					*((int *)pValue) = psta->rssi_stat.UndecoratedSmoothedPWDB;
+					*((int *)pValue) = psta->rssi_stat.UndecoratedSmoothedPWDB;     
 				}
 			}
 #else //v4 branch
@@ -5781,7 +5781,7 @@ void GetHwReg8192CU(PADAPTER Adapter, u8 variable, u8* val)
 			*((int *)pValue) = pHalData->dmpriv.UndecoratedSmoothedPWDB;
 				//}
 				//else{
-
+    
 				//}
 #endif
 			break;
@@ -5789,10 +5789,10 @@ void GetHwReg8192CU(PADAPTER Adapter, u8 variable, u8* val)
 			#ifdef CONFIG_ANTENNA_DIVERSITY
 			*((u8 *)pValue) = (IS_92C_SERIAL(pHalData->VersionID) ||(pHalData->AntDivCfg==0))?_FALSE:_TRUE;
 			#endif
-			break;
+			break;			
 		case HAL_DEF_CURRENT_ANTENNA:
 			#ifdef CONFIG_ANTENNA_DIVERSITY
-			*(( u8*)pValue) = pHalData->CurAntenna;
+			*(( u8*)pValue) = pHalData->CurAntenna;			
 			#endif
 			break;
 		case HAL_DEF_DRVINFO_SZ:
@@ -5844,8 +5844,8 @@ void GetHwReg8192CU(PADAPTER Adapter, u8 variable, u8* val)
 		case HAL_DEF_DBG_DM_FUNC:
 			{
 				u8 dm_func = *(( u8*)pValue);
-				struct dm_priv	*pdmpriv = &pHalData->dmpriv;
-
+				struct dm_priv	*pdmpriv = &pHalData->dmpriv;	
+				
 				if(dm_func == 0){ //disable all dynamic func
 					pdmpriv->DMFlag = DYNAMIC_FUNC_DISABLE;
 					DBG_8192C("==> Disable all dynamic function...\n");
@@ -5866,19 +5866,19 @@ void GetHwReg8192CU(PADAPTER Adapter, u8 variable, u8* val)
 				}
 				else if(dm_func == 5){//disable antenna diversity
 					pdmpriv->DMFlag &= (~DYNAMIC_FUNC_ANT_DIV);
-				}
+				}				
 				else if(dm_func == 6){//turn on all dynamic func
 					if(!(pdmpriv->DMFlag & DYNAMIC_FUNC_DIG))
 					{
 						struct dm_priv	*pdmpriv = &pHalData->dmpriv;
 						DIG_T	*pDigTable = &pdmpriv->DM_DigTable;
-						pDigTable->PreIGValue = rtw_read8(Adapter,0xc50);
+						pDigTable->PreIGValue = rtw_read8(Adapter,0xc50);	
 					}
-
+						
 					pdmpriv->DMFlag |= (DYNAMIC_FUNC_DIG|DYNAMIC_FUNC_HP|DYNAMIC_FUNC_SS|
 						DYNAMIC_FUNC_BT|DYNAMIC_FUNC_ANT_DIV) ;
 					DBG_8192C("==> Turn on all dynamic function...\n");
-				}
+				}			
 			}
 			break;
 		default:
@@ -5913,7 +5913,7 @@ u32  _update_92cu_basic_rate(_adapter *padapter, unsigned int mask)
 			BrateCfg = mask  & 0x159;
 	}
 
-	BrateCfg |= 0x01; // default enable 1M ACK rate
+	BrateCfg |= 0x01; // default enable 1M ACK rate					
 
 	return BrateCfg;
 }
@@ -5924,7 +5924,7 @@ void _update_response_rate(_adapter *padapter,unsigned int mask)
 	// Set RRSR rate table.
 	rtw_write8(padapter, REG_RRSR, mask&0xff);
 	rtw_write8(padapter,REG_RRSR+1, (mask>>8)&0xff);
-
+	
 
 	// Set RTS initial rate
 	while(mask > 0x1)
@@ -5939,7 +5939,7 @@ void UpdateHalRAMask8192CUsb(PADAPTER padapter, u32 mac_id)
 {
 	//volatile unsigned int result;
 	u8	init_rate=0;
-	u8	networkType, raid;
+	u8	networkType, raid;	
 	u32	mask;
 	u8	shortGIrate = _FALSE;
 	int	supportRateNum = 0;
@@ -5974,16 +5974,16 @@ void UpdateHalRAMask8192CUsb(PADAPTER padapter, u32 mac_id)
 			networkType = judge_network_type(padapter, cur_network->SupportedRates, supportRateNum) & 0xf;
 			//pmlmeext->cur_wireless_mode = networkType;
 			raid = networktype_to_raid(networkType);
-
+						
 			mask = update_supported_rate(cur_network->SupportedRates, supportRateNum);
 			mask |= (pmlmeinfo->HT_enable)? update_MSC_rate(&(pmlmeinfo->HT_caps)): 0;
 			mask |= ((raid<<28)&0xf0000000);
-
+			
 			if (support_short_GI(padapter, &(pmlmeinfo->HT_caps)))
 			{
 				shortGIrate = _TRUE;
 			}
-
+			
 			break;
 
 		case 1://for broadcast/multicast
@@ -6015,16 +6015,16 @@ void UpdateHalRAMask8192CUsb(PADAPTER padapter, u32 mac_id)
 				networkType = judge_network_type(padapter, pmlmeinfo->FW_sta_info[mac_id].SupportedRates, supportRateNum) & 0xf;
 				//pmlmeext->cur_wireless_mode = networkType;
 				raid = networktype_to_raid(networkType);
-
+				
 				mask = update_supported_rate(cur_network->SupportedRates, supportRateNum);
 				mask |= ((raid<<28)&0xf0000000);
 
 				//todo: support HT in IBSS
-
+				
 				break;
 			}
 	}
-
+	
 #ifdef CONFIG_BT_COEXIST
 	if( (pbtpriv->BT_Coexist) &&
 		(pbtpriv->BT_CoexistType == BT_CSR_BC4) &&
@@ -6033,22 +6033,22 @@ void UpdateHalRAMask8192CUsb(PADAPTER padapter, u32 mac_id)
 		((pbtpriv->BT_Service==BT_SCO)||
 		(pbtpriv->BT_Service==BT_Busy)) )
 		mask &= 0xffffcfc0;
-	else
+	else		
 #endif
 		mask &=0xffffffff;
-
-
+	
+	
 	init_rate = get_highest_rate_idx(mask)&0x3f;
-
+	
 	if(pHalData->fw_ractrl == _TRUE)
 	{
 		u8 arg = 0;
 
 		//arg = (cam_idx-4)&0x1f;//MACID
 		arg = mac_id&0x1f;//MACID
-
+		
 		arg |= BIT(7);
-
+		
 		if (shortGIrate==_TRUE)
 			arg |= BIT(5);
 
@@ -6062,15 +6062,15 @@ void UpdateHalRAMask8192CUsb(PADAPTER padapter, u32 mac_id)
 			arg |= BIT(6);
 		}
 #endif //CONFIG_INTEL_PROXIM
-		rtl8192c_set_raid_cmd(padapter, mask, arg);
-
+		rtl8192c_set_raid_cmd(padapter, mask, arg);	
+		
 	}
 	else
 	{
 		if (shortGIrate==_TRUE)
 			init_rate |= BIT(6);
 
-		rtw_write8(padapter, (REG_INIDATA_RATE_SEL+mac_id), init_rate);
+		rtw_write8(padapter, (REG_INIDATA_RATE_SEL+mac_id), init_rate);		
 	}
 
 
@@ -6089,17 +6089,17 @@ void SetBeaconRelatedRegisters8192CUsb(PADAPTER padapter)
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
-	//reset TSF, enable update TSF, correcting TSF On Beacon
-
+	//reset TSF, enable update TSF, correcting TSF On Beacon 
+	
 	//REG_BCN_INTERVAL
 	//REG_BCNDMATIM
 	//REG_ATIMWND
 	//REG_TBTT_PROHIBIT
 	//REG_DRVERLYINT
-	//REG_BCN_MAX_ERR
+	//REG_BCN_MAX_ERR	
 	//REG_BCNTCFG //(0x510)
 	//REG_DUAL_TSF_RST
-	//REG_BCN_CTRL //(0x550)
+	//REG_BCN_CTRL //(0x550) 
 
 	//BCN interval
 	rtw_write16(padapter, REG_BCN_INTERVAL, pmlmeinfo->bcn_interval);
@@ -6109,12 +6109,12 @@ void SetBeaconRelatedRegisters8192CUsb(PADAPTER padapter)
 
 	rtw_write8(padapter, REG_SLOT, 0x09);
 
-	value32 =rtw_read32(padapter, REG_TCR);
+	value32 =rtw_read32(padapter, REG_TCR); 
 	value32 &= ~TSFRST;
-	rtw_write32(padapter,  REG_TCR, value32);
+	rtw_write32(padapter,  REG_TCR, value32); 
 
 	value32 |= TSFRST;
-	rtw_write32(padapter, REG_TCR, value32);
+	rtw_write32(padapter, REG_TCR, value32); 
 
 	// NOTE: Fix test chip's bug (about contention windows's randomness)
 	rtw_write8(padapter,  REG_RXTSF_OFFSET_CCK, 0x50);
@@ -6125,7 +6125,7 @@ void SetBeaconRelatedRegisters8192CUsb(PADAPTER padapter)
 	ResumeTxBeacon(padapter);
 
 	//rtw_write8(padapter, 0x422, rtw_read8(padapter, 0x422)|BIT(6));
-
+	
 	//rtw_write8(padapter, 0x541, 0xff);
 
 	//rtw_write8(padapter, 0x542, rtw_read8(padapter, 0x541)|BIT(0));
@@ -6142,11 +6142,11 @@ static void rtl8192cu_init_default_value(_adapter * padapter)
 	u8	i;
 
 	//init default value
-	pHalData->fw_ractrl = _FALSE;
+	pHalData->fw_ractrl = _FALSE;	
 	pHalData->bIQKInitialized = _FALSE;
 	if(!pwrctrlpriv->bkeepfwalive)
 		pHalData->LastHMEBoxNum = 0;
-
+	
 	pHalData->bIQKInitialized = _FALSE;
 	//init dm default value
 	pdmpriv->TM_Trigger = 0;
@@ -6160,7 +6160,7 @@ static void rtl8192cu_init_default_value(_adapter * padapter)
 }
 
 static u8 rtl8192cu_ps_func(PADAPTER Adapter,HAL_INTF_PS_FUNC efunc_id, u8 *val)
-{
+{	
 	u8 bResult = _TRUE;
 	switch(efunc_id){
 
@@ -6210,7 +6210,7 @@ void rtl8192cu_set_hal_ops(_adapter * padapter)
 	pHalFunc->DeInitSwLeds = &rtl8192cu_DeInitSwLeds;
 #else //case of hw led or no led
 	pHalFunc->InitSwLeds = NULL;
-	pHalFunc->DeInitSwLeds = NULL;
+	pHalFunc->DeInitSwLeds = NULL;	
 #endif//CONFIG_SW_LED
 
 	//pHalFunc->dm_init = &rtl8192c_init_dm_priv;
@@ -6227,8 +6227,8 @@ void rtl8192cu_set_hal_ops(_adapter * padapter)
 
 	pHalFunc->SetHwRegHandler = &SetHwReg8192CU;
 	pHalFunc->GetHwRegHandler = &GetHwReg8192CU;
-	pHalFunc->GetHalDefVarHandler = &GetHalDefVar8192CUsb;
-	pHalFunc->SetHalDefVarHandler = &SetHalDefVar8192CUsb;
+  	pHalFunc->GetHalDefVarHandler = &GetHalDefVar8192CUsb;
+ 	pHalFunc->SetHalDefVarHandler = &SetHalDefVar8192CUsb;
 
 	pHalFunc->UpdateRAMaskHandler = &UpdateHalRAMask8192CUsb;
 	pHalFunc->SetBeaconRelatedRegistersHandler = &SetBeaconRelatedRegisters8192CUsb;
@@ -6258,3 +6258,4 @@ void rtl8192cu_set_hal_ops(_adapter * padapter)
 _func_exit_;
 
 }
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/usb_ops_ce.c b/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/usb_ops_ce.c
old mode 100644
new mode 100755
index 26148fc..9523337
--- a/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/usb_ops_ce.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/usb_ops_ce.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -80,12 +80,12 @@ void usb_read_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
 
     // This assert may fail on suprise remove,
     // but should pass during normal I/O.
-    // ASSERT( pUsbFuncs->lpIsTransferComplete(hTransfer) );
+    // ASSERT( pUsbFuncs->lpIsTransferComplete(hTransfer) ); 
 
     // CloseTransfer aborts any pending transfers
     if ( !pUsbFuncs->lpCloseTransfer(hTransfer) ) {
-
-	RT_TRACE( _module_hci_ops_os_c_, _drv_err_, ("*** CloseTransfer ERROR:%d ***\n", GetLastError()));
+     
+	RT_TRACE( _module_hci_ops_os_c_, _drv_err_, ("*** CloseTransfer ERROR:%d ***\n", GetLastError()));	
         bRc = FALSE;
     }
 
@@ -106,11 +106,11 @@ void usb_read_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
 
     if ( pUsbFuncs->lpGetTransferStatus(hTransfer, pBytesTransferred, pUsbError) ) {
         if ( USB_NO_ERROR != *pUsbError ) {
-		RT_TRACE( _module_hci_ops_os_c_, _drv_err_, ("*** CloseTransfer ERROR:%d ***\n", GetLastError()));
-            RT_TRACE( _module_hci_ops_os_c_, _drv_err_, ("GetTransferStatus (BytesTransferred:%d, UsbError:0x%x)\n", pBytesTransferred?*pBytesTransferred:-1, pUsbError?*pUsbError:-1 ));
+		RT_TRACE( _module_hci_ops_os_c_, _drv_err_, ("*** CloseTransfer ERROR:%d ***\n", GetLastError()));		
+            RT_TRACE( _module_hci_ops_os_c_, _drv_err_, ("GetTransferStatus (BytesTransferred:%d, UsbError:0x%x)\n", pBytesTransferred?*pBytesTransferred:-1, pUsbError?*pUsbError:-1 )); 
         }
     } else {
-        RT_TRACE( _module_hci_ops_os_c_, _drv_err_,("*** GetTransferStatus ERROR:%d ***\n", GetLastError()));
+        RT_TRACE( _module_hci_ops_os_c_, _drv_err_,("*** GetTransferStatus ERROR:%d ***\n", GetLastError())); 
         *pUsbError = USB_CANCELED_ERROR;
         bRc = FALSE;
     }
@@ -157,7 +157,7 @@ u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
     }
 #endif
 
-	if(adapter->bDriverStopped || adapter->bSurpriseRemoved)
+	if(adapter->bDriverStopped || adapter->bSurpriseRemoved) 
 	{
 		RT_TRACE(_module_hci_ops_os_c_, _drv_info_,("usb_read_port:( padapter->bDriverStopped ||padapter->bSurpriseRemoved)!!!\n"));
 		return _FALSE;
@@ -168,7 +168,7 @@ u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
 
 		// get a recv buffer
 		rtl8192cu_init_recvbuf(adapter, precvbuf);
-
+	
 
 
 		_rtw_spinlock(&precvpriv->lock);
@@ -179,7 +179,7 @@ u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
 
 		//translate DMA FIFO addr to pipehandle
 		hPipe = ffaddr2pipehdl(pdvobj_priv, addr);
-
+		
 
 		RT_TRACE( _module_hci_ops_os_c_, _drv_info_, ("usb_read_port(%u)\n", __LINE__));
 
@@ -195,7 +195,7 @@ u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
 
 		if(precvbuf->usb_transfer_read_port)
 		{
-
+			
 		//	  GetTransferStatus(usb_funcs_vp, hTransfer, &dwBytesTransferred,&UsbRc);
 
 		//	  CloseTransferHandle(usb_funcs_vp, hTransfer);
@@ -205,7 +205,7 @@ u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
 		{
 
 			dwErr = GetLastError();
-			//RT_TRACE( _module_hci_ops_os_c_, _drv_err_, ("usb_read_port ERROR : %d\n", dwErr));
+			//RT_TRACE( _module_hci_ops_os_c_, _drv_err_, ("usb_read_port ERROR : %d\n", dwErr));		 
 
 		}
 
@@ -217,15 +217,15 @@ u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
 		if ( ERROR_SUCCESS != dwErr ) {
 
 			SetLastError(dwErr);
-			RT_TRACE( _module_hci_ops_os_c_, _drv_err_, ("usb_read_port ERROR : %d\n", dwErr));
+			RT_TRACE( _module_hci_ops_os_c_, _drv_err_, ("usb_read_port ERROR : %d\n", dwErr));	
 		}
-
+	
 		RT_TRACE( _module_hci_ops_os_c_, _drv_info_, ("-usb_read_port(%u)\n", __LINE__));
 
 	}
 	else // if(precvbuf !=NULL)
 	{
-
+		
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port:precv_frame ==NULL\n"));
 	}
 
@@ -262,11 +262,11 @@ DWORD usb_read_port_complete( PVOID context )
 	_rtw_spinlock_ex(&precvpriv->lock);
 	precvbuf->irp_pending=_FALSE;
 	precvpriv->rx_pending_cnt --;
-	_rtw_spinunlock_ex(&precvpriv->lock);
+	_rtw_spinunlock_ex(&precvpriv->lock);	
 
 
 #if 1
-
+		
 	(*usb_funcs_vp->lpGetTransferStatus)(precvbuf->usb_transfer_read_port, &dwBytesTransferred, &dwErr);
 	fComplete = (*usb_funcs_vp->lpIsTransferComplete)(precvbuf->usb_transfer_read_port);
 	if(fComplete!=_TRUE)
@@ -274,14 +274,14 @@ DWORD usb_read_port_complete( PVOID context )
 		RT_TRACE( _module_hci_ops_os_c_, _drv_err_, ("usb_read_port_complete CloseTransfer before complete\n"));
 	}
 	(*usb_funcs_vp->lpCloseTransfer)(precvbuf->usb_transfer_read_port);
-
-
+	
+	
 #endif
 
 
 	if(USB_NO_ERROR != dwErr)
 		RT_TRACE( _module_hci_ops_os_c_, _drv_err_, ("usb_read_port_complete Fail :%d\n",dwErr));
-
+	
 	{
 
 		if ( dwBytesTransferred > MAX_RECVBUF_SZ || dwBytesTransferred < RXDESC_SIZE )
@@ -290,8 +290,8 @@ DWORD usb_read_port_complete( PVOID context )
 				("\n usb_read_port_complete: (pbulkurb->TransferBufferLength > MAX_RECVBUF_SZ) || (pbulkurb->TransferBufferLength < RXDESC_SIZE): %d\n",dwBytesTransferred));
 			rtw_read_port(adapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
 
-	    //usb_read_port(pintfhdl, 0, 0, (unsigned char *)precvframe);
-	}
+    	    //usb_read_port(pintfhdl, 0, 0, (unsigned char *)precvframe);
+    	}
 		else
 		{
 			precvbuf->transfer_len = dwBytesTransferred;
@@ -310,7 +310,7 @@ DWORD usb_read_port_complete( PVOID context )
 			{
 				if(recvbuf2recvframe(adapter, precvbuf)==_FAIL)//rx packets
 				{
-					//precvbuf->reuse = _TRUE;
+					//precvbuf->reuse = _TRUE;		
 					rtw_read_port(adapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
 				}
 			}
@@ -337,10 +337,10 @@ DWORD usb_write_mem_complete( LPVOID Context )
 	_irqL irqL;
 	_list	*head;
 	_list *plist;
-	struct io_req	*pio_req;
+	struct io_req	*pio_req;	
 	struct io_queue *pio_q = (struct io_queue *) Context;
-	struct intf_hdl *pintf = &(pio_q->intf);
-	struct intf_priv *pintfpriv = pintf->pintfpriv;
+	struct intf_hdl *pintf = &(pio_q->intf);	
+	struct intf_priv *pintfpriv = pintf->pintfpriv;	
 	_adapter *padapter = (_adapter *)pintf->adapter;
 	NTSTATUS status = STATUS_SUCCESS;
     struct xmit_priv * pxmitpriv	= &padapter->xmitpriv;
@@ -352,18 +352,18 @@ DWORD usb_write_mem_complete( LPVOID Context )
 
 	// get the head from the processing io_queue
 	head = &(pio_q->processing);
-
+	
 _func_enter_;
 	RT_TRACE( _module_hci_ops_os_c_, _drv_info_, ("+usb_write_mem_complete %p\n", Context));
 
 #if 1
 	_enter_critical_bh(&(pio_q->lock), &irqL);
+	
 
-
-	//free irp in processing list...
+	//free irp in processing list...	
 	while(rtw_is_list_empty(head) != _TRUE)
 	{
-		plist = get_next(head);
+		plist = get_next(head);	
 		rtw_list_delete(plist);
 		pio_req = LIST_CONTAINOR(plist, struct io_req, list);
 		_rtw_up_sema(&pio_req->sema);
@@ -374,7 +374,7 @@ DWORD usb_write_mem_complete( LPVOID Context )
 
 
 #if 1
-
+		
 	(*usb_funcs_vp->lpGetTransferStatus)(pio_req->usb_transfer_write_mem , &dwBytes, &dwErr);
 	fComplete = (*usb_funcs_vp->lpIsTransferComplete)(pio_req->usb_transfer_write_mem);
 	if(fComplete!=_TRUE)
@@ -382,9 +382,9 @@ DWORD usb_write_mem_complete( LPVOID Context )
 		RT_TRACE( _module_hci_ops_os_c_, _drv_err_, ("usb_write_mem_complete CloseTransfer before complete\n"));
 	}
 	(*usb_funcs_vp->lpCloseTransfer)(pio_req->usb_transfer_write_mem );
-
+	
 #endif
-
+	
 	RT_TRACE( _module_hci_ops_os_c_, _drv_info_, ("-usb_write_mem_complete\n"));
 
 _func_exit_;
@@ -413,9 +413,9 @@ void usb_write_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
 	struct intf_priv 	*pintfpriv	= pintfhdl->pintfpriv;
 	struct dvobj_priv   * pdvobj_priv   = (struct dvobj_priv*)pintfpriv->intf_dev;
 
-
+	 
     struct xmit_priv	*pxmitpriv	= &adapter->xmitpriv;
-	struct io_queue 	*pio_queue 	= (struct io_queue *)adapter->pio_queue;
+	struct io_queue 	*pio_queue 	= (struct io_queue *)adapter->pio_queue; 
 
 	LPCUSB_FUNCS usb_funcs_vp = pdvobj_priv->usb_extension._lpUsbFuncs;
 
@@ -425,34 +425,34 @@ void usb_write_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
 
 	// fetch a io_request from the io_queue
 	pio_req = alloc_ioreq(pio_queue);
-
+		
 	if ((pio_req == NULL)||(adapter->bSurpriseRemoved))
 	{
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("async_irp_write32 : pio_req =0x%x adapter->bSurpriseRemoved=0x%x",pio_req,adapter->bSurpriseRemoved ));
 		goto exit;
-	}
+	}	
 
 	_enter_critical_bh(&(pio_queue->lock), &irqL);
 
 
 	// insert the io_request into processing io_queue
 	rtw_list_insert_tail(&(pio_req->list),&(pio_queue->processing));
-
-
-	if((adapter->bDriverStopped) || (adapter->bSurpriseRemoved) ||(adapter->pwrctrlpriv.pnp_bstop_trx))
+	
+	
+	if((adapter->bDriverStopped) || (adapter->bSurpriseRemoved) ||(adapter->pwrctrlpriv.pnp_bstop_trx)) 
 	{
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("\npadapter->pwrctrlpriv.pnp_bstop_trx==_TRUE\n"));
 		goto exit;
 	}
-
+	
 	//translate DMA FIFO addr to pipehandle
-	hPipe = ffaddr2pipehdl(pdvobj_priv, addr);
+	hPipe = ffaddr2pipehdl(pdvobj_priv, addr);	
 
 	RT_TRACE( _module_hci_ops_os_c_, _drv_info_,("usb_write_mem(%u)\n",__LINE__));
 
 	pio_req->usb_transfer_write_mem = (*usb_funcs_vp->lpIssueBulkTransfer)(
 		hPipe,
-		usb_write_mem_complete,
+		usb_write_mem_complete, 
 		pio_queue,
 		USB_OUT_TRANSFER,
 		cnt,
@@ -474,24 +474,24 @@ void usb_write_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
 		}
 		else
 		{
-			RT_TRACE( _module_hci_ops_os_c_, _drv_err_,
-				("usb_write_mem not yet finished %X\n",
+			RT_TRACE( _module_hci_ops_os_c_, _drv_err_, 
+				("usb_write_mem not yet finished %X\n", 
 				pio_req->usb_transfer_write_mem));
 			rtw_msleep_os(10);
 		}
-
+		
 	}
 
 #endif
 
 
-//	_rtw_down_sema(&pio_req->sema);
+//	_rtw_down_sema(&pio_req->sema);	
 
 	RT_TRACE( _module_hci_ops_os_c_, _drv_info_, ("-usb_write_mem(%X)\n",pio_req->usb_transfer_write_mem));
 
 	_exit_critical_bh(&(pio_queue->lock), &irqL);
 
-	_rtw_down_sema(&pio_req->sema);
+	_rtw_down_sema(&pio_req->sema); 
 	free_ioreq(pio_req, pio_queue);
 
 exit:
@@ -507,105 +507,105 @@ USB_PIPE ffaddr2pipehdl(struct dvobj_priv *pNdisCEDvice, u32 addr)
 	USB_PIPE	PipeHandle = NULL;
 	_adapter	*padapter = pNdisCEDvice->padapter;
 
-
+	
 	if(pNdisCEDvice->nr_endpoint == 11)
-	{
+	{		
 		switch(addr)
-		{
-			case RTL8712_DMA_BEQ:
-				PipeHandle= padapter->halpriv.pipehdls_r8712[3] ;
+		{	    
+	     		case RTL8712_DMA_BEQ:
+		 		PipeHandle= padapter->halpriv.pipehdls_r8712[3] ; 
 				break;
-			case RTL8712_DMA_BKQ:
-				PipeHandle=  padapter->halpriv.pipehdls_r8712[4];
+	     		case RTL8712_DMA_BKQ:
+			 	PipeHandle=  padapter->halpriv.pipehdls_r8712[4]; 
 				break;
-			case RTL8712_DMA_VIQ:
-				PipeHandle=  padapter->halpriv.pipehdls_r8712[2];
-				break;
-			case RTL8712_DMA_VOQ:
-				PipeHandle=  padapter->halpriv.pipehdls_r8712[1];
-				break;
-                     case RTL8712_DMA_BCNQ:
-				PipeHandle=  padapter->halpriv.pipehdls_r8712[6];
+	     		case RTL8712_DMA_VIQ:
+		 		PipeHandle=  padapter->halpriv.pipehdls_r8712[2]; 
 				break;
+	    		case RTL8712_DMA_VOQ:
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[1]; 
+				break;					
+                     case RTL8712_DMA_BCNQ:	
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[6]; 
+				break;	 	
 			case RTL8712_DMA_BMCQ:	//HI Queue
-				PipeHandle=  padapter->halpriv.pipehdls_r8712[7];
-				break;
-			case RTL8712_DMA_MGTQ:
-				PipeHandle=  padapter->halpriv.pipehdls_r8712[8];
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[7]; 
+				break;	
+			case RTL8712_DMA_MGTQ:				
+		 		PipeHandle=  padapter->halpriv.pipehdls_r8712[8]; 
 				break;
                      case RTL8712_DMA_RX0FF:
-				PipeHandle=  padapter->halpriv.pipehdls_r8712[0];
-				break;
-			case RTL8712_DMA_C2HCMD:
-				PipeHandle=  padapter->halpriv.pipehdls_r8712[5];
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[0]; 
+				break;	 	
+			case RTL8712_DMA_C2HCMD:		 	
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[5]; 
 				break;
 			case RTL8712_DMA_H2CCMD:
-				PipeHandle=  padapter->halpriv.pipehdls_r8712[9];
-				break;
-
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[9]; 
+				break;	
+				
 		}
 
 	}
 	else if(pNdisCEDvice->nr_endpoint == 6)
 	{
 		switch(addr)
-		{
+		{	    
 			case RTL8712_DMA_BEQ:
-				PipeHandle=  padapter->halpriv.pipehdls_r8712[3];
+		 		PipeHandle=  padapter->halpriv.pipehdls_r8712[3]; 
 				break;
-		case RTL8712_DMA_BKQ:
-				PipeHandle=  padapter->halpriv.pipehdls_r8712[4];
+	     	case RTL8712_DMA_BKQ:
+			 	PipeHandle=  padapter->halpriv.pipehdls_r8712[4]; 
 				break;
-		case RTL8712_DMA_VIQ:
-				PipeHandle=  padapter->halpriv.pipehdls_r8712[2];
+	     	case RTL8712_DMA_VIQ:
+		 		PipeHandle=  padapter->halpriv.pipehdls_r8712[2]; 
 				break;
-		case RTL8712_DMA_VOQ:
-				PipeHandle=  padapter->halpriv.pipehdls_r8712[1];
+	    	case RTL8712_DMA_VOQ:                   		
+		 		PipeHandle=  padapter->halpriv.pipehdls_r8712[1]; 
 				break;
 			case RTL8712_DMA_RX0FF:
-			case RTL8712_DMA_C2HCMD:
-				PipeHandle=  padapter->halpriv.pipehdls_r8712[0];
+			case RTL8712_DMA_C2HCMD:		 	
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[0]; 
 				break;
 			case RTL8712_DMA_H2CCMD:
-			case RTL8712_DMA_BCNQ:
-			case RTL8712_DMA_BMCQ:
-			case RTL8712_DMA_MGTQ:
-				PipeHandle=  padapter->halpriv.pipehdls_r8712[5];
-				break;
-
+			case RTL8712_DMA_BCNQ:					
+			case RTL8712_DMA_BMCQ:	
+			case RTL8712_DMA_MGTQ:			
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[5]; 
+				break;	
+				
 		}
 
 	}
 	else if(pNdisCEDvice->nr_endpoint == 4)
 	{
 		switch(addr)
-		{
-		case RTL8712_DMA_BEQ:
-			case RTL8712_DMA_BKQ:
-				PipeHandle=  padapter->halpriv.pipehdls_r8712[2];
+		{	    
+	     	case RTL8712_DMA_BEQ:
+		 	case RTL8712_DMA_BKQ:
+			 	PipeHandle=  padapter->halpriv.pipehdls_r8712[2]; 
 				break;
-		case RTL8712_DMA_VIQ:
-			case RTL8712_DMA_VOQ:
-				PipeHandle=  padapter->halpriv.pipehdls_r8712[1];
+     		case RTL8712_DMA_VIQ:
+		 	case RTL8712_DMA_VOQ:					
+		 		PipeHandle=  padapter->halpriv.pipehdls_r8712[1]; 
 				break;
 			case RTL8712_DMA_RX0FF:
-			case RTL8712_DMA_C2HCMD:
-				PipeHandle=  padapter->halpriv.pipehdls_r8712[0];
-				break;
-			case RTL8712_DMA_H2CCMD:
-			case RTL8712_DMA_BCNQ:
-			case RTL8712_DMA_BMCQ:
-			case RTL8712_DMA_MGTQ:
-				PipeHandle=  padapter->halpriv.pipehdls_r8712[3];
+			case RTL8712_DMA_C2HCMD:		 	
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[0]; 
 				break;
+			case RTL8712_DMA_H2CCMD:	
+			case RTL8712_DMA_BCNQ:					
+			case RTL8712_DMA_BMCQ:	
+			case RTL8712_DMA_MGTQ:				
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[3]; 
+				break;	
 		}
-
+	
 	}
 	else
 	{
-	   RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("ffaddr2pipehdl():nr_endpoint=%d error!\n", pNdisCEDvice->nr_endpoint));
+	   RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("ffaddr2pipehdl():nr_endpoint=%d error!\n", pNdisCEDvice->nr_endpoint));	   
 	}
-
+		
 	return PipeHandle;
 
 }
@@ -625,7 +625,7 @@ DWORD usb_bulkout_zero_complete( LPVOID pZeroContext )
 _func_enter_;
 
 #if 1
-
+				
 	(*usb_funcs_vp->lpGetTransferStatus)(pxmitpriv->usb_transfer_write_port, &dwBytesTransferred, &dwErr);
 	fComplete = (*usb_funcs_vp->lpIsTransferComplete)(pxmitpriv->usb_transfer_write_port);
 	if(fComplete!=_TRUE)
@@ -633,35 +633,35 @@ DWORD usb_bulkout_zero_complete( LPVOID pZeroContext )
 		RT_TRACE( _module_hci_ops_os_c_, _drv_err_, ("usb_bulkout_zero_complete CloseTransfer before complete\n"));
 	}
 	(*usb_funcs_vp->lpCloseTransfer)(pxmitpriv->usb_transfer_write_port);
-
+	
 #endif
 
 	if(pcontext)
 	{
 		if(pcontext->pbuf)
-		{
-			rtw_mfree(pcontext->pbuf, sizeof(int));
-		}
+		{			
+			rtw_mfree(pcontext->pbuf, sizeof(int));	
+		}	
 
-		rtw_mfree((u8*)pcontext, sizeof(struct zero_bulkout_context));
-	}
+		rtw_mfree((u8*)pcontext, sizeof(struct zero_bulkout_context));	
+	}	
 
 _func_exit_;
 
 	return ERROR_SUCCESS;
-
+	
 
 }
 
 u32 usb_bulkout_zero(struct intf_hdl *pintfhdl, u32 addr)
-{
+{	
 	struct zero_bulkout_context *pcontext;
 	unsigned char *pbuf;
 	u8 len = 0 ;
 	_adapter *padapter = (_adapter *)pintfhdl->adapter;
-	struct dvobj_priv	*pdvobj = (struct dvobj_priv *)&padapter->dvobjpriv;
+	struct dvobj_priv	*pdvobj = (struct dvobj_priv *)&padapter->dvobjpriv;	
 	struct xmit_priv	* pxmitpriv     = &padapter->xmitpriv;
-
+     
 
 	LPCUSB_FUNCS usb_funcs_vp = pdvobj->usb_extension._lpUsbFuncs;
 
@@ -670,22 +670,22 @@ u32 usb_bulkout_zero(struct intf_hdl *pintfhdl, u32 addr)
 _func_enter_;
 
 	if((padapter->bDriverStopped) || (padapter->bSurpriseRemoved) ||(padapter->pwrctrlpriv.pnp_bstop_trx))
-	{
+	{		
 		return _FAIL;
 	}
 
 
 	pcontext = (struct zero_bulkout_context *)rtw_zmalloc(sizeof(struct zero_bulkout_context));
 
-	pbuf = (unsigned char *)rtw_zmalloc(sizeof(int));
+	pbuf = (unsigned char *)rtw_zmalloc(sizeof(int));	
 
 	len = 0;
-
+	
 	pcontext->pbuf = pbuf;
 	pcontext->purb = NULL;
 	pcontext->pirp = NULL;
 	pcontext->padapter = padapter;
-
+                    
 
 //translate DMA FIFO addr to pipehandle
 	hPipe = ffaddr2pipehdl(pdvobj, addr);
@@ -694,13 +694,13 @@ u32 usb_bulkout_zero(struct intf_hdl *pintfhdl, u32 addr)
 
 
 	pxmitpriv->usb_transfer_write_port = (*usb_funcs_vp->lpIssueBulkTransfer)(
-						        hPipe, usb_bulkout_zero_complete,
+						        hPipe, usb_bulkout_zero_complete, 
 						        pcontext, USB_OUT_TRANSFER,
-						    len, pbuf, 0);
-
+					    	    len, pbuf, 0);
 
+	
 _func_exit_;
-
+	
 	return _SUCCESS;
 
 }
@@ -731,7 +731,7 @@ u32 usb_write_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
 
 #if (CONFIG_PWRCTRL == 1)
     if(padapter->pwrctrlpriv.pnp_bstop_trx==_TRUE){
-	RT_TRACE( _module_hci_ops_os_c_, _drv_err_, ("\npadapter->pwrctrlpriv.pnp_bstop_trx==_TRUE\n"));
+       	RT_TRACE( _module_hci_ops_os_c_, _drv_err_, ("\npadapter->pwrctrlpriv.pnp_bstop_trx==_TRUE\n"));
 
     }
 #endif
@@ -749,17 +749,17 @@ u32 usb_write_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
 	{
 		if(pxmitframe->bpending[i] == _FALSE)
 		{
-			_rtw_spinlock(&pxmitpriv->lock);
+			_rtw_spinlock(&pxmitpriv->lock);	
 			pxmitpriv->txirp_cnt++;
 			pxmitframe->bpending[i]  = _TRUE;
 			_rtw_spinunlock(&pxmitpriv->lock);
-
+			
 			pxmitframe->sz[i] = cnt;
 			pxmitframe->ac_tag[i] = ac_tag;
 
 			break;
 		}
-	}
+	}	
 
 
 	//TODO:
@@ -771,7 +771,7 @@ u32 usb_write_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
 		//	cnt=cnt+1;
 			bwritezero = _TRUE;
 
-		}
+		}	
 	}
 	else
 	{
@@ -781,7 +781,7 @@ u32 usb_write_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
 		//	cnt=cnt+1;
 			bwritezero = _TRUE;
 
-		}
+		}	
 	}
 
 	RT_TRACE( _module_hci_ops_os_c_, _drv_info_, ("usb_write_port: pipe handle convert\n"));
@@ -801,9 +801,9 @@ u32 usb_write_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
 		("usb_write_port(%u): pxmitframe %X  pxmitframe->padapter %X\n",__LINE__, pxmitframe, pxmitframe->padapter));
 
 	pxmitpriv->usb_transfer_write_port = (*usb_funcs_vp->lpIssueBulkTransfer)(
-						        hPipe, usb_write_port_complete,
+						        hPipe, usb_write_port_complete, 
 						        pxmitframe, USB_OUT_TRANSFER,
-						    cnt, pxmitframe->mem_addr, 0);
+					    	    cnt, pxmitframe->mem_addr, 0);
 
 	RT_TRACE( _module_hci_ops_os_c_, _drv_info_, ("%s(%u)\n",__FUNCTION__, __LINE__));
 
@@ -858,22 +858,22 @@ DWORD usb_write_port_complete( LPVOID Context )
 
 	RT_TRACE(_module_hci_ops_os_c_,_drv_info_,("+usb_write_port_complete\n"));
 
-	_rtw_spinlock_ex(&pxmitpriv->lock);
+	_rtw_spinlock_ex(&pxmitpriv->lock);	
 	pxmitpriv->txirp_cnt--;
 	_rtw_spinunlock_ex(&pxmitpriv->lock);
 
 	if(pxmitpriv->txirp_cnt==0){
-		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete: txirp_cnt== 0, set allrxreturnevt!\n"));
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete: txirp_cnt== 0, set allrxreturnevt!\n"));		
 		_rtw_up_sema(&(pxmitpriv->tx_retevt));
 	}
 
 
 	//not to consider tx fragment
-	rtw_free_xmitframe(pxmitpriv, pxmitframe);
+	rtw_free_xmitframe(pxmitpriv, pxmitframe);		
 
 
 #if 1
-
+			
 	(*usb_funcs_vp->lpGetTransferStatus)(pxmitpriv->usb_transfer_write_port, &dwBytesTransferred, &dwErr);
 	fComplete = (*usb_funcs_vp->lpIsTransferComplete)(pxmitpriv->usb_transfer_write_port);
 	if(fComplete!=_TRUE)
@@ -891,8 +891,8 @@ DWORD usb_write_port_complete( LPVOID Context )
 
 #endif
 
-	RT_TRACE( _module_hci_ops_os_c_, _drv_info_,
-		("%s(%u): pxmitpriv %X pxmitpriv->free_xmitframe_cnt %X pxmitframe->padapter %X pxmitframe->padapter %X\n",
+	RT_TRACE( _module_hci_ops_os_c_, _drv_info_, 
+		("%s(%u): pxmitpriv %X pxmitpriv->free_xmitframe_cnt %X pxmitframe->padapter %X pxmitframe->padapter %X\n", 
 		__LINE__, pxmitpriv, pxmitpriv->free_xmitframe_cnt, pxmitframe->padapter));
 
     rtl8192cu_xmitframe_complete(padapter, pxmitpriv, pxmitbuf);
@@ -902,7 +902,7 @@ DWORD usb_write_port_complete( LPVOID Context )
     return STATUS_SUCCESS;
 }
 
-DWORD usb_write_scsi_complete(LPVOID pTxContext)
+DWORD usb_write_scsi_complete(LPVOID pTxContext) 
 {
 #ifndef PLATFORM_OS_CE
 	struct SCSI_BUFFER_ENTRY *psb_entry = (struct SCSI_BUFFER_ENTRY *)pTxContext;
@@ -920,7 +920,7 @@ DWORD usb_write_scsi_complete(LPVOID pTxContext)
 	RT_TRACE( _module_hci_ops_os_c_, _drv_info_, ("%s(%u): circ_space = %d\n",__FUNCTION__, __LINE__, CIRC_SPACE( psb->head,psb->tail,  SCSI_BUFFER_NUMBER)));
 
 #if 1
-
+				
 	(*lpUsbFuncs->lpGetTransferStatus)(psb_entry->usb_transfer_scsi_txcmd, &dwBytesTransferred, &dwErr);
 	fComplete = (*lpUsbFuncs->lpIsTransferComplete)(psb_entry->usb_transfer_scsi_txcmd);
 	if(fComplete!=_TRUE)
@@ -928,7 +928,7 @@ DWORD usb_write_scsi_complete(LPVOID pTxContext)
 		RT_TRACE( _module_hci_ops_os_c_, _drv_err_, ("usb_write_scsi_complete CloseTransfer before complete\n"));
 	}
 	(*lpUsbFuncs->lpCloseTransfer)(psb_entry->usb_transfer_scsi_txcmd);
-
+	
 #else
 
 	if((*lpUsbFuncs->lpIsTransferComplete)(psb_entry->usb_transfer_scsi_txcmd))
@@ -940,7 +940,7 @@ DWORD usb_write_scsi_complete(LPVOID pTxContext)
 	RT_TRACE( _module_hci_ops_os_c_, _drv_info_, ("%s(%u)\n",__FUNCTION__, __LINE__));
 	if((psb->tail+1)==SCSI_BUFFER_NUMBER)
 		psb->tail=0;
-	else
+	else 
 		psb->tail++;
 
 	RT_TRACE( _module_hci_ops_os_c_, _drv_info_, ("%s(%u)\n",__FUNCTION__, __LINE__));
@@ -974,7 +974,7 @@ uint usb_write_scsi(struct intf_hdl *pintfhdl, u32 cnt, u8 *wmem)
 _func_enter_;
 	if(padapter->bSurpriseRemoved||padapter->bDriverStopped)
 		return 0;
-
+	
 	RT_TRACE( _module_hci_ops_os_c_, _drv_info_, ("%s(%u)\n",__FUNCTION__, __LINE__));
 	psb_entry->usb_transfer_scsi_txcmd=pdev->pUsbExtension->_lpUsbFuncs->lpIssueBulkTransfer(
 			pdev->scsi_out_pipehandle,
@@ -984,11 +984,11 @@ uint usb_write_scsi(struct intf_hdl *pintfhdl, u32 cnt, u8 *wmem)
 			cnt,
 			wmem,
 			0);
-
+	
 _func_exit_;
 #endif
 
-   return _SUCCESS;
+   return _SUCCESS;  
 }
 
 
@@ -1069,29 +1069,29 @@ void usb_write_port_cancel(_adapter *padapter)
 	_rtw_spinlock(&pxmitpriv->lock);
 	pxmitpriv->txirp_cnt--; //decrease 1 for Initialize ++
 	_rtw_spinunlock(&pxmitpriv->lock);
-
-	if (pxmitpriv->txirp_cnt)
+	
+	if (pxmitpriv->txirp_cnt) 
 	{
 		// Canceling Pending Recv Irp
 		pxmitframe= (struct xmit_frame *)pxmitpriv->pxmit_frame_buf;
-
+		
 		for( i = 0; i < NR_XMITFRAME; i++ )
 		{
 			for(j=0;j<8;j++)
 			{
 				if (pxmitframe->bpending[j]==_TRUE)
-				{
+				{			
 
 					RT_TRACE(_module_hci_ops_os_c_,_drv_err_,(" usb_write_port_cancel() :IoCancelIrp\n"));
 
 				}
 			}
-
+			
 			pxmitframe++;
 		}
 
 		_rtw_down_sema(&(pxmitpriv->tx_retevt));
-
+		
 	}
 
 }
@@ -1101,7 +1101,7 @@ DWORD usbctrl_vendorreq_complete(LPVOID lpvNotifyParameter)
 	struct dvobj_priv  *pdvobjpriv = (struct dvobj_priv*)lpvNotifyParameter;
 
 	RT_TRACE(_module_hci_ops_os_c_,_drv_debug_,("+usbctrl_vendorreq_complete\n"));
-
+	
     return STATUS_SUCCESS;
 }
 
@@ -1113,7 +1113,7 @@ int usbctrl_vendorreq(struct intf_priv *pintfpriv, u8 request, u16 value, u16 in
 //	int 		fComplete;
 //	LPCUSB_DEVICE		lpDeviceInfo;
 
-	struct dvobj_priv  *pdvobjpriv = (struct dvobj_priv  *)pintfpriv->intf_dev;
+	struct dvobj_priv  *pdvobjpriv = (struct dvobj_priv  *)pintfpriv->intf_dev;   
 
     USB_TRANSFER        usbTrans;
     USB_DEVICE_REQUEST  usb_device_req;
@@ -1138,7 +1138,7 @@ int usbctrl_vendorreq(struct intf_priv *pintfpriv, u8 request, u16 value, u16 in
 	usb_device_req.bRequest 		= request;
 	usb_device_req.wValue 			= value;
 	usb_device_req.wIndex 	    	= index;
-	usb_device_req.wLength 	    	= len;
+	usb_device_req.wLength 	    	= len;    
 
 	if (requesttype == 0x01)
 	{
@@ -1153,13 +1153,13 @@ int usbctrl_vendorreq(struct intf_priv *pintfpriv, u8 request, u16 value, u16 in
 
 #if 0
 	// Remember to add callback for sync
-	usbTrans = (*usbFuncs->lpIssueVendorTransfer)(usbHandle,
-							usbctrl_vendorreq_complete, pdvobjpriv,
+	usbTrans = (*usbFuncs->lpIssueVendorTransfer)(usbHandle, 
+							usbctrl_vendorreq_complete, pdvobjpriv, 
 							transfer_flags, &usb_device_req, pdata, 0);
 #else
 	// Remember to add callback for sync
-	usbTrans = (*usbFuncs->lpIssueVendorTransfer)(usbHandle,
-							NULL, 0,
+	usbTrans = (*usbFuncs->lpIssueVendorTransfer)(usbHandle, 
+							NULL, 0, 
 							transfer_flags, &usb_device_req, pdata, 0);
 #endif
 
@@ -1199,7 +1199,9 @@ int usbctrl_vendorreq(struct intf_priv *pintfpriv, u8 request, u16 value, u16 in
 exit:
 	RT_TRACE(_module_hci_ops_os_c_,_drv_debug_,("-usbctrl_vendorreq\n"));
 _func_exit_;
-
-	return ret;
+	
+	return ret;	
 
 }
+
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/usb_ops_linux.c b/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/usb_ops_linux.c
old mode 100644
new mode 100755
index 7167c26..2d627d3
--- a/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/usb_ops_linux.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/usb_ops_linux.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -37,7 +37,7 @@
 static int usbctrl_vendorreq(struct intf_hdl *pintfhdl, u8 request, u16 value, u16 index, void *pdata, u16 len, u8 requesttype)
 {
 	_adapter *padapter = pintfhdl->padapter;
-	struct dvobj_priv  *pdvobjpriv = adapter_to_dvobj(padapter);
+	struct dvobj_priv  *pdvobjpriv = adapter_to_dvobj(padapter); 
 	struct usb_device *udev = pdvobjpriv->pusbdev;
 
 	unsigned int pipe;
@@ -67,21 +67,21 @@ static int usbctrl_vendorreq(struct intf_hdl *pintfhdl, u8 request, u16 value, u
 
 	if((padapter->bSurpriseRemoved) ||(padapter->pwrctrlpriv.pnp_bstop_trx)){
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usbctrl_vendorreq:(padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n"));
-		status = -EPERM;
+		status = -EPERM; 
 		goto exit;
-	}
+	}	
 
 	if(len>MAX_VENDOR_REQ_CMD_SIZE){
 		DBG_8192C( "[%s] Buffer len error ,vendor request failed\n", __FUNCTION__ );
 		status = -EINVAL;
 		goto exit;
-	}
+	}	
 
 	#ifdef CONFIG_USB_VENDOR_REQ_MUTEX
 	_enter_critical_mutex(&pdvobjpriv->usb_vendor_req_mutex, NULL);
 	#endif
-
-
+	
+	
 	// Acquire IO memory for vendorreq
 #ifdef CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC
 	pIo_buf = pdvobjpriv->usb_vendor_req_buf;
@@ -96,7 +96,7 @@ static int usbctrl_vendorreq(struct intf_hdl *pintfhdl, u8 request, u16 value, u
 	// Added by Albert 2010/02/09
 	// For mstar platform, mstar suggests the address for USB IO should be 16 bytes alignment.
 	// Trying to fix it here.
-	pIo_buf = (tmp_buf==NULL)?NULL:tmp_buf + ALIGNMENT_UNIT -((SIZE_PTR)(tmp_buf) & 0x0f );
+	pIo_buf = (tmp_buf==NULL)?NULL:tmp_buf + ALIGNMENT_UNIT -((SIZE_PTR)(tmp_buf) & 0x0f );	
 #endif
 
 	if ( pIo_buf== NULL) {
@@ -104,23 +104,23 @@ static int usbctrl_vendorreq(struct intf_hdl *pintfhdl, u8 request, u16 value, u
 		status = -ENOMEM;
 		goto release_mutex;
 	}
-
+	
 	while(++vendorreq_times<= MAX_USBCTRL_VENDORREQ_TIMES)
 	{
 		_rtw_memset(pIo_buf, 0, len);
-
+		
 		if (requesttype == 0x01)
 		{
 			pipe = usb_rcvctrlpipe(udev, 0);//read_in
-			reqtype =  REALTEK_USB_VENQT_READ;
-		}
-		else
+			reqtype =  REALTEK_USB_VENQT_READ;		
+		} 
+		else 
 		{
 			pipe = usb_sndctrlpipe(udev, 0);//write_out
-			reqtype =  REALTEK_USB_VENQT_WRITE;
+			reqtype =  REALTEK_USB_VENQT_WRITE;		
 			_rtw_memcpy( pIo_buf, pdata, len);
-		}
-
+		}		
+	
 		#if 0
 		//timeout test for firmware downloading
 		status = rtw_usb_control_msg(udev, pipe, request, reqtype, value, index, pIo_buf, len
@@ -129,7 +129,7 @@ static int usbctrl_vendorreq(struct intf_hdl *pintfhdl, u8 request, u16 value, u
 		#else
 		status = rtw_usb_control_msg(udev, pipe, request, reqtype, value, index, pIo_buf, len, RTW_USB_CONTROL_MSG_TIMEOUT);
 		#endif
-
+	
 		if ( status == len)   // Success this control transfer.
 		{
 			rtw_reset_continual_urb_error(pdvobjpriv);
@@ -141,10 +141,10 @@ static int usbctrl_vendorreq(struct intf_hdl *pintfhdl, u8 request, u16 value, u
 		else { // error cases
 			DBG_8192C("reg 0x%x, usb %s %u fail, status:%d value=0x%x, vendorreq_times:%d\n"
 				, value,(requesttype == 0x01)?"read":"write" , len, status, *(u32*)pdata, vendorreq_times);
-
+			
 			if (status < 0) {
 				if(status == (-ESHUTDOWN)	|| status == -ENODEV	)
-				{
+				{			
 					padapter->bSurpriseRemoved = _TRUE;
 				} else {
 					#ifdef DBG_CONFIG_ERROR_DETECT
@@ -169,15 +169,15 @@ static int usbctrl_vendorreq(struct intf_hdl *pintfhdl, u8 request, u16 value, u
 				padapter->bSurpriseRemoved = _TRUE;
 				break;
 			}
-
+	
 		}
-
+	
 		// firmware download is checksumed, don't retry
 		if( (value >= FW_8192C_START_ADDRESS && value <= FW_8192C_END_ADDRESS) || status == len )
 			break;
-
+	
 	}
-
+	
 	// release IO memory used by vendorreq
 	#ifdef CONFIG_USB_VENDOR_REQ_BUFFER_DYNAMIC_ALLOCATE
 	rtw_mfree(tmp_buf, tmp_buflen);
@@ -199,8 +199,8 @@ static u8 usb_read8(struct intf_hdl *pintfhdl, u32 addr)
 	u16 wvalue;
 	u16 index;
 	u16 len;
-	u32 data=0;
-
+	u32 data=0; 
+	
 	_func_enter_;
 
 	request = 0x05;
@@ -208,25 +208,25 @@ static u8 usb_read8(struct intf_hdl *pintfhdl, u32 addr)
 	index = 0;//n/a
 
 	wvalue = (u16)(addr&0x0000ffff);
-	len = 1;
-
+	len = 1;	
+	
 	usbctrl_vendorreq(pintfhdl, request, wvalue, index, &data, len, requesttype);
 
 	_func_exit_;
 
 	return (u8)(le32_to_cpu(data)&0x0ff);
-
+		
 }
 
 static u16 usb_read16(struct intf_hdl *pintfhdl, u32 addr)
-{
+{       
 	u8 request;
 	u8 requesttype;
 	u16 wvalue;
 	u16 index;
 	u16 len;
 	u32 data=0;
-
+	
 	_func_enter_;
 
 	request = 0x05;
@@ -234,14 +234,14 @@ static u16 usb_read16(struct intf_hdl *pintfhdl, u32 addr)
 	index = 0;//n/a
 
 	wvalue = (u16)(addr&0x0000ffff);
-	len = 2;
-
+	len = 2;	
+	
 	usbctrl_vendorreq(pintfhdl, request, wvalue, index, &data, len, requesttype);
 
 	_func_exit_;
 
 	return (u16)(le32_to_cpu(data)&0xffff);
-
+	
 }
 
 static u32 usb_read32(struct intf_hdl *pintfhdl, u32 addr)
@@ -252,7 +252,7 @@ static u32 usb_read32(struct intf_hdl *pintfhdl, u32 addr)
 	u16 index;
 	u16 len;
 	u32 data=0;
-
+	
 	_func_enter_;
 
 	request = 0x05;
@@ -260,14 +260,14 @@ static u32 usb_read32(struct intf_hdl *pintfhdl, u32 addr)
 	index = 0;//n/a
 
 	wvalue = (u16)(addr&0x0000ffff);
-	len = 4;
-
+	len = 4;	
+	
 	usbctrl_vendorreq(pintfhdl, request, wvalue, index, &data, len, requesttype);
 
 	_func_exit_;
 
 	return le32_to_cpu(data);
-
+	
 }
 
 static int usb_write8(struct intf_hdl *pintfhdl, u32 addr, u8 val)
@@ -279,7 +279,7 @@ static int usb_write8(struct intf_hdl *pintfhdl, u32 addr, u8 val)
 	u16 len;
 	u32 data;
 	int ret;
-
+	
 	_func_enter_;
 
 	request = 0x05;
@@ -288,20 +288,20 @@ static int usb_write8(struct intf_hdl *pintfhdl, u32 addr, u8 val)
 
 	wvalue = (u16)(addr&0x0000ffff);
 	len = 1;
-
+	
 	data = val;
 	data = cpu_to_le32(data&0x000000ff);
-
+	
 	ret = usbctrl_vendorreq(pintfhdl, request, wvalue, index, &data, len, requesttype);
-
+	
 	_func_exit_;
-
+	
 	return ret;
-
+	
 }
 
 static int usb_write16(struct intf_hdl *pintfhdl, u32 addr, u16 val)
-{
+{	
 	u8 request;
 	u8 requesttype;
 	u16 wvalue;
@@ -309,7 +309,7 @@ static int usb_write16(struct intf_hdl *pintfhdl, u32 addr, u16 val)
 	u16 len;
 	u32 data;
 	int ret;
-
+	
 	_func_enter_;
 
 	request = 0x05;
@@ -318,16 +318,16 @@ static int usb_write16(struct intf_hdl *pintfhdl, u32 addr, u16 val)
 
 	wvalue = (u16)(addr&0x0000ffff);
 	len = 2;
-
+	
 	data = val;
 	data = cpu_to_le32(data&0x0000ffff);
-
+	
 	ret = usbctrl_vendorreq(pintfhdl, request, wvalue, index, &data, len, requesttype);
-
+	
 	_func_exit_;
-
+	
 	return ret;
-
+	
 }
 
 static int usb_write32(struct intf_hdl *pintfhdl, u32 addr, u32 val)
@@ -339,7 +339,7 @@ static int usb_write32(struct intf_hdl *pintfhdl, u32 addr, u32 val)
 	u16 len;
 	u32 data;
 	int ret;
-
+	
 	_func_enter_;
 
 	request = 0x05;
@@ -348,15 +348,15 @@ static int usb_write32(struct intf_hdl *pintfhdl, u32 addr, u32 val)
 
 	wvalue = (u16)(addr&0x0000ffff);
 	len = 4;
-	data = cpu_to_le32(val);
-
+	data = cpu_to_le32(val);	
+	
 
 	ret =usbctrl_vendorreq(pintfhdl, request, wvalue, index, &data, len, requesttype);
-
+	
 	_func_exit_;
-
+	
 	return ret;
-
+	
 }
 
 static int usb_writeN(struct intf_hdl *pintfhdl, u32 addr, u32 length, u8 *pdata)
@@ -368,7 +368,7 @@ static int usb_writeN(struct intf_hdl *pintfhdl, u32 addr, u32 length, u8 *pdata
 	u16 len;
 	u8 buf[VENDOR_CMD_MAX_DATA_LEN]={0};
 	int ret;
-
+	
 	_func_enter_;
 
 	request = 0x05;
@@ -378,13 +378,13 @@ static int usb_writeN(struct intf_hdl *pintfhdl, u32 addr, u32 length, u8 *pdata
 	wvalue = (u16)(addr&0x0000ffff);
 	len = length;
 	 _rtw_memcpy(buf, pdata, len );
-
+	
 	ret = usbctrl_vendorreq(pintfhdl, request, wvalue, index, buf, len, requesttype);
-
+	
 	_func_exit_;
-
+	
 	return ret;
-
+	
 }
 
 #ifdef CONFIG_USB_INTERRUPT_IN_PIPE
@@ -412,13 +412,13 @@ static void usb_read_interrupt_complete(struct urb *purb, struct pt_regs *regs)
 
 		switch(purb->status) {
 			case -EINVAL:
-			case -EPIPE:
+			case -EPIPE:			
 			case -ENODEV:
 			case -ESHUTDOWN:
 				//padapter->bSurpriseRemoved=_TRUE;
 				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bSurpriseRemoved=TRUE\n"));
 			case -ENOENT:
-				padapter->bDriverStopped=_TRUE;
+				padapter->bDriverStopped=_TRUE;			
 				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bDriverStopped=TRUE\n"));
 				break;
 			case -EPROTO:
@@ -427,9 +427,9 @@ static void usb_read_interrupt_complete(struct urb *purb, struct pt_regs *regs)
 				DBG_8192C("ERROR: URB IS IN PROGRESS!/n");
 				break;
 			default:
-				break;
+				break;				
 		}
-	}
+	}	
 
 }
 
@@ -448,12 +448,12 @@ static u32 usb_read_interrupt(struct intf_hdl *pintfhdl, u32 addr)
 	//translate DMA FIFO addr to pipehandle
 	pipe = ffaddr2pipehdl(pdvobj, addr);
 
-	usb_fill_int_urb(precvpriv->int_in_urb, pusbd, pipe,
+	usb_fill_int_urb(precvpriv->int_in_urb, pusbd, pipe, 
 					precvpriv->int_in_buf,
-					sizeof(INTERRUPT_MSG_FORMAT_EX),
-					usb_read_interrupt_complete,
-					adapter,
-					1);
+            				sizeof(INTERRUPT_MSG_FORMAT_EX),
+            				usb_read_interrupt_complete,
+            				adapter,
+            				1);
 
 	err = usb_submit_urb(precvpriv->int_in_urb, GFP_ATOMIC);
 	if((err) && (err != (-EPERM)))
@@ -469,9 +469,9 @@ static u32 usb_read_interrupt(struct intf_hdl *pintfhdl, u32 addr)
 #endif
 
 static s32 pre_recv_entry(union recv_frame *precvframe, struct recv_stat *prxstat, struct phy_stat *pphy_info)
-{
+{	
 	s32 ret=_SUCCESS;
-#ifdef CONFIG_CONCURRENT_MODE
+#ifdef CONFIG_CONCURRENT_MODE	
 	u8 *primary_myid, *secondary_myid, *paddr1;
 	union recv_frame	*precvframe_if2 = NULL;
 	_adapter *primary_padapter = precvframe->u.hdr.adapter;
@@ -479,11 +479,11 @@ static s32 pre_recv_entry(union recv_frame *precvframe, struct recv_stat *prxsta
 	struct recv_priv *precvpriv = &primary_padapter->recvpriv;
 	_queue *pfree_recv_queue = &precvpriv->free_recv_queue;
 	u8	*pbuf = precvframe->u.hdr.rx_data;
-
+	
 	if(!secondary_padapter)
 		return ret;
-
-	paddr1 = GetAddr1Ptr(precvframe->u.hdr.rx_data);
+	
+	paddr1 = GetAddr1Ptr(precvframe->u.hdr.rx_data);		
 
 	if(IS_MCAST(paddr1) == _FALSE)//unicast packets
 	{
@@ -491,31 +491,31 @@ static s32 pre_recv_entry(union recv_frame *precvframe, struct recv_stat *prxsta
 		secondary_myid = myid(&secondary_padapter->eeprompriv);
 
 		if(_rtw_memcmp(paddr1, secondary_myid, ETH_ALEN))
-		{
+		{			
 			//change to secondary interface
 			precvframe->u.hdr.adapter = secondary_padapter;
-		}
+		}	
 
 		//ret = recv_entry(precvframe);
 
 	}
-	else // Handle BC/MC Packets
+	else // Handle BC/MC Packets	
 	{
-
+		
 		u8 clone = _TRUE;
-#if 0
+#if 0		
 		u8 type, subtype, *paddr2, *paddr3;
-
+	
 		type =  GetFrameType(pbuf);
 		subtype = GetFrameSubType(pbuf); //bit(7)~bit(2)
-
+		
 		switch (type)
 		{
 			case WIFI_MGT_TYPE: //Handle BC/MC mgnt Packets
 				if(subtype == WIFI_BEACON)
 				{
 					paddr3 = GetAddr3Ptr(precvframe->u.hdr.rx_data);
-
+				
 					if (check_fwstate(&secondary_padapter->mlmepriv, _FW_LINKED) &&
 						_rtw_memcmp(paddr3, get_bssid(&secondary_padapter->mlmepriv), ETH_ALEN))
 					{
@@ -529,23 +529,23 @@ static s32 pre_recv_entry(union recv_frame *precvframe, struct recv_stat *prxsta
 					{
 						if(clone==_FALSE)
 						{
-							clone = _TRUE;
-						}
+							clone = _TRUE;									
+						}	
 						else
 						{
 							clone = _FALSE;
 						}
 
-						precvframe->u.hdr.adapter = primary_padapter;
+						precvframe->u.hdr.adapter = primary_padapter;	
 					}
 
 					if(check_fwstate(&primary_padapter->mlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) ||
 						check_fwstate(&secondary_padapter->mlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING))
 					{
 						clone = _TRUE;
-						precvframe->u.hdr.adapter = primary_padapter;
+						precvframe->u.hdr.adapter = primary_padapter;	
 					}
-
+				
 				}
 				else if(subtype == WIFI_PROBEREQ)
 				{
@@ -553,14 +553,14 @@ static s32 pre_recv_entry(union recv_frame *precvframe, struct recv_stat *prxsta
 					//change to secondary interface
 					precvframe->u.hdr.adapter = secondary_padapter;
 					clone = _FALSE;
-				}
+				}			
 				break;
 			case WIFI_CTRL_TYPE: // Handle BC/MC ctrl Packets
-
+			
 				break;
 			case WIFI_DATA_TYPE: //Handle BC/MC data Packets
 					//Notes: AP MODE never rx BC/MC data packets
-
+			
 				paddr2 = GetAddr2Ptr(precvframe->u.hdr.rx_data);
 
 				if(_rtw_memcmp(paddr2, get_bssid(&secondary_padapter->mlmepriv), ETH_ALEN))
@@ -572,8 +572,8 @@ static s32 pre_recv_entry(union recv_frame *precvframe, struct recv_stat *prxsta
 
 				break;
 			default:
-
-				break;
+			
+				break;			
 		}
 #endif
 
@@ -584,13 +584,13 @@ static s32 pre_recv_entry(union recv_frame *precvframe, struct recv_stat *prxsta
 			u32 alloc_sz, skb_len;
 			_pkt	 *pkt_copy = NULL;
 			struct rx_pkt_attrib *pattrib = NULL;
-
+		
 			precvframe_if2 = rtw_alloc_recvframe(pfree_recv_queue);
 			if(precvframe_if2)
 			{
 				precvframe_if2->u.hdr.adapter = secondary_padapter;
-
-				_rtw_init_listhead(&precvframe_if2->u.hdr.list);
+		
+				_rtw_init_listhead(&precvframe_if2->u.hdr.list);	
 				precvframe_if2->u.hdr.precvbuf = NULL;	//can't access the precvbuf for new arch.
 				precvframe_if2->u.hdr.len=0;
 
@@ -639,24 +639,24 @@ static s32 pre_recv_entry(union recv_frame *precvframe, struct recv_stat *prxsta
 					skb_reserve( pkt_copy, shift_sz );//force ip_hdr at 8-byte alignment address according to shift_sz.
 					_rtw_memcpy(pkt_copy->data, pbuf, skb_len);
 					precvframe_if2->u.hdr.rx_data = precvframe_if2->u.hdr.rx_tail = pkt_copy->data;
-
-
+					
+			
 					recvframe_put(precvframe_if2, skb_len);
 					//recvframe_pull(precvframe_if2, drvinfo_sz + RXDESC_SIZE);
 
 					rtl8192c_translate_rx_signal_stuff(precvframe_if2, pphy_info);
-
+	
 					ret = rtw_recv_entry(precvframe_if2);
 
 				} else {
 					rtw_free_recvframe(precvframe_if2, pfree_recv_queue);
-					DBG_8192C("%s()-%d: alloc_skb() failed!\n", __FUNCTION__, __LINE__);
+					DBG_8192C("%s()-%d: alloc_skb() failed!\n", __FUNCTION__, __LINE__);	
 				}
 
 			}
-
+			
 		}
-
+		
 	}
 
 	rtl8192c_translate_rx_signal_stuff(precvframe, pphy_info);
@@ -687,20 +687,20 @@ static int recvbuf2recvframe(_adapter *padapter, struct recv_buf *precvbuf)
 	_queue			*pfree_recv_queue = &precvpriv->free_recv_queue;
 
 
-	transfer_len = (s32)precvbuf->transfer_len;
+	transfer_len = (s32)precvbuf->transfer_len;	
 	pbuf = precvbuf->pbuf;
 
-	prxstat = (struct recv_stat *)pbuf;
+	prxstat = (struct recv_stat *)pbuf;	
 	pkt_cnt = (le32_to_cpu(prxstat->rxdw2)>>16) & 0xff;
-
+	
 #if 0 //temp remove when disable usb rx aggregation
 	if((pkt_cnt > 10) || (pkt_cnt < 1) || (transfer_len<RXDESC_SIZE) ||(pkt_len<=0))
-	{
+	{		
 		return _FAIL;
 	}
 #endif
-
-	do{
+	
+	do{		
 		RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
 			 ("recvbuf2recvframe: rxdesc=offsset 0:0x%08x, 4:0x%08x, 8:0x%08x, C:0x%08x\n",
 			  prxstat->rxdw0, prxstat->rxdw1, prxstat->rxdw2, prxstat->rxdw4));
@@ -711,11 +711,11 @@ static int recvbuf2recvframe(_adapter *padapter, struct recv_buf *precvbuf)
 		if(precvframe==NULL)
 		{
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe: precvframe==NULL\n"));
-			DBG_8192C("%s()-%d: rtw_alloc_recvframe() failed! RX Drop!\n", __FUNCTION__, __LINE__);
+			DBG_8192C("%s()-%d: rtw_alloc_recvframe() failed! RX Drop!\n", __FUNCTION__, __LINE__);	
 			goto _exit_recvbuf2recvframe;
 		}
 
-		_rtw_init_listhead(&precvframe->u.hdr.list);
+		_rtw_init_listhead(&precvframe->u.hdr.list);	
 		precvframe->u.hdr.precvbuf = NULL;	//can't access the precvbuf for new arch.
 		precvframe->u.hdr.len=0;
 
@@ -730,9 +730,9 @@ static int recvbuf2recvframe(_adapter *padapter, struct recv_buf *precvbuf)
 		pkt_offset = RXDESC_SIZE + pattrib->drvinfo_sz + pattrib->shift_sz + pattrib->pkt_len;
 
 		if((pattrib->pkt_len<=0) || (pkt_offset>transfer_len))
-		{
+		{	
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("recvbuf2recvframe: pkt_len<=0\n"));
-			DBG_8192C("%s()-%d: RX Warning!\n", __FUNCTION__, __LINE__);
+			DBG_8192C("%s()-%d: RX Warning!\n", __FUNCTION__, __LINE__);	
 			rtw_free_recvframe(precvframe, pfree_recv_queue);
 			goto _exit_recvbuf2recvframe;
 		}
@@ -793,7 +793,7 @@ static int recvbuf2recvframe(_adapter *padapter, struct recv_buf *precvbuf)
 		}
 
 		recvframe_put(precvframe, skb_len);
-		//recvframe_pull(precvframe, drvinfo_sz + RXDESC_SIZE);
+		//recvframe_pull(precvframe, drvinfo_sz + RXDESC_SIZE);	
 
 #ifdef CONFIG_USB_RX_AGGREGATION
 		switch(pHalData->UsbRxAggMode)
@@ -805,8 +805,8 @@ static int recvbuf2recvframe(_adapter *padapter, struct recv_buf *precvbuf)
 				case USB_RX_AGG_USB:
 				pkt_offset = (u16)_RND4(pkt_offset);
 				break;
-			case USB_RX_AGG_DISABLE:
-			default:
+			case USB_RX_AGG_DISABLE:			
+			default:				
 				break;
 		}
 #endif
@@ -827,7 +827,7 @@ static int recvbuf2recvframe(_adapter *padapter, struct recv_buf *precvbuf)
 				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe: rtw_recv_entry(precvframe) != _SUCCESS\n"));
 			}
 		}
-
+	
 #else
 		rtl8192c_translate_rx_signal_stuff(precvframe, pphy_info);
 		if(rtw_recv_entry(precvframe) != _SUCCESS)
@@ -838,7 +838,7 @@ static int recvbuf2recvframe(_adapter *padapter, struct recv_buf *precvbuf)
 
 		pkt_cnt--;
 		transfer_len -= pkt_offset;
-		pbuf += pkt_offset;
+		pbuf += pkt_offset;	
 		precvframe = NULL;
 		pkt_copy = NULL;
 
@@ -853,7 +853,7 @@ static int recvbuf2recvframe(_adapter *padapter, struct recv_buf *precvbuf)
 }
 
 void rtl8192cu_recv_tasklet(void *priv)
-{
+{	
 	struct recv_buf *precvbuf = NULL;
 	_adapter	*padapter = (_adapter*)priv;
 	struct recv_priv	*precvpriv = &padapter->recvpriv;
@@ -863,31 +863,31 @@ void rtl8192cu_recv_tasklet(void *priv)
 		if ((padapter->bDriverStopped == _TRUE)||(padapter->bSurpriseRemoved== _TRUE))
 		{
 			DBG_8192C("recv_tasklet => bDriverStopped or bSurpriseRemoved \n");
-
+			
 			break;
 		}
-
+		
 
 		recvbuf2recvframe(padapter, precvbuf);
 
 		rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
-	}
-
+	}	
+	
 }
 
 static void usb_read_port_complete(struct urb *purb, struct pt_regs *regs)
-{
-	struct recv_buf	*precvbuf = (struct recv_buf *)purb->context;
+{	
+	struct recv_buf	*precvbuf = (struct recv_buf *)purb->context;	
 	_adapter 			*padapter =(_adapter *)precvbuf->adapter;
 	struct recv_priv	*precvpriv = &padapter->recvpriv;
 
 	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete!!!\n"));
-
+	
 	precvpriv->rx_pending_cnt --;
-
+		
 	if(padapter->bSurpriseRemoved || padapter->bDriverStopped||padapter->bReadPortCancel)
 	{
-		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bDriverStopped(%d) OR bSurpriseRemoved(%d)\n", padapter->bDriverStopped, padapter->bSurpriseRemoved));
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bDriverStopped(%d) OR bSurpriseRemoved(%d)\n", padapter->bDriverStopped, padapter->bSurpriseRemoved));		
 
 		goto exit;
 	}
@@ -900,22 +900,22 @@ static void usb_read_port_complete(struct urb *purb, struct pt_regs *regs)
 
 			rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
 		}
-		else
-		{
+		else 
+		{			
 			rtw_reset_continual_urb_error(adapter_to_dvobj(padapter));
+			
+			precvbuf->transfer_len = purb->actual_length;	
 
-			precvbuf->transfer_len = purb->actual_length;
-
-			//rtw_enqueue_rx_transfer_buffer(precvpriv, rx_transfer_buf);
+			//rtw_enqueue_rx_transfer_buffer(precvpriv, rx_transfer_buf);			
 			rtw_enqueue_recvbuf(precvbuf, &precvpriv->recv_buf_pending_queue);
 
-			tasklet_schedule(&precvpriv->recv_tasklet);
-		}
+			tasklet_schedule(&precvpriv->recv_tasklet);			
+		}		
 	}
 	else
 	{
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete : purb->status(%d) != 0 \n", purb->status));
-
+	
 		DBG_8192C("###=> usb_read_port_complete => urb status(%d)\n", purb->status);
 
 		if(rtw_inc_and_chk_continual_urb_error(adapter_to_dvobj(padapter)) == _TRUE ){
@@ -924,13 +924,13 @@ static void usb_read_port_complete(struct urb *purb, struct pt_regs *regs)
 
 		switch(purb->status) {
 			case -EINVAL:
-			case -EPIPE:
+			case -EPIPE:			
 			case -ENODEV:
 			case -ESHUTDOWN:
 				//padapter->bSurpriseRemoved=_TRUE;
 				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bSurpriseRemoved=TRUE\n"));
 			case -ENOENT:
-				padapter->bDriverStopped=_TRUE;
+				padapter->bDriverStopped=_TRUE;			
 				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bDriverStopped=TRUE\n"));
 				break;
 			case -EPROTO:
@@ -938,31 +938,31 @@ static void usb_read_port_complete(struct urb *purb, struct pt_regs *regs)
 			case -ETIME:
 			case -ECOMM:
 			case -EOVERFLOW:
-				#ifdef DBG_CONFIG_ERROR_DETECT
-				{
+				#ifdef DBG_CONFIG_ERROR_DETECT	
+				{	
 					HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
-					pHalData->srestpriv.Wifi_Error_Status = USB_READ_PORT_FAIL;
+					pHalData->srestpriv.Wifi_Error_Status = USB_READ_PORT_FAIL;			
 				}
 				#endif
-				rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
+				rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);			
 				break;
 			case -EINPROGRESS:
 				DBG_8192C("ERROR: URB IS IN PROGRESS!/n");
 				break;
 			default:
-				break;
+				break;				
 		}
+		
+	}	
 
-	}
-
-exit:
-
+exit:	
+	
 _func_exit_;
-
+	
 }
 
 static u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
-{
+{		
 	int err;
 	unsigned int pipe;
 	u32 ret = _SUCCESS;
@@ -974,7 +974,7 @@ static u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
 	struct usb_device	*pusbd = pdvobj->pusbdev;
 
 _func_enter_;
-
+	
 	if(adapter->bDriverStopped || adapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)
 	{
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port:( padapter->bDriverStopped ||padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n"));
@@ -982,37 +982,37 @@ static u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
 	}
 
 	if(precvbuf !=NULL)
-	{
+	{	
 		rtl8192cu_init_recvbuf(adapter, precvbuf);
 
 		if(precvbuf->pbuf)
-		{
+		{			
 			precvpriv->rx_pending_cnt++;
-
-			purb = precvbuf->purb;
+		
+			purb = precvbuf->purb;		
 
 			//translate DMA FIFO addr to pipehandle
-			pipe = ffaddr2pipehdl(pdvobj, addr);
+			pipe = ffaddr2pipehdl(pdvobj, addr);	
 
-			usb_fill_bulk_urb(purb, pusbd, pipe,
+			usb_fill_bulk_urb(purb, pusbd, pipe, 
 						precvbuf->pbuf,
-						MAX_RECVBUF_SZ,
-						usb_read_port_complete,
-						precvbuf);//context is precvbuf
+                				MAX_RECVBUF_SZ,
+                				usb_read_port_complete,
+                				precvbuf);//context is precvbuf
 
 			purb->transfer_dma = precvbuf->dma_transfer_addr;
-			purb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
+			purb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;								
 
-			err = usb_submit_urb(purb, GFP_ATOMIC);
+			err = usb_submit_urb(purb, GFP_ATOMIC);	
 			if((err) && (err != (-EPERM)))
 			{
 				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("cannot submit rx in-token(err=0x%.8x), URB_STATUS =0x%.8x", err, purb->status));
 				DBG_8192C("cannot submit rx in-token(err = 0x%08x),urb_status = %d\n",err,purb->status);
 				ret = _FAIL;
 			}
-
+			
 		}
-
+			
 	}
 	else
 	{
@@ -1042,20 +1042,20 @@ static int recvbuf2recvframe(_adapter *padapter, _pkt *pskb)
 	_queue			*pfree_recv_queue = &precvpriv->free_recv_queue;
 
 
-	transfer_len = (s32)pskb->len;
+	transfer_len = (s32)pskb->len;	
 	pbuf = pskb->data;
 
-	prxstat = (struct recv_stat *)pbuf;
+	prxstat = (struct recv_stat *)pbuf;	
 	pkt_cnt = (le32_to_cpu(prxstat->rxdw2)>>16) & 0xff;
 
 #if 0 //temp remove when disable usb rx aggregation
 	if((pkt_cnt > 10) || (pkt_cnt < 1) || (transfer_len<RXDESC_SIZE) ||(pkt_len<=0))
-	{
+	{		
 		return _FAIL;
 	}
 #endif
 
-	do{
+	do{		
 		RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
 			 ("recvbuf2recvframe: rxdesc=offsset 0:0x%08x, 4:0x%08x, 8:0x%08x, C:0x%08x\n",
 			  prxstat->rxdw0, prxstat->rxdw1, prxstat->rxdw2, prxstat->rxdw4));
@@ -1066,11 +1066,11 @@ static int recvbuf2recvframe(_adapter *padapter, _pkt *pskb)
 		if(precvframe==NULL)
 		{
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe: precvframe==NULL\n"));
-			DBG_8192C("%s()-%d: rtw_alloc_recvframe() failed! RX Drop!\n", __FUNCTION__, __LINE__);
+			DBG_8192C("%s()-%d: rtw_alloc_recvframe() failed! RX Drop!\n", __FUNCTION__, __LINE__);	
 			goto _exit_recvbuf2recvframe;
 		}
 
-		_rtw_init_listhead(&precvframe->u.hdr.list);
+		_rtw_init_listhead(&precvframe->u.hdr.list);	
 		precvframe->u.hdr.precvbuf = NULL;	//can't access the precvbuf for new arch.
 		precvframe->u.hdr.len=0;
 
@@ -1085,9 +1085,9 @@ static int recvbuf2recvframe(_adapter *padapter, _pkt *pskb)
 		pkt_offset = RXDESC_SIZE + pattrib->drvinfo_sz + pattrib->shift_sz + pattrib->pkt_len;
 
 		if((pattrib->pkt_len<=0) || (pkt_offset>transfer_len))
-		{
+		{	
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("recvbuf2recvframe: pkt_len<=0\n"));
-			DBG_8192C("%s()-%d: RX Warning!\n", __FUNCTION__, __LINE__);
+			DBG_8192C("%s()-%d: RX Warning!\n", __FUNCTION__, __LINE__);	
 			rtw_free_recvframe(precvframe, pfree_recv_queue);
 			goto _exit_recvbuf2recvframe;
 		}
@@ -1133,7 +1133,7 @@ static int recvbuf2recvframe(_adapter *padapter, _pkt *pskb)
 			skb_reserve( pkt_copy, shift_sz );//force ip_hdr at 8-byte alignment address according to shift_sz.
 			_rtw_memcpy(pkt_copy->data, (pbuf + pattrib->shift_sz + pattrib->drvinfo_sz + RXDESC_SIZE), skb_len);
 			precvframe->u.hdr.rx_data = precvframe->u.hdr.rx_tail = pkt_copy->data;
-
+			
 		}
 		else
 		{
@@ -1152,7 +1152,7 @@ static int recvbuf2recvframe(_adapter *padapter, _pkt *pskb)
 		}
 
 		recvframe_put(precvframe, skb_len);
-		//recvframe_pull(precvframe, drvinfo_sz + RXDESC_SIZE);
+		//recvframe_pull(precvframe, drvinfo_sz + RXDESC_SIZE);	
 
 #ifdef CONFIG_USB_RX_AGGREGATION
 		switch(pHalData->UsbRxAggMode)
@@ -1164,8 +1164,8 @@ static int recvbuf2recvframe(_adapter *padapter, _pkt *pskb)
 				case USB_RX_AGG_USB:
 				pkt_offset = (u16)_RND4(pkt_offset);
 				break;
-			case USB_RX_AGG_DISABLE:
-			default:
+			case USB_RX_AGG_DISABLE:			
+			default:				
 				break;
 		}
 #endif
@@ -1186,18 +1186,18 @@ static int recvbuf2recvframe(_adapter *padapter, _pkt *pskb)
 				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe: rtw_recv_entry(precvframe) != _SUCCESS\n"));
 			}
 		}
-
+	
 #else
 		rtl8192c_translate_rx_signal_stuff(precvframe, pphy_info);
 		if(rtw_recv_entry(precvframe) != _SUCCESS)
 		{
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe: rtw_recv_entry(precvframe) != _SUCCESS\n"));
 		}
-#endif
+#endif		
 
 		pkt_cnt--;
 		transfer_len -= pkt_offset;
-		pbuf += pkt_offset;
+		pbuf += pkt_offset;	
 		precvframe = NULL;
 		pkt_copy = NULL;
 
@@ -1208,7 +1208,7 @@ static int recvbuf2recvframe(_adapter *padapter, _pkt *pskb)
 
 _exit_recvbuf2recvframe:
 
-	return _SUCCESS;
+	return _SUCCESS;	
 }
 
 void rtl8192cu_recv_tasklet(void *priv)
@@ -1216,7 +1216,7 @@ void rtl8192cu_recv_tasklet(void *priv)
 	_pkt			*pskb;
 	_adapter		*padapter = (_adapter*)priv;
 	struct recv_priv	*precvpriv = &padapter->recvpriv;
-
+	
 	while (NULL != (pskb = skb_dequeue(&precvpriv->rx_skb_queue)))
 	{
 		if ((padapter->bDriverStopped == _TRUE)||(padapter->bSurpriseRemoved== _TRUE))
@@ -1225,7 +1225,7 @@ void rtl8192cu_recv_tasklet(void *priv)
 			rtw_skb_free(pskb);
 			break;
 		}
-
+	
 		recvbuf2recvframe(padapter, pskb);
 
 #ifdef CONFIG_PREALLOC_RECV_SKB
@@ -1233,15 +1233,15 @@ void rtl8192cu_recv_tasklet(void *priv)
 		skb_reset_tail_pointer(pskb);
 
 		pskb->len = 0;
-
+		
 		skb_queue_tail(&precvpriv->free_recv_skb_queue, pskb);
-
+		
 #else
 		rtw_skb_free(pskb);
 #endif
-
+				
 	}
-
+	
 }
 
 
@@ -1249,39 +1249,39 @@ static void usb_read_port_complete(struct urb *purb, struct pt_regs *regs)
 {
 	_irqL irqL;
 	uint isevt, *pbuf;
-	struct recv_buf	*precvbuf = (struct recv_buf *)purb->context;
+	struct recv_buf	*precvbuf = (struct recv_buf *)purb->context;	
 	_adapter 			*padapter =(_adapter *)precvbuf->adapter;
-	struct recv_priv	*precvpriv = &padapter->recvpriv;
-
+	struct recv_priv	*precvpriv = &padapter->recvpriv;	
+	
 	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete!!!\n"));
-
+	
 	//_enter_critical(&precvpriv->lock, &irqL);
 	//precvbuf->irp_pending=_FALSE;
 	//precvpriv->rx_pending_cnt --;
 	//_exit_critical(&precvpriv->lock, &irqL);
-
+		
 	precvpriv->rx_pending_cnt --;
-
+		
 	//if(precvpriv->rx_pending_cnt== 0)
-	//{
+	//{		
 	//	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete: rx_pending_cnt== 0, set allrxreturnevt!\n"));
-	//	_rtw_up_sema(&precvpriv->allrxreturnevt);
+	//	_rtw_up_sema(&precvpriv->allrxreturnevt);	
 	//}
 
 	if(padapter->bSurpriseRemoved || padapter->bDriverStopped||padapter->bReadPortCancel)
 	{
-		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bDriverStopped(%d) OR bSurpriseRemoved(%d)\n", padapter->bDriverStopped, padapter->bSurpriseRemoved));
-
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bDriverStopped(%d) OR bSurpriseRemoved(%d)\n", padapter->bDriverStopped, padapter->bSurpriseRemoved));		
+		
 	#ifdef CONFIG_PREALLOC_RECV_SKB
 		precvbuf->reuse = _TRUE;
 	#else
 		if(precvbuf->pskb){
 			DBG_8192C("==> free skb(%p)\n",precvbuf->pskb);
 			rtw_skb_free(precvbuf->pskb);
-		}
+		}	
 	#endif
-		DBG_8192C("%s()-%d: RX Warning! bDriverStopped(%d) OR bSurpriseRemoved(%d) bReadPortCancel(%d)\n",
-		__FUNCTION__, __LINE__,padapter->bDriverStopped, padapter->bSurpriseRemoved,padapter->bReadPortCancel);
+		DBG_8192C("%s()-%d: RX Warning! bDriverStopped(%d) OR bSurpriseRemoved(%d) bReadPortCancel(%d)\n", 
+		__FUNCTION__, __LINE__,padapter->bDriverStopped, padapter->bSurpriseRemoved,padapter->bReadPortCancel);	
 		goto exit;
 	}
 
@@ -1292,14 +1292,14 @@ static void usb_read_port_complete(struct urb *purb, struct pt_regs *regs)
 			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete: (purb->actual_length > MAX_RECVBUF_SZ) || (purb->actual_length < RXDESC_SIZE)\n"));
 			precvbuf->reuse = _TRUE;
 			rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
-			DBG_8192C("%s()-%d: RX Warning!\n", __FUNCTION__, __LINE__);
+			DBG_8192C("%s()-%d: RX Warning!\n", __FUNCTION__, __LINE__);	
 		}
-		else
-		{
+		else 
+		{	
 			rtw_reset_continual_urb_error(adapter_to_dvobj(padapter));
-
-			precvbuf->transfer_len = purb->actual_length;
-			skb_put(precvbuf->pskb, purb->actual_length);
+			
+			precvbuf->transfer_len = purb->actual_length;			
+			skb_put(precvbuf->pskb, purb->actual_length);	
 			skb_queue_tail(&precvpriv->rx_skb_queue, precvbuf->pskb);
 
 			if (skb_queue_len(&precvpriv->rx_skb_queue)<=1)
@@ -1307,13 +1307,13 @@ static void usb_read_port_complete(struct urb *purb, struct pt_regs *regs)
 
 			precvbuf->pskb = NULL;
 			precvbuf->reuse = _FALSE;
-			rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
-		}
+			rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);			
+		}		
 	}
 	else
 	{
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete : purb->status(%d) != 0 \n", purb->status));
-
+	
 		DBG_8192C("###=> usb_read_port_complete => urb status(%d)\n", purb->status);
 
 		if(rtw_inc_and_chk_continual_urb_error(adapter_to_dvobj(padapter)) == _TRUE ){
@@ -1322,13 +1322,13 @@ static void usb_read_port_complete(struct urb *purb, struct pt_regs *regs)
 
 		switch(purb->status) {
 			case -EINVAL:
-			case -EPIPE:
+			case -EPIPE:			
 			case -ENODEV:
 			case -ESHUTDOWN:
 				//padapter->bSurpriseRemoved=_TRUE;
 				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bSurpriseRemoved=TRUE\n"));
 			case -ENOENT:
-				padapter->bDriverStopped=_TRUE;
+				padapter->bDriverStopped=_TRUE;			
 				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bDriverStopped=TRUE\n"));
 				break;
 			case -EPROTO:
@@ -1336,14 +1336,14 @@ static void usb_read_port_complete(struct urb *purb, struct pt_regs *regs)
 			case -ETIME:
 			case -ECOMM:
 			case -EOVERFLOW:
-				#ifdef DBG_CONFIG_ERROR_DETECT
-				{
+				#ifdef DBG_CONFIG_ERROR_DETECT	
+				{	
 					HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
-					pHalData->srestpriv.Wifi_Error_Status = USB_READ_PORT_FAIL;
+					pHalData->srestpriv.Wifi_Error_Status = USB_READ_PORT_FAIL;			
 				}
 				#endif
 				precvbuf->reuse = _TRUE;
-				rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
+				rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);			
 				break;
 			case -EINPROGRESS:
 				precvpriv->read_port_complete_EINPROGRESS_cnt++;
@@ -1351,19 +1351,19 @@ static void usb_read_port_complete(struct urb *purb, struct pt_regs *regs)
 				break;
 			default:
 				precvpriv->read_port_complete_other_urb_err_cnt++;
-				break;
+				break;				
 		}
+		
+	}	
 
-	}
-
-exit:
-
+exit:	
+	
 _func_exit_;
-
+	
 }
 
 static u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
-{
+{	
 	_irqL irqL;
 	int err;
 	unsigned int pipe;
@@ -1376,9 +1376,9 @@ static u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
 	struct dvobj_priv	*pdvobj = adapter_to_dvobj(adapter);
 	struct recv_priv	*precvpriv = &adapter->recvpriv;
 	struct usb_device	*pusbd = pdvobj->pusbdev;
-
+	
 _func_enter_;
-
+	
 	if(adapter->bDriverStopped || adapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)
 	{
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port:( padapter->bDriverStopped ||padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n"));
@@ -1394,41 +1394,41 @@ static u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
 		}
 	}
 #endif
-
+	
 
 	if(precvbuf !=NULL)
-	{
-		rtl8192cu_init_recvbuf(adapter, precvbuf);
+	{	
+		rtl8192cu_init_recvbuf(adapter, precvbuf);		
 
 		//re-assign for linux based on skb
 		if((precvbuf->reuse == _FALSE) || (precvbuf->pskb == NULL))
 		{
 			precvbuf->pskb = rtw_skb_alloc(MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ);
 
-			if(precvbuf->pskb == NULL)
+			if(precvbuf->pskb == NULL)		
 			{
 				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("init_recvbuf(): alloc_skb fail!\n"));
 				precvpriv->recvbuf_skb_alloc_fail_cnt++;
 				return _FAIL;
-			}
+			}	
 
 			tmpaddr = (SIZE_PTR)precvbuf->pskb->data;
-			alignment = tmpaddr & (RECVBUFF_ALIGN_SZ-1);
+	        	alignment = tmpaddr & (RECVBUFF_ALIGN_SZ-1);
 			skb_reserve(precvbuf->pskb, (RECVBUFF_ALIGN_SZ - alignment));
 
 			precvbuf->phead = precvbuf->pskb->head;
-			precvbuf->pdata = precvbuf->pskb->data;
+		   	precvbuf->pdata = precvbuf->pskb->data;
 			precvbuf->ptail = skb_tail_pointer(precvbuf->pskb);
 			precvbuf->pend = skb_end_pointer(precvbuf->pskb);
 			precvbuf->pbuf = precvbuf->pskb->data;
-		}
+		}	
 		else//reuse skb
 		{
 			precvbuf->phead = precvbuf->pskb->head;
 			precvbuf->pdata = precvbuf->pskb->data;
 			precvbuf->ptail = skb_tail_pointer(precvbuf->pskb);
 			precvbuf->pend = skb_end_pointer(precvbuf->pskb);
-		precvbuf->pbuf = precvbuf->pskb->data;
+       		precvbuf->pbuf = precvbuf->pskb->data;
 
 			precvbuf->reuse = _FALSE;
 		}
@@ -1445,11 +1445,11 @@ static u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
 		//translate DMA FIFO addr to pipehandle
 		pipe = ffaddr2pipehdl(pdvobj, addr);
 
-		usb_fill_bulk_urb(purb, pusbd, pipe,
+		usb_fill_bulk_urb(purb, pusbd, pipe, 
 						precvbuf->pbuf,
-						MAX_RECVBUF_SZ,
-						usb_read_port_complete,
-						precvbuf);//context is precvbuf
+                				MAX_RECVBUF_SZ,
+                				usb_read_port_complete,
+                				precvbuf);//context is precvbuf
 
 		err = usb_submit_urb(purb, GFP_ATOMIC);
 		if((err) && (err != (-EPERM)))
@@ -1473,7 +1473,7 @@ static u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
 #endif	// CONFIG_USE_USB_BUFFER_ALLOC_RX
 
 void rtl8192cu_xmit_tasklet(void *priv)
-{
+{	
 	int ret = _FALSE;
 	_adapter *padapter = (_adapter*)priv;
 	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
@@ -1493,33 +1493,33 @@ void rtl8192cu_xmit_tasklet(void *priv)
 
 		if(ret==_FALSE)
 			break;
-
+		
 	}
-
+	
 }
 
 void rtl8192cu_set_intf_ops(struct _io_ops	*pops)
 {
 	_func_enter_;
-
-	_rtw_memset((u8 *)pops, 0, sizeof(struct _io_ops));
+	
+	_rtw_memset((u8 *)pops, 0, sizeof(struct _io_ops));	
 
 	pops->_read8 = &usb_read8;
 	pops->_read16 = &usb_read16;
 	pops->_read32 = &usb_read32;
 	pops->_read_mem = &usb_read_mem;
-	pops->_read_port = &usb_read_port;
-
+	pops->_read_port = &usb_read_port;	
+	
 	pops->_write8 = &usb_write8;
 	pops->_write16 = &usb_write16;
 	pops->_write32 = &usb_write32;
 	pops->_writeN = &usb_writeN;
-
-#ifdef CONFIG_USB_SUPPORT_ASYNC_VDN_REQ
+	
+#ifdef CONFIG_USB_SUPPORT_ASYNC_VDN_REQ	
 	pops->_write8_async= &usb_async_write8;
 	pops->_write16_async = &usb_async_write16;
 	pops->_write32_async = &usb_async_write32;
-#endif
+#endif	
 	pops->_write_mem = &usb_write_mem;
 	pops->_write_port = &usb_write_port;
 
@@ -1533,3 +1533,4 @@ void rtl8192cu_set_intf_ops(struct _io_ops	*pops)
 	_func_exit_;
 
 }
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/usb_ops_xp.c b/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/usb_ops_xp.c
old mode 100644
new mode 100755
index 59143e3..32ff645
--- a/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/usb_ops_xp.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/hal/rtl8192c/usb/usb_ops_xp.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -52,7 +52,7 @@ struct zero_bulkout_context
 	void *padapter;
 };
 
-#define usb_write_cmd usb_write_mem
+#define usb_write_cmd usb_write_mem 
 #define usb_read_cmd usb_read_mem
 #define usb_write_cmd_complete usb_write_mem_complete
 //#define usb_read_cmd_complete usb_read_mem_complete
@@ -61,56 +61,56 @@ struct zero_bulkout_context
 
 uint usb_init_intf_priv(struct intf_priv *pintfpriv)
 {
-
+	        
 	PURB	piorw_urb;
 	u8		NextDeviceStackSize;
 	struct dvobj_priv   *pdev = (struct dvobj_priv   *)pintfpriv->intf_dev;
 	_adapter * padapter=pdev->padapter;
 
 _func_enter_;
-
+	
 	RT_TRACE(_module_hci_ops_os_c_,_drv_info_,("\n +usb_init_intf_priv\n"));
 
 	pintfpriv->intf_status = _IOREADY;
 
        if(pdev->ishighspeed) pintfpriv->max_iosz =  128;
-	else pintfpriv->max_iosz =  64;
+	else pintfpriv->max_iosz =  64;	
 
 
 	_init_timer(&pintfpriv->io_timer, padapter->hndis_adapter, io_irp_timeout_handler, pintfpriv);
 
-
+	
 	RT_TRACE(_module_hci_ops_os_c_,_drv_info_,("usb_init_intf_priv:pintfpriv->max_iosz:%d\n",pintfpriv->max_iosz));
 
 	pintfpriv->io_wsz = 0;
-	pintfpriv->io_rsz = 0;
-
-	pintfpriv->allocated_io_rwmem = rtw_zmalloc(pintfpriv->max_iosz +4);
-
-	if (pintfpriv->allocated_io_rwmem == NULL){
+	pintfpriv->io_rsz = 0;	
+	
+ 	pintfpriv->allocated_io_rwmem = rtw_zmalloc(pintfpriv->max_iosz +4); 
+	
+   	if (pintfpriv->allocated_io_rwmem == NULL){
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("\n usb_init_intf_priv:pintfpriv->allocated_io_rwmem == NULL\n"));
-		goto usb_init_intf_priv_fail;
-	}
+    		goto usb_init_intf_priv_fail;
+   	}
 
 	pintfpriv->io_rwmem = pintfpriv->allocated_io_rwmem +  4 \
 					-( (u32)(pintfpriv->allocated_io_rwmem) & 3);
+	
 
+     
+     NextDeviceStackSize = (u8)pdev->nextdevstacksz;//pintfpriv->pUsbDevObj->StackSize + 1; 
 
-
-     NextDeviceStackSize = (u8)pdev->nextdevstacksz;//pintfpriv->pUsbDevObj->StackSize + 1;
-
-      piorw_urb = (PURB)ExAllocatePool(NonPagedPool, sizeof(URB) );
-      if(piorw_urb == NULL)
+      piorw_urb = (PURB)ExAllocatePool(NonPagedPool, sizeof(URB) ); 
+      if(piorw_urb == NULL) 
 	  goto usb_init_intf_priv_fail;
-
+	  
       pintfpriv->piorw_urb = piorw_urb;
 
-      pintfpriv->piorw_irp = IoAllocateIrp(NextDeviceStackSize , FALSE);
-
+      pintfpriv->piorw_irp = IoAllocateIrp(NextDeviceStackSize , FALSE);	 
+    
 
       pintfpriv->io_irp_cnt=1;
       pintfpriv->bio_irp_pending=_FALSE;
-
+	 
      _rtw_init_sema(&(pintfpriv->io_retevt), 0);//NdisInitializeEvent(&pintfpriv->io_irp_return_evt);
 
 _func_exit_;
@@ -120,33 +120,33 @@ uint usb_init_intf_priv(struct intf_priv *pintfpriv)
 
 	if (pintfpriv->allocated_io_rwmem)
 		rtw_mfree((u8 *)(pintfpriv->allocated_io_rwmem), pintfpriv->max_iosz +4);
-
+	
 	if(piorw_urb)
-		ExFreePool(piorw_urb);
+		ExFreePool(piorw_urb);	
 
 	RT_TRACE(_module_hci_ops_os_c_,_drv_info_,("\n -usb_init_intf_priv(usb_init_intf_priv_fail)\n"));
 
-_func_exit_;
+_func_exit_;	
 	return _FAIL;
-
+		
 }
 
 void usb_unload_intf_priv(struct intf_priv *pintfpriv)
 {
 
 _func_enter_;
-
+	
 	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("\n+usb_unload_intf_priv\n"));
-
+	
 	rtw_mfree((u8 *)(pintfpriv->allocated_io_rwmem), pintfpriv->max_iosz+4);
-
+	
 #ifdef PLATFORM_WINDOWS
 	if(pintfpriv->piorw_urb)
-		ExFreePool(pintfpriv->piorw_urb);
+		ExFreePool(pintfpriv->piorw_urb);	
 
 	if(pintfpriv->piorw_irp)
 		IoFreeIrp(pintfpriv->piorw_irp);
-#endif
+#endif		
 
 
 #ifdef PLATFORM_LINUX
@@ -166,7 +166,7 @@ void usb_unload_intf_priv(struct intf_priv *pintfpriv)
 	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("\n-usb_unload_intf_priv\n"));
 
 _func_exit_;
-
+	
 }
 
 void *ffaddr2pipehdl(struct dvobj_priv *pNdisCEDvice, u32 addr)
@@ -174,164 +174,164 @@ void *ffaddr2pipehdl(struct dvobj_priv *pNdisCEDvice, u32 addr)
 	HANDLE PipeHandle = NULL;
 	_adapter	*padapter = pNdisCEDvice->padapter;
 
-
+	
 	if(pNdisCEDvice->nr_endpoint == 11)
-	{
+	{		
 		switch(addr)
-		{
-			case RTL8712_DMA_BEQ:
-				PipeHandle= padapter->halpriv.pipehdls_r8712[3] ;
+		{	    
+	     		case RTL8712_DMA_BEQ:
+		 		PipeHandle= padapter->halpriv.pipehdls_r8712[3] ; 
 				break;
-			case RTL8712_DMA_BKQ:
-				PipeHandle=  padapter->halpriv.pipehdls_r8712[4];
+	     		case RTL8712_DMA_BKQ:
+			 	PipeHandle=  padapter->halpriv.pipehdls_r8712[4]; 
 				break;
-			case RTL8712_DMA_VIQ:
-				PipeHandle=  padapter->halpriv.pipehdls_r8712[2];
-				break;
-			case RTL8712_DMA_VOQ:
-				PipeHandle=  padapter->halpriv.pipehdls_r8712[1];
-				break;
-                     case RTL8712_DMA_BCNQ:
-				PipeHandle=  padapter->halpriv.pipehdls_r8712[6];
+	     		case RTL8712_DMA_VIQ:
+		 		PipeHandle=  padapter->halpriv.pipehdls_r8712[2]; 
 				break;
+	    		case RTL8712_DMA_VOQ:
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[1]; 
+				break;					
+                     case RTL8712_DMA_BCNQ:	
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[6]; 
+				break;	 	
 			case RTL8712_DMA_BMCQ:	//HI Queue
-				PipeHandle=  padapter->halpriv.pipehdls_r8712[7];
-				break;
-			case RTL8712_DMA_MGTQ:
-				PipeHandle=  padapter->halpriv.pipehdls_r8712[8];
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[7]; 
+				break;	
+			case RTL8712_DMA_MGTQ:				
+		 		PipeHandle=  padapter->halpriv.pipehdls_r8712[8]; 
 				break;
                      case RTL8712_DMA_RX0FF:
-				PipeHandle=  padapter->halpriv.pipehdls_r8712[0];
-				break;
-			case RTL8712_DMA_C2HCMD:
-				PipeHandle=  padapter->halpriv.pipehdls_r8712[5];
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[0]; 
+				break;	 	
+			case RTL8712_DMA_C2HCMD:		 	
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[5]; 
 				break;
 			case RTL8712_DMA_H2CCMD:
-				PipeHandle=  padapter->halpriv.pipehdls_r8712[9];
-				break;
-
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[9]; 
+				break;	
+				
 		}
 
 	}
 	else if(pNdisCEDvice->nr_endpoint == 6)
 	{
 		switch(addr)
-		{
-			case RTL8712_DMA_BEQ:
-				PipeHandle=  padapter->halpriv.pipehdls_r8712[3];
+		{	    
+	     		case RTL8712_DMA_BEQ:
+		 		PipeHandle=  padapter->halpriv.pipehdls_r8712[3]; 
 				break;
-			case RTL8712_DMA_BKQ:
-				PipeHandle=  padapter->halpriv.pipehdls_r8712[4];
+	     		case RTL8712_DMA_BKQ:
+			 	PipeHandle=  padapter->halpriv.pipehdls_r8712[4]; 
 				break;
-			case RTL8712_DMA_VIQ:
-				PipeHandle=  padapter->halpriv.pipehdls_r8712[2];
+	     		case RTL8712_DMA_VIQ:
+		 		PipeHandle=  padapter->halpriv.pipehdls_r8712[2]; 
 				break;
-			case RTL8712_DMA_VOQ:
-				PipeHandle=  padapter->halpriv.pipehdls_r8712[1];
+	    		case RTL8712_DMA_VOQ:                   		
+		 		PipeHandle=  padapter->halpriv.pipehdls_r8712[1]; 
 				break;
                      case RTL8712_DMA_RX0FF:
-			case RTL8712_DMA_C2HCMD:
-				PipeHandle=  padapter->halpriv.pipehdls_r8712[0];
+			case RTL8712_DMA_C2HCMD:		 	
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[0]; 
 				break;
 			case RTL8712_DMA_H2CCMD:
-			case RTL8712_DMA_BCNQ:
-			case RTL8712_DMA_BMCQ:
-			case RTL8712_DMA_MGTQ:
-				PipeHandle=  padapter->halpriv.pipehdls_r8712[5];
-				break;
-
+			case RTL8712_DMA_BCNQ:					
+			case RTL8712_DMA_BMCQ:	
+			case RTL8712_DMA_MGTQ:			
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[5]; 
+				break;	
+				
 		}
 
 	}
 	else if(pNdisCEDvice->nr_endpoint == 4)
 	{
 		switch(addr)
-		{
-			case RTL8712_DMA_BEQ:
-			//case RTL8712_DMA_BKQ:
-				PipeHandle=  padapter->halpriv.pipehdls_r8712[2];
+		{		
+	     		case RTL8712_DMA_BEQ:
+		 	//case RTL8712_DMA_BKQ:
+			 	PipeHandle=  padapter->halpriv.pipehdls_r8712[2]; 
 				break;
-			//case RTL8712_DMA_VIQ:
-			case RTL8712_DMA_VOQ:
-				PipeHandle=  padapter->halpriv.pipehdls_r8712[1];
+	     		//case RTL8712_DMA_VIQ:
+		 	case RTL8712_DMA_VOQ:					
+		 		PipeHandle=  padapter->halpriv.pipehdls_r8712[1]; 
 				break;
 			case RTL8712_DMA_RX0FF:
-			case RTL8712_DMA_C2HCMD:
-				PipeHandle=  padapter->halpriv.pipehdls_r8712[0];
-				break;
-			case RTL8712_DMA_H2CCMD:
-			case RTL8712_DMA_BCNQ:
-			case RTL8712_DMA_BMCQ:
-			case RTL8712_DMA_MGTQ:
-				PipeHandle=  padapter->halpriv.pipehdls_r8712[3];
+			case RTL8712_DMA_C2HCMD:		 	
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[0]; 
 				break;
+			case RTL8712_DMA_H2CCMD:	
+			case RTL8712_DMA_BCNQ:					
+			case RTL8712_DMA_BMCQ:	
+			case RTL8712_DMA_MGTQ:				
+				PipeHandle=  padapter->halpriv.pipehdls_r8712[3]; 
+				break;	
 		}
-
+	
 	}
 	else
 	{
-	   RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("ffaddr2pipehdl():nr_endpoint=%d error!\n", pNdisCEDvice->nr_endpoint));
+	   RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("ffaddr2pipehdl():nr_endpoint=%d error!\n", pNdisCEDvice->nr_endpoint));	   
 	}
-
+		
 	return PipeHandle;
 
 }
 
 
 NTSTATUS usb_bulkout_zero_complete(
-	PDEVICE_OBJECT	pUsbDevObj,
+	PDEVICE_OBJECT	pUsbDevObj, 
 	PIRP		pIrp, void*	pZeroContext)
-{
+{	
 	struct zero_bulkout_context *pcontext = (struct zero_bulkout_context *)pZeroContext;
-
+			   
 _func_enter_;
 
 	if(pcontext)
 	{
 		if(pcontext->pbuf)
 		{
-			ExFreePool(pcontext->pbuf);
-		}
+			ExFreePool(pcontext->pbuf);	  
+		}	
 
 		if(pcontext->purb)
 		{
-			ExFreePool(pcontext->purb);
+			ExFreePool(pcontext->purb);	
 		}
 
 		if(pcontext->pirp && (pIrp ==pcontext->pirp))
-		{
+		{			
 			IoFreeIrp(pIrp);
 		}
 
-		ExFreePool(pcontext);
-	}
+		ExFreePool(pcontext);	
+	}	
 
 _func_exit_;
 
 	return STATUS_MORE_PROCESSING_REQUIRED;
-
+	
 
 }
 
 u32 usb_bulkout_zero(struct intf_hdl *pintfhdl, u32 addr)
-{
+{	
 	struct zero_bulkout_context *pcontext;
 	unsigned char *pbuf;
 	char NextDeviceStackSize, len;
 	PIO_STACK_LOCATION	nextStack;
 	USBD_STATUS		usbdstatus;
-	HANDLE				PipeHandle;
+	HANDLE				PipeHandle;	
 	PIRP					pirp = NULL;
-	PURB				purb = NULL;
+	PURB				purb = NULL;	
 	NDIS_STATUS			ndisStatus = NDIS_STATUS_SUCCESS;
 	_adapter *padapter = (_adapter *)pintfhdl->adapter;
-	struct dvobj_priv	*pdvobj = (struct dvobj_priv *)&padapter->dvobjpriv;
+	struct dvobj_priv	*pdvobj = (struct dvobj_priv *)&padapter->dvobjpriv;	
 
 
 _func_enter_;
 
 	if((padapter->bDriverStopped) || (padapter->bSurpriseRemoved) ||(padapter->pwrctrlpriv.pnp_bstop_trx))
-	{
+	{		
 		return _FAIL;
 	}
 
@@ -339,17 +339,17 @@ u32 usb_bulkout_zero(struct intf_hdl *pintfhdl, u32 addr)
 	NextDeviceStackSize = (char)pdvobj->nextdevstacksz;
 
 	pcontext = (struct zero_bulkout_context *)ExAllocatePool(NonPagedPool, sizeof(struct zero_bulkout_context));
-	pbuf = (unsigned char *)ExAllocatePool(NonPagedPool, sizeof(int));
-	purb = (PURB)ExAllocatePool(NonPagedPool, sizeof(URB));
-	pirp = IoAllocateIrp(NextDeviceStackSize, FALSE);
+	pbuf = (unsigned char *)ExAllocatePool(NonPagedPool, sizeof(int));	
+    	purb = (PURB)ExAllocatePool(NonPagedPool, sizeof(URB));
+      	pirp = IoAllocateIrp(NextDeviceStackSize, FALSE);
 
 	pcontext->pbuf = pbuf;
 	pcontext->purb = purb;
 	pcontext->pirp = pirp;
 	pcontext->padapter = padapter;
-
+                    
 	//translate DMA FIFO addr to pipehandle
-	PipeHandle = ffaddr2pipehdl(pdvobj, addr);
+	PipeHandle = ffaddr2pipehdl(pdvobj, addr);	
 
 
 	// Build our URB for USBD
@@ -357,12 +357,12 @@ u32 usb_bulkout_zero(struct intf_hdl *pintfhdl, u32 addr)
 				purb,
 				sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER),
 				PipeHandle,
-				pbuf,
-				NULL,
-				len,
-				0,
+				pbuf, 
+				NULL, 
+				len, 
+				0, 
 				NULL);
-
+	
 	//
 	// call the calss driver to perform the operation
 	// pass the URB to the USB driver stack
@@ -375,19 +375,19 @@ u32 usb_bulkout_zero(struct intf_hdl *pintfhdl, u32 addr)
 	//Set Completion Routine
 	IoSetCompletionRoutine(pirp,					// irp to use
 				               usb_bulkout_zero_complete,	// callback routine
-				               pcontext,				// context
+				               pcontext,				// context 
 				               TRUE,					// call on success
 				               TRUE,					// call on error
 				               TRUE);					// call on cancel
 
-
+	
 	// Call IoCallDriver to send the irp to the usb bus driver
 	//
 	ndisStatus = IoCallDriver(pdvobj->pnextdevobj, pirp);
 	usbdstatus = URB_STATUS(purb);
 
 	if( USBD_HALTED(usbdstatus) )
-	{
+	{		
 		padapter->bDriverStopped=_TRUE;
 		padapter->bSurpriseRemoved=_TRUE;
 	}
@@ -396,12 +396,12 @@ u32 usb_bulkout_zero(struct intf_hdl *pintfhdl, u32 addr)
 	// The usb bus driver should always return STATUS_PENDING when bulk out irp async
 	//
 	if ( ndisStatus != STATUS_PENDING )
-	{
+	{		
 		return _FAIL;
-	}
-
+	} 	
+	
 _func_exit_;
-
+	
 	return _SUCCESS;
 
 }
@@ -409,61 +409,61 @@ u32 usb_bulkout_zero(struct intf_hdl *pintfhdl, u32 addr)
 void usb_read_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
 {
 	_func_enter_;
+	
 
-
-
+	
 	_func_exit_;
 }
 
 NTSTATUS usb_write_mem_complete(PDEVICE_OBJECT	pUsbDevObj, PIRP piowrite_irp, PVOID pusb_cnxt)
 {
-
+		
 	_irqL irqL;
 	_list	*head, *plist;
-	struct io_req	*pio_req;
+	struct io_req	*pio_req;	
 	struct io_queue *pio_q = (struct io_queue *) pusb_cnxt;
-	struct intf_hdl *pintf = &(pio_q->intf);
-	struct intf_priv *pintfpriv = pintf->pintfpriv;
+	struct intf_hdl *pintf = &(pio_q->intf);	
+	struct intf_priv *pintfpriv = pintf->pintfpriv;	
 	_adapter *padapter = (_adapter *)pintf->adapter;
 	NTSTATUS status = STATUS_SUCCESS;
 
 	head = &(pio_q->processing);
-
+	
 	_func_enter_;
-
+	
 	_enter_critical_bh(&(pio_q->lock), &irqL);
-
+	
 	pintfpriv->io_irp_cnt--;
-	if(pintfpriv->io_irp_cnt ==0){
+	if(pintfpriv->io_irp_cnt ==0){		
 		_rtw_up_sema(&(pintfpriv->io_retevt));
-	}
-
+	}	
+	
 	pintfpriv->bio_irp_pending=_FALSE;
-
+	
 	switch(piowrite_irp->IoStatus.Status)
-	{
+	{		
 		case STATUS_SUCCESS:
 			break;
-
+			
 		default:
 			padapter->bSurpriseRemoved=_TRUE;
 			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("\n usbAsynIntOutComplete:pioread_irp->IoStatus.Status !=STATUS_SUCCESS\n"));
 			break;
-	}
+	}				
 
-	//free irp in processing list...
+	//free irp in processing list...	
 	while(rtw_is_list_empty(head) != _TRUE)
 	{
-		plist = get_next(head);
+		plist = get_next(head);	
 		rtw_list_delete(plist);
 		pio_req = LIST_CONTAINOR(plist, struct io_req, list);
 		_rtw_up_sema(&pio_req->sema);
-	}
-
+	}	
+						
 	_exit_critical_bh(&(pio_q->lock), &irqL);
 
 	_func_exit_;
-
+	
 	return STATUS_MORE_PROCESSING_REQUIRED;
 
 }
@@ -472,30 +472,30 @@ void usb_write_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
 {
 	u32 bwritezero;
 	_irqL	irqL;
-	USBD_STATUS			usbdstatus;
+	USBD_STATUS			usbdstatus;		
 	PIO_STACK_LOCATION		nextStack;
-	HANDLE				PipeHandle;
+	HANDLE				PipeHandle;	
 	struct io_req *pio_req;
-
+	
 	_adapter *adapter = (_adapter *)pintfhdl->adapter;
 	struct intf_priv *pintfpriv = pintfhdl->pintfpriv;
-	struct dvobj_priv   *pdev = (struct dvobj_priv   *)pintfpriv->intf_dev;
+	struct dvobj_priv   *pdev = (struct dvobj_priv   *)pintfpriv->intf_dev;      
 	PURB	piorw_urb = pintfpriv->piorw_urb;
-	PIRP		piorw_irp  = pintfpriv->piorw_irp;
-	struct io_queue	*pio_queue = (struct io_queue *)adapter->pio_queue;
-	NTSTATUS NtStatus = STATUS_SUCCESS;
-
-	_func_enter_;
+	PIRP		piorw_irp  = pintfpriv->piorw_irp; 	
+	struct io_queue	*pio_queue = (struct io_queue *)adapter->pio_queue;	
+	NTSTATUS NtStatus = STATUS_SUCCESS;	
+	
+	_func_enter_;	
 
 	pio_req = alloc_ioreq(pio_queue);
-
+	
 	if ((pio_req == NULL)||(adapter->bSurpriseRemoved)){
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("async_irp_write32 : pio_req =0x%x adapter->bSurpriseRemoved=0x%x",pio_req,adapter->bSurpriseRemoved ));
 		goto exit;
-	}
-
+	}	
+	
 	_enter_critical_bh(&(pio_queue->lock), &irqL);
-
+	
 	rtw_list_insert_tail(&(pio_req->list),&(pio_queue->processing));
 
 
@@ -505,7 +505,7 @@ void usb_write_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
 	piorw_irp->Cancel = _FALSE;
 #endif
 
-	if((adapter->bDriverStopped) || (adapter->bSurpriseRemoved) ||(adapter->pwrctrlpriv.pnp_bstop_trx))
+	if((adapter->bDriverStopped) || (adapter->bSurpriseRemoved) ||(adapter->pwrctrlpriv.pnp_bstop_trx))	
 	{
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("\npadapter->pwrctrlpriv.pnp_bstop_trx==_TRUE\n"));
 		_func_exit_;
@@ -513,21 +513,21 @@ void usb_write_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
 	}
 
 	//translate DMA FIFO addr to pipehandle
-	PipeHandle = ffaddr2pipehdl(pdev, addr);
-
+	PipeHandle = ffaddr2pipehdl(pdev, addr);	
 
+	
 	pintfpriv->io_irp_cnt++;
-	pintfpriv->bio_irp_pending=_TRUE;
+	pintfpriv->bio_irp_pending=_TRUE;	
 	// Build our URB for USBD
 	UsbBuildInterruptOrBulkTransferRequest(
 				piorw_urb,
 				sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER),
 				PipeHandle,
 				(PVOID)wmem,
-				NULL,
-				cnt,
-				0,
-				NULL);
+				NULL, 
+				cnt, 
+				0, 
+				NULL);  
 
 	//
 	// call the calss driver to perform the operation
@@ -539,14 +539,14 @@ void usb_write_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
 	nextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;
 
 	IoSetCompletionRoutine(
-				piorw_irp,				// irp to use
+				piorw_irp,				// irp to use				
 				usb_write_mem_complete,		// routine to call when irp is done
 				pio_queue,				// context to pass routine
 				TRUE,					// call on success
 				TRUE,					// call on error
 				TRUE);					// call on cancel
-
-	//
+	
+	// 
 	// Call IoCallDriver to send the irp to the usb port
 	//
 	NtStatus	= IoCallDriver(pdev->pnextdevobj, piorw_irp);
@@ -567,65 +567,65 @@ void usb_write_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
 	}
 
 	_exit_critical_bh(&(pio_queue->lock), &irqL);
-
-	_rtw_down_sema(&pio_req->sema);
+	
+	_rtw_down_sema(&pio_req->sema);	
 	free_ioreq(pio_req, pio_queue);
-
+	
 
 	bwritezero = _FALSE;
        if (pdev->ishighspeed)
 	{
 		if(cnt> 0 && cnt%512 == 0)
 			bwritezero = _TRUE;
-
+			
 	}
 	else
 	{
 		if(cnt > 0 && cnt%64 == 0)
-			bwritezero = _TRUE;
+			bwritezero = _TRUE;		
 	}
 
-
+	
 	if(bwritezero == _TRUE)
 	{
 		usb_bulkout_zero(pintfhdl, addr);
 	}
-
+	
 exit:
-
+	
 	_func_exit_;
-
+	
 }
 
 NTSTATUS usb_read_port_complete(PDEVICE_OBJECT pUsbDevObj, PIRP pIrp, PVOID context)
-{
+{	
 	uint isevt, *pbuf;
 	struct _URB_BULK_OR_INTERRUPT_TRANSFER	*pbulkurb;
-	USBD_STATUS		usbdstatus;
-	struct recv_buf		*precvbuf = (struct recv_buf *)context;
+	USBD_STATUS		usbdstatus;	
+	struct recv_buf		*precvbuf = (struct recv_buf *)context;	
 	_adapter 				*adapter =(_adapter *)precvbuf->adapter;
 	struct recv_priv		*precvpriv = &adapter->recvpriv;
 	struct dvobj_priv   	*dev = (struct dvobj_priv   *)&adapter->dvobjpriv;
 	PURB				purb = precvbuf->purb;
 	struct intf_hdl 		*pintfhdl = &adapter->pio_queue->intf;
-
+	
 	//RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete!!!\n"));
 
 	usbdstatus = URB_STATUS(purb);
-
+	
 	_rtw_spinlock_ex(&precvpriv->lock);
 	precvbuf->irp_pending=_FALSE;
 	precvpriv->rx_pending_cnt --;
-	_rtw_spinunlock_ex(&precvpriv->lock);
-
-	if(precvpriv->rx_pending_cnt== 0) {
+	_rtw_spinunlock_ex(&precvpriv->lock);	
+	
+	if(precvpriv->rx_pending_cnt== 0) {		
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete: rx_pending_cnt== 0, set allrxreturnevt!\n"));
-		_rtw_up_sema(&precvpriv->allrxreturnevt);
+		_rtw_up_sema(&precvpriv->allrxreturnevt);	
 	}
 
 
 	if( pIrp->Cancel == _TRUE ) {
-
+		
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete: One IRP has been cancelled succesfully\n"));
 		return STATUS_MORE_PROCESSING_REQUIRED;
 	}
@@ -635,50 +635,50 @@ NTSTATUS usb_read_port_complete(PDEVICE_OBJECT pUsbDevObj, PIRP pIrp, PVOID cont
 		return STATUS_MORE_PROCESSING_REQUIRED;
 	}
 
-	switch(pIrp->IoStatus.Status)
+	switch(pIrp->IoStatus.Status) 
 	{
 		case STATUS_SUCCESS:
-
+			
 			pbulkurb = &(precvbuf->purb)->UrbBulkOrInterruptTransfer;
-			if((pbulkurb->TransferBufferLength >(MAX_RECVBUF_SZ)) || (pbulkurb->TransferBufferLength < RXDESC_SIZE) )
-			{
+			if((pbulkurb->TransferBufferLength >(MAX_RECVBUF_SZ)) || (pbulkurb->TransferBufferLength < RXDESC_SIZE) ) 
+			{								
 				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("\n usb_read_port_complete: (pbulkurb->TransferBufferLength > MAX_RECVBUF_SZ) || (pbulkurb->TransferBufferLength < RXDESC_SIZE)\n"));
 				rtw_read_port(adapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
 			}
-			else
-			{
+			else 
+			{	
 			       precvbuf->transfer_len = pbulkurb->TransferBufferLength;
 
 				pbuf = (uint*)precvbuf->pbuf;
 
 				if((isevt = *(pbuf+1)&0x1ff) == 0x1ff)
-				{
+				{								
 					rxcmd_event_hdl(adapter, pbuf);//rx c2h events
-
+					
 					rtw_read_port(adapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
 				}
 				else
 				{
 					if(recvbuf2recvframe(adapter, precvbuf)==_FAIL)//rx packets
 					{
-						//precvbuf->reuse = _TRUE;
+						//precvbuf->reuse = _TRUE;		
 						rtw_read_port(adapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
 					}
 				}
-
+				
 			}
-
+	
 			break;
-
+			
 		default:
-
+			
 			if( !USBD_HALTED(usbdstatus) )
-			{
-				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("\n usb_read_port_complete():USBD_HALTED(usbdstatus)=%x  (need to handle ) \n",USBD_HALTED(usbdstatus)));
-
+			{				
+				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("\n usb_read_port_complete():USBD_HALTED(usbdstatus)=%x  (need to handle ) \n",USBD_HALTED(usbdstatus)));				
+			
 			}
-			else
-			{
+			else 
+			{				
 				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("\n usb_read_port_complete(): USBD_HALTED(usbdstatus)=%x \n\n", USBD_HALTED(usbdstatus)) );
 				adapter->bDriverStopped = _TRUE;
 				adapter->bSurpriseRemoved = _TRUE;
@@ -686,11 +686,11 @@ NTSTATUS usb_read_port_complete(PDEVICE_OBJECT pUsbDevObj, PIRP pIrp, PVOID cont
 			}
 
 		      break;
-
+			  
 	}
 
 	return STATUS_MORE_PROCESSING_REQUIRED;
-
+	
 }
 
 u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
@@ -702,7 +702,7 @@ u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
 	PIO_STACK_LOCATION	nextStack;
 	NTSTATUS			ntstatus;
 	USBD_STATUS		usbdstatus;
-	HANDLE				PipeHandle;
+	HANDLE				PipeHandle;	
 	struct recv_buf		*precvbuf = (struct recv_buf *)rmem;
 	struct intf_priv		*pintfpriv = pintfhdl->pintfpriv;
 	struct dvobj_priv		*pdev = (struct dvobj_priv   *)pintfpriv->intf_dev;
@@ -711,7 +711,7 @@ u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
 	u32					bResult = _FALSE;
 
 _func_enter_;
-
+	
 	if(adapter->bDriverStopped || adapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx) {
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port:( padapter->bDriverStopped ||padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n"));
 		return bResult;
@@ -721,7 +721,7 @@ u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
 	{
 
 		rtl8192cu_init_recvbuf(adapter, precvbuf);
-
+	
 		_rtw_spinlock(&precvpriv->lock);
 		precvpriv->rx_pending_cnt++;
 		precvbuf->irp_pending = _TRUE;
@@ -730,19 +730,19 @@ u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
 	       pdata = (u8*)precvbuf->pbuf;
 
 		size	 = sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER );
-		purb = precvbuf->purb;
+		purb = precvbuf->purb;	
 
 		//translate DMA FIFO addr to pipehandle
-		PipeHandle = ffaddr2pipehdl(pdev, addr);
-
+		PipeHandle = ffaddr2pipehdl(pdev, addr);	
+		 
 		UsbBuildInterruptOrBulkTransferRequest(
 			purb,
 			(USHORT)size,
 			PipeHandle,
 			pdata,
-			NULL,
+			NULL, 
 			MAX_RECVBUF_SZ,
-			USBD_TRANSFER_DIRECTION_IN | USBD_SHORT_TRANSFER_OK,
+			USBD_TRANSFER_DIRECTION_IN | USBD_SHORT_TRANSFER_OK, 
 			NULL
 			);
 
@@ -764,13 +764,13 @@ u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
 		IoSetCompletionRoutine(
 			pirp,					// irp to use
 			usb_read_port_complete,	// routine to call when irp is done
-			precvbuf,					// context to pass routine
+			precvbuf,					// context to pass routine 
 			TRUE,					// call on success
 			TRUE,					// call on error
 			TRUE);					// call on cancel
 
 		//
-		// The IoCallDriver routine
+		// The IoCallDriver routine  
 		// sends an IRP to the driver associated with a specified device object.
 		//
 		ntstatus = IoCallDriver(pdev->pnextdevobj, pirp);
@@ -783,7 +783,7 @@ u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
 		}
 
 		if( ntstatus == STATUS_PENDING )
-		{
+		{ 
 			bResult = _TRUE;// The IRP is pended in USBD as we expected.
 		}
 		else {
@@ -797,95 +797,95 @@ u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
 	}
 
 _func_exit_;
-
+	
 	return bResult;
-
+	
 }
 
 void usb_read_port_cancel(_adapter *padapter)
-{
+{	
 	struct recv_buf  *precvbuf;
 	sint i;
 	struct dvobj_priv   *pdev = &padapter->dvobjpriv;
-	struct recv_priv *precvpriv=&padapter->recvpriv;
-
+	struct recv_priv *precvpriv=&padapter->recvpriv;	
+		
 	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("\n ==>usb_read_port_cancel\n"));
 
 	_rtw_spinlock(&precvpriv->lock);
-	precvpriv->rx_pending_cnt--; //decrease 1 for Initialize ++
+	precvpriv->rx_pending_cnt--; //decrease 1 for Initialize ++ 
 	_rtw_spinunlock(&precvpriv->lock);
 
 	if (precvpriv->rx_pending_cnt)
 	{
 		// Canceling Pending Recv Irp
 		precvbuf = (struct recv_buf  *)precvpriv->precv_buf;
-
+		
 		for( i = 0; i < NR_RECVBUFF; i++ )
 		{
 			if (precvbuf->irp_pending == _TRUE)
-			{
+			{	
 				IoCancelIrp(precvbuf->pirp);
 				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_cancel() :IoCancelIrp\n"));
 			}
-
+			
 			precvbuf++;
 		}
-
+		
 		_rtw_down_sema(&precvpriv->allrxreturnevt);
-
+		
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_cancel:down sema\n"));
 
 	}
-
+	
 	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("<==usb_read_port_cancel\n"));
-
+	
 }
 
 NTSTATUS usb_write_port_complete(
 	PDEVICE_OBJECT	pUsbDevObj,
 	PIRP				pIrp,
 	PVOID			pTxContext
-)
-{
+) 
+{	
 	u32	i, bIrpSuccess, sz;
 	NTSTATUS	status = STATUS_SUCCESS;
 	u8 *ptr;
 	struct xmit_frame	*pxmitframe = (struct xmit_frame *) pTxContext;
         struct xmit_buf *pxmitbuf = pxmitframe->pxmitbuf;
 	_adapter			*padapter = pxmitframe->padapter;
-	struct dvobj_priv	*pdev =	(struct dvobj_priv *)&padapter->dvobjpriv;
+	struct dvobj_priv	*pdev =	(struct dvobj_priv *)&padapter->dvobjpriv;	
 	struct io_queue	*pio_queue = (struct io_queue *)padapter->pio_queue;
 	struct intf_hdl	*pintfhdl = &(pio_queue->intf);
-       struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
-
+       struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;		
+	   
 _func_enter_;
 
 	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("+usb_write_port_complete\n"));
 
-	_rtw_spinlock_ex(&pxmitpriv->lock);
+	_rtw_spinlock_ex(&pxmitpriv->lock);	
 	pxmitpriv->txirp_cnt--;
 	_rtw_spinunlock_ex(&pxmitpriv->lock);
-
+	
 	if(pxmitpriv->txirp_cnt==0){
-		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete: txirp_cnt== 0, set allrxreturnevt!\n"));
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete: txirp_cnt== 0, set allrxreturnevt!\n"));		
 		_rtw_up_sema(&(pxmitpriv->tx_retevt));
 	}
-
+	
 	status = pIrp->IoStatus.Status;
 
-	if( status == STATUS_SUCCESS )
-		bIrpSuccess = _TRUE;
-	else
+	if( status == STATUS_SUCCESS ) 
+		bIrpSuccess = _TRUE;	
+	else	
 		bIrpSuccess = _FALSE;
-
+	
 	if( pIrp->Cancel == _TRUE )
-	{
+	{		
 	    if(pxmitframe !=NULL)
-	    {
-			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("\n usb_write_port_complete:pIrp->Cancel == _TRUE,(pxmitframe !=NULL\n"));
-			rtw_free_xmitframe(pxmitpriv, pxmitframe);
+	    {	       
+	    		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("\n usb_write_port_complete:pIrp->Cancel == _TRUE,(pxmitframe !=NULL\n"));
+			rtw_free_xmitframe(pxmitpriv, pxmitframe);			
 	    }
-
+		  	 
 	     return STATUS_MORE_PROCESSING_REQUIRED;
 	}
 
@@ -899,15 +899,15 @@ NTSTATUS usb_write_port_complete(
 	//
 	// Send 0-byte here if necessary.
 	//
-	// <Note>
+	// <Note> 
 	// 1. We MUST keep at most one IRP pending in each endpoint, otherwise USB host controler driver will hang.
 	// Besides, even 0-byte IRP shall be count into #IRP sent down, so, we send 0-byte here instead of TxFillDescriptor8187().
-	// 2. If we don't count 0-byte IRP into an #IRP sent down, Tx will stuck when we download files via BT and
+	// 2. If we don't count 0-byte IRP into an #IRP sent down, Tx will stuck when we download files via BT and 
 	// play online video on XP SP1 EHCU.
 	// 2005.12.26, by rcnjko.
 	//
 
-
+	
 	for(i=0; i< 8; i++)
 	{
             if(pIrp == pxmitframe->pxmit_irp[i])
@@ -915,23 +915,23 @@ NTSTATUS usb_write_port_complete(
 		    pxmitframe->bpending[i] = _FALSE;//
 		    //ac_tag = pxmitframe->ac_tag[i];
                   sz = pxmitframe->sz[i];
-		    break;
+		    break;		  
             }
 	}
 
-#if 0
+#if 0	
 	pxmitframe->fragcnt--;
 	if(pxmitframe->fragcnt == 0)// if((pxmitframe->fragcnt == 0) && (pxmitframe->irpcnt == 8)){
 	{
 		//RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("\n usb_write_port_complete:pxmitframe->fragcnt == 0\n"));
-		rtw_free_xmitframe(pxmitpriv,pxmitframe);
-	}
-#else
+		rtw_free_xmitframe(pxmitpriv,pxmitframe);	          
+      	}
+#else	
 
 	//not to consider tx fragment
-	rtw_free_xmitframe(pxmitpriv, pxmitframe);
+	rtw_free_xmitframe(pxmitpriv, pxmitframe);		
 
-#endif
+#endif	
 
 	rtl8192cu_xmitframe_complete(padapter, pxmitpriv, pxmitbuf);
 
@@ -943,16 +943,16 @@ NTSTATUS usb_write_port_complete(
 
 u32 usb_write_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
 {
-       u32 i, bwritezero;
+       u32 i, bwritezero;      	
 	u8 *ptr;
 	PIO_STACK_LOCATION	nextStack;
 	USBD_STATUS		usbdstatus;
-	HANDLE				PipeHandle;
+	HANDLE				PipeHandle;	
 	PIRP					pirp = NULL;
-	PURB				purb = NULL;
+	PURB				purb = NULL;	
 	NDIS_STATUS			ndisStatus = NDIS_STATUS_SUCCESS;
 	_adapter *padapter = (_adapter *)pintfhdl->adapter;
-	struct dvobj_priv	*pNdisCEDvice = (struct dvobj_priv   *)&padapter->dvobjpriv;
+	struct dvobj_priv	*pNdisCEDvice = (struct dvobj_priv   *)&padapter->dvobjpriv;	
 	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
 	struct xmit_frame *pxmitframe = (struct xmit_frame *)wmem;
 
@@ -963,26 +963,26 @@ u32 usb_write_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port:( padapter->bDriverStopped ||padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n"));
 		return _FAIL;
 	}
-
+	
 
 	for(i=0; i<8; i++)
        {
 		if(pxmitframe->bpending[i] == _FALSE)
 		{
-			_rtw_spinlock(&pxmitpriv->lock);
+			_rtw_spinlock(&pxmitpriv->lock);	
 			pxmitpriv->txirp_cnt++;
 			pxmitframe->bpending[i]  = _TRUE;
 			_rtw_spinunlock(&pxmitpriv->lock);
-
+			
 			pxmitframe->sz[i] = cnt;
 			purb	= pxmitframe->pxmit_urb[i];
 			pirp	= pxmitframe->pxmit_irp[i];
-
+			
 			//pxmitframe->ac_tag[i] = ac_tag;
-
-			break;
+			
+			break;	 
 		}
-       }
+       }	
 
 	bwritezero = _FALSE;
        if (pNdisCEDvice->ishighspeed)
@@ -992,7 +992,7 @@ u32 usb_write_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
 			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("ishighspeed, cnt=%d\n", cnt));
 			//cnt=cnt+1;
 			bwritezero = _TRUE;
-		}
+		}	
 	}
 	else
 	{
@@ -1001,9 +1001,9 @@ u32 usb_write_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
 			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("cnt=%d\n", cnt));
 			//cnt=cnt+1;
 			bwritezero = _TRUE;
-		}
+		}	
 	}
-
+	
 
 #ifdef NDIS51_MINIPORT
 	IoReuseIrp(pirp, STATUS_SUCCESS);
@@ -1013,7 +1013,7 @@ u32 usb_write_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
 
 
 	//translate DMA FIFO addr to pipehandle
-	PipeHandle = ffaddr2pipehdl(pNdisCEDvice, addr);
+	PipeHandle = ffaddr2pipehdl(pNdisCEDvice, addr);	
 
 
 	// Build our URB for USBD
@@ -1021,12 +1021,12 @@ u32 usb_write_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
 				purb,
 				sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER),
 				PipeHandle,
-				pxmitframe->mem_addr,
-				NULL,
-				cnt,
-				0,
+				pxmitframe->mem_addr, 
+				NULL, 
+				cnt, 
+				0, 
 				NULL);
-
+	
 	//
 	// call the calss driver to perform the operation
 	// pass the URB to the USB driver stack
@@ -1039,12 +1039,12 @@ u32 usb_write_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
 	//Set Completion Routine
 	IoSetCompletionRoutine(pirp,					// irp to use
 				               usb_write_port_complete,	// callback routine
-				               pxmitframe,				// context
+				               pxmitframe,				// context 
 				               TRUE,					// call on success
 				               TRUE,					// call on error
 				               TRUE);					// call on cancel
 
-
+	
 	// Call IoCallDriver to send the irp to the usb bus driver
 	//
 	ndisStatus = IoCallDriver(pNdisCEDvice->pnextdevobj, pirp);
@@ -1063,20 +1063,20 @@ u32 usb_write_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
 	if ( ndisStatus != STATUS_PENDING )
 	{
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("\n usb_write_port(): ndisStatus(%x) != STATUS_PENDING!\n\n", ndisStatus));
-
+		
 		_func_exit_;
-
+		
 		return _FAIL;
-	}
-
+	} 	
+	
 	if(bwritezero == _TRUE)
 	{
 		usb_bulkout_zero(pintfhdl, addr);
 	}
 
-
+	
 _func_exit_;
-
+	
 	return _SUCCESS;
 
 }
@@ -1093,29 +1093,29 @@ void usb_write_port_cancel(_adapter *padapter)
 	_rtw_spinlock(&pxmitpriv->lock);
 	pxmitpriv->txirp_cnt--; //decrease 1 for Initialize ++
 	_rtw_spinunlock(&pxmitpriv->lock);
-
-	if (pxmitpriv->txirp_cnt)
+	
+	if (pxmitpriv->txirp_cnt) 
 	{
 		// Canceling Pending Recv Irp
 		pxmitframe= (struct xmit_frame *)pxmitpriv->pxmit_frame_buf;
-
+		
 		for( i = 0; i < NR_XMITFRAME; i++ )
 		{
 			for(j=0;j<8;j++)
 			{
 				if (pxmitframe->bpending[j]==_TRUE)
-				{
-					IoCancelIrp(pxmitframe->pxmit_irp[j]);
+				{			
+					IoCancelIrp(pxmitframe->pxmit_irp[j]);		
 					RT_TRACE(_module_hci_ops_os_c_,_drv_err_,(" usb_write_port_cancel() :IoCancelIrp\n"));
 
 				}
 			}
-
+			
 			pxmitframe++;
 		}
 
 		_rtw_down_sema(&(pxmitpriv->tx_retevt));
-
+		
 	}
 
 }
@@ -1135,24 +1135,24 @@ NTSTATUS  sync_callusbd(struct dvobj_priv *pdvobjpriv, PURB purb)
 	LARGE_INTEGER			waittime;
 	NTSTATUS ntstatus = STATUS_SUCCESS;
 	_adapter *padapter = pdvobjpriv->padapter;
-
+	
 
 	_func_enter_;
 
 //	if(padapter->bDriverStopped) {
 //		goto exit;
 //	}
-
+	
 	KeInitializeEvent(&kevent, NotificationEvent, _FALSE);
 	irp = IoBuildDeviceIoControlRequest(
 			IOCTL_INTERNAL_USB_SUBMIT_URB,
-			pdvobjpriv->pphysdevobj,//CEdevice->pUsbDevObj,
-			NULL,
-			0,
-			NULL,
-			0,
-			_TRUE,
-			&kevent,
+			pdvobjpriv->pphysdevobj,//CEdevice->pUsbDevObj, 
+			NULL, 
+			0, 
+			NULL, 
+			0, 
+			_TRUE, 
+			&kevent, 
 			&iostatusblock);
 
 	if(irp == NULL) {
@@ -1160,30 +1160,30 @@ NTSTATUS  sync_callusbd(struct dvobj_priv *pdvobjpriv, PURB purb)
 		ntstatus=STATUS_INSUFFICIENT_RESOURCES;
 		goto exit;
 	}
-
+	
 	nextstack = IoGetNextIrpStackLocation(irp);
-	if(nextstack == NULL)
+	if(nextstack == NULL)	
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("IoGetNextIrpStackLocation fail\n"));
 
 	nextstack->Parameters.Others.Argument1 = purb;
-
+	
 	// Issue an IRP for Sync IO.
 	ntstatus = IoCallDriver(pdvobjpriv->pphysdevobj, irp);
 	usbdstatus = URB_STATUS(purb);
 
 	if(ntstatus == STATUS_PENDING)
-	{
+	{		
 		// Method 1
 		waittime.QuadPart = -10000 * 50000;
 		ntstatus = KeWaitForSingleObject(&kevent, Executive, KernelMode, _FALSE, &waittime); //8150 code
-
+		
 		// Method 2
 		//ntStatus = KeWaitForSingleObject(&Kevent, Executive, KernelMode, FALSE, NULL); //DDK sample
-
+		
 		usbdstatus = URB_STATUS(purb);
 
-		if(ntstatus == STATUS_TIMEOUT)
-		{
+		if(ntstatus == STATUS_TIMEOUT) 
+		{			
 			//usbdevice->nIoStuckCnt++;
 			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("SyncCallUSBD: TIMEOUT....5000ms\n"));
 
@@ -1194,15 +1194,15 @@ NTSTATUS  sync_callusbd(struct dvobj_priv *pdvobjpriv, PURB purb)
 
 			usbdstatus = USBD_STATUS_SUCCESS;
 		}
-
+		
 	}
-
-exit:
-
+	
+exit:	
+	
 	_func_exit_;
-
+	
 	return ntstatus;
-
+	
 }
 int usbctrl_vendorreq(struct intf_priv *pintfpriv, u8 request, u16 value, u16 index, void *pdata, u16 len, u8 requesttype)
 {
@@ -1211,14 +1211,14 @@ int usbctrl_vendorreq(struct intf_priv *pintfpriv, u8 request, u16 value, u16 in
 	unsigned long		transferflags;
 	NTSTATUS		ntstatus;
 
-	struct dvobj_priv  *pdvobjpriv = (struct dvobj_priv  *)pintfpriv->intf_dev;
-
+	struct dvobj_priv  *pdvobjpriv = (struct dvobj_priv  *)pintfpriv->intf_dev;   
+	
 	_func_enter_;
 
 	ret=_TRUE;
 	purb = (PURB)ExAllocatePool(NonPagedPool, sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST) );
 	if(purb == NULL) {
-
+		
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usbctrl_vendorreq(): Failed to allocate urb !!!\n"));
 		ret =_FALSE;
 		goto exit;
@@ -1231,18 +1231,18 @@ int usbctrl_vendorreq(struct intf_priv *pintfpriv, u8 request, u16 value, u16 in
 	}
 
 	UsbBuildVendorRequest(
-			purb, 		//Pointer to an URB that is to be formatted as a vendor or class request.
-			URB_FUNCTION_VENDOR_DEVICE,	//Indicates the URB is a vendor-defined request for a USB device.
-			sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST),  //Specifies the length, in bytes, of the URB.
-			transferflags, 	//TransferFlags
-			0,			//ReservedBits
-			request, 	//Request
-			value, 		//Value
+			purb, 		//Pointer to an URB that is to be formatted as a vendor or class request. 
+			URB_FUNCTION_VENDOR_DEVICE,	//Indicates the URB is a vendor-defined request for a USB device. 
+			sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST),  //Specifies the length, in bytes, of the URB. 
+			transferflags, 	//TransferFlags 
+			0,			//ReservedBits 
+			request, 	//Request 
+			value, 		//Value 
 			index,		//Index
-			pdata,		//TransferBuffer
-			NULL,		//TransferBufferMDL
-			len,			//TransferBufferLength
-			NULL		//Link
+			pdata,		//TransferBuffer 
+			NULL,		//TransferBufferMDL 
+			len,			//TransferBufferLength 
+			NULL		//Link 
 	);
 
 	ntstatus = sync_callusbd(pdvobjpriv, purb);
@@ -1256,9 +1256,10 @@ int usbctrl_vendorreq(struct intf_priv *pintfpriv, u8 request, u16 value, u16 in
 
 	ExFreePool(purb);
 
-exit:
+exit:	
 	_func_exit_;
-
-	return ret;
+	
+	return ret;	
 
 }
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192CEHWImg.h b/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192CEHWImg.h
old mode 100644
new mode 100755
index 2ae36e4..4ae3630
--- a/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192CEHWImg.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192CEHWImg.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192CPhyCfg.h b/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192CPhyCfg.h
old mode 100644
new mode 100755
index 918b520..3afb292
--- a/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192CPhyCfg.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192CPhyCfg.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -21,18 +21,18 @@
  * Module:	__INC_HAL8192CPHYCFG_H
  *
  *
- * Note:
- *
+ * Note:	
+ *			
  *
  * Export:	Constants, macro, functions(API), global variables(None).
  *
- * Abbrev:
+ * Abbrev:	
  *
  * History:
- *		Data		Who		Remark
+ *		Data		Who		Remark 
  *      08/07/2007  MHC    	1. Porting from 9x series PHYCFG.h.
  *							2. Reorganize code architecture.
- *
+ * 
  *****************************************************************************/
  /* Check to see if the file has been included already.  */
 #ifndef __INC_HAL8192CPHYCFG_H
@@ -83,7 +83,7 @@
 /*--------------------------Define Parameters-------------------------------*/
 
 
-/*------------------------------Define structure----------------------------*/
+/*------------------------------Define structure----------------------------*/ 
 typedef enum _SwChnlCmdID{
 	CmdID_End,
 	CmdID_SetTxPowerLevel,
@@ -147,63 +147,63 @@
 typedef	enum _RF_TYPE_8190P{
 	RF_TYPE_MIN,	// 0
 	RF_8225=1,			// 1 11b/g RF for verification only
-	RF_8256=2,			// 2 11b/g/n
+	RF_8256=2,			// 2 11b/g/n 
 	RF_8258=3,			// 3 11a/b/g/n RF
 	RF_6052=4,		// 4 11b/g/n RF
 	//RF_6052=5,		// 4 11b/g/n RF
 	// TODO: We sholud remove this psudo PHY RF after we get new RF.
-	RF_PSEUDO_11N=5,	// 5, It is a temporality RF.
+	RF_PSEUDO_11N=5,	// 5, It is a temporality RF. 
 }RF_TYPE_8190P_E,*PRF_TYPE_8190P_E;
 
 typedef struct _BB_REGISTER_DEFINITION{
-	u32 rfintfs;			// set software control:
+	u32 rfintfs;			// set software control: 
 							//		0x870~0x877[8 bytes]
-
-	u32 rfintfi;			// readback data:
+							
+	u32 rfintfi;			// readback data: 
 							//		0x8e0~0x8e7[8 bytes]
-
-	u32 rfintfo; 		// output data:
+							
+	u32 rfintfo; 		// output data: 
 							//		0x860~0x86f [16 bytes]
-
-	u32 rfintfe; 		// output enable:
+							
+	u32 rfintfe; 		// output enable: 
 							//		0x860~0x86f [16 bytes]
-
+							
 	u32 rf3wireOffset;	// LSSI data:
 							//		0x840~0x84f [16 bytes]
-
-	u32 rfLSSI_Select;	// BB Band Select:
+							
+	u32 rfLSSI_Select;	// BB Band Select: 
 							//		0x878~0x87f [8 bytes]
-
-	u32 rfTxGainStage;	// Tx gain stage:
+							
+	u32 rfTxGainStage;	// Tx gain stage: 
 							//		0x80c~0x80f [4 bytes]
-
-	u32 rfHSSIPara1; 	// wire parameter control1 :
+							
+	u32 rfHSSIPara1; 	// wire parameter control1 : 
 							//		0x820~0x823,0x828~0x82b, 0x830~0x833, 0x838~0x83b [16 bytes]
-
-	u32 rfHSSIPara2; 	// wire parameter control2 :
+							
+	u32 rfHSSIPara2; 	// wire parameter control2 : 
 							//		0x824~0x827,0x82c~0x82f, 0x834~0x837, 0x83c~0x83f [16 bytes]
-
-	u32 rfSwitchControl; //Tx Rx antenna control :
+								
+	u32 rfSwitchControl; //Tx Rx antenna control : 
 							//		0x858~0x85f [16 bytes]
-
-	u32 rfAGCControl1; 	//AGC parameter control1 :
-							//		0xc50~0xc53,0xc58~0xc5b, 0xc60~0xc63, 0xc68~0xc6b [16 bytes]
-
-	u32 rfAGCControl2; 	//AGC parameter control2 :
-							//		0xc54~0xc57,0xc5c~0xc5f, 0xc64~0xc67, 0xc6c~0xc6f [16 bytes]
-
-	u32 rfRxIQImbalance; //OFDM Rx IQ imbalance matrix :
+								
+	u32 rfAGCControl1; 	//AGC parameter control1 : 
+							//		0xc50~0xc53,0xc58~0xc5b, 0xc60~0xc63, 0xc68~0xc6b [16 bytes] 
+								
+	u32 rfAGCControl2; 	//AGC parameter control2 : 
+							//		0xc54~0xc57,0xc5c~0xc5f, 0xc64~0xc67, 0xc6c~0xc6f [16 bytes] 
+							
+	u32 rfRxIQImbalance; //OFDM Rx IQ imbalance matrix : 
 							//		0xc14~0xc17,0xc1c~0xc1f, 0xc24~0xc27, 0xc2c~0xc2f [16 bytes]
-
-	u32 rfRxAFE;  		//Rx IQ DC ofset and Rx digital filter, Rx DC notch filter :
+							
+	u32 rfRxAFE;  		//Rx IQ DC ofset and Rx digital filter, Rx DC notch filter : 
 							//		0xc10~0xc13,0xc18~0xc1b, 0xc20~0xc23, 0xc28~0xc2b [16 bytes]
-
+							
 	u32 rfTxIQImbalance; //OFDM Tx IQ imbalance matrix
 							//		0xc80~0xc83,0xc88~0xc8b, 0xc90~0xc93, 0xc98~0xc9b [16 bytes]
-
+							
 	u32 rfTxAFE; 		//Tx IQ DC Offset and Tx DFIR type
 							//		0xc84~0xc87,0xc8c~0xc8f, 0xc94~0xc97, 0xc9c~0xc9f [16 bytes]
-
+								
 	u32 rfLSSIReadBack; 	//LSSI RF readback data SI mode
 								//		0x8a0~0x8af [16 bytes]
 
@@ -228,14 +228,14 @@
 		ANTENNA_AB		,
 		ANTENNA_ABD		,
 		ANTENNA_ABC		,
-		ANTENNA_ABCD
+		ANTENNA_ABCD	
 } ANTENNA_PATH;
 #endif
 
-typedef struct _R_ANTENNA_SELECT_OFDM{
-	u32			r_tx_antenna:4;
+typedef struct _R_ANTENNA_SELECT_OFDM{	
+	u32			r_tx_antenna:4;	
 	u32			r_ant_l:4;
-	u32			r_ant_non_ht:4;
+	u32			r_ant_non_ht:4;	
 	u32			r_ant_ht1:4;
 	u32			r_ant_ht2:4;
 	u32			r_ant_ht_s1:4;
@@ -245,12 +245,12 @@
 }R_ANTENNA_SELECT_OFDM;
 
 typedef struct _R_ANTENNA_SELECT_CCK{
-	u8			r_cckrx_enable_2:2;
+	u8			r_cckrx_enable_2:2;	
 	u8			r_cckrx_enable:2;
 	u8			r_ccktx_enable:4;
 }R_ANTENNA_SELECT_CCK;
 
-/*------------------------------Define structure----------------------------*/
+/*------------------------------Define structure----------------------------*/ 
 
 
 /*------------------------Export global variable----------------------------*/
@@ -306,7 +306,7 @@ int	rtl8192c_PHY_CheckBBAndRFOK(	IN	PADAPTER			Adapter,
 //
 // RF Power setting
 //
-//extern	BOOLEAN	PHY_SetRFPowerState(IN	PADAPTER			Adapter,
+//extern	BOOLEAN	PHY_SetRFPowerState(IN	PADAPTER			Adapter, 
 //									IN	RT_RF_POWER_STATE	eRFPowerState);
 
 //
@@ -320,7 +320,7 @@ BOOLEAN	PHY_UpdateTxPowerDbm8192C(	IN	PADAPTER	Adapter,
 											IN	int		powerInDbm	);
 
 //
-VOID
+VOID 
 PHY_ScanOperationBackup8192C(IN	PADAPTER	Adapter,
 										IN	u8		Operation	);
 
@@ -358,12 +358,12 @@ void	PHY_SwChnlPhy8192C(	IN	PADAPTER		pAdapter,
 
 void ChkFwCmdIoDone(	IN	PADAPTER	Adapter);
 
-#ifdef USE_WORKITEM
+#ifdef USE_WORKITEM	
 //extern 	void SetIOWorkItemCallback( IN PVOID            pContext );
 #else
 //extern	void SetIOTimerCallback( IN PRT_TIMER		pTimer);
-#endif
-
+#endif	
+				
 //
 // BB/MAC/RF other monitor API
 //
@@ -393,7 +393,7 @@ BOOLEAN	PHY_CheckIsLegalRfPath8192C(IN	PADAPTER	pAdapter,
 //
 // Modify the value of the hw register when beacon interval be changed.
 //
-void
+void	
 rtl8192c_PHY_SetBeaconHwReg(	IN	PADAPTER		Adapter,
 					IN	u16			BeaconInterval	);
 
@@ -411,7 +411,7 @@ BOOLEAN	PHY_CheckIsLegalRfPath8192C(IN	PADAPTER	pAdapter,
 BOOLEAN
 SetAntennaConfig92C(
 	IN	PADAPTER	Adapter,
-	IN	u8		DefaultAnt
+	IN	u8		DefaultAnt	
 	);
 
 
@@ -425,3 +425,4 @@ BOOLEAN	PHY_CheckIsLegalRfPath8192C(IN	PADAPTER	pAdapter,
 #define PHY_SetMacReg	PHY_SetBBReg
 
 #endif	// __INC_HAL8192CPHYCFG_H
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192CPhyReg.h b/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192CPhyReg.h
old mode 100644
new mode 100755
index 746326e..6364166
--- a/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192CPhyReg.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192CPhyReg.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -27,18 +27,18 @@
  *			3. PMAC/BB register bit mask.
  *			4. RF reg bit mask.
  *			5. Other BB/RF relative definition.
- *
+ *			
  *
  * Export:	Constants, macro, functions(API), global variables(None).
  *
- * Abbrev:
+ * Abbrev:	
  *
  * History:
- *		Data		Who		Remark
+ *		Data		Who		Remark 
  *      08/07/2007  MHC    	1. Porting from 9x series PHYCFG.h.
  *							2. Reorganize code architecture.
  *	09/25/2008	MH		1. Add RL6052 register definition
- *
+ * 
  *****************************************************************************/
 #ifndef __INC_HAL8192CPHYREG_H
 #define __INC_HAL8192CPHYREG_H
@@ -199,7 +199,7 @@
 //
 // PageB(0xB00)
 //
-#define		rPdp_AntA      				0xb00
+#define		rPdp_AntA      				0xb00  
 #define		rPdp_AntA_4    				0xb04
 #define		rConfig_Pmpd_AntA 			0xb28
 #define		rConfig_AntA 				0xb68
@@ -228,7 +228,7 @@
 #define		rOFDM0_XDRxIQImbalance    	0xc2c
 
 #define		rOFDM0_RxDetector1			0xc30  //PD,BW & SBD	// DM tune init gain
-#define		rOFDM0_RxDetector2			0xc34  //SBD & Fame Sync.
+#define		rOFDM0_RxDetector2			0xc34  //SBD & Fame Sync. 
 #define		rOFDM0_RxDetector3			0xc38  //Frame Sync.
 #define		rOFDM0_RxDetector4			0xc3c  //PD, SBD, Frame Sync & Short-GI
 
@@ -399,55 +399,55 @@
 //
 // RL6052 Register definition
 //
-#define		RF_AC						0x00	//
+#define		RF_AC						0x00	// 
 
-#define		RF_IQADJ_G1				0x01	//
-#define		RF_IQADJ_G2				0x02	//
+#define		RF_IQADJ_G1				0x01	// 
+#define		RF_IQADJ_G2				0x02	// 
 #define		RF_BS_PA_APSET_G1_G4		0x03
 #define		RF_BS_PA_APSET_G5_G8		0x04
-#define		RF_POW_TRSW				0x05	//
+#define		RF_POW_TRSW				0x05	// 
 
-#define		RF_GAIN_RX					0x06	//
-#define		RF_GAIN_TX					0x07	//
+#define		RF_GAIN_RX					0x06	// 
+#define		RF_GAIN_TX					0x07	// 
 
-#define		RF_TXM_IDAC				0x08	//
-#define		RF_IPA_G					0x09	//
+#define		RF_TXM_IDAC				0x08	// 
+#define		RF_IPA_G					0x09	// 
 #define		RF_TXBIAS_G				0x0A
 #define		RF_TXPA_AG					0x0B
-#define		RF_IPA_A					0x0C	//
+#define		RF_IPA_A					0x0C	// 
 #define		RF_TXBIAS_A				0x0D
 #define		RF_BS_PA_APSET_G9_G11	0x0E
-#define		RF_BS_IQGEN				0x0F	//
+#define		RF_BS_IQGEN				0x0F	// 
 
-#define		RF_MODE1					0x10	//
-#define		RF_MODE2					0x11	//
+#define		RF_MODE1					0x10	// 
+#define		RF_MODE2					0x11	// 
 
-#define		RF_RX_AGC_HP				0x12	//
-#define		RF_TX_AGC					0x13	//
-#define		RF_BIAS						0x14	//
-#define		RF_IPA						0x15	//
-#define		RF_POW_ABILITY			0x17	//
-#define		RF_MODE_AG				0x18	//
+#define		RF_RX_AGC_HP				0x12	// 
+#define		RF_TX_AGC					0x13	// 
+#define		RF_BIAS						0x14	// 
+#define		RF_IPA						0x15	// 
+#define		RF_POW_ABILITY			0x17	// 
+#define		RF_MODE_AG				0x18	// 
 #define		rRfChannel					0x18	// RF channel and BW switch
 #define		RF_CHNLBW					0x18	// RF channel and BW switch
-#define		RF_TOP						0x19	//
+#define		RF_TOP						0x19	// 
 
-#define		RF_RX_G1					0x1A	//
-#define		RF_RX_G2					0x1B	//
+#define		RF_RX_G1					0x1A	// 
+#define		RF_RX_G2					0x1B	// 
 
-#define		RF_RX_BB2					0x1C	//
-#define		RF_RX_BB1					0x1D	//
+#define		RF_RX_BB2					0x1C	// 
+#define		RF_RX_BB1					0x1D	// 
 
-#define		RF_RCK1					0x1E	//
-#define		RF_RCK2					0x1F	//
+#define		RF_RCK1					0x1E	// 
+#define		RF_RCK2					0x1F	// 
 
-#define		RF_TX_G1					0x20	//
-#define		RF_TX_G2					0x21	//
-#define		RF_TX_G3					0x22	//
+#define		RF_TX_G1					0x20	// 
+#define		RF_TX_G2					0x21	// 
+#define		RF_TX_G3					0x22	// 
 
-#define		RF_TX_BB1					0x23	//
+#define		RF_TX_BB1					0x23	// 
 
-#define		RF_T_METER					0x24	//
+#define		RF_T_METER					0x24	// 
 
 #define		RF_SYN_G1					0x25	// RF TX Power control
 #define		RF_SYN_G2					0x26	// RF TX Power control
@@ -531,7 +531,7 @@
 #define		bXBTxAGC                  			0xf00	// Reg 80c rFPGA0_TxGainStage
 #define		bXCTxAGC                  			0xf000
 #define		bXDTxAGC                  			0xf0000
-
+       		
 #define		bPAStart                  			0xf0000000	// Useless now
 #define		bTRStart                  			0x00f00000
 #define		bRFStart                  			0x0000f000
@@ -577,7 +577,7 @@
 #define		bRFSI_ANTSW               		0x100
 #define		bRFSI_ANTSWB              		0x200
 #define		bRFSI_PAPE                			0x400
-#define		bRFSI_PAPE5G              		0x800
+#define		bRFSI_PAPE5G              		0x800 
 #define		bBandSelect               			0x1
 #define		bHTSIG2_GI                			0x80
 #define		bHTSIG2_Smoothing         		0x01
@@ -603,7 +603,7 @@
 #define		bLSSIReadBackData         		0xfffff		// T65 RF
 
 #define		bLSSIReadOKFlag           		0x1000	// Useless now
-#define		bCCKSampleRate            		0x8       //0: 44MHz, 1:88MHz
+#define		bCCKSampleRate            		0x8       //0: 44MHz, 1:88MHz       		
 #define		bRegulator0Standby        		0x1
 #define		bRegulatorPLLStandby      		0x2
 #define		bRegulator1Standby        		0x4
@@ -648,8 +648,8 @@
 #define		bAD11PowerUpAtTx          		0x1
 #define		bDA10PSAtTx               		0x10
 #define		bAD11PowerUpAtRx          		0x100
-#define		bDA10PSAtRx               		0x1000
-#define		bCCKRxAGCFormat           		0x200
+#define		bDA10PSAtRx               		0x1000       		
+#define		bCCKRxAGCFormat           		0x200       		
 #define		bPSDFFTSamplepPoint       		0xc000
 #define		bPSDAverageNum            		0x3000
 #define		bIQPathControl            		0xc00
@@ -748,9 +748,9 @@
 #define		bCCKRxFACounterLower	0xff
 #define		bCCKRxFACounterUpper	0xff000000
 #define		bCCKRxHPAGCStart		0xe000
-#define		bCCKRxHPAGCFinal		0x1c00
+#define		bCCKRxHPAGCFinal		0x1c00       		
 #define		bCCKRxFalseAlarmEnable	0x8000
-#define		bCCKFACounterFreeze	0x4000
+#define		bCCKFACounterFreeze	0x4000       		
 #define		bCCKTxPathSel			0x10000000
 #define		bCCKDefaultRxPath		0xc000000
 #define		bCCKOptionRxPath		0x3000000
@@ -902,16 +902,16 @@
 #define		bRxSGI_TH				0xc0000000
 #define		bDFSCnt0				0xff
 #define		bDFSCnt1				0xff00
-#define		bDFSFlag				0xf0000
+#define		bDFSFlag				0xf0000       		
 #define		bMFWeightSum			0x300000
-#define		bMinIdxTH				0x7f000000
-#define		bDAFormat				0x40000
-#define		bTxChEmuEnable		0x01000000
+#define		bMinIdxTH				0x7f000000       		
+#define		bDAFormat				0x40000       		
+#define		bTxChEmuEnable		0x01000000       		
 #define		bTRSWIsolation_A		0x7f
 #define		bTRSWIsolation_B		0x7f00
 #define		bTRSWIsolation_C		0x7f0000
-#define		bTRSWIsolation_D		0x7f000000
-#define		bExtLNAGain				0x7c00
+#define		bTRSWIsolation_D		0x7f000000       		
+#define		bExtLNAGain				0x7c00          
 
 // 6. PageE(0xE00)
 #define		bSTBCEn				0x4	// Useless
@@ -948,7 +948,7 @@
 #define		bLongCFOFLength	11
 #define		bTailCFO			0x1fff
 #define		bTailCFOTLength		13
-#define		bTailCFOFLength		12
+#define		bTailCFOFLength		12       		
 #define		bmax_en_pwdB		0xffff
 #define		bCC_power_dB		0xffff0000
 #define		bnoise_pwdB		0xffff
@@ -956,27 +956,27 @@
 #define		bPowerMeasFLength	3
 #define		bRx_HT_BW			0x1
 #define		bRxSC				0x6
-#define		bRx_HT				0x8
+#define		bRx_HT				0x8       		
 #define		bNB_intf_det_on		0x1
 #define		bIntf_win_len_cfg	0x30
-#define		bNB_Intf_TH_cfg		0x1c0
+#define		bNB_Intf_TH_cfg		0x1c0       		
 #define		bRFGain				0x3f
 #define		bTableSel			0x40
-#define		bTRSW				0x80
+#define		bTRSW				0x80       		
 #define		bRxSNR_A			0xff
 #define		bRxSNR_B			0xff00
 #define		bRxSNR_C			0xff0000
 #define		bRxSNR_D			0xff000000
 #define		bSNREVMTLength		8
-#define		bSNREVMFLength		1
+#define		bSNREVMFLength		1       		
 #define		bCSI1st				0xff
 #define		bCSI2nd				0xff00
 #define		bRxEVM1st			0xff0000
-#define		bRxEVM2nd			0xff000000
+#define		bRxEVM2nd			0xff000000       		
 #define		bSIGEVM			0xff
 #define		bPWDB				0xff00
 #define		bSGIEN				0x10000
-
+       		
 #define		bSFactorQAM1		0xf	// Useless
 #define		bSFactorQAM2		0xf0
 #define		bSFactorQAM3		0xf00
@@ -987,7 +987,7 @@
 #define		bSFactorQAM8		0xf000000
 #define		bSFactorQAM9		0xf0000000
 #define		bCSIScheme			0x100000
-
+       		
 #define		bNoiseLvlTopSet		0x3	// Useless
 #define		bChSmooth			0x4
 #define		bChSmoothCfg1		0x38
@@ -996,7 +996,7 @@
 #define		bChSmoothCfg4		0x7000
 #define		bMRCMode			0x800000
 #define		bTHEVMCfg			0x7000000
-
+       		
 #define		bLoopFitType		0x1	// Useless
 #define		bUpdCFO			0x40
 #define		bUpdCFOOffData		0x80
@@ -1070,24 +1070,24 @@
 #define		bMaskLWord			0x0000ffff
 #define		bMaskDWord		0xffffffff
 #define		bMask12Bits			0xfff
-#define		bMaskH4Bits			0xf0000000
+#define		bMaskH4Bits			0xf0000000	
 #define		bMaskOFDM_D		0xffc00000
 #define		bMaskCCK			0x3f3f3f3f
 
 //for PutRFRegsetting & GetRFRegSetting BitMask
 //#define		bMask12Bits               0xfffff	// RF Reg mask bits
 //#define		bMask20Bits               0xfffff	// RF Reg mask bits T65 RF
-#define 		bRFRegOffsetMask	0xfffff
-
+#define 		bRFRegOffsetMask	0xfffff		
+  		
 #define		bEnable			0x1	// Useless
 #define		bDisable		0x0
-
+       		
 #define		LeftAntenna		0x0	// Useless
 #define		RightAntenna	0x1
-
+       		
 #define		tCheckTxStatus		500   //500ms // Useless
 #define		tUpdateRxCounter	100   //100ms
-
+       		
 #define		rateCCK		0	// Useless
 #define		rateOFDM	1
 #define		rateHT		2
@@ -1110,7 +1110,7 @@
 #define		bPMACControl		0x0		// Useless
 #define		bWMACControl		0x1
 #define		bWNICControl		0x2
-
+       		
 #define		PathA			0x0	// Useless
 #define		PathB			0x1
 #define		PathC			0x2
@@ -1120,3 +1120,4 @@
 
 
 #endif	//__INC_HAL8192SPHYREG_H
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192CUHWImg.h b/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192CUHWImg.h
old mode 100644
new mode 100755
index cafea7b..ba3c282
--- a/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192CUHWImg.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192CUHWImg.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192CUHWImg_wowlan.h b/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192CUHWImg_wowlan.h
old mode 100644
new mode 100755
index 6e18fbc..47d4d2f
--- a/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192CUHWImg_wowlan.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192CUHWImg_wowlan.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -31,3 +31,4 @@
 extern u8 Rtl8192CUFwUMCBCutWWImgArray[UMCBCutWWImgArrayLength];
 
 #endif //__INC_HAL8192CU_FW_IMG_WOWLAN_H
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192DEHWImg.h b/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192DEHWImg.h
old mode 100644
new mode 100755
index 55998c2..0639775
--- a/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192DEHWImg.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192DEHWImg.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192DPhyCfg.h b/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192DPhyCfg.h
old mode 100644
new mode 100755
index 43c1188..624fbda
--- a/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192DPhyCfg.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192DPhyCfg.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -22,18 +22,18 @@
  * Module:	__INC_HAL8192DPHYCFG_H
  *
  *
- * Note:
- *
+ * Note:	
+ *			
  *
  * Export:	Constants, macro, functions(API), global variables(None).
  *
- * Abbrev:
+ * Abbrev:	
  *
  * History:
- *		Data		Who		Remark
+ *		Data		Who		Remark 
  *      08/07/2007  MHC    	1. Porting from 9x series PHYCFG.h.
  *							2. Reorganize code architecture.
- *
+ * 
  *****************************************************************************/
  /* Check to see if the file has been included already.  */
 #ifndef __INC_HAL8192DPHYCFG_H
@@ -86,7 +86,7 @@
 /*--------------------------Define Parameters-------------------------------*/
 
 
-/*------------------------------Define structure----------------------------*/
+/*------------------------------Define structure----------------------------*/ 
 typedef enum _SwChnlCmdID{
 	CmdID_End,
 	CmdID_SetTxPowerLevel,
@@ -189,63 +189,63 @@
 typedef	enum _RF_TYPE_8190P{
 	RF_TYPE_MIN,	// 0
 	RF_8225=1,			// 1 11b/g RF for verification only
-	RF_8256=2,			// 2 11b/g/n
+	RF_8256=2,			// 2 11b/g/n 
 	RF_8258=3,			// 3 11a/b/g/n RF
 	RF_6052=4,		// 4 11b/g/n RF
 	//RF_6052=5,		// 4 11b/g/n RF
 	// TODO: We sholud remove this psudo PHY RF after we get new RF.
-	RF_PSEUDO_11N=5,	// 5, It is a temporality RF.
+	RF_PSEUDO_11N=5,	// 5, It is a temporality RF. 
 }RF_TYPE_8190P_E,*PRF_TYPE_8190P_E;
 
 typedef struct _BB_REGISTER_DEFINITION{
-	u32 rfintfs;			// set software control:
+	u32 rfintfs;			// set software control: 
 							//		0x870~0x877[8 bytes]
-
-	u32 rfintfi;			// readback data:
+							
+	u32 rfintfi;			// readback data: 
 							//		0x8e0~0x8e7[8 bytes]
-
-	u32 rfintfo; 		// output data:
+							
+	u32 rfintfo; 		// output data: 
 							//		0x860~0x86f [16 bytes]
-
-	u32 rfintfe; 		// output enable:
+							
+	u32 rfintfe; 		// output enable: 
 							//		0x860~0x86f [16 bytes]
-
+							
 	u32 rf3wireOffset;	// LSSI data:
 							//		0x840~0x84f [16 bytes]
-
-	u32 rfLSSI_Select;	// BB Band Select:
+							
+	u32 rfLSSI_Select;	// BB Band Select: 
 							//		0x878~0x87f [8 bytes]
-
-	u32 rfTxGainStage;	// Tx gain stage:
+							
+	u32 rfTxGainStage;	// Tx gain stage: 
 							//		0x80c~0x80f [4 bytes]
-
-	u32 rfHSSIPara1; 	// wire parameter control1 :
+							
+	u32 rfHSSIPara1; 	// wire parameter control1 : 
 							//		0x820~0x823,0x828~0x82b, 0x830~0x833, 0x838~0x83b [16 bytes]
-
-	u32 rfHSSIPara2; 	// wire parameter control2 :
+							
+	u32 rfHSSIPara2; 	// wire parameter control2 : 
 							//		0x824~0x827,0x82c~0x82f, 0x834~0x837, 0x83c~0x83f [16 bytes]
-
-	u32 rfSwitchControl; //Tx Rx antenna control :
+								
+	u32 rfSwitchControl; //Tx Rx antenna control : 
 							//		0x858~0x85f [16 bytes]
-
-	u32 rfAGCControl1; 	//AGC parameter control1 :
-							//		0xc50~0xc53,0xc58~0xc5b, 0xc60~0xc63, 0xc68~0xc6b [16 bytes]
-
-	u32 rfAGCControl2; 	//AGC parameter control2 :
-							//		0xc54~0xc57,0xc5c~0xc5f, 0xc64~0xc67, 0xc6c~0xc6f [16 bytes]
-
-	u32 rfRxIQImbalance; //OFDM Rx IQ imbalance matrix :
+								
+	u32 rfAGCControl1; 	//AGC parameter control1 : 
+							//		0xc50~0xc53,0xc58~0xc5b, 0xc60~0xc63, 0xc68~0xc6b [16 bytes] 
+								
+	u32 rfAGCControl2; 	//AGC parameter control2 : 
+							//		0xc54~0xc57,0xc5c~0xc5f, 0xc64~0xc67, 0xc6c~0xc6f [16 bytes] 
+							
+	u32 rfRxIQImbalance; //OFDM Rx IQ imbalance matrix : 
 							//		0xc14~0xc17,0xc1c~0xc1f, 0xc24~0xc27, 0xc2c~0xc2f [16 bytes]
-
-	u32 rfRxAFE;  		//Rx IQ DC ofset and Rx digital filter, Rx DC notch filter :
+							
+	u32 rfRxAFE;  		//Rx IQ DC ofset and Rx digital filter, Rx DC notch filter : 
 							//		0xc10~0xc13,0xc18~0xc1b, 0xc20~0xc23, 0xc28~0xc2b [16 bytes]
-
+							
 	u32 rfTxIQImbalance; //OFDM Tx IQ imbalance matrix
 							//		0xc80~0xc83,0xc88~0xc8b, 0xc90~0xc93, 0xc98~0xc9b [16 bytes]
-
+							
 	u32 rfTxAFE; 		//Tx IQ DC Offset and Tx DFIR type
 							//		0xc84~0xc87,0xc8c~0xc8f, 0xc94~0xc97, 0xc9c~0xc9f [16 bytes]
-
+								
 	u32 rfLSSIReadBack; 	//LSSI RF readback data SI mode
 								//		0x8a0~0x8af [16 bytes]
 
@@ -270,14 +270,14 @@
 		ANTENNA_AB		,
 		ANTENNA_ABD		,
 		ANTENNA_ABC		,
-		ANTENNA_ABCD
+		ANTENNA_ABCD	
 } ANTENNA_PATH;
 #endif
 
-typedef struct _R_ANTENNA_SELECT_OFDM{
-	u32			r_tx_antenna:4;
+typedef struct _R_ANTENNA_SELECT_OFDM{	
+	u32			r_tx_antenna:4;	
 	u32			r_ant_l:4;
-	u32			r_ant_non_ht:4;
+	u32			r_ant_non_ht:4;	
 	u32			r_ant_ht1:4;
 	u32			r_ant_ht2:4;
 	u32			r_ant_ht_s1:4;
@@ -287,12 +287,12 @@
 }R_ANTENNA_SELECT_OFDM;
 
 typedef struct _R_ANTENNA_SELECT_CCK{
-	u8			r_cckrx_enable_2:2;
+	u8			r_cckrx_enable_2:2;	
 	u8			r_cckrx_enable:2;
 	u8			r_ccktx_enable:4;
 }R_ANTENNA_SELECT_CCK;
 
-/*------------------------------Define structure----------------------------*/
+/*------------------------------Define structure----------------------------*/ 
 
 
 /*------------------------Export global variable----------------------------*/
@@ -355,7 +355,7 @@ int	rtl8192d_PHY_CheckBBAndRFOK(	IN	PADAPTER			Adapter,
 //
 // RF Power setting
 //
-//extern	BOOLEAN	PHY_SetRFPowerState(IN	PADAPTER			Adapter,
+//extern	BOOLEAN	PHY_SetRFPowerState(IN	PADAPTER			Adapter, 
 //									IN	RT_RF_POWER_STATE	eRFPowerState);
 
 //
@@ -369,7 +369,7 @@ BOOLEAN	PHY_UpdateTxPowerDbm8192D(	IN	PADAPTER	Adapter,
 											IN	int		powerInDbm	);
 
 //
-VOID
+VOID 
 PHY_ScanOperationBackup8192D(IN	PADAPTER	Adapter,
 										IN	u8		Operation	);
 
@@ -407,12 +407,12 @@ void	PHY_SwChnlPhy8192D(	IN	PADAPTER		pAdapter,
 
 extern void ChkFwCmdIoDone(	IN	PADAPTER	Adapter);
 
-#ifdef USE_WORKITEM
+#ifdef USE_WORKITEM	
 //extern 	void SetIOWorkItemCallback( IN PVOID            pContext );
 #else
 //extern	void SetIOTimerCallback( IN PRT_TIMER		pTimer);
-#endif
-
+#endif	
+				
 //
 // BB/MAC/RF other monitor API
 //
@@ -442,7 +442,7 @@ BOOLEAN	PHY_CheckIsLegalRfPath8192D(IN	PADAPTER	pAdapter,
 //
 // Modify the value of the hw register when beacon interval be changed.
 //
-void
+void	
 rtl8192d_PHY_SetBeaconHwReg(	IN	PADAPTER		Adapter,
 					IN	u16			BeaconInterval	);
 
@@ -460,10 +460,10 @@ BOOLEAN	PHY_CheckIsLegalRfPath8192D(IN	PADAPTER	pAdapter,
 BOOLEAN
 SetAntennaConfig92C(
 	IN	PADAPTER	Adapter,
-	IN	u8		DefaultAnt
+	IN	u8		DefaultAnt	
 	);
 
-VOID
+VOID 
 PHY_StopTRXBeforeChangeBand8192D(
 	  PADAPTER		Adapter
 );
@@ -476,7 +476,7 @@ BOOLEAN	PHY_CheckIsLegalRfPath8192D(IN	PADAPTER	pAdapter,
 
 VOID PHY_ReadMacPhyMode92D(
 	IN PADAPTER	Adapter,
-	IN BOOLEAN 	AutoloadFail
+	IN BOOLEAN 	AutoloadFail	
 );
 
 VOID PHY_ConfigMacPhyMode92D(
@@ -502,7 +502,7 @@ VOID PHY_ConfigMacCoexist_RFPage92D(
 );
 
 
-VOID
+VOID 
 rtl8192d_PHY_SetRFPathSwitch(IN	PADAPTER	pAdapter, IN	BOOLEAN		bMain);
 
 VOID
@@ -511,7 +511,7 @@ VOID PHY_ConfigMacCoexist_RFPage92D(
 	IN	BOOLEAN		bCCKDisable
 );
 
-VOID
+VOID 
 PHY_InitPABias92D(IN	PADAPTER Adapter);
 
 /*--------------------------Exported Function prototype---------------------*/
@@ -525,3 +525,4 @@ VOID PHY_ConfigMacCoexist_RFPage92D(
 #define PHY_SetMacReg	PHY_SetBBReg
 
 #endif	// __INC_HAL8192SPHYCFG_H
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192DPhyReg.h b/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192DPhyReg.h
old mode 100644
new mode 100755
index f79d8a2..f28aa03
--- a/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192DPhyReg.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192DPhyReg.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -27,18 +27,18 @@
  *			3. PMAC/BB register bit mask.
  *			4. RF reg bit mask.
  *			5. Other BB/RF relative definition.
- *
+ *			
  *
  * Export:	Constants, macro, functions(API), global variables(None).
  *
- * Abbrev:
+ * Abbrev:	
  *
  * History:
- *		Data		Who		Remark
+ *		Data		Who		Remark 
  *      08/07/2007  MHC    	1. Porting from 9x series PHYCFG.h.
  *							2. Reorganize code architecture.
  *	09/25/2008	MH		1. Add RL6052 register definition
- *
+ * 
  *****************************************************************************/
 #ifndef __INC_HAL8192DPHYREG_H
 #define __INC_HAL8192DPHYREG_H
@@ -190,7 +190,7 @@
 //
 // PageB(0xB00)
 //
-#define		rPdp_AntA      					0xb00
+#define		rPdp_AntA      					0xb00  
 #define		rPdp_AntA_4    				0xb04
 #define		rPdp_AntA_8    				0xb08
 #define		rPdp_AntA_C    				0xb0c
@@ -254,7 +254,7 @@
 #define		rOFDM0_XDRxIQImbalance    	0xc2c
 
 #define		rOFDM0_RxDetector1			0xc30  //PD,BW & SBD	// DM tune init gain
-#define		rOFDM0_RxDetector2			0xc34  //SBD & Fame Sync.
+#define		rOFDM0_RxDetector2			0xc34  //SBD & Fame Sync. 
 #define		rOFDM0_RxDetector3			0xc38  //Frame Sync.
 #define		rOFDM0_RxDetector4			0xc3c  //PD, SBD, Frame Sync & Short-GI
 
@@ -434,55 +434,55 @@
 //
 // RL6052 Register definition
 //
-#define		RF_AC						0x00	//
+#define		RF_AC						0x00	// 
 
-#define		RF_IQADJ_G1				0x01	//
-#define		RF_IQADJ_G2				0x02	//
+#define		RF_IQADJ_G1				0x01	// 
+#define		RF_IQADJ_G2				0x02	// 
 #define		RF_BS_PA_APSET_G1_G4		0x03
 #define		RF_BS_PA_APSET_G5_G8		0x04
-#define		RF_POW_TRSW				0x05	//
+#define		RF_POW_TRSW				0x05	// 
 
-#define		RF_GAIN_RX					0x06	//
-#define		RF_GAIN_TX					0x07	//
+#define		RF_GAIN_RX					0x06	// 
+#define		RF_GAIN_TX					0x07	// 
 
-#define		RF_TXM_IDAC				0x08	//
-#define		RF_IPA_G					0x09	//
+#define		RF_TXM_IDAC				0x08	// 
+#define		RF_IPA_G					0x09	// 
 #define		RF_TXBIAS_G				0x0A
 #define		RF_TXPA_AG					0x0B
-#define		RF_IPA_A					0x0C	//
+#define		RF_IPA_A					0x0C	// 
 #define		RF_TXBIAS_A				0x0D
 #define		RF_BS_PA_APSET_G9_G11	0x0E
-#define		RF_BS_IQGEN				0x0F	//
+#define		RF_BS_IQGEN				0x0F	// 
 
-#define		RF_MODE1					0x10	//
-#define		RF_MODE2					0x11	//
+#define		RF_MODE1					0x10	// 
+#define		RF_MODE2					0x11	// 
 
-#define		RF_RX_AGC_HP				0x12	//
-#define		RF_TX_AGC					0x13	//
-#define		RF_BIAS						0x14	//
-#define		RF_IPA						0x15	//
-#define		RF_POW_ABILITY			0x17	//
-#define		RF_MODE_AG				0x18	//
+#define		RF_RX_AGC_HP				0x12	// 
+#define		RF_TX_AGC					0x13	// 
+#define		RF_BIAS						0x14	// 
+#define		RF_IPA						0x15	// 
+#define		RF_POW_ABILITY			0x17	// 
+#define		RF_MODE_AG				0x18	// 
 #define		rRfChannel					0x18	// RF channel and BW switch
 #define		RF_CHNLBW					0x18	// RF channel and BW switch
-#define		RF_TOP						0x19	//
+#define		RF_TOP						0x19	// 
 
-#define		RF_RX_G1					0x1A	//
-#define		RF_RX_G2					0x1B	//
+#define		RF_RX_G1					0x1A	// 
+#define		RF_RX_G2					0x1B	// 
 
-#define		RF_RX_BB2					0x1C	//
-#define		RF_RX_BB1					0x1D	//
+#define		RF_RX_BB2					0x1C	// 
+#define		RF_RX_BB1					0x1D	// 
 
-#define		RF_RCK1					0x1E	//
-#define		RF_RCK2					0x1F	//
+#define		RF_RCK1					0x1E	// 
+#define		RF_RCK2					0x1F	// 
 
-#define		RF_TX_G1					0x20	//
-#define		RF_TX_G2					0x21	//
-#define		RF_TX_G3					0x22	//
+#define		RF_TX_G1					0x20	// 
+#define		RF_TX_G2					0x21	// 
+#define		RF_TX_G3					0x22	// 
 
-#define		RF_TX_BB1					0x23	//
+#define		RF_TX_BB1					0x23	// 
 
-#define		RF_T_METER					0x42	//
+#define		RF_T_METER					0x42	// 
 
 #define		RF_SYN_G1					0x25	// RF TX Power control
 #define		RF_SYN_G2					0x26	// RF TX Power control
@@ -573,7 +573,7 @@
 #define		bXBTxAGC                  			0xf00	// Reg 80c rFPGA0_TxGainStage
 #define		bXCTxAGC                  			0xf000
 #define		bXDTxAGC                  			0xf0000
-
+       		
 #define		bPAStart                  			0xf0000000	// Useless now
 #define		bTRStart                  			0x00f00000
 #define		bRFStart                  			0x0000f000
@@ -619,7 +619,7 @@
 #define		bRFSI_ANTSW               		0x100
 #define		bRFSI_ANTSWB              		0x200
 #define		bRFSI_PAPE                			0x400
-#define		bRFSI_PAPE5G              		0x800
+#define		bRFSI_PAPE5G              		0x800 
 #define		bBandSelect               			0x1
 #define		bHTSIG2_GI                			0x80
 #define		bHTSIG2_Smoothing         		0x01
@@ -645,7 +645,7 @@
 #define		bLSSIReadBackData         		0xfffff		// T65 RF
 
 #define		bLSSIReadOKFlag           		0x1000	// Useless now
-#define		bCCKSampleRate            		0x8       //0: 44MHz, 1:88MHz
+#define		bCCKSampleRate            		0x8       //0: 44MHz, 1:88MHz       		
 #define		bRegulator0Standby        		0x1
 #define		bRegulatorPLLStandby      		0x2
 #define		bRegulator1Standby        		0x4
@@ -690,8 +690,8 @@
 #define		bAD11PowerUpAtTx          		0x1
 #define		bDA10PSAtTx               		0x10
 #define		bAD11PowerUpAtRx          		0x100
-#define		bDA10PSAtRx               		0x1000
-#define		bCCKRxAGCFormat           		0x200
+#define		bDA10PSAtRx               		0x1000       		
+#define		bCCKRxAGCFormat           		0x200       		
 #define		bPSDFFTSamplepPoint       		0xc000
 #define		bPSDAverageNum            		0x3000
 #define		bIQPathControl            		0xc00
@@ -790,9 +790,9 @@
 #define		bCCKRxFACounterLower	0xff
 #define		bCCKRxFACounterUpper	0xff000000
 #define		bCCKRxHPAGCStart		0xe000
-#define		bCCKRxHPAGCFinal		0x1c00
+#define		bCCKRxHPAGCFinal		0x1c00       		
 #define		bCCKRxFalseAlarmEnable	0x8000
-#define		bCCKFACounterFreeze	0x4000
+#define		bCCKFACounterFreeze	0x4000       		
 #define		bCCKTxPathSel			0x10000000
 #define		bCCKDefaultRxPath		0xc000000
 #define		bCCKOptionRxPath		0x3000000
@@ -944,16 +944,16 @@
 #define		bRxSGI_TH				0xc0000000
 #define		bDFSCnt0				0xff
 #define		bDFSCnt1				0xff00
-#define		bDFSFlag				0xf0000
+#define		bDFSFlag				0xf0000       		
 #define		bMFWeightSum			0x300000
-#define		bMinIdxTH				0x7f000000
-#define		bDAFormat				0x40000
-#define		bTxChEmuEnable		0x01000000
+#define		bMinIdxTH				0x7f000000       		
+#define		bDAFormat				0x40000       		
+#define		bTxChEmuEnable		0x01000000       		
 #define		bTRSWIsolation_A		0x7f
 #define		bTRSWIsolation_B		0x7f00
 #define		bTRSWIsolation_C		0x7f0000
-#define		bTRSWIsolation_D		0x7f000000
-#define		bExtLNAGain				0x7c00
+#define		bTRSWIsolation_D		0x7f000000       		
+#define		bExtLNAGain				0x7c00          
 
 // 6. PageE(0xE00)
 #define		bSTBCEn				0x4	// Useless
@@ -990,7 +990,7 @@
 #define		bLongCFOFLength	11
 #define		bTailCFO			0x1fff
 #define		bTailCFOTLength		13
-#define		bTailCFOFLength		12
+#define		bTailCFOFLength		12       		
 #define		bmax_en_pwdB		0xffff
 #define		bCC_power_dB		0xffff0000
 #define		bnoise_pwdB		0xffff
@@ -998,27 +998,27 @@
 #define		bPowerMeasFLength	3
 #define		bRx_HT_BW			0x1
 #define		bRxSC				0x6
-#define		bRx_HT				0x8
+#define		bRx_HT				0x8       		
 #define		bNB_intf_det_on		0x1
 #define		bIntf_win_len_cfg	0x30
-#define		bNB_Intf_TH_cfg		0x1c0
+#define		bNB_Intf_TH_cfg		0x1c0       		
 #define		bRFGain				0x3f
 #define		bTableSel			0x40
-#define		bTRSW				0x80
+#define		bTRSW				0x80       		
 #define		bRxSNR_A			0xff
 #define		bRxSNR_B			0xff00
 #define		bRxSNR_C			0xff0000
 #define		bRxSNR_D			0xff000000
 #define		bSNREVMTLength		8
-#define		bSNREVMFLength		1
+#define		bSNREVMFLength		1       		
 #define		bCSI1st				0xff
 #define		bCSI2nd				0xff00
 #define		bRxEVM1st			0xff0000
-#define		bRxEVM2nd			0xff000000
+#define		bRxEVM2nd			0xff000000       		
 #define		bSIGEVM			0xff
 #define		bPWDB				0xff00
 #define		bSGIEN				0x10000
-
+       		
 #define		bSFactorQAM1		0xf	// Useless
 #define		bSFactorQAM2		0xf0
 #define		bSFactorQAM3		0xf00
@@ -1029,7 +1029,7 @@
 #define		bSFactorQAM8		0xf000000
 #define		bSFactorQAM9		0xf0000000
 #define		bCSIScheme			0x100000
-
+       		
 #define		bNoiseLvlTopSet		0x3	// Useless
 #define		bChSmooth			0x4
 #define		bChSmoothCfg1		0x38
@@ -1038,7 +1038,7 @@
 #define		bChSmoothCfg4		0x7000
 #define		bMRCMode			0x800000
 #define		bTHEVMCfg			0x7000000
-
+       		
 #define		bLoopFitType		0x1	// Useless
 #define		bUpdCFO			0x40
 #define		bUpdCFOOffData		0x80
@@ -1112,7 +1112,7 @@
 #define		bMaskLWord			0x0000ffff
 #define		bMaskDWord		0xffffffff
 #define		bMask12Bits			0xfff
-#define		bMaskH4Bits			0xf0000000
+#define		bMaskH4Bits			0xf0000000	
 #define		bMaskOFDM_D		0xffc00000
 #define		bMaskCCK			0x3f3f3f3f
 
@@ -1120,7 +1120,7 @@
 //#define		bMask12Bits               	0xfffff	// RF Reg mask bits
 //#define		bMask20Bits               	0xfffff	// RF Reg mask bits T65 RF
 #define 		bRFRegOffsetMask		0xfffff
-//#define 		bRFRegOffsetMask		0xfff
+//#define 		bRFRegOffsetMask		0xfff	
 
 //MAC0 will wirte PHY1
 #define	MAC0_ACCESS_PHY1	0x4000
@@ -1129,13 +1129,13 @@
 
 #define		bEnable			0x1	// Useless
 #define		bDisable		0x0
-
+       		
 #define		LeftAntenna		0x0	// Useless
 #define		RightAntenna	0x1
-
+       		
 #define		tCheckTxStatus		500   //500ms // Useless
 #define		tUpdateRxCounter	100   //100ms
-
+       		
 #define		rateCCK		0	// Useless
 #define		rateOFDM	1
 #define		rateHT		2
@@ -1158,7 +1158,7 @@
 #define		bPMACControl		0x0		// Useless
 #define		bWMACControl		0x1
 #define		bWNICControl		0x2
-
+       		
 #define		PathA			0x0	// Useless
 #define		PathB			0x1
 #define		PathC			0x2
@@ -1168,3 +1168,4 @@
 
 
 #endif	//__INC_HAL8192SPHYREG_H
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192DUHWImg.h b/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192DUHWImg.h
old mode 100644
new mode 100755
index 0d225ce..d6c66d9
--- a/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192DUHWImg.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192DUHWImg.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192DUHWImg_wowlan.h b/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192DUHWImg_wowlan.h
old mode 100644
new mode 100755
index b5ab71f..cc27a77
--- a/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192DUHWImg_wowlan.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/Hal8192DUHWImg_wowlan.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -27,3 +27,4 @@
 extern u8 Rtl8192DUFwWWImgArray[DUWWImgArrayLength];
 
 #endif //__INC_HAL8192DU_FW_IMG_WOWLAN_H
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/HalPwrSeqCmd.h b/drivers/net/wireless/realtek/rtl8192cu/include/HalPwrSeqCmd.h
old mode 100644
new mode 100755
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/autoconf.h b/drivers/net/wireless/realtek/rtl8192cu/include/autoconf.h
old mode 100644
new mode 100755
index 001b48f..f62231b
--- a/drivers/net/wireless/realtek/rtl8192cu/include/autoconf.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/autoconf.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -31,11 +31,10 @@
 
 #define PLATFORM_LINUX	1
 
-#define CONFIG_IOCTL_CFG80211 1
+//#define CONFIG_IOCTL_CFG80211 1
 #ifdef CONFIG_IOCTL_CFG80211
-	/* Indicate new sta asoc through cfg80211_new_sta */
-	#define RTW_USE_CFG80211_STA_EVENT
-	/*#define CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER*/
+	//#define RTW_USE_CFG80211_STA_EVENT /* Indecate new sta asoc through cfg80211_new_sta */
+	#define CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER
 	//#define CONFIG_DEBUG_CFG80211 1
 	//#define CONFIG_DRV_ISSUE_PROV_REQ // IOT FOR S2
 	#define CONFIG_SET_SCAN_DENY_TIMER
@@ -68,7 +67,7 @@
 
 //#define CONFIG_TCP_CSUM_OFFLOAD_RX	1
 
-//#define CONFIG_BEFORE_LINKED_DIG
+//#define CONFIG_BEFORE_LINKED_DIG	
 //#define CONFIG_DRVEXT_MODULE	1
 
 #ifndef CONFIG_MP_INCLUDED
@@ -76,7 +75,7 @@
 	#ifdef CONFIG_IPS
 		//#define CONFIG_IPS_LEVEL_2	1 //enable this to set default IPS mode to IPS_LEVEL_2
 	#endif
-
+	
 	#define SUPPORT_HW_RFOFF_DETECTED	1
 
 	#define CONFIG_LPS	1
@@ -84,11 +83,11 @@
 
 	//befor link
 	#define CONFIG_ANTENNA_DIVERSITY
-
+	
 	//after link
 	#ifdef CONFIG_ANTENNA_DIVERSITY
-		#define CONFIG_SW_ANTENNA_DIVERSITY
-		//#define CONFIG_HW_ANTENNA_DIVERSITY
+		#define CONFIG_SW_ANTENNA_DIVERSITY	 
+		//#define CONFIG_HW_ANTENNA_DIVERSITY	
 	#endif
 
 	#define CONFIG_IOL
@@ -101,7 +100,7 @@
 	#define CONFIG_NATIVEAP_MLME	1
 	#ifndef CONFIG_NATIVEAP_MLME
 		#define CONFIG_HOSTAPD_MLME	1
-	#endif
+	#endif			
 	#define CONFIG_FIND_BEST_CHANNEL	1
 	//#define CONFIG_NO_WIRELESS_HANDLERS	1
 #endif
@@ -112,7 +111,7 @@
 	//Added by Albert 20110812
 	//The CONFIG_WFD is for supporting the Wi-Fi display
 	#define CONFIG_WFD
-
+	
 	#ifndef CONFIG_WIFI_TEST
 		#define CONFIG_P2P_REMOVE_GROUP_INFO
 	#endif
@@ -124,10 +123,10 @@
 	#define P2P_OP_CHECK_SOCIAL_CH
 		// Added comment by Borg 2013/06/21
 		// Issue:  Nexus 4 is hard to do miracast.
-		// Root Cause: After group formation,
-		//			Nexus 4 is possible to be not at OP channel of Invitation Resp/Nego Confirm but at social channel.
-		// Patch: While scan OP channel,
-		//		 not only scan OP channel of Invitation Resp/Nego Confirm,
+		// Root Cause: After group formation, 
+		//			Nexus 4 is possible to be not at OP channel of Invitation Resp/Nego Confirm but at social channel. 
+		// Patch: While scan OP channel, 
+		//		 not only scan OP channel of Invitation Resp/Nego Confirm, 
 		//		 but also scan social channel(1, 6, 11)
 #endif
 
@@ -198,7 +197,7 @@
 /*
  * Interface  Related Config
  */
-
+ 
 //#define CONFIG_USB_ONE_OUT_EP
 //#define CONFIG_USB_INTERRUPT_IN_PIPE	1
 
@@ -211,7 +210,7 @@
 //#define CONFIG_REDUCE_USB_TX_INT	1	// Trade-off: Improve performance, but may cause TX URBs blocked by USB Host/Bus driver on few platforms.
 //#define CONFIG_EASY_REPLACEMENT	1
 
-/*
+/* 
  * CONFIG_USE_USB_BUFFER_ALLOC_XX uses Linux USB Buffer alloc API and is for Linux platform only now!
  */
 //#define CONFIG_USE_USB_BUFFER_ALLOC_TX 1	// Trade-off: For TX path, improve stability on some platforms, but may cause performance degrade on other platforms.
@@ -220,7 +219,7 @@
 #undef CONFIG_PREALLOC_RECV_SKB
 #endif
 
-/*
+/* 
  * USB VENDOR REQ BUFFER ALLOCATION METHOD
  * if not set we'll use function local variable (stack memory)
  */
@@ -325,7 +324,7 @@
 
 //#define DBG_MEMORY_LEAK	1
 
-/*#define DBG_CONFIG_ERROR_DETECT*/
+#define DBG_CONFIG_ERROR_DETECT
 //#define DBG_CONFIG_ERROR_RESET
 
 //TX use 1 urb
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/basic_types.h b/drivers/net/wireless/realtek/rtl8192cu/include/basic_types.h
old mode 100644
new mode 100755
index c52fe3a..f76e68f
--- a/drivers/net/wireless/realtek/rtl8192cu/include/basic_types.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/basic_types.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -29,13 +29,13 @@
 #ifndef TRUE
 	#define _TRUE	1
 #else
-	#define _TRUE	TRUE
+	#define _TRUE	TRUE	
 #endif
-
-#ifndef FALSE
+		
+#ifndef FALSE		
 	#define _FALSE	0
 #else
-	#define _FALSE	FALSE
+	#define _FALSE	FALSE	
 #endif
 
 #ifdef PLATFORM_WINDOWS
@@ -48,7 +48,7 @@
 
 	typedef signed long s32;
 	typedef unsigned long u32;
-
+	
 	typedef unsigned int	uint;
 	typedef	signed int		sint;
 
@@ -57,7 +57,7 @@
 	typedef unsigned long long u64;
 
 	#ifdef NDIS50_MINIPORT
-
+	
 		#define NDIS_MAJOR_VERSION       5
 		#define NDIS_MINOR_VERSION       0
 
@@ -96,14 +96,14 @@
         #define UCHAR u8
 	#define USHORT u16
 	#define UINT u32
-	#define ULONG u32
+	#define ULONG u32	
 
 	typedef void (*proc_t)(void*);
 
-	typedef 	__kernel_size_t	SIZE_T;
+	typedef 	__kernel_size_t	SIZE_T;	
 	typedef	__kernel_ssize_t	SSIZE_T;
 	#define FIELD_OFFSET(s,field)	((SSIZE_T)&((s*)(0))->field)
-
+	
 #endif
 
 
@@ -117,7 +117,7 @@
 
 	typedef signed int s32;
 	typedef unsigned int u32;
-
+	
 	typedef unsigned int	uint;
 	typedef	signed int		sint;
 	typedef long atomic_t;
@@ -129,7 +129,7 @@
 	#define VOID void
 	#define NDIS_OID uint
 	#define NDIS_STATUS uint
-
+	
 	#ifndef	PVOID
 	typedef void * PVOID;
 	//#define PVOID	(void *)
@@ -138,17 +138,17 @@
     #define UCHAR u8
 	#define USHORT u16
 	#define UINT u32
-	#define ULONG u32
+	#define ULONG u32	
 
 	typedef void (*proc_t)(void*);
-
+  
   typedef unsigned int __kernel_size_t;
   typedef int __kernel_ssize_t;
-
-	typedef 	__kernel_size_t	SIZE_T;
+  
+	typedef 	__kernel_size_t	SIZE_T;	
 	typedef	__kernel_ssize_t	SSIZE_T;
 	#define FIELD_OFFSET(s,field)	((SSIZE_T)&((s*)(0))->field)
-
+	
 #endif
 
 #define MEM_ALIGNMENT_OFFSET	(sizeof (SIZE_T))
@@ -170,7 +170,7 @@
 //
 // Byte Swapping routine.
 //
-#define EF1Byte
+#define EF1Byte	
 #define EF2Byte 	le16_to_cpu
 #define EF4Byte	le32_to_cpu
 
@@ -186,7 +186,7 @@
 //
 #define WriteEF1Byte(_ptr, _val)	(*((u8 *)(_ptr)))=EF1Byte(_val)
 #define WriteEF2Byte(_ptr, _val)	(*((u16 *)(_ptr)))=EF2Byte(_val)
-#define WriteEF4Byte(_ptr, _val)	(*((u32 *)(_ptr)))=EF4Byte(_val)
+#define WriteEF4Byte(_ptr, _val)	(*((u32 *)(_ptr)))=EF4Byte(_val)									
 
 //
 //	Example:
@@ -203,7 +203,7 @@
 //		BIT_OFFSET_LEN_MASK_32(16, 2) => 0x00030000
 //
 #define BIT_OFFSET_LEN_MASK_32(__BitOffset, __BitLen) \
-	(BIT_LEN_MASK_32(__BitLen) << (__BitOffset))
+	(BIT_LEN_MASK_32(__BitLen) << (__BitOffset)) 
 
 //
 //	Description:
@@ -227,7 +227,7 @@
 
 //
 //	Description:
-//		Mask subfield (continuous bits in little-endian) of 4-byte value in litten byte oredering
+//		Mask subfield (continuous bits in little-endian) of 4-byte value in litten byte oredering  
 //		and return the result in 4-byte value in host byte ordering.
 //
 #define LE_BITS_CLEARED_TO_4BYTE(__pStart, __BitOffset, __BitLen) \
@@ -239,7 +239,7 @@
 
 //
 //	Description:
-//		Set subfield of little-endian 4-byte value to specified value.
+//		Set subfield of little-endian 4-byte value to specified value.	
 //
 #define SET_BITS_TO_LE_4BYTE(__pStart, __BitOffset, __BitLen, __Value) \
 	*((u32 *)(__pStart)) = \
@@ -249,23 +249,23 @@
 			( (((u32)__Value) & BIT_LEN_MASK_32(__BitLen)) << (__BitOffset) ) \
 		);
 
-
+		
 #define BIT_LEN_MASK_16(__BitLen) \
 		(0xFFFF >> (16 - (__BitLen)))
-
+		
 #define BIT_OFFSET_LEN_MASK_16(__BitOffset, __BitLen) \
 	(BIT_LEN_MASK_16(__BitLen) << (__BitOffset))
-
+	
 #define LE_P2BYTE_TO_HOST_2BYTE(__pStart) \
 	(EF2Byte(*((u16 *)(__pStart))))
-
+	
 #define LE_BITS_TO_2BYTE(__pStart, __BitOffset, __BitLen) \
 	( \
 		( LE_P2BYTE_TO_HOST_2BYTE(__pStart) >> (__BitOffset) ) \
 		& \
 		BIT_LEN_MASK_16(__BitLen) \
 	)
-
+	
 #define LE_BITS_CLEARED_TO_2BYTE(__pStart, __BitOffset, __BitLen) \
 	( \
 		LE_P2BYTE_TO_HOST_2BYTE(__pStart) \
@@ -280,7 +280,7 @@
 			| \
 			( (((u16)__Value) & BIT_LEN_MASK_16(__BitLen)) << (__BitOffset) ) \
 		);
-
+			
 #define BIT_LEN_MASK_8(__BitLen) \
 		(0xFF >> (8 - (__BitLen)))
 
@@ -318,3 +318,4 @@
 typedef unsigned char	BOOLEAN,*PBOOLEAN;
 
 #endif //__BASIC_TYPES_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/byteorder/big_endian.h b/drivers/net/wireless/realtek/rtl8192cu/include/byteorder/big_endian.h
old mode 100644
new mode 100755
index 0cd3504..eca68a6
--- a/drivers/net/wireless/realtek/rtl8192cu/include/byteorder/big_endian.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/byteorder/big_endian.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/byteorder/generic.h b/drivers/net/wireless/realtek/rtl8192cu/include/byteorder/generic.h
old mode 100644
new mode 100755
index 11676a6..7c8d4d7
--- a/drivers/net/wireless/realtek/rtl8192cu/include/byteorder/generic.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/byteorder/generic.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/byteorder/little_endian.h b/drivers/net/wireless/realtek/rtl8192cu/include/byteorder/little_endian.h
old mode 100644
new mode 100755
index 9f77fb4..433045e
--- a/drivers/net/wireless/realtek/rtl8192cu/include/byteorder/little_endian.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/byteorder/little_endian.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/byteorder/swab.h b/drivers/net/wireless/realtek/rtl8192cu/include/byteorder/swab.h
old mode 100644
new mode 100755
index 1cf2821..a3ca9ea
--- a/drivers/net/wireless/realtek/rtl8192cu/include/byteorder/swab.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/byteorder/swab.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -34,15 +34,15 @@
 #endif
 
 #ifndef __u64
-typedef unsigned long long	__u64;
+typedef unsigned long long	__u64;	
 #endif
 
 
 __inline static __u16  ___swab16(__u16 x)
 {
-	__u16 __x = x;
-	return
-	((__u16)(
+	__u16 __x = x; 
+	return 
+	((__u16)( 
 		(((__u16)(__x) & (__u16)0x00ffU) << 8) |
 		(((__u16)(__x) & (__u16)0xff00U) >> 8) ));
 
@@ -61,8 +61,8 @@ __inline static __u32  ___swab32(__u32 x)
 __inline static __u64  ___swab64(__u64 x)
 {
 	__u64 __x = (x);
-
-	return
+	
+	return 
 	((__u64)( \
 		(__u64)(((__u64)(__x) & (__u64)0x00000000000000ffULL) << 56) | \
 		(__u64)(((__u64)(__x) & (__u64)0x000000000000ff00ULL) << 40) | \
@@ -86,7 +86,7 @@ __inline static __u16 __arch__swab16(__u16 x)
 #ifndef __arch__swab32
 __inline static __u32 __arch__swab32(__u32 x)
 {
-	__u32 __tmp = (x) ;
+	__u32 __tmp = (x) ; 
 	return ___swab32(__tmp);
 }
 #endif
@@ -95,7 +95,7 @@ __inline static __u32 __arch__swab32(__u32 x)
 
 __inline static __u64 __arch__swab64(__u64 x)
 {
-	__u64 __tmp = (x) ;
+	__u64 __tmp = (x) ; 
 	return ___swab64(__tmp);
 }
 
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/byteorder/swabb.h b/drivers/net/wireless/realtek/rtl8192cu/include/byteorder/swabb.h
old mode 100644
new mode 100755
index cf0fad6..7e2a118
--- a/drivers/net/wireless/realtek/rtl8192cu/include/byteorder/swabb.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/byteorder/swabb.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/circ_buf.h b/drivers/net/wireless/realtek/rtl8192cu/include/circ_buf.h
old mode 100644
new mode 100755
index 236fbe6..1bd4704
--- a/drivers/net/wireless/realtek/rtl8192cu/include/circ_buf.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/circ_buf.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/cmd_osdep.h b/drivers/net/wireless/realtek/rtl8192cu/include/cmd_osdep.h
old mode 100644
new mode 100755
index c4903f4..077efa7
--- a/drivers/net/wireless/realtek/rtl8192cu/include/cmd_osdep.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/cmd_osdep.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -33,3 +33,4 @@
 extern struct	cmd_obj	*_rtw_dequeue_cmd(_queue *queue);
 
 #endif
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/drv_conf.h b/drivers/net/wireless/realtek/rtl8192cu/include/drv_conf.h
old mode 100644
new mode 100755
index 370a121..1317687
--- a/drivers/net/wireless/realtek/rtl8192cu/include/drv_conf.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/drv_conf.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -62,7 +62,7 @@
 #endif
 
 //About USB VENDOR REQ
-#if defined(CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC) && !defined(CONFIG_USB_VENDOR_REQ_MUTEX)
+#if defined(CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC) && !defined(CONFIG_USB_VENDOR_REQ_MUTEX) 
 	#warning "define CONFIG_USB_VENDOR_REQ_MUTEX for CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC automatically"
 	#define CONFIG_USB_VENDOR_REQ_MUTEX
 #endif
@@ -75,3 +75,4 @@
 //#include <rtl871x_byteorder.h>
 
 #endif // __DRV_CONF_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/drv_types.h b/drivers/net/wireless/realtek/rtl8192cu/include/drv_types.h
old mode 100644
new mode 100755
index 46ab663..0ac34f2
--- a/drivers/net/wireless/realtek/rtl8192cu/include/drv_types.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/drv_types.h
@@ -98,7 +98,7 @@ enum{
 #endif	// CONFIG_BR_EXT
 
 #ifdef CONFIG_IOCTL_CFG80211
-	#include "ioctl_cfg80211.h"
+	#include "ioctl_cfg80211.h"	
 #endif //CONFIG_IOCTL_CFG80211
 
 #define SPEC_DEV_ID_NONE BIT(0)
@@ -239,8 +239,8 @@ struct registry_priv
 enum _IFACE_ID {
 	IFACE_ID0, //maping to PRIMARY_ADAPTER
 	IFACE_ID1, //maping to SECONDARY_ADAPTER
-	IFACE_ID2,
-	IFACE_ID3,
+	IFACE_ID2, 
+	IFACE_ID3, 
 	IFACE_ID_MAX,
 };
 
@@ -264,7 +264,7 @@ struct dvobj_priv
 
 	//extend to support mulitu interface
 	//padapters[IFACE_ID0] == if1
-	//padapters[IFACE_ID1] == if2
+	//padapters[IFACE_ID1] == if2	
 	_adapter *padapters[IFACE_ID_MAX];
 	u8 iface_nums; // total number of ifaces used runtime
 
@@ -408,7 +408,7 @@ enum _IFACE_TYPE {
 enum _ADAPTER_TYPE {
 	PRIMARY_ADAPTER,
 	SECONDARY_ADAPTER,
-	MAX_ADAPTER = 0xFF,
+	MAX_ADAPTER = 0xFF,	
 };
 
 typedef enum _DRIVER_STATE{
@@ -417,7 +417,7 @@ enum _ADAPTER_TYPE {
 	DRIVER_REPLACE_DONGLE = 2,
 }DRIVER_STATE;
 
-#ifdef CONFIG_INTEL_PROXIM
+#ifdef CONFIG_INTEL_PROXIM	
 struct proxim {
 	bool proxim_support;
 	bool proxim_on;
@@ -466,7 +466,7 @@ struct _ADAPTER{
 	struct	sta_priv	stapriv;
 	struct	security_priv	securitypriv;
 	_lock   security_key_mutex; // add for CONFIG_IEEE80211W, none 11w also can use
-	struct	registry_priv	registrypriv;
+	struct	registry_priv	registrypriv;	
 	struct	pwrctrl_priv	pwrctrlpriv;
 	struct 	eeprom_priv eeprompriv;
 	struct	led_priv	ledpriv;
@@ -600,20 +600,20 @@ struct _ADAPTER{
 	//and their pbuddy_adapter is PRIMARY_ADAPTER.
 	//for PRIMARY_ADAPTER(IFACE_ID0) can directly refer to if1 in struct dvobj_priv
 	_adapter *pbuddy_adapter;
-
+	
 #if defined(CONFIG_CONCURRENT_MODE) || defined(CONFIG_DUALMAC_CONCURRENT)
 	u8 isprimary; //is primary adapter or not
-	//notes:
+	//notes: 
 	// if isprimary is true, the adapter_type value is 0, iface_id is IFACE_ID0 for PRIMARY_ADAPTER
 	// if isprimary is false, the adapter_type value is 1, iface_id is IFACE_ID1 for SECONDARY_ADAPTER
 	// refer to iface_id if iface_nums>2 and isprimary is false and the adapter_type value is 0xff.
-	u8 adapter_type;//used only in  two inteface case(PRIMARY_ADAPTER and SECONDARY_ADAPTER) .
-	u8 iface_type; //interface port type, it depends on HW port
+	u8 adapter_type;//used only in  two inteface case(PRIMARY_ADAPTER and SECONDARY_ADAPTER) . 
+	u8 iface_type; //interface port type, it depends on HW port 
 #endif
 
 	//extend to support multi interface
        //IFACE_ID0 is equals to PRIMARY_ADAPTER
-       //IFACE_ID1 is equals to SECONDARY_ADAPTER
+       //IFACE_ID1 is equals to SECONDARY_ADAPTER	
 	u8 iface_id;
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
@@ -635,9 +635,9 @@ struct _ADAPTER{
 	struct br_ext_info		ethBrExtInfo;
 #endif	// CONFIG_BR_EXT
 
-#ifdef CONFIG_INTEL_PROXIM
+#ifdef CONFIG_INTEL_PROXIM	
 	/* intel Proximity, should be alloc mem
-	 * in intel Proximity module and can only
+	 * in intel Proximity module and can only 
 	 * be used in intel Proximity mode */
 	struct proxim proximity;
 #endif	//CONFIG_INTEL_PROXIM
@@ -659,3 +659,4 @@ __inline static u8 *myid(struct eeprom_priv *peepriv)
 
 
 #endif //__DRV_TYPES_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/drv_types_ce.h b/drivers/net/wireless/realtek/rtl8192cu/include/drv_types_ce.h
old mode 100644
new mode 100755
index 25794fd..be0459d
--- a/drivers/net/wireless/realtek/rtl8192cu/include/drv_types_ce.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/drv_types_ce.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -49,7 +49,7 @@
 	u8			Type;		// NdisParameterInteger/NdisParameterHexInteger/NdisParameterStringle/NdisParameterMultiString
 	uint			FieldOffset;	// offset to MP_ADAPTER field
 	uint			FieldSize;	// size (in bytes) of the field
-
+	
 #ifdef UNDER_AMD64
 	u64			Default;
 #else
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/drv_types_linux.h b/drivers/net/wireless/realtek/rtl8192cu/include/drv_types_linux.h
old mode 100644
new mode 100755
index 812b744..db1c585
--- a/drivers/net/wireless/realtek/rtl8192cu/include/drv_types_linux.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/drv_types_linux.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -22,3 +22,4 @@
 
 
 #endif
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/drv_types_sdio.h b/drivers/net/wireless/realtek/rtl8192cu/include/drv_types_sdio.h
old mode 100644
new mode 100755
index c445712..fd467ca
--- a/drivers/net/wireless/realtek/rtl8192cu/include/drv_types_sdio.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/drv_types_sdio.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -39,7 +39,7 @@
 typedef struct sdio_data
 {
 	u8  func_number;
-
+ 
 	u8  tx_block_mode;
 	u8  rx_block_mode;
 	u32 block_transfer_len;
@@ -67,3 +67,4 @@
 } SDIO_DATA, *PSDIO_DATA;
 
 #endif
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/drv_types_xp.h b/drivers/net/wireless/realtek/rtl8192cu/include/drv_types_xp.h
old mode 100644
new mode 100755
index 1d735d6..2d51b1d
--- a/drivers/net/wireless/realtek/rtl8192cu/include/drv_types_xp.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/drv_types_xp.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -70,7 +70,7 @@
 	u8			Type;		// NdisParameterInteger/NdisParameterHexInteger/NdisParameterStringle/NdisParameterMultiString
 	uint			FieldOffset;	// offset to MP_ADAPTER field
 	uint			FieldSize;	// size (in bytes) of the field
-
+	
 #ifdef UNDER_AMD64
 	u64			Default;
 #else
@@ -92,3 +92,4 @@
 
 
 #endif
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/ethernet.h b/drivers/net/wireless/realtek/rtl8192cu/include/ethernet.h
old mode 100644
new mode 100755
index e22c12b..36e29c0
--- a/drivers/net/wireless/realtek/rtl8192cu/include/ethernet.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/ethernet.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -17,7 +17,7 @@
  *
  *
  ******************************************************************************/
-/*! \file */
+/*! \file */ 
 #ifndef __INC_ETHERNET_H
 #define __INC_ETHERNET_H
 
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/h2clbk.h b/drivers/net/wireless/realtek/rtl8192cu/include/h2clbk.h
old mode 100644
new mode 100755
index 847356e..359c9e7
--- a/drivers/net/wireless/realtek/rtl8192cu/include/h2clbk.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/h2clbk.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/hal_com.h b/drivers/net/wireless/realtek/rtl8192cu/include/hal_com.h
old mode 100644
new mode 100755
index 382f124..42aae0e
--- a/drivers/net/wireless/realtek/rtl8192cu/include/hal_com.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/hal_com.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -25,7 +25,7 @@
 #define RATE_2M						BIT(1)
 #define RATE_5_5M					BIT(2)
 #define RATE_11M					BIT(3)
-//OFDM
+//OFDM 
 #define RATE_6M						BIT(4)
 #define RATE_9M						BIT(5)
 #define RATE_12M					BIT(6)
@@ -54,15 +54,15 @@
 #define RATE_MCS15					BIT(27)
 
 // ALL CCK Rate
-#define	RATE_ALL_CCK				RATR_1M|RATR_2M|RATR_55M|RATR_11M
+#define	RATE_ALL_CCK				RATR_1M|RATR_2M|RATR_55M|RATR_11M 
 #define	RATE_ALL_OFDM_AG			RATR_6M|RATR_9M|RATR_12M|RATR_18M|RATR_24M|\
-									RATR_36M|RATR_48M|RATR_54M
+									RATR_36M|RATR_48M|RATR_54M	
 #define	RATE_ALL_OFDM_1SS			RATR_MCS0|RATR_MCS1|RATR_MCS2|RATR_MCS3 |\
-									RATR_MCS4|RATR_MCS5|RATR_MCS6	|RATR_MCS7
+									RATR_MCS4|RATR_MCS5|RATR_MCS6	|RATR_MCS7	
 #define	RATE_ALL_OFDM_2SS			RATR_MCS8|RATR_MCS9	|RATR_MCS10|RATR_MCS11|\
 									RATR_MCS12|RATR_MCS13|RATR_MCS14|RATR_MCS15
 
-/*------------------------------ Tx Desc definition Macro ------------------------*/
+/*------------------------------ Tx Desc definition Macro ------------------------*/ 
 //#pragma mark -- Tx Desc related definition. --
 //----------------------------------------------------------------------------
 //-----------------------------------------------------------
@@ -143,3 +143,4 @@ void	HalSetBrateCfg(
 s32 c2h_evt_read(_adapter *adapter, u8 *buf);
 
 #endif //__HAL_COMMON_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/hal_intf.h b/drivers/net/wireless/realtek/rtl8192cu/include/hal_intf.h
old mode 100644
new mode 100755
index cac4408..dd82662
--- a/drivers/net/wireless/realtek/rtl8192cu/include/hal_intf.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/hal_intf.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -43,7 +43,7 @@ enum _CHIP_TYPE {
 	RTL8188C_8192C,
 	RTL8192D,
 	RTL8723A,
-	RTL8188E,
+	RTL8188E,	
 	MAX_CHIP_TYPE
 };
 
@@ -98,11 +98,11 @@ enum _CHIP_TYPE {
 	HW_VAR_TDLS_WRCR,
 	HW_VAR_TDLS_INIT_CH_SEN,
 	HW_VAR_TDLS_RS_RCR,
-	HW_VAR_TDLS_DONE_CH_SEN,
+	HW_VAR_TDLS_DONE_CH_SEN,	
 	HW_VAR_INITIAL_GAIN,
 	HW_VAR_TRIGGER_GPIO_0,
 	HW_VAR_BT_SET_COEXIST,
-	HW_VAR_BT_ISSUE_DELBA,
+	HW_VAR_BT_ISSUE_DELBA,	
 	HW_VAR_CURRENT_ANTENNA,
 	HW_VAR_ANTENNA_DIVERSITY_LINK,
 	HW_VAR_ANTENNA_DIVERSITY_SELECT,
@@ -212,10 +212,10 @@ struct hal_ops {
 	int 	(*Efuse_PgPacketRead)(PADAPTER pAdapter, u8 offset, u8 *data, BOOLEAN bPseudoTest);
 	int 	(*Efuse_PgPacketWrite)(PADAPTER pAdapter, u8 offset, u8 word_en, u8 *data, BOOLEAN bPseudoTest);
 	u8	(*Efuse_WordEnableDataWrite)(PADAPTER pAdapter, u16 efuse_addr, u8 word_en, u8 *data, BOOLEAN bPseudoTest);
-
+	
 #ifdef DBG_CONFIG_ERROR_DETECT
 	void (*sreset_init_value)(_adapter *padapter);
-	void (*sreset_reset_value)(_adapter *padapter);
+	void (*sreset_reset_value)(_adapter *padapter);		
 	void (*silentreset)(_adapter *padapter);
 	void (*sreset_xmit_status_check)(_adapter *padapter);
 	void (*sreset_linked_status_check) (_adapter *padapter);
@@ -429,3 +429,4 @@ struct wowlan_ioctl_param{
 c2h_id_filter rtw_hal_c2h_id_filter_ccx(_adapter *adapter);
 
 #endif //__HAL_INTF_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/ieee80211.h b/drivers/net/wireless/realtek/rtl8192cu/include/ieee80211.h
old mode 100644
new mode 100755
index b3735bd..e283a5f
--- a/drivers/net/wireless/realtek/rtl8192cu/include/ieee80211.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/ieee80211.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -35,7 +35,7 @@
 	#include <linux/wireless.h>
 	#endif
 #else
-
+	
 	#include <list.h>
 
 #endif
@@ -183,8 +183,8 @@ enum NETWORK_TYPE
     WIRELESS_11A = BIT(2), // tx: ofdm only, rx: ofdm only, hw: ofdm only
     WIRELESS_11_24N = BIT(3), // tx: MCS only, rx: MCS & cck, hw: MCS & cck
     WIRELESS_11_5N = BIT(4), // tx: MCS only, rx: MCS & ofdm, hw: ofdm only
-	//WIRELESS_AUTO 	= BIT(5),
-	WIRELESS_AC 		= BIT(6),
+	//WIRELESS_AUTO 	= BIT(5), 
+	WIRELESS_AC 		= BIT(6), 
 
     //Combination
     WIRELESS_11BG = (WIRELESS_11B|WIRELESS_11G), // tx: cck & ofdm, rx: cck & ofdm & MCS, hw: cck & ofdm
@@ -210,7 +210,7 @@ enum NETWORK_TYPE
 
 #define IsSupportedTxCCK(NetType) ((NetType) & (WIRELESS_11B) ? _TRUE : _FALSE)
 #define IsSupportedTxOFDM(NetType) ((NetType) & (WIRELESS_11G|WIRELESS_11A) ? _TRUE : _FALSE)
-#define IsSupportedTxMCS(NetType) ((NetType) & (WIRELESS_11_24N|WIRELESS_11_5N) ? _TRUE : _FALSE)
+#define IsSupportedTxMCS(NetType) ((NetType) & (WIRELESS_11_24N|WIRELESS_11_5N) ? _TRUE : _FALSE) 
 
 
 typedef struct ieee_param {
@@ -228,7 +228,7 @@ enum NETWORK_TYPE
 		} wpa_ie;
 	        struct{
 			int command;
-			int reason_code;
+    			int reason_code;
 		} mlme;
 		struct {
 			u8 alg[IEEE_CRYPT_ALG_NAME_LEN];
@@ -244,7 +244,7 @@ enum NETWORK_TYPE
 			u16 aid;
 			u16 capability;
 			int flags;
-			u8 tx_supp_rates[16];
+			u8 tx_supp_rates[16];		
 			struct rtw_ieee80211_ht_cap ht_cap;
 		} add_sta;
 		struct {
@@ -253,7 +253,7 @@ enum NETWORK_TYPE
 		} bcn_ie;
 #endif
 
-	} u;
+	} u;	   
 }ieee_param;
 
 #ifdef CONFIG_AP_MODE
@@ -268,7 +268,7 @@ struct sta_data{
 	u16 capability;
 	int flags;
 	u32 sta_set;
-	u8 tx_supp_rates[16];
+	u8 tx_supp_rates[16];	
 	u32 tx_supp_rates_len;
 	struct rtw_ieee80211_ht_cap ht_cap;
 	u64	rx_pkts;
@@ -315,7 +315,7 @@ struct ieee_ibss_seq {
 	_list	list;
 };
 
-#if defined(PLATFORM_LINUX) || defined(CONFIG_RTL8711FW)||defined(PLATFORM_FREEBSD)
+#if defined(PLATFORM_LINUX) || defined(CONFIG_RTL8711FW)||defined(PLATFORM_FREEBSD) 
 
 struct rtw_ieee80211_hdr {
 	u16 frame_ctl;
@@ -1110,9 +1110,9 @@ struct ieee80211_network {
 	u8 rates_len;
 	u8 rates_ex[MAX_RATES_EX_LENGTH];
 	u8 rates_ex_len;
-
+	
 	u8 edca_parmsets[18];
-
+		
 	u8 mode;
 	u8 flags;
 	u8 time_stamp[8];
@@ -1131,7 +1131,7 @@ struct ieee80211_network {
 	u8 qbssload[5];
 	u8 network_type;
 	int join_res;
-	unsigned long	last_scanned;
+	unsigned long	last_scanned;	
 };
 #endif
 /*
@@ -1147,7 +1147,7 @@ enum ieee80211_state {
 
 	/* the card is not linked at all */
 	IEEE80211_NOLINK = 0,
-
+	
 	/* IEEE80211_ASSOCIATING* are for BSS client mode
 	 * the driver shall not perform RX filtering unless
 	 * the state is LINKED.
@@ -1155,31 +1155,31 @@ enum ieee80211_state {
 	 * defaults to NOLINK for ALL the other states (including
 	 * LINKED_SCANNING)
 	 */
-
+	
 	/* the association procedure will start (wq scheduling)*/
 	IEEE80211_ASSOCIATING,
 	IEEE80211_ASSOCIATING_RETRY,
-
+	
 	/* the association procedure is sending AUTH request*/
 	IEEE80211_ASSOCIATING_AUTHENTICATING,
-
+	
 	/* the association procedure has successfully authentcated
 	 * and is sending association request
 	 */
 	IEEE80211_ASSOCIATING_AUTHENTICATED,
-
+	
 	/* the link is ok. the card associated to a BSS or linked
 	 * to a ibss cell or acting as an AP and creating the bss
 	 */
 	IEEE80211_LINKED,
-
+	
 	/* same as LINKED, but the driver shall apply RX filter
 	 * rules as we are in NO_LINK mode. As the card is still
 	 * logically linked, but it is doing a syncro site survey
 	 * then it will be back to LINKED state.
 	 */
 	IEEE80211_LINKED_SCANNING,
-
+	
 };
 #endif //PLATFORM_FREEBSD
 
@@ -1392,7 +1392,7 @@ enum rtw_ieee80211_back_parties {
           RTW_IEEE80211_CHAN_NO_HT40PLUS      = 1<<4,
           RTW_IEEE80211_CHAN_NO_HT40MINUS     = 1<<5,
   };
-
+  
   #define RTW_IEEE80211_CHAN_NO_HT40 \
           (RTW_IEEE80211_CHAN_NO_HT40PLUS | RTW_IEEE80211_CHAN_NO_HT40MINUS)
 
@@ -1409,7 +1409,7 @@ struct rtw_ieee80211_channel {
 	//u32 orig_flags;
 	//int orig_mag;
 	//int orig_mpwr;
-};
+}; 
 
 #define CHAN_FMT \
 	/*"band:%d, "*/ \
@@ -1422,7 +1422,7 @@ struct rtw_ieee80211_channel {
 	/*"beacon_found:%u\n"*/ \
 	/*"orig_flags:0x%08x\n"*/ \
 	/*"orig_mag:%d\n"*/ \
-	/*"orig_mpwr:%d\n"*/
+	/*"orig_mpwr:%d\n"*/ 
 
 #define CHAN_ARG(channel) \
 	/*(channel)->band*/ \
@@ -1577,3 +1577,4 @@ enum secondary_ch_offset {
 const char *action_public_str(u8 action);
 
 #endif /* IEEE80211_H */
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/ieee80211_ext.h b/drivers/net/wireless/realtek/rtl8192cu/include/ieee80211_ext.h
old mode 100644
new mode 100755
index eba9001..3e55305
--- a/drivers/net/wireless/realtek/rtl8192cu/include/ieee80211_ext.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/ieee80211_ext.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -67,22 +67,22 @@ struct wme_ac_parameter {
 	/* byte 1 */
 	u8 	aifsn:4,
 		acm:1,
-		aci:2,
-		reserved:1;
+	 	aci:2,
+	 	reserved:1;
 
 	/* byte 2 */
 	u8 	eCWmin:4,
-		eCWmax:4;
+	 	eCWmax:4;
 #elif defined(CONFIG_BIG_ENDIAN)
 	/* byte 1 */
 	u8 	reserved:1,
-		aci:2,
-		acm:1,
-		aifsn:4;
+	 	aci:2,
+	 	acm:1,
+	 	aifsn:4;
 
 	/* byte 2 */
 	u8 	eCWmax:4,
-		eCWmin:4;
+	 	eCWmin:4;
 #else
 #error	"Please fix <endian.h>"
 #endif
@@ -376,7 +376,7 @@ struct ieee80211_mgmt {
 		struct {
 			u16 reason_code;
 		}  disassoc;
-#if 0
+#if 0		
 		struct {
 			__le64 timestamp;
 			u16 beacon_int;
@@ -389,7 +389,7 @@ struct ieee80211_mgmt {
 			/* only variable items: SSID, Supported rates */
 			u8 variable[0];
 		}  probe_req;
-
+		
 		struct {
 			__le64 timestamp;
 			u16 beacon_int;
@@ -398,7 +398,7 @@ struct ieee80211_mgmt {
 			 * FH Params, DS Params, CF Params, IBSS Params */
 			u8 variable[0];
 		}  probe_resp;
-#endif
+#endif	
 		struct {
 			u8 category;
 			union {
@@ -408,7 +408,7 @@ struct ieee80211_mgmt {
 					u8 status_code;
 					u8 variable[0];
 				}  wme_action;
-/*
+/*				
 				struct{
 					u8 action_code;
 					u8 element_id;
@@ -422,7 +422,7 @@ struct ieee80211_mgmt {
 					u8 length;
 					struct ieee80211_msrment_ie msr_elem;
 				}  measurement;
-*/
+*/				
 				struct{
 					u8 action_code;
 					u8 dialog_token;
@@ -474,3 +474,4 @@ struct ieee80211_mgmt {
 
 
 #endif
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/if_ether.h b/drivers/net/wireless/realtek/rtl8192cu/include/if_ether.h
old mode 100644
new mode 100755
index c81c536..9e36d7f
--- a/drivers/net/wireless/realtek/rtl8192cu/include/if_ether.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/if_ether.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -17,13 +17,13 @@
  *
  *
  ******************************************************************************/
-
+ 
 #ifndef _LINUX_IF_ETHER_H
 #define _LINUX_IF_ETHER_H
 
 /*
  *	IEEE 802.3 Ethernet magic constants.  The frame sizes omit the preamble
- *	and FCS/CRC (frame check sequence).
+ *	and FCS/CRC (frame check sequence). 
  */
 
 #define ETH_ALEN	6		/* Octets in one ethernet addr	 */
@@ -69,7 +69,7 @@
 /*
  *	Non DIX types. Won't clash for 1500 types.
  */
-
+ 
 #define ETH_P_802_3	0x0001		/* Dummy type for 802.3 frames  */
 #define ETH_P_AX25	0x0002		/* Dummy protocol id for AX.25  */
 #define ETH_P_ALL	0x0003		/* Every packet (be careful!!!) */
@@ -89,8 +89,8 @@
 /*
  *	This is an Ethernet frame header.
  */
-
-struct ethhdr
+ 
+struct ethhdr 
 {
 	unsigned char	h_dest[ETH_ALEN];	/* destination eth addr	*/
 	unsigned char	h_source[ETH_ALEN];	/* source ether addr	*/
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/ioctl_cfg80211.h b/drivers/net/wireless/realtek/rtl8192cu/include/ioctl_cfg80211.h
old mode 100644
new mode 100755
index 6102527..ceb0db8
--- a/drivers/net/wireless/realtek/rtl8192cu/include/ioctl_cfg80211.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/ioctl_cfg80211.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -18,7 +18,7 @@
  *
  ******************************************************************************/
 #ifndef __IOCTL_CFG80211_H__
-#define __IOCTL_CFG80211_H__
+#define __IOCTL_CFG80211_H__ 
 
 #if defined(CONFIG_IOCTL_CFG80211) && !defined(CONFIG_CFG80211) && !defined(CONFIG_CFG80211_MODULE)
 	#error "Can't define CONFIG_IOCTL_CFG80211 because neither CONFIG_CFG80211 nor CONFIG_CFG80211_MODULE is defined in kernel"
@@ -84,9 +84,9 @@ struct rtw_wdev_nego_info {
 	} while (0)
 
 struct rtw_wdev_priv
-{
+{	
 	struct wireless_dev *rtw_wdev;
-
+	
 	_adapter *padapter;
 
 	struct cfg80211_scan_request *scan_request;
@@ -108,9 +108,9 @@ struct rtw_wdev_priv
 
 #ifdef CONFIG_CONCURRENT_MODE
 	ATOMIC_T ro_ch_to;
-	ATOMIC_T switch_ch_to;
-#endif
-
+	ATOMIC_T switch_ch_to;	
+#endif	
+	
 };
 
 #define wdev_to_priv(w) ((struct rtw_wdev_priv *)(wdev_priv(w)))
@@ -149,15 +149,8 @@ struct rtw_wdev_priv
 #define rtw_cfg80211_rx_mgmt(adapter, freq, sig_dbm, buf, len, gfp) cfg80211_rx_mgmt((adapter)->pnetdev, freq, buf, len, gfp)
 #elif (LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0))
 #define rtw_cfg80211_rx_mgmt(adapter, freq, sig_dbm, buf, len, gfp) cfg80211_rx_mgmt((adapter)->pnetdev, freq, sig_dbm, buf, len, gfp)
-#elif (LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0))
-#define rtw_cfg80211_rx_mgmt(adapter, freq, sig_dbm, buf, len, gfp) cfg80211_rx_mgmt((adapter)->rtw_wdev, freq, sig_dbm, buf, len, gfp)
-#elif (LINUX_VERSION_CODE < KERNEL_VERSION(3,18,0))
-/* 3.12 added a flags argument which is just set to zero*/
-#define rtw_cfg80211_rx_mgmt(adapter, freq, sig_dbm, buf, len, gfp) \
-	cfg80211_rx_mgmt((adapter)->rtw_wdev, freq, sig_dbm, buf, len, 0, gfp)
 #else
-#define rtw_cfg80211_rx_mgmt(adapter, freq, sig_dbm, buf, len, gfp) \
-	cfg80211_rx_mgmt((adapter)->rtw_wdev, freq, sig_dbm, buf, len, 0)
+#define rtw_cfg80211_rx_mgmt(adapter, freq, sig_dbm, buf, len, gfp) cfg80211_rx_mgmt((adapter)->rtw_wdev, freq, sig_dbm, buf, len, gfp)
 #endif
 
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0))  && !defined(COMPAT_KERNEL_RELEASE)
@@ -184,3 +177,4 @@ struct rtw_wdev_priv
 #endif
 
 #endif //__IOCTL_CFG80211_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/ip.h b/drivers/net/wireless/realtek/rtl8192cu/include/ip.h
old mode 100644
new mode 100755
index 2c3d2f3..d7f723d
--- a/drivers/net/wireless/realtek/rtl8192cu/include/ip.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/ip.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -103,7 +103,7 @@ struct ip_options {
                 is_data:1,			/* Options in __data, rather than skb	*/
                 is_strictroute:1,		/* Strict source route			*/
                 srr_is_hit:1,			/* Packet destination addr was our one	*/
-                is_changed:1,			/* IP checksum more not valid		*/
+                is_changed:1,			/* IP checksum more not valid		*/	
                 rr_needaddr:1,			/* Need to record addr of outgoing dev	*/
                 ts_needtime:1,			/* Need to record timestamp		*/
                 ts_needaddr:1;			/* Need to record addr of outgoing dev  */
@@ -122,7 +122,7 @@ struct iphdr {
 		version:4;
 #elif defined (__BIG_ENDIAN_BITFIELD)
 	__u8	version:4,
-		ihl:4;
+  		ihl:4;
 #else
 #error	"Please fix <asm/byteorder.h>"
 #endif
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/linux/wireless.h b/drivers/net/wireless/realtek/rtl8192cu/include/linux/wireless.h
old mode 100644
new mode 100755
index 036fc32..24a22d6
--- a/drivers/net/wireless/realtek/rtl8192cu/include/linux/wireless.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/linux/wireless.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -51,7 +51,7 @@ struct	iw_point
 
 /* ------------------------ IOCTL REQUEST ------------------------ */
 /*
- * This structure defines the payload of an ioctl, and is used
+ * This structure defines the payload of an ioctl, and is used 
  * below.
  *
  * Note that this structure should fit on the memory footprint
@@ -76,7 +76,7 @@ struct	iw_point
  * convenience...
  * Do I need to remind you about structure size (32 octets) ?
  */
-struct	iwreq
+struct	iwreq 
 {
 	union
 	{
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/mlme_osdep.h b/drivers/net/wireless/realtek/rtl8192cu/include/mlme_osdep.h
old mode 100644
new mode 100755
index 383fc38..75754db
--- a/drivers/net/wireless/realtek/rtl8192cu/include/mlme_osdep.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/mlme_osdep.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -37,3 +37,4 @@
 void rtw_reset_securitypriv( _adapter *adapter );
 
 #endif	//_MLME_OSDEP_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/mp_custom_oid.h b/drivers/net/wireless/realtek/rtl8192cu/include/mp_custom_oid.h
old mode 100644
new mode 100755
index 9c9c69b..5f86738
--- a/drivers/net/wireless/realtek/rtl8192cu/include/mp_custom_oid.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/mp_custom_oid.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -71,7 +71,7 @@
 #define OID_RT_PRO_READ_EEPROM				0xFF818022
 #define OID_RT_PRO_RESET_TX_PACKET_SENT			0xFF818023
 #define OID_RT_PRO_QUERY_TX_PACKET_SENT			0xFF818024
-#define OID_RT_PRO_RESET_RX_PACKET_RECEIVED		0xFF818025
+#define OID_RT_PRO_RESET_RX_PACKET_RECEIVED		0xFF818025 
 #define OID_RT_PRO_QUERY_RX_PACKET_RECEIVED		0xFF818026
 #define OID_RT_PRO_QUERY_RX_PACKET_CRC32_ERROR		0xFF818027
 #define OID_RT_PRO_QUERY_CURRENT_ADDRESS		0xFF818028
@@ -84,7 +84,7 @@
 #define OID_RT_PRO_SET_MODULATION			0xFF81802F
 //
 
-//Sean
+//Sean		
 #define OID_RT_DRIVER_OPTION				0xFF818080
 #define OID_RT_RF_OFF					0xFF818081
 #define OID_RT_AUTH_STATUS				0xFF818082
@@ -122,7 +122,7 @@
 #define OID_RT_SET_CHANNEL				0xFF010182
 #define OID_RT_SET_SNIFFER_MODE                 	0xFF010183
 #define OID_RT_GET_SIGNAL_QUALITY               	0xFF010184
-#define OID_RT_GET_SMALL_PACKET_CRC			0xFF010185
+#define OID_RT_GET_SMALL_PACKET_CRC			0xFF010185		
 #define OID_RT_GET_MIDDLE_PACKET_CRC			0xFF010186
 #define OID_RT_GET_LARGE_PACKET_CRC			0xFF010187
 #define OID_RT_GET_TX_RETRY				0xFF010188
@@ -239,7 +239,7 @@
 #define OID_RT_PRO_READ_REGISTER			0xFF871101 //Q
 #define OID_RT_PRO_WRITE_REGISTER			0xFF871102 //S
 
-#define OID_RT_PRO_BURST_READ_REGISTER			0xFF871103 //Q
+#define OID_RT_PRO_BURST_READ_REGISTER			0xFF871103 //Q		
 #define OID_RT_PRO_BURST_WRITE_REGISTER 		0xFF871104 //S
 
 #define OID_RT_PRO_WRITE_TXCMD				0xFF871105 //S
@@ -283,9 +283,9 @@
 #define OID_RT_PRO_READ_TSSI				0xFF871123//S
 #define OID_RT_PRO_SET_POWER_TRACKING			0xFF871124//S
 
-
+ 
 #define OID_RT_PRO_QRY_PWRSTATE				0xFF871150 //Q
-#define OID_RT_PRO_SET_PWRSTATE				0xFF871151 //S
+#define OID_RT_PRO_SET_PWRSTATE				0xFF871151 //S 
 
 //Method 2 , using workitem
 #define OID_RT_SET_READ_REG				0xFF871181 //S
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/nic_spec.h b/drivers/net/wireless/realtek/rtl8192cu/include/nic_spec.h
old mode 100644
new mode 100755
index fba5e56..18e7b2c
--- a/drivers/net/wireless/realtek/rtl8192cu/include/nic_spec.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/nic_spec.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -16,7 +16,7 @@
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
  *
  *
- ******************************************************************************/
+ ******************************************************************************/	
 
 
 #ifndef __NIC_SPEC_H__
@@ -44,3 +44,4 @@
 
 
 #endif // __RTL8711_SPEC_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/osdep_ce_service.h b/drivers/net/wireless/realtek/rtl8192cu/include/osdep_ce_service.h
old mode 100644
new mode 100755
index 4b4def0..e374077
--- a/drivers/net/wireless/realtek/rtl8192cu/include/osdep_ce_service.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/osdep_ce_service.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -71,7 +71,7 @@ __inline static _list *get_prev(_list	*list)
 {
 	return list->Blink;
 }
-
+	
 __inline static _list *get_next(_list	*list)
 {
 	return list->Flink;
@@ -96,12 +96,12 @@ __inline static void _exit_critical(_lock *plock, _irqL *pirqL)
 
 __inline static _enter_critical_ex(_lock *plock, _irqL *pirqL)
 {
-	NdisDprAcquireSpinLock(plock);
+	NdisDprAcquireSpinLock(plock);	
 }
 
 __inline static _exit_critical_ex(_lock *plock, _irqL *pirqL)
 {
-	NdisDprReleaseSpinLock(plock);
+	NdisDprReleaseSpinLock(plock);	
 }
 
 
@@ -129,7 +129,7 @@ __inline static void _init_timer(_timer *ptimer,_nic_hdl nic_hdl,void *pfunc,PVO
 
 __inline static void _set_timer(_timer *ptimer,u32 delay_time)
 {
-	NdisMSetTimer(ptimer,delay_time);
+ 	NdisMSetTimer(ptimer,delay_time);
 }
 
 __inline static void _cancel_timer(_timer *ptimer,u8 *bcancelled)
@@ -168,3 +168,4 @@ __inline static void _set_workitem(_workitem *pwork)
     NdisInterlockedDecrement((PULONG)&(_MutexCounter));              \
 }
 #endif
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/osdep_intf.h b/drivers/net/wireless/realtek/rtl8192cu/include/osdep_intf.h
old mode 100644
new mode 100755
index 10e5e4a..3cd1659
--- a/drivers/net/wireless/realtek/rtl8192cu/include/osdep_intf.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/osdep_intf.h
@@ -152,3 +152,4 @@ static void rtw_proc_remove_one(struct net_device *dev){}
 void rtw_ndev_destructor(_nic_hdl ndev);
 
 #endif	//_OSDEP_INTF_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/osdep_service.h b/drivers/net/wireless/realtek/rtl8192cu/include/osdep_service.h
old mode 100644
new mode 100755
index b610ed7..a72d2c6
--- a/drivers/net/wireless/realtek/rtl8192cu/include/osdep_service.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/osdep_service.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -20,6 +20,10 @@
 #ifndef __OSDEP_SERVICE_H_
 #define __OSDEP_SERVICE_H_
 
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
+#include <linux/sched/signal.h>
+#endif
 #include <drv_conf.h>
 #include <basic_types.h>
 //#include <rtl871x_byteorder.h>
@@ -34,7 +38,7 @@
 
 #undef _FALSE
 #define _FALSE		0
-
+	
 
 #ifdef PLATFORM_FREEBSD
 #include <sys/cdefs.h>
@@ -101,21 +105,21 @@
 	struct list_head *next, *prev;
 	};
 	struct	__queue	{
-		struct	list_head	queue;
+		struct	list_head	queue;	
 		_lock	lock;
 	};
 
 	//typedef	struct sk_buff	_pkt;
 	typedef	struct mbuf	_pkt;
 	typedef struct mbuf	_buffer;
-
+	
 	typedef struct	__queue	_queue;
 	typedef struct	list_head	_list;
 	typedef	int	_OS_STATUS;
 	//typedef u32	_irqL;
 	typedef unsigned long _irqL;
 	typedef	struct	ifnet * _nic_hdl;
-
+	
 	typedef pid_t		_thread_hdl_;
 //	typedef struct thread		_thread_hdl_;
 	typedef void		thread_return;
@@ -141,7 +145,7 @@
 #define LIST_CONTAINOR(ptr, type, member) \
         ((type *)((char *)(ptr)-(SIZE_T)(&((type *)0)->member)))
 #define container_of(p,t,n) (t*)((p)-&(((t*)0)->n))
-/*
+/* 
  * Linux timers are emulated using FreeBSD callout functions
  * (and taskqueue functionality).
  *
@@ -155,11 +159,11 @@ struct timer_list {
         /* FreeBSD callout related fields */
         struct callout callout;
 
-	//timeout function
+ 	//timeout function
         void (*function)(void*);
 	//argument
 	 void *arg;
-
+        
 };
 struct workqueue_struct;
 struct work_struct;
@@ -169,13 +173,13 @@ struct timer_list {
         WORK_STATE_UNSET = 0,
         WORK_STATE_CALLOUT_PENDING = 1,
         WORK_STATE_TASK_PENDING = 2,
-        WORK_STATE_WORK_CANCELLED = 3
+        WORK_STATE_WORK_CANCELLED = 3        
 } work_state_t;
 
 struct work_struct {
         struct task task; /* FreeBSD task */
         work_state_t state; /* the pending or otherwise state of work. */
-        work_func_t func;
+        work_func_t func;       
 };
 #define spin_unlock_irqrestore mtx_unlock_irqrestore
 #define spin_unlock_bh mtx_unlock_irqrestore
@@ -203,10 +207,10 @@ struct work_struct {
 typedef union ktime ktime_t;		/* Kill this */
 
 void rtw_mtx_lock(_lock *plock);
-
+	
 void rtw_mtx_unlock(_lock *plock);
 
-/**
+/** 
  *	struct sk_buff - socket buffer
  *	@next: Next buffer in list
  *	@prev: Previous buffer in list
@@ -235,7 +239,7 @@ struct work_struct {
  *	@priority: Packet queueing priority
  *	@users: User count - see {datagram,tcp}.c
  *	@protocol: Packet protocol from driver
- *	@truesize: Buffer size
+ *	@truesize: Buffer size 
  *	@head: Head of buffer
  *	@data: Data head pointer
  *	@tail: Tail pointer
@@ -498,7 +502,7 @@ static inline void skb_queue_head_init(struct sk_buff_head *list)
  *
  * These macros will use the SYSINIT framework to call a specified
  * function (with no arguments) on module loading or unloading.
- *
+ * 
  */
 
 void module_init_exit_wrapper(void *arg);
@@ -515,13 +519,13 @@ static inline void skb_queue_head_init(struct sk_buff_head *list)
 
 /*
  * The usb_register and usb_deregister functions are used to register
- * usb drivers with the usb subsystem.
+ * usb drivers with the usb subsystem. 
  */
 int usb_register(struct usb_driver *driver);
 int usb_deregister(struct usb_driver *driver);
 
 /*
- * usb_get_dev and usb_put_dev - increment/decrement the reference count
+ * usb_get_dev and usb_put_dev - increment/decrement the reference count 
  * of the usb device structure.
  *
  * Original body of usb_get_dev:
@@ -539,7 +543,7 @@ static inline void skb_queue_head_init(struct sk_buff_head *list)
         return dev;
 }
 
-static inline void
+static inline void 
 usb_put_dev(struct usb_device *dev)
 {
         return;
@@ -623,18 +627,18 @@ int rtw_usb_bulk_msg(struct usb_device *udev, struct usb_host_endpoint *uhe,
 __inline static _list *get_next(_list	*list)
 {
 	return list->next;
-}
+}	
 
 __inline static _list	*get_list_head(_queue	*queue)
 {
 	return (&(queue->queue));
 }
 
-
+	
 #define LIST_CONTAINOR(ptr, type, member) \
-        ((type *)((char *)(ptr)-(SIZE_T)(&((type *)0)->member)))
-
+        ((type *)((char *)(ptr)-(SIZE_T)(&((type *)0)->member)))	
 
+        
 __inline static void _enter_critical(_lock *plock, _irqL *pirqL)
 {
 	spin_lock_irqsave(plock, *pirqL);
@@ -703,7 +707,7 @@ __inline static void _init_timer(_timer *ptimer,_nic_hdl padapter,void *pfunc,vo
 }
 
 __inline static void _set_timer(_timer *ptimer,u32 delay_time)
-{
+{	
 	//	mod_timer(ptimer , (jiffies+(delay_time*HZ/1000)));
 	if(ptimer->function && ptimer->arg){
 		rtw_mtx_lock(NULL);
@@ -714,8 +718,8 @@ __inline static void _set_timer(_timer *ptimer,u32 delay_time)
 
 __inline static void _cancel_timer(_timer *ptimer,u8 *bcancelled)
 {
-	//	del_timer_sync(ptimer);
-	//	*bcancelled=  _TRUE;//TRUE ==1; FALSE==0
+	//	del_timer_sync(ptimer); 	
+	//	*bcancelled=  _TRUE;//TRUE ==1; FALSE==0	
 	rtw_mtx_lock(NULL);
 	callout_drain(&ptimer->callout);
 	rtw_mtx_unlock(NULL);
@@ -786,13 +790,11 @@ __inline static void _set_workitem(_workitem *pwork)
 	#include <linux/interrupt.h>	// for struct tasklet_struct
 	#include <linux/ip.h>
 	#include <linux/kthread.h>
-	#include <linux/signal.h>
-	#include <linux/sched/signal.h>
 
-#ifdef CONFIG_IOCTL_CFG80211
-//	#include <linux/ieee80211.h>
+#ifdef CONFIG_IOCTL_CFG80211	
+//	#include <linux/ieee80211.h>        
         #include <net/ieee80211_radiotap.h>
-	#include <net/cfg80211.h>
+	#include <net/cfg80211.h>	
 #endif //CONFIG_IOCTL_CFG80211
 
 #ifdef CONFIG_TCP_CSUM_OFFLOAD_TX
@@ -813,7 +815,7 @@ __inline static void _set_workitem(_workitem *pwork)
 	#include <linux/pci.h>
 #endif
 
-
+	
 #ifdef CONFIG_USB_HCI
 	typedef struct urb *  PURB;
 #if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,22))
@@ -833,20 +835,20 @@ __inline static void _set_workitem(_workitem *pwork)
 	typedef struct timer_list _timer;
 
 	struct	__queue	{
-		struct	list_head	queue;
+		struct	list_head	queue;	
 		_lock	lock;
 	};
 
 	typedef	struct sk_buff	_pkt;
 	typedef unsigned char	_buffer;
-
+	
 	typedef struct	__queue	_queue;
 	typedef struct	list_head	_list;
 	typedef	int	_OS_STATUS;
 	//typedef u32	_irqL;
 	typedef unsigned long _irqL;
 	typedef	struct	net_device * _nic_hdl;
-
+	
 	typedef void*		_thread_hdl_;
 	typedef int		thread_return;
 	typedef void*	thread_context;
@@ -887,18 +889,18 @@ static inline unsigned char *skb_end_pointer(const struct sk_buff *skb)
 __inline static _list *get_next(_list	*list)
 {
 	return list->next;
-}
+}	
 
 __inline static _list	*get_list_head(_queue	*queue)
 {
 	return (&(queue->queue));
 }
 
-
+	
 #define LIST_CONTAINOR(ptr, type, member) \
-        ((type *)((char *)(ptr)-(SIZE_T)(&((type *)0)->member)))
-
+        ((type *)((char *)(ptr)-(SIZE_T)(&((type *)0)->member)))	
 
+        
 __inline static void _enter_critical(_lock *plock, _irqL *pirqL)
 {
 	spin_lock_irqsave(plock, *pirqL);
@@ -953,22 +955,24 @@ __inline static void rtw_list_delete(_list *plist)
 	list_del_init(plist);
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
 __inline static void _init_timer(_timer *ptimer,_nic_hdl nic_hdl,void *pfunc,void* cntx)
 {
-	//setup_timer(ptimer, pfunc,(u32)cntx);
+	//setup_timer(ptimer, pfunc,(u32)cntx);	
 	ptimer->function = pfunc;
 	ptimer->data = (unsigned long)cntx;
 	init_timer(ptimer);
 }
+#endif
 
 __inline static void _set_timer(_timer *ptimer,u32 delay_time)
-{
-	mod_timer(ptimer , (jiffies+(delay_time*HZ/1000)));
+{	
+	mod_timer(ptimer , (jiffies+(delay_time*HZ/1000)));	
 }
 
 __inline static void _cancel_timer(_timer *ptimer,u8 *bcancelled)
 {
-	del_timer_sync(ptimer);
+	del_timer_sync(ptimer); 	
 	*bcancelled=  _TRUE;//TRUE ==1; FALSE==0
 }
 
@@ -1081,7 +1085,7 @@ static inline void rtw_netif_stop_queue(struct net_device *pnetdev)
 	typedef KSEMAPHORE 	_sema;
 	typedef	LIST_ENTRY	_list;
 	typedef NDIS_STATUS _OS_STATUS;
-
+	
 
 	typedef NDIS_SPIN_LOCK	_lock;
 
@@ -1096,14 +1100,14 @@ static inline void rtw_netif_stop_queue(struct net_device *pnetdev)
 	typedef NDIS_MINIPORT_TIMER    _timer;
 
 	struct	__queue	{
-		LIST_ENTRY	queue;
+		LIST_ENTRY	queue;	
 		_lock	lock;
 	};
 
 	typedef	NDIS_PACKET	_pkt;
 	typedef NDIS_BUFFER	_buffer;
 	typedef struct	__queue	_queue;
-
+	
 	typedef PKTHREAD _thread_hdl_;
 	typedef void	thread_return;
 	typedef void* thread_context;
@@ -1114,40 +1118,40 @@ static inline void rtw_netif_stop_queue(struct net_device *pnetdev)
 
 	#define HZ			10000000
 	#define SEMA_UPBND	(0x7FFFFFFF)   //8192
-
+	
 __inline static _list *get_next(_list	*list)
 {
 	return list->Flink;
-}
+}	
 
 __inline static _list	*get_list_head(_queue	*queue)
 {
 	return (&(queue->queue));
 }
-
+	
 
 #define LIST_CONTAINOR(ptr, type, member) CONTAINING_RECORD(ptr, type, member)
-
+     
 
 __inline static _enter_critical(_lock *plock, _irqL *pirqL)
 {
-	NdisAcquireSpinLock(plock);
+	NdisAcquireSpinLock(plock);	
 }
 
 __inline static _exit_critical(_lock *plock, _irqL *pirqL)
 {
-	NdisReleaseSpinLock(plock);
+	NdisReleaseSpinLock(plock);	
 }
 
 
 __inline static _enter_critical_ex(_lock *plock, _irqL *pirqL)
 {
-	NdisDprAcquireSpinLock(plock);
+	NdisDprAcquireSpinLock(plock);	
 }
 
 __inline static _exit_critical_ex(_lock *plock, _irqL *pirqL)
 {
-	NdisDprReleaseSpinLock(plock);
+	NdisDprReleaseSpinLock(plock);	
 }
 
 __inline static void _enter_critical_bh(_lock *plock, _irqL *pirqL)
@@ -1175,7 +1179,7 @@ __inline static _exit_critical_mutex(_mutex *pmutex, _irqL *pirqL)
 __inline static void rtw_list_delete(_list *plist)
 {
 	RemoveEntryList(plist);
-	InitializeListHead(plist);
+	InitializeListHead(plist);	
 }
 
 __inline static void _init_timer(_timer *ptimer,_nic_hdl nic_hdl,void *pfunc,PVOID cntx)
@@ -1184,8 +1188,8 @@ __inline static void _init_timer(_timer *ptimer,_nic_hdl nic_hdl,void *pfunc,PVO
 }
 
 __inline static void _set_timer(_timer *ptimer,u32 delay_time)
-{
-	NdisMSetTimer(ptimer,delay_time);
+{	
+ 	NdisMSetTimer(ptimer,delay_time);	
 }
 
 __inline static void _cancel_timer(_timer *ptimer,u8 *bcancelled)
@@ -1397,8 +1401,8 @@ enum mstat_f {
 extern void*	rtw_malloc2d(int h, int w, int size);
 extern void	rtw_mfree2d(void *pbuf, int h, int w, int size);
 
-extern void	_rtw_memcpy(void *dec, const void *sour, u32 sz);
-extern int	_rtw_memcmp(const void *dst, const void *src, u32 sz);
+extern void	_rtw_memcpy(void* dec, void* sour, u32 sz);
+extern int	_rtw_memcmp(void *dst, void *src, u32 sz);
 extern void	_rtw_memset(void *pbuf, int c, u32 sz);
 
 extern void	_rtw_init_listhead(_list *list);
@@ -1465,9 +1469,9 @@ __inline static unsigned char _cancel_timer_ex(_timer *ptimer)
 #endif
 #ifdef PLATFORM_WINDOWS
 	u8 bcancelled;
-
+	
 	_cancel_timer(ptimer, &bcancelled);
-
+	
 	return bcancelled;
 #endif
 }
@@ -1491,10 +1495,10 @@ static __inline void thread_enter(char *name)
 #ifdef PLATFORM_FREEBSD
 #define thread_exit() do{printf("%s", "RTKTHREAD_exit");}while(0)
 #endif //PLATFORM_FREEBSD
-__inline static void flush_signals_thread(void)
+__inline static void flush_signals_thread(void) 
 {
 #ifdef PLATFORM_LINUX
-	if (signal_pending (current))
+	if (signal_pending (current)) 
 	{
 		flush_signals(current);
 	}
@@ -1516,8 +1520,8 @@ __inline static _OS_STATUS res_to_status(sint res)
 	else
 		return NDIS_STATUS_FAILURE;
 
-#endif
-
+#endif	
+	
 }
 
 __inline static void rtw_dump_stack(void)
@@ -1542,7 +1546,7 @@ __inline static u32 _RND4(u32 sz)
 	u32	val;
 
 	val = ((sz >> 2) + ((sz & 3) ? 1: 0)) << 2;
-
+	
 	return val;
 
 }
@@ -1553,7 +1557,7 @@ __inline static u32 _RND8(u32 sz)
 	u32	val;
 
 	val = ((sz >> 3) + ((sz & 7) ? 1: 0)) << 3;
-
+	
 	return val;
 
 }
@@ -1564,7 +1568,7 @@ __inline static u32 _RND128(u32 sz)
 	u32	val;
 
 	val = ((sz >> 7) + ((sz & 127) ? 1: 0)) << 7;
-
+	
 	return val;
 
 }
@@ -1575,7 +1579,7 @@ __inline static u32 _RND256(u32 sz)
 	u32	val;
 
 	val = ((sz >> 8) + ((sz & 255) ? 1: 0)) << 8;
-
+	
 	return val;
 
 }
@@ -1586,7 +1590,7 @@ __inline static u32 _RND512(u32 sz)
 	u32	val;
 
 	val = ((sz >> 9) + ((sz & 511) ? 1: 0)) << 9;
-
+	
 	return val;
 
 }
@@ -1746,7 +1750,7 @@ struct rtw_netdev_priv_indicator {
 	} while (0)
 
 #define RTW_GET_BE24(a) ((((u32) (a)[0]) << 16) | (((u32) (a)[1]) << 8) | \
-			 ((u32) (a)[2]))
+			 ((u32) (a)[2]))			 
 #define RTW_PUT_BE24(a, val)					\
 	do {							\
 		(a)[0] = (u8) ((((u32) (val)) >> 16) & 0xff);	\
@@ -1755,7 +1759,7 @@ struct rtw_netdev_priv_indicator {
 	} while (0)
 
 #define RTW_GET_BE32(a) ((((u32) (a)[0]) << 24) | (((u32) (a)[1]) << 16) | \
-			 (((u32) (a)[2]) << 8) | ((u32) (a)[3]))
+			 (((u32) (a)[2]) << 8) | ((u32) (a)[3]))			 
 #define RTW_PUT_BE32(a, val)					\
 	do {							\
 		(a)[0] = (u8) ((((u32) (val)) >> 24) & 0xff);	\
@@ -1765,7 +1769,7 @@ struct rtw_netdev_priv_indicator {
 	} while (0)
 
 #define RTW_GET_LE32(a) ((((u32) (a)[3]) << 24) | (((u32) (a)[2]) << 16) | \
-			 (((u32) (a)[1]) << 8) | ((u32) (a)[0]))
+			 (((u32) (a)[1]) << 8) | ((u32) (a)[0]))			 
 #define RTW_PUT_LE32(a, val)					\
 	do {							\
 		(a)[3] = (u8) ((((u32) (val)) >> 24) & 0xff);	\
@@ -1777,7 +1781,7 @@ struct rtw_netdev_priv_indicator {
 #define RTW_GET_BE64(a) ((((u64) (a)[0]) << 56) | (((u64) (a)[1]) << 48) | \
 			 (((u64) (a)[2]) << 40) | (((u64) (a)[3]) << 32) | \
 			 (((u64) (a)[4]) << 24) | (((u64) (a)[5]) << 16) | \
-			 (((u64) (a)[6]) << 8) | ((u64) (a)[7]))
+			 (((u64) (a)[6]) << 8) | ((u64) (a)[7]))			 
 #define RTW_PUT_BE64(a, val)				\
 	do {						\
 		(a)[0] = (u8) (((u64) (val)) >> 56);	\
@@ -1813,3 +1817,5 @@ struct rtw_cbuf {
 void rtw_cbuf_free(struct rtw_cbuf *cbuf);
 
 #endif
+
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/pci_hal.h b/drivers/net/wireless/realtek/rtl8192cu/include/pci_hal.h
old mode 100644
new mode 100755
index 650b04f..1ee0ee2
--- a/drivers/net/wireless/realtek/rtl8192cu/include/pci_hal.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/pci_hal.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -31,29 +31,29 @@
 #define	PCI_MAX_DEVICES				32
 #define	PCI_MAX_FUNCTION				8
 
-#define	PCI_CONF_ADDRESS   				0x0CF8   // PCI Configuration Space Address
-#define	PCI_CONF_DATA					0x0CFC   // PCI Configuration Space Data
+#define	PCI_CONF_ADDRESS   				0x0CF8   // PCI Configuration Space Address 
+#define	PCI_CONF_DATA					0x0CFC   // PCI Configuration Space Data 
 
 #define	PCI_CLASS_BRIDGE_DEV			0x06
 #define	PCI_SUBCLASS_BR_PCI_TO_PCI	0x04
 
 #define 	PCI_CAPABILITY_ID_PCI_EXPRESS	0x10
 
-#define	U1DONTCARE 					0xFF
-#define	U2DONTCARE 					0xFFFF
+#define	U1DONTCARE 					0xFF	
+#define	U2DONTCARE 					0xFFFF	
 #define	U4DONTCARE 					0xFFFFFFFF
 
 #define PCI_VENDER_ID_REALTEK		0x10ec
 
 #define HAL_HW_PCI_8180_DEVICE_ID           	0x8180
 #define HAL_HW_PCI_8185_DEVICE_ID           	0x8185	//8185 or 8185b
-#define HAL_HW_PCI_8188_DEVICE_ID           	0x8188	//8185b
-#define HAL_HW_PCI_8198_DEVICE_ID           	0x8198	//8185b
+#define HAL_HW_PCI_8188_DEVICE_ID           	0x8188	//8185b		
+#define HAL_HW_PCI_8198_DEVICE_ID           	0x8198	//8185b		
 #define HAL_HW_PCI_8190_DEVICE_ID           	0x8190	//8190
 #define HAL_HW_PCI_8723E_DEVICE_ID		0x8723	//8723E
 #define HAL_HW_PCI_8192_DEVICE_ID           	0x8192	//8192 PCI-E
 #define HAL_HW_PCI_8192SE_DEVICE_ID		0x8192	//8192 SE
-#define HAL_HW_PCI_8174_DEVICE_ID           	0x8174	//8192 SE
+#define HAL_HW_PCI_8174_DEVICE_ID           	0x8174	//8192 SE 
 #define HAL_HW_PCI_8173_DEVICE_ID           	0x8173	//8191 SE Crab
 #define HAL_HW_PCI_8172_DEVICE_ID           	0x8172	//8191 SE RE
 #define HAL_HW_PCI_8171_DEVICE_ID           	0x8171	//8191 SE Unicron
@@ -99,10 +99,10 @@ struct rt_pci_capabilities_header {
 
 struct pci_priv{
 	u8	linkctrl_reg;
-
+	
 	u8	busnumber;
-	u8	devnumber;
-	u8	funcnumber;
+	u8	devnumber;	
+	u8	funcnumber;	
 
 	u8	pcibridge_busnum;
 	u8	pcibridge_devnum;
@@ -111,7 +111,7 @@ struct pci_priv{
 	u16	pcibridge_vendorid;
 	u16	pcibridge_deviceid;
 	u8	pcibridge_pciehdr_offset;
-	u8	pcibridge_linkctrlreg;
+	u8	pcibridge_linkctrlreg;	
 
 	u8	amd_l1_patch;
 };
@@ -127,10 +127,10 @@ struct pci_priv{
 
 //#define RegAddr(addr)           (addr + 0xB2000000UL)
 //some platform macros will def here
-static inline void NdisRawWritePortUlong(u32 port,  u32 val)
+static inline void NdisRawWritePortUlong(u32 port,  u32 val) 		
 {
 	outl(val, port);
-	//writel(val, (u8 *)RegAddr(port));
+	//writel(val, (u8 *)RegAddr(port));	
 }
 
 static inline void NdisRawWritePortUchar(u32 port,  u8 val)
@@ -165,3 +165,4 @@ static inline void NdisRawReadPortUlong(u32 port, u32 *pval)
 #endif
 
 #endif //__PCIE_HAL_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/pci_ops.h b/drivers/net/wireless/realtek/rtl8192cu/include/pci_ops.h
old mode 100644
new mode 100755
index 51d96c4..9404ff4
--- a/drivers/net/wireless/realtek/rtl8192cu/include/pci_ops.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/pci_ops.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/pci_osintf.h b/drivers/net/wireless/realtek/rtl8192cu/include/pci_osintf.h
old mode 100644
new mode 100755
index 8d38a533..09715af
--- a/drivers/net/wireless/realtek/rtl8192cu/include/pci_osintf.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/pci_osintf.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -30,3 +30,4 @@
 
 
 #endif
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/recv_osdep.h b/drivers/net/wireless/realtek/rtl8192cu/include/recv_osdep.h
old mode 100644
new mode 100755
index b39e00b..536ed31
--- a/drivers/net/wireless/realtek/rtl8192cu/include/recv_osdep.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/recv_osdep.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -29,13 +29,13 @@
 extern void _rtw_free_recv_priv (struct recv_priv *precvpriv);
 
 
-extern s32  rtw_recv_entry(union recv_frame *precv_frame);
+extern s32  rtw_recv_entry(union recv_frame *precv_frame);	
 extern int rtw_recv_indicatepkt(_adapter *adapter, union recv_frame *precv_frame);
 extern void rtw_recv_returnpacket(IN _nic_hdl cnxt, IN _pkt *preturnedpkt);
 
 extern void rtw_hostapd_mlme_rx(_adapter *padapter, union recv_frame *precv_frame);
 extern void rtw_handle_tkip_mic_err(_adapter *padapter,u8 bgroup);
-
+		
 
 int	rtw_init_recv_priv(struct recv_priv *precvpriv, _adapter *padapter);
 void rtw_free_recv_priv (struct recv_priv *precvpriv);
@@ -55,3 +55,4 @@
 
 
 #endif //
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_cmd.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_cmd.h
old mode 100644
new mode 100755
index 3a63316..c54cc31
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_cmd.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_cmd.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -22,7 +22,7 @@
 
 
 enum cmd_msg_element_id
-{
+{	
 	NONE_CMDMSG_EID,
 	AP_OFFLOAD_EID=0,
 	SET_PWRMODE_EID=1,
@@ -68,7 +68,7 @@ struct cmd_msg_parm {
 typedef struct _SETWOWLAN_PARM{
 	u8 	mode;
 	u8 	gpio_index;
-	u8	gpio_duration;
+	u8	gpio_duration;	
 	u8  second_mode;
 	u8  reserve;
 }SETWOWLAN_PARM, *PSETWOWLAN_PARM;
@@ -150,3 +150,4 @@ struct P2P_PS_CTWPeriod_t {
 #endif // CONFIG_WOWLAN
 
 #endif	// __RTL8192C_CMD_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_dm.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_dm.h
old mode 100644
new mode 100755
index 3c56d49..9d06540
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_dm.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_dm.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -56,7 +56,7 @@
 	u8		CurRFState;
 
 	s32		Rssi_val_min;
-
+	
 }PS_T;
 
 typedef struct _Dynamic_Initial_Gain_Threshold_
@@ -144,7 +144,7 @@
 
 typedef enum tag_DIG_Connect_Definition
 {
-	DIG_STA_DISCONNECT = 0,
+	DIG_STA_DISCONNECT = 0,	
 	DIG_STA_CONNECT = 1,
 	DIG_STA_BEFORE_CONNECT = 2,
 	DIG_MultiSTA_DISCONNECT = 3,
@@ -155,12 +155,12 @@
 
 
 typedef	enum _BT_Ant_NUM{
-	Ant_x2	= 0,
+	Ant_x2	= 0,		
 	Ant_x1	= 1
 } BT_Ant_NUM, *PBT_Ant_NUM;
 
 typedef	enum _BT_CoType{
-	BT_2Wire		= 0,
+	BT_2Wire		= 0,		
 	BT_ISSC_3Wire	= 1,
 	BT_Accel		= 2,
 	BT_CSR_BC4		= 3,
@@ -169,12 +169,12 @@
 } BT_CoType, *PBT_CoType;
 
 typedef	enum _BT_CurState{
-	BT_OFF		= 0,
+	BT_OFF		= 0,	
 	BT_ON		= 1,
 } BT_CurState, *PBT_CurState;
 
 typedef	enum _BT_ServiceType{
-	BT_SCO		= 0,
+	BT_SCO		= 0,	
 	BT_A2DP		= 1,
 	BT_HID		= 2,
 	BT_HID_Idle	= 3,
@@ -187,7 +187,7 @@
 } BT_ServiceType, *PBT_ServiceType;
 
 typedef	enum _BT_RadioShared{
-	BT_Radio_Shared 	= 0,
+	BT_Radio_Shared 	= 0,	
 	BT_Radio_Individual	= 1,
 } BT_RadioShared, *PBT_RadioShared;
 
@@ -263,7 +263,7 @@ struct btcoexist_priv	{
 #define		TX_POWER_NEAR_FIELD_THRESH_LVL2	74
 #define		TX_POWER_NEAR_FIELD_THRESH_LVL1	67
 
-#define		TxHighPwrLevel_Normal		0
+#define		TxHighPwrLevel_Normal		0	
 #define		TxHighPwrLevel_Level1		1
 #define		TxHighPwrLevel_Level2		2
 #define		TxHighPwrLevel_BT1			3
@@ -282,14 +282,14 @@ struct btcoexist_priv	{
 {
 	u8				RateAdaptiveDisabled;
 	u8				RATRState;
-	u16				reserve;
-
+	u16				reserve;	
+	
 	u32				HighRSSIThreshForRA;
 	u32				High2LowRSSIThreshForRA;
 	u8				Low2HighRSSIThreshForRA40M;
-	u32				LowRSSIThreshForRA40M;
+	u32				LowRSSIThreshForRA40M;	
 	u8				Low2HighRSSIThreshForRA20M;
-	u32				LowRSSIThreshForRA20M;
+	u32				LowRSSIThreshForRA20M;	
 	u32				UpperRSSIThresholdRATR;
 	u32				MiddleRSSIThresholdRATR;
 	u32				LowRSSIThresholdRATR;
@@ -300,7 +300,7 @@ struct btcoexist_priv	{
 	u32				PingRSSIThreshForRA;//cosa add for Netcore long range ping issue
 	u32				LastRATR;
 	u8				PreRATRState;
-
+	
 } RATE_ADAPTIVE, *PRATE_ADAPTIVE;
 
 typedef enum tag_SW_Antenna_Switch_Definition
@@ -311,7 +311,7 @@ struct btcoexist_priv	{
 }DM_SWAS_E;
 
 #ifdef CONFIG_ANTENNA_DIVERSITY
-// This indicates two different the steps.
+// This indicates two different the steps. 
 // In SWAW_STEP_PEAK, driver needs to switch antenna and listen to the signal on the air.
 // In SWAW_STEP_DETERMINE, driver just compares the signal captured in SWAW_STEP_PEAK
 // with original RSSI to determine if it is necessary to switch antenna.
@@ -342,11 +342,11 @@ struct btcoexist_priv	{
 #endif
 
 
-struct 	dm_priv
+struct 	dm_priv	
 {
 	u8	DM_Type;
 	u8	DMFlag, DMFlag_tmp;
-
+	
 
 	//for DIG
 	u8	bDMInitialGainEnable;
@@ -356,7 +356,7 @@ struct 	dm_priv
 	PS_T	DM_PSTable;
 
 	FALSE_ALARM_STATISTICS FalseAlmCnt;
-
+	
 	//for rate adaptive, in fact,  88c/92c fw will handle this
 	u8 bUseRAMask;
 	RATE_ADAPTIVE RateAdaptive;
@@ -372,11 +372,11 @@ struct 	dm_priv
 	u8 bDynamicTxPowerEnable;
 	u8 LastDTPLvl;
 	u8 DynamicTxHighPowerLvl;//Add by Jacken Tx Power Control for Near/Far Range 2008/03/06
-
+		
 	//for tx power tracking
 	//u8	bTXPowerTracking;
 	u8	TXPowercount;
-	u8	bTXPowerTrackingInit;
+	u8	bTXPowerTrackingInit;	
 	u8	TxPowerTrackControl;	//for mp mode, turn off txpwrtracking as default
 	u8	TM_Trigger;
 
@@ -442,10 +442,10 @@ struct 	dm_priv
 	//for Antenna diversity
 #ifdef CONFIG_ANTENNA_DIVERSITY
 	SWAT_T DM_SWAT_Table;
-#endif
+#endif	
 #ifdef CONFIG_SW_ANTENNA_DIVERSITY
 	_timer SwAntennaSwitchTimer;
-
+	
 	u64	lastTxOkCnt;
 	u64	lastRxOkCnt;
 	u64	TXByteCnt_A;
@@ -504,7 +504,7 @@ struct 	dm_priv
 #endif
 
 #ifdef CONFIG_SW_ANTENNA_DIVERSITY
-void SwAntDivRSSICheck8192C(_adapter *padapter ,u32 RxPWDBAll);
+void SwAntDivRSSICheck8192C(_adapter *padapter ,u32 RxPWDBAll); 
 void SwAntDivRestAfterLink8192C(IN	PADAPTER Adapter);
 #endif
 #ifdef CONFIG_ANTENNA_DIVERSITY
@@ -513,3 +513,4 @@ struct 	dm_priv
 #endif
 
 #endif	//__HAL8190PCIDM_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_event.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_event.h
old mode 100644
new mode 100755
index ddc08bff..1013f74
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_event.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_event.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -24,3 +24,5 @@
 
 
 #endif
+
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_hal.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_hal.h
old mode 100644
new mode 100755
index c803139..3348971
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_hal.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_hal.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -82,20 +82,20 @@
 //		RTL8723E From file
 //---------------------------------------------------------------------
 	#define RTL8723_FW_UMC_IMG				"rtl8723E\\rtl8723fw.bin"
-	#define RTL8723_PHY_REG					"rtl8723E\\PHY_REG_1T.txt"
+	#define RTL8723_PHY_REG					"rtl8723E\\PHY_REG_1T.txt" 
 	#define RTL8723_PHY_RADIO_A				"rtl8723E\\radio_a_1T.txt"
-	#define RTL8723_PHY_RADIO_B				"rtl8723E\\radio_b_1T.txt"
+	#define RTL8723_PHY_RADIO_B				"rtl8723E\\radio_b_1T.txt" 
 	#define RTL8723_AGC_TAB					"rtl8723E\\AGC_TAB_1T.txt"
 	#define RTL8723_PHY_MACREG 				"rtl8723E\\MAC_REG.txt"
 	#define RTL8723_PHY_MACREG 				"rtl8723E\\MAC_REG.txt"
 	#define RTL8723_PHY_REG_PG					"rtl8723E\\PHY_REG_PG.txt"
-	#define RTL8723_PHY_REG_MP 				"rtl8723E\\PHY_REG_MP.txt"
+	#define RTL8723_PHY_REG_MP 				"rtl8723E\\PHY_REG_MP.txt" 	
 
 	// The file name "_2T" is for 92CE, "_1T"  is for 88CE. Modified by tynli. 2009.11.24.
 	#define Rtl819XFwTSMCImageArray			Rtl8192CEFwTSMCImgArray
 	#define Rtl819XFwUMCACutImageArray			Rtl8192CEFwUMCACutImgArray
 	#define Rtl819XFwUMCBCutImageArray			Rtl8192CEFwUMCBCutImgArray
-
+	
 	#define Rtl8723FwUMCImageArray				Rtl8192CEFwUMC8723ImgArray
 	#define Rtl819XMAC_Array					Rtl8192CEMAC_2T_Array
 	#define Rtl819XAGCTAB_2TArray				Rtl8192CEAGCTAB_2TArray
@@ -136,7 +136,7 @@
 	#define RTL8188C_PHY_RADIO_A				"rtl8188CU\\radio_a.txt"
 	#define RTL8188C_PHY_RADIO_B				"rtl8188CU\\radio_b.txt"
 	#define RTL8188C_PHY_RADIO_A_mCard		"rtl8192CU\\radio_a_1T_mCard.txt"
-	#define RTL8188C_PHY_RADIO_B_mCard		"rtl8192CU\\radio_b_1T_mCard.txt"
+	#define RTL8188C_PHY_RADIO_B_mCard		"rtl8192CU\\radio_b_1T_mCard.txt" 
 	#define RTL8188C_PHY_RADIO_A_HP			"rtl8192CU\\radio_a_1T_HP.txt"
 	#define RTL8188C_AGC_TAB					"rtl8188CU\\AGC_TAB.txt"
 	#define RTL8188C_PHY_MACREG				"rtl8188CU\\MACREG.txt"
@@ -153,14 +153,14 @@
 //		RTL8723U From file
 //---------------------------------------------------------------------
 	#define RTL8723_FW_UMC_IMG				"rtl8723U\\rtl8723fw.bin"
-	#define RTL8723_PHY_REG					"rtl8723U\\PHY_REG_1T.txt"
+	#define RTL8723_PHY_REG					"rtl8723U\\PHY_REG_1T.txt" 
 	#define RTL8723_PHY_RADIO_A				"rtl8723U\\radio_a_1T.txt"
-	#define RTL8723_PHY_RADIO_B				"rtl8723U\\radio_b_1T.txt"
+	#define RTL8723_PHY_RADIO_B				"rtl8723U\\radio_b_1T.txt" 
 	#define RTL8723_AGC_TAB					"rtl8723U\\AGC_TAB_1T.txt"
 	#define RTL8723_PHY_MACREG 				"rtl8723U\\MAC_REG.txt"
 	#define RTL8723_PHY_MACREG 				"rtl8723U\\MAC_REG.txt"
 	#define RTL8723_PHY_REG_PG					"rtl8723U\\PHY_REG_PG.txt"
-	#define RTL8723_PHY_REG_MP					"rtl8723U\\PHY_REG_MP.txt"
+	#define RTL8723_PHY_REG_MP					"rtl8723U\\PHY_REG_MP.txt"	
 
 	// The file name "_2T" is for 92CU, "_1T"  is for 88CU. Modified by tynli. 2009.11.24.
 	#define Rtl819XFwImageArray					Rtl8192CUFwTSMCImgArray
@@ -170,7 +170,7 @@
 #ifdef CONFIG_WOWLAN
 	#define Rtl8192C_FwTSMCWWImageArray		Rtl8192CUFwTSMCWWImgArray
 	#define Rtl8192C_FwUMCWWImageArray		Rtl8192CUFwUMCACutWWImgArray
-	#define Rtl8192C_FwUMCBCutWWImageArray	Rtl8192CUFwUMCBCutWWImgArray
+	#define Rtl8192C_FwUMCBCutWWImageArray	Rtl8192CUFwUMCBCutWWImgArray		
 #endif //CONFIG_WOWLAN
 	#define Rtl819XMAC_Array					Rtl8192CUMAC_2T_Array
 	#define Rtl819XAGCTAB_2TArray				Rtl8192CUAGCTAB_2TArray
@@ -178,18 +178,18 @@
 	#define Rtl819XAGCTAB_1T_HPArray			Rtl8192CUAGCTAB_1T_HPArray
 	#define Rtl819XPHY_REG_2TArray				Rtl8192CUPHY_REG_2TArray
 	#define Rtl819XPHY_REG_1TArray				Rtl8192CUPHY_REG_1TArray
-	#define Rtl819XPHY_REG_1T_mCardArray		Rtl8192CUPHY_REG_1T_mCardArray
-	#define Rtl819XPHY_REG_2T_mCardArray		Rtl8192CUPHY_REG_2T_mCardArray
+	#define Rtl819XPHY_REG_1T_mCardArray		Rtl8192CUPHY_REG_1T_mCardArray 					
+	#define Rtl819XPHY_REG_2T_mCardArray		Rtl8192CUPHY_REG_2T_mCardArray	
 	#define Rtl819XPHY_REG_1T_HPArray			Rtl8192CUPHY_REG_1T_HPArray
 	#define Rtl819XRadioA_2TArray				Rtl8192CURadioA_2TArray
 	#define Rtl819XRadioA_1TArray				Rtl8192CURadioA_1TArray
-	#define Rtl819XRadioA_1T_mCardArray		Rtl8192CURadioA_1T_mCardArray
+	#define Rtl819XRadioA_1T_mCardArray		Rtl8192CURadioA_1T_mCardArray			
 	#define Rtl819XRadioB_2TArray				Rtl8192CURadioB_2TArray
-	#define Rtl819XRadioB_1TArray				Rtl8192CURadioB_1TArray
+	#define Rtl819XRadioB_1TArray				Rtl8192CURadioB_1TArray	
 	#define Rtl819XRadioB_1T_mCardArray		Rtl8192CURadioB_1T_mCardArray
-	#define Rtl819XRadioA_1T_HPArray			Rtl8192CURadioA_1T_HPArray
+	#define Rtl819XRadioA_1T_HPArray			Rtl8192CURadioA_1T_HPArray	
 	#define Rtl819XPHY_REG_Array_PG 			Rtl8192CUPHY_REG_Array_PG
-	#define Rtl819XPHY_REG_Array_PG_mCard 		Rtl8192CUPHY_REG_Array_PG_mCard
+	#define Rtl819XPHY_REG_Array_PG_mCard 		Rtl8192CUPHY_REG_Array_PG_mCard			
 	#define Rtl819XPHY_REG_Array_PG_HP			Rtl8192CUPHY_REG_Array_PG_HP
 	#define Rtl819XPHY_REG_Array_MP 			Rtl8192CUPHY_REG_Array_MP
 #endif
@@ -353,7 +353,7 @@
 #define IC_TYPE_MASK					(BIT(0)|BIT(1)|BIT(2))
 #define CHIP_TYPE_MASK 				BIT(3)
 #define RF_TYPE_MASK					(BIT(4)|BIT(5)|BIT(6))
-#define MANUFACTUER_MASK			BIT(7)
+#define MANUFACTUER_MASK			BIT(7)	
 #define ROM_VERSION_MASK				(BIT(11)|BIT(10)|BIT(9)|BIT(8))
 #define CUT_VERSION_MASK				(BIT(15)|BIT(14)|BIT(13)|BIT(12))
 
@@ -379,7 +379,7 @@
 #define IS_92C_SERIAL(version)   				((IS_81XXC(version) && IS_2T2R(version)) ? _TRUE : _FALSE)
 #define IS_VENDOR_UMC_A_CUT(version)		((IS_CHIP_VENDOR_UMC(version)) ? ((GET_CVID_CUT_VERSION(version)) ? _FALSE : _TRUE) : _FALSE)
 #define IS_VENDOR_8723_A_CUT(version)		((IS_8723_SERIES(version)) ? ((GET_CVID_CUT_VERSION(version)) ? _FALSE : _TRUE) : _FALSE)
-// <tynli_Note> 88/92C UMC B-cut vendor is set to TSMC so we need to check CHIP_VENDOR_UMC bit is not 1.
+// <tynli_Note> 88/92C UMC B-cut vendor is set to TSMC so we need to check CHIP_VENDOR_UMC bit is not 1. 
 #define IS_81xxC_VENDOR_UMC_B_CUT(version)	((IS_CHIP_VENDOR_UMC(version)) ? ((GET_CVID_CUT_VERSION(version) == B_CUT_VERSION) ? _TRUE : _FALSE):_FALSE)
 #define IS_92D_SINGLEPHY(version)     			((IS_92D(version)) ? (IS_2T2R(version) ? _TRUE: _FALSE) : _FALSE)
 #define IS_92D_C_CUT(version)    				((IS_92D(version)) ? ((GET_CVID_CUT_VERSION(version) == 0x2) ? _TRUE : _FALSE) : _FALSE)
@@ -389,17 +389,17 @@
 	VERSION_TEST_CHIP_88C = 0x0000,
 	VERSION_TEST_CHIP_92C = 0x0020,
 	VERSION_TEST_UMC_CHIP_8723 = 0x0081,
-	VERSION_NORMAL_TSMC_CHIP_88C = 0x0008,
+	VERSION_NORMAL_TSMC_CHIP_88C = 0x0008, 
 	VERSION_NORMAL_TSMC_CHIP_92C = 0x0028,
 	VERSION_NORMAL_TSMC_CHIP_92C_1T2R = 0x0018,
 	VERSION_NORMAL_UMC_CHIP_88C_A_CUT = 0x0088,
 	VERSION_NORMAL_UMC_CHIP_92C_A_CUT = 0x00a8,
-	VERSION_NORMAL_UMC_CHIP_92C_1T2R_A_CUT = 0x0098,
+	VERSION_NORMAL_UMC_CHIP_92C_1T2R_A_CUT = 0x0098,		
 	VERSION_NORMAL_UMC_CHIP_8723_1T1R_A_CUT = 0x0089,
-	VERSION_NORMAL_UMC_CHIP_8723_1T1R_B_CUT = 0x1089,
-	VERSION_NORMAL_UMC_CHIP_88C_B_CUT = 0x1088,
-	VERSION_NORMAL_UMC_CHIP_92C_B_CUT = 0x10a8,
-	VERSION_NORMAL_UMC_CHIP_92C_1T2R_B_CUT = 0x1090,
+	VERSION_NORMAL_UMC_CHIP_8723_1T1R_B_CUT = 0x1089,	
+	VERSION_NORMAL_UMC_CHIP_88C_B_CUT = 0x1088, 
+	VERSION_NORMAL_UMC_CHIP_92C_B_CUT = 0x10a8, 
+	VERSION_NORMAL_UMC_CHIP_92C_1T2R_B_CUT = 0x1090, 
 	VERSION_TEST_CHIP_92D_SINGLEPHY= 0x0022,
 	VERSION_TEST_CHIP_92D_DUALPHY = 0x0002,
 	VERSION_NORMAL_CHIP_92D_SINGLEPHY= 0x002a,
@@ -450,7 +450,7 @@ enum ChannelPlan{
 // <Roger_Notes> To prevent out of boundary programming case, leave 1byte and program full section
 // 9bytes + 1byt + 5bytes and pre 1byte.
 // For worst case:
-// | 1byte|----8bytes----|1byte|--5bytes--|
+// | 1byte|----8bytes----|1byte|--5bytes--| 
 // |         |            Reserved(14bytes)	      |
 //
 #define		EFUSE_OOB_PROTECT_BYTES 		15	// PG data exclude header, dummy 6 bytes frome CP test and reserved 1byte.
@@ -483,13 +483,13 @@ enum ChannelPlan{
 //
 typedef enum _RT_POLARITY_CTL{
 	RT_POLARITY_LOW_ACT = 0,
-	RT_POLARITY_HIGH_ACT = 1,
+	RT_POLARITY_HIGH_ACT = 1,	
 }RT_POLARITY_CTL,*PRT_POLARITY_CTL;
 
 // For RTL8723 regulator mode. by tynli. 2011.01.14.
 typedef enum _RT_REGULATOR_MODE{
 	RT_SWITCHING_REGULATOR = 0,
-	RT_LDO_REGULATOR = 1,
+	RT_LDO_REGULATOR = 1,	
 }RT_REGULATOR_MODE,*PRT_REGULATOR_MODE;
 
 enum c2h_id_8192c {
@@ -524,7 +524,7 @@ struct hal_data_8192ce
 	u32	IntrMaskToSet[2];
 
 	u32	DisabledFunctions;
-
+	
 	//current WIFI_PHY values
 	u32	ReceiveConfig;
 	u32	TransmitConfig;
@@ -553,8 +553,8 @@ struct hal_data_8192ce
 	u16	EEPROMChannelPlan;
 	u16	EEPROMVersion;
 
-	u8	EEPROMChnlAreaTxPwrCCK[2][3];
-	u8	EEPROMChnlAreaTxPwrHT40_1S[2][3];
+	u8	EEPROMChnlAreaTxPwrCCK[2][3];	
+	u8	EEPROMChnlAreaTxPwrHT40_1S[2][3];	
 	u8	EEPROMChnlAreaTxPwrHT40_2SDiff[2][3];
 	u8	EEPROMPwrLimitHT20[3];
 	u8	EEPROMPwrLimitHT40[3];
@@ -572,7 +572,7 @@ struct hal_data_8192ce
 
 	u8	TxPwrLevelCck[RF_PATH_MAX][CHANNEL_MAX_NUMBER];
 	u8	TxPwrLevelHT40_1S[RF_PATH_MAX][CHANNEL_MAX_NUMBER];	// For HT 40MHZ pwr
-	u8	TxPwrLevelHT40_2S[RF_PATH_MAX][CHANNEL_MAX_NUMBER];	// For HT 40MHZ pwr
+	u8	TxPwrLevelHT40_2S[RF_PATH_MAX][CHANNEL_MAX_NUMBER];	// For HT 40MHZ pwr	
 	s8	TxPwrHt20Diff[RF_PATH_MAX][CHANNEL_MAX_NUMBER];// HT 20<->40 Pwr diff
 	u8	TxPwrLegacyHtDiff[RF_PATH_MAX][CHANNEL_MAX_NUMBER];// For HT<->legacy pwr diff
 	// For power group
@@ -635,7 +635,7 @@ struct hal_data_8192ce
 	u32	RegBcnCtrlVal;
 	u8	RegFwHwTxQCtrl;
 	u8	RegReg542;
-	u8	CurAntenna;
+	u8	CurAntenna;	
 	u8	AntDivCfg;
 
 #ifdef CONFIG_SW_ANTENNA_DIVERSITY
@@ -666,7 +666,7 @@ struct hal_data_8192ce
 	u8	FwRsvdPageStartOffset; //2010.06.23. Added by tynli. Reserve page start offset except beacon in TxQ.
 
 	u16	EfuseUsedBytes;
-
+	
 #ifdef CONFIG_P2P
 	struct P2P_PS_Offload_t	p2p_ps_offload;
 #endif //CONFIG_P2P
@@ -741,7 +741,7 @@ struct hal_data_8192cu
 
 	u8	TxPwrLevelCck[RF_PATH_MAX][CHANNEL_MAX_NUMBER];
 	u8	TxPwrLevelHT40_1S[RF_PATH_MAX][CHANNEL_MAX_NUMBER];	// For HT 40MHZ pwr
-	u8	TxPwrLevelHT40_2S[RF_PATH_MAX][CHANNEL_MAX_NUMBER];	// For HT 40MHZ pwr
+	u8	TxPwrLevelHT40_2S[RF_PATH_MAX][CHANNEL_MAX_NUMBER];	// For HT 40MHZ pwr	
 	s8	TxPwrHt20Diff[RF_PATH_MAX][CHANNEL_MAX_NUMBER];// HT 20<->40 Pwr diff
 	u8	TxPwrLegacyHtDiff[RF_PATH_MAX][CHANNEL_MAX_NUMBER];// For HT<->legacy pwr diff
 	// For power group
@@ -805,12 +805,12 @@ struct hal_data_8192cu
 	struct dm_priv	dmpriv;
 #ifdef DBG_CONFIG_ERROR_DETECT
 	struct sreset_priv srestpriv;
-#endif
+#endif	
 
 #ifdef CONFIG_BT_COEXIST
 	struct btcoexist_priv	bt_coexist;
 #endif
-	u8	CurAntenna;
+	u8	CurAntenna;	
 	u8	AntDivCfg;
 
 #ifdef CONFIG_SW_ANTENNA_DIVERSITY
@@ -932,3 +932,6 @@ struct hal_data_8192cu
 extern void Hal_SetOFDMContinuousTx(PADAPTER pAdapter, u8 bStart);
 
 #endif
+
+
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_led.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_led.h
old mode 100644
new mode 100755
index 88002db..1ccf935
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_led.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_led.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -39,3 +39,4 @@
 #endif
 
 #endif
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_recv.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_recv.h
old mode 100644
new mode 100755
index 9cfca91..d5656f5
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_recv.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_recv.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -125,10 +125,10 @@ struct phy_stat
 	unsigned char idle_long:1;
 	unsigned char r_ant_train_en:1;
 	unsigned char ANTSELB:1;
-	unsigned char ANTSEL:1;
+	unsigned char ANTSEL:1;	
 #else	// _BIG_ENDIAN_
 	//unsigned char rsvd:4;
-	unsigned char ANTSEL:1;
+	unsigned char ANTSEL:1;	
 	unsigned char ANTSELB:1;
 	unsigned char r_ant_train_en:1;
 	unsigned char idle_long:1;
@@ -181,3 +181,4 @@ struct phy_stat
 void rtl8192c_query_rx_desc_status(union recv_frame *precvframe, struct recv_stat *pdesc);
 
 #endif
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_rf.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_rf.h
old mode 100644
new mode 100755
index 7e22503..26c678a
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_rf.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_rf.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -18,24 +18,24 @@
  *
  ******************************************************************************/
 /******************************************************************************
- *
- *
+ * 
+ * 
  * Module:	rtl8192c_rf.h	( Header File)
- *
- * Note:	Collect every HAL RF type exter API or constant.
- *
- * Function:
- *
- * Export:
- *
- * Abbrev:
- *
+ * 
+ * Note:	Collect every HAL RF type exter API or constant.	 
+ *
+ * Function:	
+ * 		 
+ * Export:	
+ * 
+ * Abbrev:	
+ * 
  * History:
  * Data			Who		Remark
- *
+ * 
  * 09/25/2008	MHC		Create initial version.
- *
- *
+ * 
+ * 
 ******************************************************************************/
 #ifndef _RTL8192C_RF_H_
 #define _RTL8192C_RF_H_
@@ -53,9 +53,9 @@
 /*--------------------------Define Parameters-------------------------------*/
 
 
-/*------------------------------Define structure----------------------------*/
+/*------------------------------Define structure----------------------------*/ 
 
-/*------------------------------Define structure----------------------------*/
+/*------------------------------Define structure----------------------------*/ 
 
 
 /*------------------------Export global variable----------------------------*/
@@ -71,11 +71,11 @@
 //
 // RF RL6052 Series API
 //
-void		rtl8192c_RF_ChangeTxPath(	IN	PADAPTER	Adapter,
+void		rtl8192c_RF_ChangeTxPath(	IN	PADAPTER	Adapter, 
 										IN	u16		DataRate);
-void		rtl8192c_PHY_RF6052SetBandwidth(
+void		rtl8192c_PHY_RF6052SetBandwidth(	
 										IN	PADAPTER				Adapter,
-										IN	HT_CHANNEL_WIDTH		Bandwidth);
+										IN	HT_CHANNEL_WIDTH		Bandwidth);	
 VOID	rtl8192c_PHY_RF6052SetCckTxPower(
 										IN	PADAPTER	Adapter,
 										IN	u8*		pPowerlevel);
@@ -89,3 +89,4 @@ VOID	rtl8192c_PHY_RF6052SetOFDMTxPower(
 
 
 #endif/* End of HalRf.h */
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_spec.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_spec.h
old mode 100644
new mode 100755
index c45a140..8ff13a7
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_spec.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_spec.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -208,7 +208,7 @@
 //
 //-----------------------------------------------------
 #define	REG_PCIE_CTRL_REG			0x0300
-#define	REG_INT_MIG				0x0304	// Interrupt Migration
+#define	REG_INT_MIG				0x0304	// Interrupt Migration 
 #define	REG_BCNQ_DESA				0x0308	// TX Beacon Descriptor Address
 #define	REG_HQ_DESA				0x0310	// TX High Queue Descriptor Address
 #define	REG_MGQ_DESA				0x0318	// TX Manage Queue Descriptor Address
@@ -328,7 +328,7 @@
 #define REG_ATIMWND				0x055A
 #define REG_BCN_MAX_ERR			0x055D
 #define REG_RXTSF_OFFSET_CCK		0x055E
-#define REG_RXTSF_OFFSET_OFDM		0x055F
+#define REG_RXTSF_OFFSET_OFDM		0x055F	
 #define REG_TSFTR					0x0560
 #define REG_TSFTR1					0x0568
 #define REG_INIT_TSFTR				0x0564
@@ -520,7 +520,7 @@
 #define	GPIO_MOD					(REG_GPIO_PIN_CTRL+3)
 
 //----------------------------------------------------------------------------
-//       8192C (MSR) Media Status Register	(Offset 0x4C, 8 bits)
+//       8192C (MSR) Media Status Register	(Offset 0x4C, 8 bits)  
 //----------------------------------------------------------------------------
 /*
 Network Type
@@ -548,16 +548,16 @@
 #define	RRSR_RSC_LOWSUBCHNL		0x200000
 #define	RRSR_SHORT					0x800000
 #define	RRSR_1M					BIT0
-#define	RRSR_2M					BIT1
-#define	RRSR_5_5M					BIT2
-#define	RRSR_11M					BIT3
-#define	RRSR_6M					BIT4
-#define	RRSR_9M					BIT5
-#define	RRSR_12M					BIT6
-#define	RRSR_18M					BIT7
-#define	RRSR_24M					BIT8
-#define	RRSR_36M					BIT9
-#define	RRSR_48M					BIT10
+#define	RRSR_2M					BIT1 
+#define	RRSR_5_5M					BIT2 
+#define	RRSR_11M					BIT3 
+#define	RRSR_6M					BIT4 
+#define	RRSR_9M					BIT5 
+#define	RRSR_12M					BIT6 
+#define	RRSR_18M					BIT7 
+#define	RRSR_24M					BIT8 
+#define	RRSR_36M					BIT9 
+#define	RRSR_48M					BIT10 
 #define	RRSR_54M					BIT11
 #define	RRSR_MCS0					BIT12
 #define	RRSR_MCS1					BIT13
@@ -567,7 +567,7 @@
 #define	RRSR_MCS5					BIT17
 #define	RRSR_MCS6					BIT18
 #define	RRSR_MCS7					BIT19
-#define	BRSR_AckShortPmb			BIT23
+#define	BRSR_AckShortPmb			BIT23	
 // CCK ACK: use Short Preamble or not
 
 
@@ -579,7 +579,7 @@
 #define	RATR_2M					0x00000002
 #define	RATR_55M					0x00000004
 #define	RATR_11M					0x00000008
-//OFDM
+//OFDM 		
 #define	RATR_6M					0x00000010
 #define	RATR_9M					0x00000020
 #define	RATR_12M					0x00000040
@@ -588,7 +588,7 @@
 #define	RATR_36M					0x00000200
 #define	RATR_48M					0x00000400
 #define	RATR_54M					0x00000800
-//MCS 1 Spatial Stream
+//MCS 1 Spatial Stream	
 #define	RATR_MCS0					0x00001000
 #define	RATR_MCS1					0x00002000
 #define	RATR_MCS2					0x00004000
@@ -623,19 +623,19 @@
 #define	CAM_USEDK					BIT5
 
 #define	CAM_CONTENT_COUNT 		8
-
+       	       		
 #define	CAM_NONE					0x0
 #define	CAM_WEP40					0x01
 #define	CAM_TKIP					0x02
 #define	CAM_AES					0x04
 #define	CAM_WEP104				0x05
-
+        		
 #define	TOTAL_CAM_ENTRY			32
-#define	HALF_CAM_ENTRY			16
-
+#define	HALF_CAM_ENTRY			16	
+       		
 #define	CAM_CONFIG_USEDK			_TRUE
 #define	CAM_CONFIG_NO_USEDK		_FALSE
-
+       		
 #define	CAM_WRITE					BIT16
 #define	CAM_READ					0x00000000
 #define	CAM_POLLINIG				BIT31
@@ -670,7 +670,7 @@
 #define	IMR_TIMEOUT2					BIT17		// Timeout interrupt 2
 #define	IMR_TIMEOUT1					BIT16		// Timeout interrupt 1
 #define	IMR_TXFOVW					BIT15		// Transmit FIFO Overflow
-#define	IMR_PSTIMEOUT					BIT14		// Power save time out interrupt
+#define	IMR_PSTIMEOUT					BIT14		// Power save time out interrupt 
 #define	IMR_BcnInt						BIT13		// Beacon DMA Interrupt 0
 #define	IMR_RXFOVW					BIT12		// Receive FIFO Overflow
 #define	IMR_RDU						BIT11		// Receive Descriptor Unavailable
@@ -815,7 +815,7 @@
 
 #define EEPROM_NORMAL_BoardType			EEPROM_RF_OPT1	//[7:5]
 
-#endif
+#endif 
 
 #ifdef CONFIG_USB_HCI
 
@@ -894,7 +894,7 @@
 
 #define EEPROM_TxPowerCCK						0x5A // CCK Tx Power
 
-// 2009/02/09 Cosa Add for SD3 requirement
+// 2009/02/09 Cosa Add for SD3 requirement 
 #define EEPROM_TX_PWR_HT20_DIFF				0x6e// HT20 Tx Power Index Difference
 #define DEFAULT_HT20_TXPWR_DIFF				2	// HT20<->40 default Tx Power Index Difference
 #define EEPROM_TX_PWR_OFDM_DIFF				0x71// OFDM Tx Power Index Difference
@@ -996,7 +996,7 @@
 
 /*===================================================================
 =====================================================================
-Here the register defines are for 92C. When the define is as same with 92C,
+Here the register defines are for 92C. When the define is as same with 92C, 
 we will use the 92C's define for the consistency
 So the following defines for 92C is not entire!!!!!!
 =====================================================================
@@ -1033,23 +1033,23 @@
 #define	RCR_ACF					BIT12		//Accept control type frame
 #define	RCR_ADF					BIT11		//Accept data type frame
 #define	RCR_AICV					BIT9		//Accept ICV error packet
-#define	RCR_ACRC32					BIT8		//Accept CRC32 error packet
+#define	RCR_ACRC32					BIT8		//Accept CRC32 error packet 
 #define	RCR_CBSSID_BCN			BIT7		//Accept BSSID match packet (Rx beacon, probe rsp)
 #define	RCR_CBSSID_DATA			BIT6		//Accept BSSID match packet (Data)
 #define	RCR_CBSSID					RCR_CBSSID_DATA		//Accept BSSID match packet
 #define	RCR_APWRMGT				BIT5		//Accept power management packet
 #define	RCR_ADD3					BIT4		//Accept address 3 match packet
-#define	RCR_AB						BIT3		//Accept broadcast packet
-#define	RCR_AM						BIT2		//Accept multicast packet
+#define	RCR_AB						BIT3		//Accept broadcast packet 
+#define	RCR_AM						BIT2		//Accept multicast packet 
 #define	RCR_APM					BIT1		//Accept physical match packet
-#define	RCR_AAP					BIT0		//Accept all unicast packet
+#define	RCR_AAP					BIT0		//Accept all unicast packet 
 #define	RCR_MXDMA_OFFSET			8
 #define	RCR_FIFO_OFFSET			13
 
 
 
 //============================================================================
-//       8192c USB specific Regsiter Offset and Content definition,
+//       8192c USB specific Regsiter Offset and Content definition, 
 //       2009.08.18, added by vivi. for merge 92c and 92C into one driver
 //============================================================================
 //#define APS_FSMCO				0x0004  same with 92Ce
@@ -1080,7 +1080,7 @@
 #define	InvalidBBRFValue			0x12345678
 
 //============================================================================
-//       8192C Regsiter Bit and Content definition
+//       8192C Regsiter Bit and Content definition 
 //============================================================================
 //-----------------------------------------------------
 //
@@ -1293,7 +1293,7 @@
 #define EFUSE_ACCESS_ON			0x69	// For RTL8723 only.
 #define EFUSE_ACCESS_OFF			0x00	// For RTL8723 only.
 
-//2 PWR_DATA
+//2 PWR_DATA 
 
 //2 CAL_TIMER
 
@@ -1324,7 +1324,7 @@
 //2 GPIO_INTM
 
 //2 LEDCFG
-#define LED0PL 						BIT(4)
+#define LED0PL 						BIT(4)  
 #define LED0DIS						BIT(7)
 #define LED1DIS						BIT(15)
 #define LED1PL 						BIT(12)
@@ -1380,7 +1380,7 @@
 //2REG_GPIO_OUTSTS (For RTL8723 only)
 #define	EFS_HCI_SEL				(BIT(0)|BIT(1))
 #define	PAD_HCI_SEL				(BIT(2)|BIT(3))
-#define	HCI_SEL						(BIT(4)|BIT(5))
+#define	HCI_SEL						(BIT(4)|BIT(5)) 
 #define	PKG_SEL_HCI				BIT(6)
 #define	FEN_GPS					BIT(7)
 #define	FEN_BT						BIT(8)
@@ -1476,7 +1476,7 @@
 // For normal driver, 0x10C
 #define _TXDMA_HIQ_MAP(x) 	 		(((x)&0x3) << 14)
 #define _TXDMA_MGQ_MAP(x) 	 		(((x)&0x3) << 12)
-#define _TXDMA_BKQ_MAP(x) 	 		(((x)&0x3) << 10)
+#define _TXDMA_BKQ_MAP(x) 	 		(((x)&0x3) << 10)		
 #define _TXDMA_BEQ_MAP(x) 	 		(((x)&0x3) << 8 )
 #define _TXDMA_VIQ_MAP(x) 	 		(((x)&0x3) << 6 )
 #define _TXDMA_VOQ_MAP(x) 	 		(((x)&0x3) << 4 )
@@ -1862,3 +1862,4 @@
 #include "basic_types.h"
 
 #endif
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_sreset.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_sreset.h
old mode 100644
new mode 100755
index 6f5b953..20e88b5
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_sreset.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_sreset.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_xmit.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_xmit.h
old mode 100644
new mode 100755
index 9abbae9..7d2059d
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_xmit.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192c_xmit.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -126,3 +126,4 @@ struct txrpt_ccx_8192c {
 #endif
 
 #endif
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_cmd.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_cmd.h
old mode 100644
new mode 100755
index 8a8873a..ad7e783
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_cmd.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_cmd.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -22,7 +22,7 @@
 
 
 //--------------------------------------------
-//3				Host Message Box
+//3				Host Message Box 
 //--------------------------------------------
 
 // User Define Message [31:8]
@@ -63,7 +63,7 @@ struct P2P_PS_Offload_t {
 
 // Description: Determine the types of H2C commands that are the same in driver and Fw.
 // Fisrt constructed by tynli. 2009.10.09.
-typedef enum _RTL8192D_H2C_CMD
+typedef enum _RTL8192D_H2C_CMD 
 {
 	H2C_AP_OFFLOAD = 0,		/*0*/
 	H2C_SETPWRMODE = 1,		/*1*/
@@ -116,7 +116,7 @@ struct cmd_msg_parm {
 typedef struct _SETWOWLAN_PARM{
 	u8 	mode;
 	u8 	gpio_index;
-	u8	gpio_duration;
+	u8	gpio_duration;	
 	u8  second_mode;
 	u8  reserve;
 }SETWOWLAN_PARM, *PSETWOWLAN_PARM;
@@ -138,3 +138,5 @@ struct cmd_msg_parm {
 #endif // CONFIG_WOWLAN
 
 #endif	// __RTL8192D_CMD_H_
+
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_dm.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_dm.h
old mode 100644
new mode 100755
index eaf1e4f..ab5e5f7
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_dm.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_dm.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -57,14 +57,14 @@
 	u8		CurRFState;
 
 	//int		Rssi_val_min;
-
+	
 }PS_T,*pPS_T;
 
 typedef struct _Dynamic_Initial_Gain_Threshold_
 {
 	u8		Dig_Enable_Flag;
 	u8		Dig_Ext_Port_Stage;
-
+	
 	int		RssiLowThresh;
 	int		RssiHighThresh;
 
@@ -141,7 +141,7 @@
 
 typedef enum tag_DIG_Connect_Definition
 {
-	DIG_STA_DISCONNECT = 0,
+	DIG_STA_DISCONNECT = 0,	
 	DIG_STA_CONNECT = 1,
 	DIG_STA_BEFORE_CONNECT = 2,
 	DIG_MultiSTA_DISCONNECT = 3,
@@ -193,7 +193,7 @@
 #define		TX_POWER_NEAR_FIELD_THRESH_LVL2	74
 #define		TX_POWER_NEAR_FIELD_THRESH_LVL1	67
 
-#define		TxHighPwrLevel_Normal		0
+#define		TxHighPwrLevel_Normal		0	
 #define		TxHighPwrLevel_Level1		1
 #define		TxHighPwrLevel_Level2		2
 #define		TxHighPwrLevel_BT1			3
@@ -211,14 +211,14 @@
 {
 	u8				RateAdaptiveDisabled;
 	u8				RATRState;
-	u16				reserve;
-
+	u16				reserve;	
+	
 	u32				HighRSSIThreshForRA;
 	u32				High2LowRSSIThreshForRA;
 	u8				Low2HighRSSIThreshForRA40M;
-	u32				LowRSSIThreshForRA40M;
+	u32				LowRSSIThreshForRA40M;	
 	u8				Low2HighRSSIThreshForRA20M;
-	u32				LowRSSIThreshForRA20M;
+	u32				LowRSSIThreshForRA20M;	
 	u32				UpperRSSIThresholdRATR;
 	u32				MiddleRSSIThresholdRATR;
 	u32				LowRSSIThresholdRATR;
@@ -229,7 +229,7 @@
 	u32				PingRSSIThreshForRA;//cosa add for Netcore long range ping issue
 	u32				LastRATR;
 	u8				PreRATRState;
-
+	
 } RATE_ADAPTIVE, *PRATE_ADAPTIVE;
 
 typedef enum tag_SW_Antenna_Switch_Definition
@@ -240,7 +240,7 @@
 }DM_SWAS_E;
 
 // 20100514 Joseph: Add definition for antenna switching test after link.
-// This indicates two different the steps.
+// This indicates two different the steps. 
 // In SWAW_STEP_PEAK, driver needs to switch antenna and listen to the signal on the air.
 // In SWAW_STEP_DETERMINE, driver just compares the signal captured in SWAW_STEP_PEAK
 // with original RSSI to determine if it is necessary to switch antenna.
@@ -255,7 +255,7 @@
 //=============================
 //Neil Chen---2011--06--15--
 //==============================
-//3 PathDiv
+//3 PathDiv 
 typedef struct _SW_Antenna_Switch_
 {
 	u8		try_flag;
@@ -273,7 +273,7 @@
 }SWAT_T, *pSWAT_T;
 //========================================
 
-struct 	dm_priv
+struct 	dm_priv	
 {
 	u8	DM_Type;
 	u8	DMFlag, DMFlag_tmp;
@@ -285,8 +285,8 @@ struct 	dm_priv
 
 	PS_T	DM_PSTable;
 
-	FALSE_ALARM_STATISTICS	FalseAlmCnt;
-
+	FALSE_ALARM_STATISTICS	FalseAlmCnt;	
+	
 	//for rate adaptive, in fact,  88c/92c fw will handle this
 	u8	bUseRAMask;
 	RATE_ADAPTIVE	RateAdaptive;
@@ -311,11 +311,11 @@ struct 	dm_priv
 	u8	bDynamicTxPowerEnable;
 	u8	LastDTPLvl;
 	u8	DynamicTxHighPowerLvl;//Add by Jacken Tx Power Control for Near/Far Range 2008/03/06
-
+		
 	//for tx power tracking
 	u8	bTXPowerTracking;
 	u8	TXPowercount;
-	u8	bTXPowerTrackingInit;
+	u8	bTXPowerTrackingInit;	
 	u8	TxPowerTrackControl;	//for mp mode, turn off txpwrtracking as default
 	u8	TM_Trigger;
 
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_hal.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_hal.h
old mode 100644
new mode 100755
index 347337c..1ab5f98
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_hal.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_hal.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -43,7 +43,7 @@
 #define RF_REG_NUM_for_C_CUT_5G 	6
 #define RF_REG_NUM_for_C_CUT_5G_internalPA	7
 #define RF_REG_NUM_for_C_CUT_2G 	5
-#define RF_CHNL_NUM_5G			19
+#define RF_CHNL_NUM_5G			19	
 #define RF_CHNL_NUM_5G_40M		17
 #define TARGET_CHNL_NUM_5G	221
 #define TARGET_CHNL_NUM_2G	14
@@ -53,28 +53,28 @@
 //static u32	 RF_REG_FOR_5G_SWCHNL[MAX_RF_IMR_INDEX]={0,0x2f,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x38,0x39,0x0};
 static u32	   RF_REG_FOR_5G_SWCHNL_NORMAL[MAX_RF_IMR_INDEX_NORMAL]={0,0x2f,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x0};
 
-static u8	RF_REG_for_C_CUT_5G[RF_REG_NUM_for_C_CUT_5G] =
+static u8	RF_REG_for_C_CUT_5G[RF_REG_NUM_for_C_CUT_5G] = 
 			{RF_SYN_G1, RF_SYN_G2,	RF_SYN_G3,	RF_SYN_G4,	RF_SYN_G5,	RF_SYN_G6};
 
-static u8	RF_REG_for_C_CUT_5G_internalPA[RF_REG_NUM_for_C_CUT_5G_internalPA] =
+static u8	RF_REG_for_C_CUT_5G_internalPA[RF_REG_NUM_for_C_CUT_5G_internalPA] = 
 			{0x0B,	0x48,	0x49,	0x4B,	0x03,	0x04,	0x0E};
-static u8	RF_REG_for_C_CUT_2G[RF_REG_NUM_for_C_CUT_2G] =
+static u8	RF_REG_for_C_CUT_2G[RF_REG_NUM_for_C_CUT_2G] = 
 			{RF_SYN_G1, RF_SYN_G2,	RF_SYN_G3,	RF_SYN_G7,	RF_SYN_G8};
 
 #if DBG
-static u32	RF_REG_MASK_for_C_CUT_2G[RF_REG_NUM_for_C_CUT_2G] =
-			{BIT19|BIT18|BIT17|BIT14|BIT1,	BIT10|BIT9,
-			BIT18|BIT17|BIT16|BIT1, 	BIT2|BIT1,
+static u32	RF_REG_MASK_for_C_CUT_2G[RF_REG_NUM_for_C_CUT_2G] = 
+			{BIT19|BIT18|BIT17|BIT14|BIT1,	BIT10|BIT9, 
+			BIT18|BIT17|BIT16|BIT1, 	BIT2|BIT1,	
 			BIT15|BIT14|BIT13|BIT12|BIT11};
 #endif	//amy, temp remove
-static u8	RF_CHNL_5G[RF_CHNL_NUM_5G] =
+static u8	RF_CHNL_5G[RF_CHNL_NUM_5G] = 
 			{36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140};
-static u8	RF_CHNL_5G_40M[RF_CHNL_NUM_5G_40M] =
+static u8	RF_CHNL_5G_40M[RF_CHNL_NUM_5G_40M] = 
 			{38,42,46,50,54,58,62,102,106,110,114,118,122,126,130,134,138};
 
 static u32	RF_REG_Param_for_C_CUT_5G[5][RF_REG_NUM_for_C_CUT_5G] = {
 			{0xE43BE,	0xFC638,	0x77C0A,	0xDE471,	0xd7110,	0x8EB04},
-			{0xE43BE,	0xFC078,	0xF7C1A,	0xE0C71,	0xD7550,	0xAEB04},
+			{0xE43BE,	0xFC078,	0xF7C1A,	0xE0C71,	0xD7550,	0xAEB04},	
 			{0xE43BF,	0xFF038,	0xF7C0A,	0xDE471,	0xE5550,	0xAEB04},
 			{0xE43BF,	0xFF079,	0xF7C1A,	0xDE471,	0xE5550,	0xAEB04},
 			{0xE43BF,	0xFF038,	0xF7C1A,	0xDE471,	0xd7550,	0xAEB04}};
@@ -90,7 +90,7 @@
 
 static u32	RF_REG_Param_for_C_CUT_5G_internalPA[3][RF_REG_NUM_for_C_CUT_5G_internalPA] = {
 			{0x01a00,	0x40443,	0x00eb5,	0x89bec,	0x94a12,	0x94a12,	0x94a12},
-			{0x01800,	0xc0443,	0x00730,	0x896ee,	0x94a52,	0x94a52,	0x94a52},
+			{0x01800,	0xc0443,	0x00730,	0x896ee,	0x94a52,	0x94a52,	0x94a52},	
 			{0x01800,	0xc0443,	0x00730,	0x896ee,	0x94a12,	0x94a12,	0x94a12}};
 
 
@@ -174,14 +174,14 @@
 	#define RTL8192D_PHY_REG					"rtl8192DE\\PHY_REG.txt"
 	#define RTL8192D_PHY_REG_PG				"rtl8192DE\\PHY_REG_PG.txt"
 	#define RTL8192D_PHY_REG_MP				"rtl8192DE\\PHY_REG_MP.txt"
-
+	
 	#define RTL8192D_AGC_TAB					"rtl8192DE\\AGC_TAB.txt"
 	#define RTL8192D_AGC_TAB_2G				"rtl8192DE\\AGC_TAB_2G.txt"
 	#define RTL8192D_AGC_TAB_5G				"rtl8192DE\\AGC_TAB_5G.txt"
 	#define RTL8192D_PHY_RADIO_A				"rtl8192DE\\radio_a.txt"
 	#define RTL8192D_PHY_RADIO_B				"rtl8192DE\\radio_b.txt"
 	#define RTL8192D_PHY_RADIO_A_intPA		"rtl8192DE\\radio_a_intPA.txt"
-	#define RTL8192D_PHY_RADIO_B_intPA		"rtl8192DE\\radio_b_intPA.txt"
+	#define RTL8192D_PHY_RADIO_B_intPA		"rtl8192DE\\radio_b_intPA.txt"			
 	#define RTL8192D_PHY_MACREG				"rtl8192DE\\MAC_REG.txt"
 
 //---------------------------------------------------------------------
@@ -198,7 +198,7 @@
 	#define Rtl8192D_AGCTAB_2GArray			Rtl8192DEAGCTAB_2GArray
 	#define Rtl8192D_AGCTAB_2TArray 			Rtl8192DEAGCTAB_2TArray
 	#define Rtl8192D_AGCTAB_1TArray 			Rtl8192DEAGCTAB_1TArray
-	#define Rtl8192D_PHY_REG_2TArray			Rtl8192DEPHY_REG_2TArray
+	#define Rtl8192D_PHY_REG_2TArray			Rtl8192DEPHY_REG_2TArray		
 	#define Rtl8192D_PHY_REG_1TArray			Rtl8192DEPHY_REG_1TArray
 	#define Rtl8192D_PHY_REG_Array_PG			Rtl8192DEPHY_REG_Array_PG
 	#define Rtl8192D_PHY_REG_Array_MP			Rtl8192DEPHY_REG_Array_MP
@@ -241,8 +241,8 @@
 
 	#define RTL8192D_PHY_REG					"rtl8192DU\\PHY_REG.txt"
 	#define RTL8192D_PHY_REG_PG				"rtl8192DU\\PHY_REG_PG.txt"
-	#define RTL8192D_PHY_REG_MP				"rtl8192DU\\PHY_REG_MP.txt"
-
+	#define RTL8192D_PHY_REG_MP				"rtl8192DU\\PHY_REG_MP.txt"			
+	
 	#define RTL8192D_AGC_TAB					"rtl8192DU\\AGC_TAB.txt"
 	#define RTL8192D_AGC_TAB_2G				"rtl8192DU\\AGC_TAB_2G.txt"
 	#define RTL8192D_AGC_TAB_5G				"rtl8192DU\\AGC_TAB_5G.txt"
@@ -255,7 +255,7 @@
 //---------------------------------------------------------------------
 //		RTL8192DU From header
 //---------------------------------------------------------------------
-
+		
 	// Fw Array
 	#define Rtl8192D_FwImageArray 					Rtl8192DUFwImgArray
 #ifdef CONFIG_WOWLAN
@@ -268,7 +268,7 @@
 	#define Rtl8192D_AGCTAB_2GArray				Rtl8192DUAGCTAB_2GArray
 	#define Rtl8192D_AGCTAB_2TArray 				Rtl8192DUAGCTAB_2TArray
 	#define Rtl8192D_AGCTAB_1TArray 				Rtl8192DUAGCTAB_1TArray
-	#define Rtl8192D_PHY_REG_2TArray				Rtl8192DUPHY_REG_2TArray
+	#define Rtl8192D_PHY_REG_2TArray				Rtl8192DUPHY_REG_2TArray			
 	#define Rtl8192D_PHY_REG_1TArray				Rtl8192DUPHY_REG_1TArray
 	#define Rtl8192D_PHY_REG_Array_PG				Rtl8192DUPHY_REG_Array_PG
 	#define Rtl8192D_PHY_REG_Array_MP				Rtl8192DUPHY_REG_Array_MP
@@ -278,7 +278,7 @@
 	#define Rtl8192D_RadioB_1TArray					Rtl8192DURadioB_1TArray
 	#define Rtl8192D_RadioA_2T_intPAArray			Rtl8192DURadioA_2T_intPAArray
 	#define Rtl8192D_RadioB_2T_intPAArray 			Rtl8192DURadioB_2T_intPAArray
-
+	
 	// Array length
 	#define Rtl8192D_FwImageArrayLength			Rtl8192DUImgArrayLength
 	#define Rtl8192D_MAC_ArrayLength				Rtl8192DUMAC_2T_ArrayLength
@@ -293,7 +293,7 @@
 	#define Rtl8192D_PHY_REG_Array_MPLength		Rtl8192DUPHY_REG_Array_MPLength
 	#define Rtl8192D_RadioA_2TArrayLength			Rtl8192DURadioA_2TArrayLength
 	#define Rtl8192D_RadioB_2TArrayLength			Rtl8192DURadioB_2TArrayLength
-	#define Rtl8192D_RadioA_2T_intPAArrayLength		Rtl8192DURadioA_2T_intPAArrayLength
+	#define Rtl8192D_RadioA_2T_intPAArrayLength		Rtl8192DURadioA_2T_intPAArrayLength			
 	#define Rtl8192D_RadioB_2T_intPAArrayLength		Rtl8192DURadioB_2T_intPAArrayLength
 
 	// The file name "_2T" is for 92CU, "_1T"  is for 88CU. Modified by tynli. 2009.11.24.
@@ -322,7 +322,7 @@
 #define PageNum_128(_Len)		(u32)(((_Len)>>7) + ((_Len)&0x7F ? 1:0))
 
 //
-// Check if FW header exists. We do not consider the lower 4 bits in this case.
+// Check if FW header exists. We do not consider the lower 4 bits in this case. 
 // By tynli. 2009.12.04.
 //
 #define IS_FW_HEADER_EXIST(_pFwHdr)	((le16_to_cpu(_pFwHdr->Signature)&0xFFF0) == 0x92C0 ||\
@@ -390,7 +390,7 @@
 #define BCN_DMA_ATIME_INT_TIME		0x02
 
 typedef	enum _BT_CoType{
-	BT_2Wire			= 0,
+	BT_2Wire			= 0,		
 	BT_ISSC_3Wire	= 1,
 	BT_Accel			= 2,
 	BT_CSR			= 3,
@@ -399,12 +399,12 @@
 } BT_CoType, *PBT_CoType;
 
 typedef	enum _BT_CurState{
-	BT_OFF		= 0,
+	BT_OFF		= 0,	
 	BT_ON		= 1,
 } BT_CurState, *PBT_CurState;
 
 typedef	enum _BT_ServiceType{
-	BT_SCO			= 0,
+	BT_SCO			= 0,	
 	BT_A2DP			= 1,
 	BT_HID			= 2,
 	BT_HID_Idle		= 3,
@@ -416,7 +416,7 @@
 } BT_ServiceType, *PBT_ServiceType;
 
 typedef	enum _BT_RadioShared{
-	BT_Radio_Shared 	= 0,
+	BT_Radio_Shared 	= 0,	
 	BT_Radio_Individual	= 1,
 } BT_RadioShared, *PBT_RadioShared;
 
@@ -428,7 +428,7 @@
 	u8					BT_CUR_State;		//0:on, 1:off
 	u8					BT_Ant_isolation;	//0:good, 1:bad
 	u8					BT_PapeCtrl;		//0:SW, 1:SW/HW dynamic
-	u8					BT_Service;
+	u8					BT_Service;			
 	u8					BT_RadioSharedType;
 	u8					Ratio_Tx;
 	u8					Ratio_PRI;
@@ -439,10 +439,10 @@
 	BOOLEAN 	bIQKDone;
 #if 1
 	int		Value[1][IQK_Matrix_REG_NUM];
-#else
+#else	
 	u32		Mark[IQK_Matrix_REG_NUM];
 	u32		Value[IQK_Matrix_REG_NUM];
-#endif
+#endif	
 }IQK_MATRIX_REGS_SETTING,*PIQK_MATRIX_REGS_SETTING;
 
 #ifdef CONFIG_USB_RX_AGGREGATION
@@ -549,7 +549,7 @@
 #define IC_TYPE_MASK					(BIT(0)|BIT(1)|BIT(2))
 #define CHIP_TYPE_MASK 				BIT(3)
 #define RF_TYPE_MASK					(BIT(4)|BIT(5)|BIT(6))
-#define MANUFACTUER_MASK			BIT(7)
+#define MANUFACTUER_MASK			BIT(7)	
 #define ROM_VERSION_MASK				(BIT(11)|BIT(10)|BIT(9)|BIT(8))
 #define CUT_VERSION_MASK				(BIT(15)|BIT(14)|BIT(13)|BIT(12))
 
@@ -572,7 +572,7 @@
 #define IS_92C_SERIAL(version)   				((IS_81XXC(version) && IS_2T2R(version)) ? _TRUE : _FALSE)
 #define IS_VENDOR_UMC_A_CUT(version)		((IS_CHIP_VENDOR_UMC(version)) ? ((GET_CVID_CUT_VERSION(version)) ? _FALSE : _TRUE) : _FALSE)
 #define IS_VENDOR_8723_A_CUT(version)		((IS_8723_SERIES(version)) ? ((GET_CVID_CUT_VERSION(version)) ? _FALSE : _TRUE) : _FALSE)
-// <tynli_Note> 88/92C UMC B-cut vendor is set to TSMC so we need to check CHIP_VENDOR_UMC bit is not 1.
+// <tynli_Note> 88/92C UMC B-cut vendor is set to TSMC so we need to check CHIP_VENDOR_UMC bit is not 1. 
 #define IS_81xxC_VENDOR_UMC_B_CUT(version)	((IS_CHIP_VENDOR_UMC(version)) ? ((GET_CVID_CUT_VERSION(version) == B_CUT_VERSION) ? _TRUE : _FALSE):_FALSE)
 #define IS_92D_SINGLEPHY(version)     			((IS_92D(version)) ? (IS_2T2R(version) ? _TRUE: _FALSE) : _FALSE)
 
@@ -585,17 +585,17 @@
 	VERSION_TEST_CHIP_88C = 0x0000,
 	VERSION_TEST_CHIP_92C = 0x0020,
 	VERSION_TEST_UMC_CHIP_8723 = 0x0081,
-	VERSION_NORMAL_TSMC_CHIP_88C = 0x0008,
+	VERSION_NORMAL_TSMC_CHIP_88C = 0x0008, 
 	VERSION_NORMAL_TSMC_CHIP_92C = 0x0028,
 	VERSION_NORMAL_TSMC_CHIP_92C_1T2R = 0x0018,
 	VERSION_NORMAL_UMC_CHIP_88C_A_CUT = 0x0088,
 	VERSION_NORMAL_UMC_CHIP_92C_A_CUT = 0x00a8,
-	VERSION_NORMAL_UMC_CHIP_92C_1T2R_A_CUT = 0x0098,
+	VERSION_NORMAL_UMC_CHIP_92C_1T2R_A_CUT = 0x0098,		
 	VERSION_NORMAL_UMC_CHIP_8723_1T1R_A_CUT = 0x0089,
-	VERSION_NORMAL_UMC_CHIP_8723_1T1R_B_CUT = 0x1089,
-	VERSION_NORMAL_UMC_CHIP_88C_B_CUT = 0x1088,
-	VERSION_NORMAL_UMC_CHIP_92C_B_CUT = 0x10a8,
-	VERSION_NORMAL_UMC_CHIP_92C_1T2R_B_CUT = 0x1090,
+	VERSION_NORMAL_UMC_CHIP_8723_1T1R_B_CUT = 0x1089,	
+	VERSION_NORMAL_UMC_CHIP_88C_B_CUT = 0x1088, 
+	VERSION_NORMAL_UMC_CHIP_92C_B_CUT = 0x10a8, 
+	VERSION_NORMAL_UMC_CHIP_92C_1T2R_B_CUT = 0x1090, 
 	VERSION_TEST_CHIP_92D_SINGLEPHY= 0x0022,
 	VERSION_TEST_CHIP_92D_DUALPHY = 0x0002,
 	VERSION_NORMAL_CHIP_92D_SINGLEPHY= 0x002a,
@@ -653,7 +653,7 @@ enum ChannelPlan{
 typedef enum _PA_MODE {
 	PA_MODE_EXTERNAL = 0x00,
 	PA_MODE_INTERNAL_SP3T = 0x01,
-	PA_MODE_INTERNAL_SPDT = 0x02
+	PA_MODE_INTERNAL_SPDT = 0x02	
 } PA_MODE;
 
 /* Copy from rtl8192c */
@@ -677,7 +677,7 @@ struct hal_data_8192de
 {
 	VERSION_8192D	VersionID;
 
-	// add for 92D Phy mode/mac/Band mode
+	// add for 92D Phy mode/mac/Band mode 
 	MACPHY_MODE_8192D	MacPhyMode92D;
 	BAND_TYPE	CurrentBandType92D;	//0:2.4G, 1:5G
 	BAND_TYPE	BandSet92D;
@@ -737,7 +737,7 @@ struct hal_data_8192de
 
 	u8	TxPwrLevelCck[RF_PATH_MAX][CHANNEL_MAX_NUMBER_2G];
 	u8	TxPwrLevelHT40_1S[RF_PATH_MAX][CHANNEL_MAX_NUMBER];	// For HT 40MHZ pwr
-	u8	TxPwrLevelHT40_2S[RF_PATH_MAX][CHANNEL_MAX_NUMBER];	// For HT 40MHZ pwr
+	u8	TxPwrLevelHT40_2S[RF_PATH_MAX][CHANNEL_MAX_NUMBER];	// For HT 40MHZ pwr	
 	s8	TxPwrHt20Diff[RF_PATH_MAX][CHANNEL_MAX_NUMBER];// HT 20<->40 Pwr diff
 	u8	TxPwrLegacyHtDiff[RF_PATH_MAX][CHANNEL_MAX_NUMBER];// For HT<->legacy pwr diff
 	// For power group
@@ -811,7 +811,7 @@ struct hal_data_8192de
 #else
 	//regc80regc94regc4cregc88regc9cregc14regca0regc1cregc78
 	u4Byte				IQKMatrixReg[IQK_Matrix_REG_NUM];
-	IQK_MATRIX_REGS_SETTING			   IQKMatrixRegSetting[IQK_Matrix_Settings_NUM];	// 1->2G,24->5G 20M channel,21->5G 40M channel.
+	IQK_MATRIX_REGS_SETTING			   IQKMatrixRegSetting[IQK_Matrix_Settings_NUM];	// 1->2G,24->5G 20M channel,21->5G 40M channel.													
 #endif
 
 	//for host message to fw
@@ -878,7 +878,7 @@ struct hal_data_8192du
 {
 	VERSION_8192D	VersionID;
 
-	// add for 92D Phy mode/mac/Band mode
+	// add for 92D Phy mode/mac/Band mode 
 	MACPHY_MODE_8192D	MacPhyMode92D;
 	BAND_TYPE	CurrentBandType92D;	//0:2.4G, 1:5G
 	BAND_TYPE	BandSet92D;
@@ -923,7 +923,7 @@ struct hal_data_8192du
 	u16	EEPROMSVID;
 	u16	EEPROMSDID;
 	u8	EEPROMCustomerID;
-	u8	EEPROMSubCustomerID;
+	u8	EEPROMSubCustomerID;	
 	u8	EEPROMRegulatory;
 
 	u8	EEPROMThermalMeter;
@@ -934,7 +934,7 @@ struct hal_data_8192du
 
 	u8	TxPwrLevelCck[RF_PATH_MAX][CHANNEL_MAX_NUMBER_2G];
 	u8	TxPwrLevelHT40_1S[RF_PATH_MAX][CHANNEL_MAX_NUMBER];	// For HT 40MHZ pwr
-	u8	TxPwrLevelHT40_2S[RF_PATH_MAX][CHANNEL_MAX_NUMBER];	// For HT 40MHZ pwr
+	u8	TxPwrLevelHT40_2S[RF_PATH_MAX][CHANNEL_MAX_NUMBER];	// For HT 40MHZ pwr	
 	s8	TxPwrHt20Diff[RF_PATH_MAX][CHANNEL_MAX_NUMBER];// HT 20<->40 Pwr diff
 	u8	TxPwrLegacyHtDiff[RF_PATH_MAX][CHANNEL_MAX_NUMBER];// For HT<->legacy pwr diff
 	// For power group
@@ -1008,7 +1008,7 @@ struct hal_data_8192du
 #else
 	//regc80regc94regc4cregc88regc9cregc14regca0regc1cregc78
 	u4Byte				IQKMatrixReg[IQK_Matrix_REG_NUM];
-	IQK_MATRIX_REGS_SETTING			   IQKMatrixRegSetting[IQK_Matrix_Settings_NUM];	// 1->2G,24->5G 20M channel,21->5G 40M channel.
+	IQK_MATRIX_REGS_SETTING			   IQKMatrixRegSetting[IQK_Matrix_Settings_NUM];	// 1->2G,24->5G 20M channel,21->5G 40M channel.													
 #endif
 
 	//for host message to fw
@@ -1123,3 +1123,4 @@ struct hal_data_8192du
 
 
 #endif //end CONFIG_MP_INCLUDED
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_led.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_led.h
old mode 100644
new mode 100755
index b1f7a94..d736bda4
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_led.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_led.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -40,3 +40,4 @@
 #endif
 
 #endif
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_recv.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_recv.h
old mode 100644
new mode 100755
index e03347a..36cc232
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_recv.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_recv.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -130,10 +130,10 @@ struct phy_stat
 	unsigned char idle_long:1;
 	unsigned char r_ant_train_en:1;
 	unsigned char ANTSELB:1;
-	unsigned char ANTSEL:1;
+	unsigned char ANTSEL:1;	
 #else	// _BIG_ENDIAN_
 	//unsigned char rsvd:4;
-	unsigned char ANTSEL:1;
+	unsigned char ANTSEL:1;	
 	unsigned char ANTSELB:1;
 	unsigned char r_ant_train_en:1;
 	unsigned char idle_long:1;
@@ -184,3 +184,4 @@ struct phy_stat
 void rtl8192d_query_rx_desc_status(union recv_frame *precvframe, struct recv_stat *pdesc);
 
 #endif
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_rf.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_rf.h
old mode 100644
new mode 100755
index 1aba229..0b439a3
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_rf.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_rf.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -18,24 +18,24 @@
  *
  ******************************************************************************/
 /******************************************************************************
- *
- *
+ * 
+ * 
  * Module:	rtl8192d_rf.h	( Header File)
- *
- * Note:	Collect every HAL RF type exter API or constant.
- *
- * Function:
- *
- * Export:
- *
- * Abbrev:
- *
+ * 
+ * Note:	Collect every HAL RF type exter API or constant.	 
+ *
+ * Function:	
+ * 		 
+ * Export:	
+ * 
+ * Abbrev:	
+ * 
  * History:
  * Data			Who		Remark
- *
+ * 
  * 09/25/2008	MHC		Create initial version.
- *
- *
+ * 
+ * 
 ******************************************************************************/
 #ifndef _RTL8192D_RF_H_
 #define _RTL8192D_RF_H_
@@ -53,9 +53,9 @@
 /*--------------------------Define Parameters-------------------------------*/
 
 
-/*------------------------------Define structure----------------------------*/
+/*------------------------------Define structure----------------------------*/ 
 
-/*------------------------------Define structure----------------------------*/
+/*------------------------------Define structure----------------------------*/ 
 
 
 /*------------------------Export global variable----------------------------*/
@@ -71,11 +71,11 @@
 //
 // RF RL6052 Series API
 //
-void		rtl8192d_RF_ChangeTxPath(	IN	PADAPTER	Adapter,
+void		rtl8192d_RF_ChangeTxPath(	IN	PADAPTER	Adapter, 
 										IN	u16		DataRate);
-void		rtl8192d_PHY_RF6052SetBandwidth(
+void		rtl8192d_PHY_RF6052SetBandwidth(	
 										IN	PADAPTER				Adapter,
-										IN	HT_CHANNEL_WIDTH		Bandwidth);
+										IN	HT_CHANNEL_WIDTH		Bandwidth);	
 VOID	rtl8192d_PHY_RF6052SetCckTxPower(
 										IN	PADAPTER	Adapter,
 										IN	u8*		pPowerlevel);
@@ -94,3 +94,4 @@ VOID	rtl8192d_PHY_RF6052SetOFDMTxPower(
 
 
 #endif/* End of HalRf.h */
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_spec.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_spec.h
old mode 100644
new mode 100755
index d2d3e89..bef7184
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_spec.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_spec.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -217,7 +217,7 @@
 //
 //-----------------------------------------------------
 #define	REG_PCIE_CTRL_REG			0x0300
-#define	REG_INT_MIG				0x0304	// Interrupt Migration
+#define	REG_INT_MIG				0x0304	// Interrupt Migration 
 #define	REG_BCNQ_DESA				0x0308	// TX Beacon Descriptor Address
 #define	REG_HQ_DESA				0x0310	// TX High Queue Descriptor Address
 #define	REG_MGQ_DESA				0x0318	// TX Manage Queue Descriptor Address
@@ -342,7 +342,7 @@
 #define REG_USTIME_TSF				0x055C
 #define REG_BCN_MAX_ERR			0x055D
 #define REG_RXTSF_OFFSET_CCK		0x055E
-#define REG_RXTSF_OFFSET_OFDM		0x055F
+#define REG_RXTSF_OFFSET_OFDM		0x055F	
 #define REG_TSFTR					0x0560
 #define REG_TSFTR1					0x0568
 #define REG_INIT_TSFTR				0x0564
@@ -436,7 +436,7 @@
 #define REG_USB_AGG_TO				0xFE5C
 #define REG_USB_AGG_TH				0xFE5D
 
-// for 92DU high_Queue low_Queue Normal_Queue select
+// for 92DU high_Queue low_Queue Normal_Queue select 
 #define REG_USB_High_NORMAL_Queue_Select_MAC0  0xFE44
 //#define REG_USB_LOW_Queue_Select_MAC0       0xFE45
 #define REG_USB_High_NORMAL_Queue_Select_MAC1  0xFE47
@@ -538,7 +538,7 @@
 
 
 //----------------------------------------------------------------------------
-//       8192C (MSR) Media Status Register	(Offset 0x4C, 8 bits)
+//       8192C (MSR) Media Status Register	(Offset 0x4C, 8 bits)  
 //----------------------------------------------------------------------------
 /*
 Network Type
@@ -566,16 +566,16 @@
 #define	RRSR_RSC_LOWSUBCHNL		0x200000
 #define	RRSR_SHORT					0x800000
 #define	RRSR_1M					BIT0
-#define	RRSR_2M					BIT1
-#define	RRSR_5_5M					BIT2
-#define	RRSR_11M					BIT3
-#define	RRSR_6M					BIT4
-#define	RRSR_9M					BIT5
-#define	RRSR_12M					BIT6
-#define	RRSR_18M					BIT7
-#define	RRSR_24M					BIT8
-#define	RRSR_36M					BIT9
-#define	RRSR_48M					BIT10
+#define	RRSR_2M					BIT1 
+#define	RRSR_5_5M					BIT2 
+#define	RRSR_11M					BIT3 
+#define	RRSR_6M					BIT4 
+#define	RRSR_9M					BIT5 
+#define	RRSR_12M					BIT6 
+#define	RRSR_18M					BIT7 
+#define	RRSR_24M					BIT8 
+#define	RRSR_36M					BIT9 
+#define	RRSR_48M					BIT10 
 #define	RRSR_54M					BIT11
 #define	RRSR_MCS0					BIT12
 #define	RRSR_MCS1					BIT13
@@ -585,7 +585,7 @@
 #define	RRSR_MCS5					BIT17
 #define	RRSR_MCS6					BIT18
 #define	RRSR_MCS7					BIT19
-#define	BRSR_AckShortPmb			BIT23
+#define	BRSR_AckShortPmb			BIT23	
 // CCK ACK: use Short Preamble or not
 
 
@@ -597,7 +597,7 @@
 #define	RATR_2M					0x00000002
 #define	RATR_55M					0x00000004
 #define	RATR_11M					0x00000008
-//OFDM
+//OFDM 		
 #define	RATR_6M					0x00000010
 #define	RATR_9M					0x00000020
 #define	RATR_12M					0x00000040
@@ -606,7 +606,7 @@
 #define	RATR_36M					0x00000200
 #define	RATR_48M					0x00000400
 #define	RATR_54M					0x00000800
-//MCS 1 Spatial Stream
+//MCS 1 Spatial Stream	
 #define	RATR_MCS0					0x00001000
 #define	RATR_MCS1					0x00002000
 #define	RATR_MCS2					0x00004000
@@ -651,11 +651,11 @@
 
 
 #define	TOTAL_CAM_ENTRY			32
-#define	HALF_CAM_ENTRY			16
-
+#define	HALF_CAM_ENTRY			16	
+       		
 #define	CAM_CONFIG_USEDK			_TRUE
 #define	CAM_CONFIG_NO_USEDK		_FALSE
-
+       		
 #define	CAM_WRITE					BIT16
 #define	CAM_READ					0x00000000
 #define	CAM_POLLINIG				BIT31
@@ -690,7 +690,7 @@
 #define	IMR_TIMEOUT2				BIT17		// Timeout interrupt 2
 #define	IMR_TIMEOUT1				BIT16		// Timeout interrupt 1
 #define	IMR_TXFOVW				BIT15		// Transmit FIFO Overflow
-#define	IMR_PSTIMEOUT				BIT14		// Power save time out interrupt
+#define	IMR_PSTIMEOUT				BIT14		// Power save time out interrupt 
 #define	IMR_BcnInt					BIT13		// Beacon DMA Interrupt 0
 #define	IMR_RXFOVW				BIT12		// Receive FIFO Overflow
 #define	IMR_RDU					BIT11		// Receive Descriptor Unavailable
@@ -846,7 +846,7 @@
 #define EEPROM_HT40_MAX_PWR_OFFSET_5GH		0xB5
 #define EEPROM_HT20_MAX_PWR_OFFSET_5GH		0xB8
 
-#define EEPROM_CHANNEL_PLAN					0xBB // Map of supported channels.
+#define EEPROM_CHANNEL_PLAN					0xBB // Map of supported channels.	
 #define EEPROM_IQK_DELTA						0xBC
 #define EEPROM_LCK_DELTA						0xBC
 #define EEPROM_XTAL_K							0xBD	//[7:5]
@@ -871,7 +871,7 @@
 #define EEPROM_DEF_PART_NO					0x3FD  //Byte
 #define EEPROME_CHIP_VERSION_L				0x3FF
 #define EEPROME_CHIP_VERSION_H				0x3FE
-#endif
+#endif 
 
 #ifdef CONFIG_USB_HCI
 #define RTL8190_EEPROM_ID						0x8129	// 0-1
@@ -928,7 +928,7 @@
 #define EEPROM_HT40_MAX_PWR_OFFSET_5GH		0xB5
 #define EEPROM_HT20_MAX_PWR_OFFSET_5GH		0xB8
 
-#define EEPROM_CHANNEL_PLAN					0xBB // Map of supported channels.
+#define EEPROM_CHANNEL_PLAN					0xBB // Map of supported channels.	
 #define EEPROM_TEST_CHANNEL_PLAN				0xBB
 #define EEPROM_IQK_DELTA						0xBC
 #define EEPROM_LCK_DELTA						0xBC
@@ -1039,7 +1039,7 @@
 
 /*===================================================================
 =====================================================================
-Here the register defines are for 92C. When the define is as same with 92C,
+Here the register defines are for 92C. When the define is as same with 92C, 
 we will use the 92C's define for the consistency
 So the following defines for 92C is not entire!!!!!!
 =====================================================================
@@ -1075,23 +1075,23 @@
 #define	RCR_ACF					BIT12		//Accept control type frame
 #define	RCR_ADF					BIT11		//Accept data type frame
 #define	RCR_AICV					BIT9		//Accept ICV error packet
-#define	RCR_ACRC32					BIT8		//Accept CRC32 error packet
+#define	RCR_ACRC32					BIT8		//Accept CRC32 error packet 
 #define	RCR_CBSSID_BCN			BIT7		//Accept BSSID match packet (Rx beacon, probe rsp)
 #define	RCR_CBSSID_DATA			BIT6		//Accept BSSID match packet (Data)
 #define	RCR_CBSSID					RCR_CBSSID_DATA		//Accept BSSID match packet
 #define	RCR_APWRMGT				BIT5		//Accept power management packet
 #define	RCR_ADD3					BIT4		//Accept address 3 match packet
-#define	RCR_AB						BIT3		//Accept broadcast packet
-#define	RCR_AM						BIT2		//Accept multicast packet
+#define	RCR_AB						BIT3		//Accept broadcast packet 
+#define	RCR_AM						BIT2		//Accept multicast packet 
 #define	RCR_APM					BIT1		//Accept physical match packet
-#define	RCR_AAP					BIT0		//Accept all unicast packet
+#define	RCR_AAP					BIT0		//Accept all unicast packet 
 #define	RCR_MXDMA_OFFSET			8
 #define	RCR_FIFO_OFFSET			13
 
 
 
 //============================================================================
-//       8192c USB specific Regsiter Offset and Content definition,
+//       8192c USB specific Regsiter Offset and Content definition, 
 //       2009.08.18, added by vivi. for merge 92c and 92C into one driver
 //============================================================================
 //#define APS_FSMCO				0x0004  same with 92Ce
@@ -1122,7 +1122,7 @@
 #define InvalidBBRFValue			0x12345678
 
 //============================================================================
-//       8192C Regsiter Bit and Content definition
+//       8192C Regsiter Bit and Content definition 
 //============================================================================
 //-----------------------------------------------------
 //
@@ -1312,11 +1312,11 @@
 #define EF_PD						BIT(19)
 #define EF_FLAG						BIT(31)
 
-//2 EFUSE_TEST
+//2 EFUSE_TEST 
 #define EF_TRPT						BIT(7)
 #define LDOE25_EN					BIT(31)
 
-//2 PWR_DATA
+//2 PWR_DATA 
 
 //2 CAL_TIMER
 
@@ -1346,7 +1346,7 @@
 //2 GPIO_INTM
 
 //2 LEDCFG
-#define LED0PL 					BIT(4)
+#define LED0PL 					BIT(4)  
 #define LED1PL 					BIT(12)
 #define LED0DIS					BIT(7)
 
@@ -1471,7 +1471,7 @@
 // For normal driver, 0x10C
 #define _TXDMA_HIQ_MAP(x) 	 		(((x)&0x3) << 14)
 #define _TXDMA_MGQ_MAP(x) 	 		(((x)&0x3) << 12)
-#define _TXDMA_BKQ_MAP(x) 	 		(((x)&0x3) << 10)
+#define _TXDMA_BKQ_MAP(x) 	 		(((x)&0x3) << 10)		
 #define _TXDMA_BEQ_MAP(x) 	 		(((x)&0x3) << 8 )
 #define _TXDMA_VIQ_MAP(x) 	 		(((x)&0x3) << 6 )
 #define _TXDMA_VOQ_MAP(x) 	 		(((x)&0x3) << 4 )
@@ -1838,3 +1838,4 @@
 #include "basic_types.h"
 
 #endif
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_xmit.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_xmit.h
old mode 100644
new mode 100755
index bc651c1..d01fb4a
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_xmit.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtl8192d_xmit.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -142,3 +142,4 @@ struct txrpt_ccx_8192d {
 
 
 #endif
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_android.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_android.h
old mode 100644
new mode 100755
index 468ae77..f9214c2
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_android.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_android.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -17,7 +17,7 @@
  *
  *
  ******************************************************************************/
-
+ 
 #ifndef __RTW_ANDROID_H__
 #define __RTW_ANDROID_H__
 
@@ -25,28 +25,28 @@
 #include <linux/netdevice.h>
 
 enum ANDROID_WIFI_CMD {
-	ANDROID_WIFI_CMD_START,
-	ANDROID_WIFI_CMD_STOP,
+	ANDROID_WIFI_CMD_START,				
+	ANDROID_WIFI_CMD_STOP,			
 	ANDROID_WIFI_CMD_SCAN_ACTIVE,
-	ANDROID_WIFI_CMD_SCAN_PASSIVE,
-	ANDROID_WIFI_CMD_RSSI,
+	ANDROID_WIFI_CMD_SCAN_PASSIVE,		
+	ANDROID_WIFI_CMD_RSSI,	
 	ANDROID_WIFI_CMD_LINKSPEED,
 	ANDROID_WIFI_CMD_RXFILTER_START,
-	ANDROID_WIFI_CMD_RXFILTER_STOP,
-	ANDROID_WIFI_CMD_RXFILTER_ADD,
+	ANDROID_WIFI_CMD_RXFILTER_STOP,	
+	ANDROID_WIFI_CMD_RXFILTER_ADD,	
 	ANDROID_WIFI_CMD_RXFILTER_REMOVE,
 	ANDROID_WIFI_CMD_BTCOEXSCAN_START,
 	ANDROID_WIFI_CMD_BTCOEXSCAN_STOP,
 	ANDROID_WIFI_CMD_BTCOEXMODE,
 	ANDROID_WIFI_CMD_SETSUSPENDOPT,
-	ANDROID_WIFI_CMD_P2P_DEV_ADDR,
-	ANDROID_WIFI_CMD_SETFWPATH,
-	ANDROID_WIFI_CMD_SETBAND,
-	ANDROID_WIFI_CMD_GETBAND,
-	ANDROID_WIFI_CMD_COUNTRY,
+	ANDROID_WIFI_CMD_P2P_DEV_ADDR,	
+	ANDROID_WIFI_CMD_SETFWPATH,		
+	ANDROID_WIFI_CMD_SETBAND,		
+	ANDROID_WIFI_CMD_GETBAND,			
+	ANDROID_WIFI_CMD_COUNTRY,			
 	ANDROID_WIFI_CMD_P2P_SET_NOA,
-	ANDROID_WIFI_CMD_P2P_GET_NOA,
-	ANDROID_WIFI_CMD_P2P_SET_PS,
+	ANDROID_WIFI_CMD_P2P_GET_NOA,	
+	ANDROID_WIFI_CMD_P2P_SET_PS,	
 	ANDROID_WIFI_CMD_SET_AP_WPS_P2P_IE,
 #ifdef PNO_SUPPORT
 	ANDROID_WIFI_CMD_PNOSSIDCLR_SET,
@@ -61,7 +61,7 @@ enum ANDROID_WIFI_CMD {
 
 	ANDROID_WIFI_CMD_WFD_ENABLE,
 	ANDROID_WIFI_CMD_WFD_DISABLE,
-
+	
 	ANDROID_WIFI_CMD_WFD_SET_TCPPORT,
 	ANDROID_WIFI_CMD_WFD_SET_MAX_TPUT,
 	ANDROID_WIFI_CMD_WFD_SET_DEVTYPE,
@@ -87,3 +87,4 @@ static void rtw_android_wifictrl_func_del(void) {}
 #endif /* defined(RTW_ENABLE_WIFI_CONTROL_FUNC) */
 
 #endif //__RTW_ANDROID_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_ap.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_ap.h
old mode 100644
new mode 100755
index 1265174..42be4c6
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_ap.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_ap.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -38,7 +38,7 @@
 void rtw_add_bcn_ie(_adapter *padapter, WLAN_BSSID_EX *pnetwork, u8 index, u8 *data, u8 len);
 void rtw_remove_bcn_ie(_adapter *padapter, WLAN_BSSID_EX *pnetwork, u8 index);
 void update_beacon(_adapter *padapter, u8 ie_id, u8 *oui, u8 tx);
-void expire_timeout_chk(_adapter *padapter);
+void expire_timeout_chk(_adapter *padapter);	
 void update_sta_info_apmode(_adapter *padapter, struct sta_info *psta);
 int rtw_check_beacon_data(_adapter *padapter, u8 *pbuf,  int len);
 void rtw_ap_restore_network(_adapter *padapter);
@@ -61,3 +61,4 @@
 #endif //end of CONFIG_AP_MODE
 
 #endif
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_br_ext.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_br_ext.h
old mode 100644
new mode 100755
index 1b5709a..9da3fdd
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_br_ext.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_br_ext.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -73,3 +73,4 @@ struct br_ext_info {
 void nat25_db_cleanup(_adapter *priv);
 
 #endif // _RTW_BR_EXT_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_byteorder.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_byteorder.h
old mode 100644
new mode 100755
index 757b01d..0f06b7a
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_byteorder.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_byteorder.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -37,3 +37,4 @@
 #endif
 
 #endif /* _RTL871X_BYTEORDER_H_ */
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_cmd.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_cmd.h
old mode 100644
new mode 100755
index 5253911..ab115c5
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_cmd.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_cmd.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -34,7 +34,7 @@
 
 
 	#define FREE_CMDOBJ_SZ	128
-
+	
 	#define MAX_CMDSZ	1024
 	#define MAX_RSPSZ	512
 	#define MAX_EVTSZ	1024
@@ -60,12 +60,12 @@
 	struct cmd_priv {
 		_sema	cmd_queue_sema;
 		//_sema	cmd_done_sema;
-		_sema	terminate_cmdthread_sema;
+		_sema	terminate_cmdthread_sema;		
 		_queue	cmd_queue;
 		u8	cmd_seq;
 		u8	*cmd_buf;	//shall be non-paged, and 4 bytes aligned
 		u8	*cmd_allocated_buf;
-		u8	*rsp_buf;	//shall be non-paged, and 4 bytes aligned
+		u8	*rsp_buf;	//shall be non-paged, and 4 bytes aligned		
 		u8	*rsp_allocated_buf;
 		u32	cmd_issued_cnt;
 		u32	cmd_done_cnt;
@@ -80,7 +80,7 @@
 		u16	evtcode;
 		u8	res;
 		u8	*parmbuf;
-		u32	evtsz;
+		u32	evtsz;		
 		_list	list;
 	};
 #endif
@@ -99,15 +99,15 @@
 		struct rtw_cbuf *c2h_queue;
 		#define C2H_QUEUE_MAX_LEN 10
 #endif
-
+		
 #ifdef CONFIG_H2CLBK
 		_sema	lbkevt_done;
 		u8	lbkevt_limit;
 		u8	lbkevt_num;
-		u8	*cmdevt_parm;
+		u8	*cmdevt_parm;		
 #endif
 		ATOMIC_T event_seq;
-		u8	*evt_buf;	//shall be non-paged, and 4 bytes aligned
+		u8	*evt_buf;	//shall be non-paged, and 4 bytes aligned		
 		u8	*evt_allocated_buf;
 		u32	evt_done_cnt;
 #ifdef CONFIG_SDIO_HCI
@@ -168,7 +168,7 @@ struct c2h_evt_hdr {
 #endif	/* CONFIG_RTL8711FW */
 
 enum rtw_drvextra_cmd_id
-{
+{	
 	NONE_WK_CID,
 	DYNAMIC_CHK_WK_CID,
 	DM_CTRL_WK_CID,
@@ -285,14 +285,14 @@ struct	setopmode_parm {
 
 Notes: To ask RTL8711 performing site-survey
 
-Command-Event Mode
+Command-Event Mode 
 
 */
 
 #define RTW_SSID_SCAN_AMOUNT 9 // for WEXT_CSCAN_AMOUNT 9
 #define RTW_CHANNEL_SCAN_AMOUNT (14+37)
 struct sitesurvey_parm {
-	sint scan_mode;	//active: 1, passive: 0
+	sint scan_mode;	//active: 1, passive: 0 
 	/* sint bsslimit;	// 1 ~ 48 */
 	u8 ssid_num;
 	u8 ch_num;
@@ -328,25 +328,25 @@ struct setauth_parm {
 */
 struct setkey_parm {
 	u8	algorithm;	// encryption algorithm, could be none, wep40, TKIP, CCMP, wep104
-	u8	keyid;
+	u8	keyid;		
 	u8 	grpkey;		// 1: this is the grpkey for 802.1x. 0: this is the unicast key for 802.1x
 	u8 	set_tx;		// 1: main tx key for wep. 0: other key.
 	u8	key[16];	// this could be 40 or 104
 };
 
 /*
-When in AP or Ad-Hoc mode, this is used to
+When in AP or Ad-Hoc mode, this is used to 
 allocate an sw/hw entry for a newly associated sta.
 
 Command
 
-when shared key ==> algorithm/keyid
+when shared key ==> algorithm/keyid 
 
 */
 struct set_stakey_parm {
 	u8	addr[ETH_ALEN];
 	u8	algorithm;
-	u8 	id;// currently for erasing cam entry if algorithm == _NO_PRIVACY_
+	u8 	id;// currently for erasing cam entry if algorithm == _NO_PRIVACY_ 
 	u8	key[16];
 };
 
@@ -377,11 +377,11 @@ struct set_assocsta_rsp {
 
 /*
 	Caller Ad-Hoc/AP
-
+	
 	Command mode
-
+	
 	This is to force fw to del an sta_data entry per driver's request
-
+	
 	FW will invalidate the cam entry associated with it.
 
 */
@@ -458,7 +458,7 @@ struct setdatarate_parm {
 */
 struct getdatarate_parm {
 	u32 rsvd;
-
+	
 };
 struct getdatarate_rsp {
 	u8 datarates[NumRates];
@@ -568,16 +568,16 @@ struct Tx_Beacon_param
 /*
 	Notes: This command is used for H2C/C2H loopback testing
 
-	mac[0] == 0
+	mac[0] == 0 
 	==> CMD mode, return H2C_SUCCESS.
 	The following condition must be ture under CMD mode
 		mac[1] == mac[4], mac[2] == mac[3], mac[0]=mac[5]= 0;
 		s0 == 0x1234, s1 == 0xabcd, w0 == 0x78563412, w1 == 0x5aa5def7;
 		s2 == (b1 << 8 | b0);
-
+	
 	mac[0] == 1
 	==> CMD_RSP mode, return H2C_SUCCESS_RSP
-
+	
 	The rsp layout shall be:
 	rsp: 			parm:
 		mac[0]  =   mac[5];
@@ -593,7 +593,7 @@ struct Tx_Beacon_param
 		s2		= 	s0 + s1
 		b1		= 	b0
 		w1		=	w0
-
+		
 	mac[0] == 	2
 	==> CMD_EVENT mode, return 	H2C_SUCCESS
 	The event layout shall be:
@@ -609,14 +609,14 @@ struct Tx_Beacon_param
 		w0		=  	swap32(w0);
 		b0		= 	b1
 		s2		= 	s0 + event.mac[2]
-		b1		= 	b0
-		w1		=	swap32(w1) - event.mac[2];
-
+		b1		= 	b0 
+		w1		=	swap32(w1) - event.mac[2];	
+	
 		parm->mac[3] is the total event counts that host requested.
-
-
+		
+	
 	event will be the same with the cmd's param.
-
+		
 */
 
 #ifdef CONFIG_H2CLBK
@@ -633,7 +633,7 @@ struct seth2clbk_parm {
 };
 
 struct geth2clbk_parm {
-	u32 rsv;
+	u32 rsv;	
 };
 
 struct geth2clbk_rsp {
@@ -659,10 +659,10 @@ struct drvextra_cmd_parm {
 /*------------------- Below are used for RF/BB tunning ---------------------*/
 
 struct	setantenna_parm {
-	u8	tx_antset;
+	u8	tx_antset;		
 	u8	rx_antset;
-	u8	tx_antenna;
-	u8	rx_antenna;
+	u8	tx_antenna;		
+	u8	rx_antenna;		
 };
 
 struct	enrateadaptive_parm {
@@ -815,7 +815,7 @@ struct setassocrspextraie_parm {
 
 struct addBaReq_parm
 {
-	unsigned int tid;
+ 	unsigned int tid;
 	u8	addr[ETH_ALEN];
 };
 
@@ -884,25 +884,25 @@ struct SwitchBandwidth_parm
 
 #endif	/* MP_FIRMWARE_OFFLOAD */
 
-/*H2C Handler index: 59 */
+/*H2C Handler index: 59 */ 
 struct SetChannelPlan_param
 {
 	u8 channel_plan;
 };
 
-/*H2C Handler index: 60 */
+/*H2C Handler index: 60 */ 
 struct LedBlink_param
 {
 	PLED_871x	 pLed;
 };
 
-/*H2C Handler index: 61 */
+/*H2C Handler index: 61 */ 
 struct SetChannelSwitch_param
 {
 	u8 new_ch_no;
 };
 
-/*H2C Handler index: 62 */
+/*H2C Handler index: 62 */ 
 struct TDLSoption_param
 {
 	u8 addr[ETH_ALEN];
@@ -914,7 +914,7 @@ struct TDLSoption_param
 
 /*
 
-Result:
+Result: 
 0x00: success
 0x01: sucess, and check Response.
 0x02: cmd ignored due to duplicated sequcne number
@@ -990,7 +990,7 @@ struct TDLSoption_param
 
 extern void rtw_survey_cmd_callback(_adapter  *padapter, struct cmd_obj *pcmd);
 extern void rtw_disassoc_cmd_callback(_adapter  *padapter, struct cmd_obj *pcmd);
-extern void rtw_joinbss_cmd_callback(_adapter  *padapter, struct cmd_obj *pcmd);
+extern void rtw_joinbss_cmd_callback(_adapter  *padapter, struct cmd_obj *pcmd);	
 extern void rtw_createbss_cmd_callback(_adapter  *padapter, struct cmd_obj *pcmd);
 extern void rtw_getbbrfreg_cmdrsp_callback(_adapter  *padapter, struct cmd_obj *pcmd);
 extern void rtw_readtssi_cmdrsp_callback(_adapter*	padapter,  struct cmd_obj *pcmd);
@@ -1008,77 +1008,77 @@ struct _cmd_callback {
 enum rtw_h2c_cmd
 {
 	GEN_CMD_CODE(_Read_MACREG) ,	/*0*/
-	GEN_CMD_CODE(_Write_MACREG) ,
-	GEN_CMD_CODE(_Read_BBREG) ,
-	GEN_CMD_CODE(_Write_BBREG) ,
-	GEN_CMD_CODE(_Read_RFREG) ,
-	GEN_CMD_CODE(_Write_RFREG) , /*5*/
-	GEN_CMD_CODE(_Read_EEPROM) ,
-	GEN_CMD_CODE(_Write_EEPROM) ,
-	GEN_CMD_CODE(_Read_EFUSE) ,
-	GEN_CMD_CODE(_Write_EFUSE) ,
-
-	GEN_CMD_CODE(_Read_CAM) ,	/*10*/
-	GEN_CMD_CODE(_Write_CAM) ,
-	GEN_CMD_CODE(_setBCNITV),
-	GEN_CMD_CODE(_setMBIDCFG),
-	GEN_CMD_CODE(_JoinBss),   /*14*/
-	GEN_CMD_CODE(_DisConnect) , /*15*/
-	GEN_CMD_CODE(_CreateBss) ,
-	GEN_CMD_CODE(_SetOpMode) ,
+ 	GEN_CMD_CODE(_Write_MACREG) ,    
+ 	GEN_CMD_CODE(_Read_BBREG) ,  
+ 	GEN_CMD_CODE(_Write_BBREG) ,  
+ 	GEN_CMD_CODE(_Read_RFREG) ,  
+ 	GEN_CMD_CODE(_Write_RFREG) , /*5*/
+ 	GEN_CMD_CODE(_Read_EEPROM) ,  
+ 	GEN_CMD_CODE(_Write_EEPROM) ,  
+ 	GEN_CMD_CODE(_Read_EFUSE) ,  
+ 	GEN_CMD_CODE(_Write_EFUSE) , 
+ 	
+ 	GEN_CMD_CODE(_Read_CAM) ,	/*10*/
+ 	GEN_CMD_CODE(_Write_CAM) ,   
+ 	GEN_CMD_CODE(_setBCNITV),
+ 	GEN_CMD_CODE(_setMBIDCFG),
+ 	GEN_CMD_CODE(_JoinBss),   /*14*/
+ 	GEN_CMD_CODE(_DisConnect) , /*15*/
+ 	GEN_CMD_CODE(_CreateBss) ,
+	GEN_CMD_CODE(_SetOpMode) , 
 	GEN_CMD_CODE(_SiteSurvey),  /*18*/
-	GEN_CMD_CODE(_SetAuth) ,
-
-	GEN_CMD_CODE(_SetKey) ,	/*20*/
-	GEN_CMD_CODE(_SetStaKey) ,
-	GEN_CMD_CODE(_SetAssocSta) ,
-	GEN_CMD_CODE(_DelAssocSta) ,
-	GEN_CMD_CODE(_SetStaPwrState) ,
-	GEN_CMD_CODE(_SetBasicRate) , /*25*/
-	GEN_CMD_CODE(_GetBasicRate) ,
-	GEN_CMD_CODE(_SetDataRate) ,
-	GEN_CMD_CODE(_GetDataRate) ,
+ 	GEN_CMD_CODE(_SetAuth) ,
+ 	
+ 	GEN_CMD_CODE(_SetKey) ,	/*20*/
+ 	GEN_CMD_CODE(_SetStaKey) ,
+ 	GEN_CMD_CODE(_SetAssocSta) ,
+ 	GEN_CMD_CODE(_DelAssocSta) ,
+ 	GEN_CMD_CODE(_SetStaPwrState) , 
+ 	GEN_CMD_CODE(_SetBasicRate) , /*25*/
+ 	GEN_CMD_CODE(_GetBasicRate) ,
+ 	GEN_CMD_CODE(_SetDataRate) ,
+ 	GEN_CMD_CODE(_GetDataRate) ,
 	GEN_CMD_CODE(_SetPhyInfo) ,
-
-	GEN_CMD_CODE(_GetPhyInfo) ,	/*30*/
+	
+ 	GEN_CMD_CODE(_GetPhyInfo) ,	/*30*/
 	GEN_CMD_CODE(_SetPhy) ,
-	GEN_CMD_CODE(_GetPhy) ,
-	GEN_CMD_CODE(_readRssi) ,
-	GEN_CMD_CODE(_readGain) ,
-	GEN_CMD_CODE(_SetAtim) , /*35*/
-	GEN_CMD_CODE(_SetPwrMode) ,
-	GEN_CMD_CODE(_JoinbssRpt),
-	GEN_CMD_CODE(_SetRaTable) ,
-	GEN_CMD_CODE(_GetRaTable) ,
-
-	GEN_CMD_CODE(_GetCCXReport), /*40*/
-	GEN_CMD_CODE(_GetDTMReport),
-	GEN_CMD_CODE(_GetTXRateStatistics),
-	GEN_CMD_CODE(_SetUsbSuspend),
-	GEN_CMD_CODE(_SetH2cLbk),
-	GEN_CMD_CODE(_AddBAReq) , /*45*/
+ 	GEN_CMD_CODE(_GetPhy) ,
+ 	GEN_CMD_CODE(_readRssi) ,
+ 	GEN_CMD_CODE(_readGain) ,
+ 	GEN_CMD_CODE(_SetAtim) , /*35*/
+ 	GEN_CMD_CODE(_SetPwrMode) , 
+ 	GEN_CMD_CODE(_JoinbssRpt),
+ 	GEN_CMD_CODE(_SetRaTable) ,
+ 	GEN_CMD_CODE(_GetRaTable) ,  	
+ 	
+ 	GEN_CMD_CODE(_GetCCXReport), /*40*/
+ 	GEN_CMD_CODE(_GetDTMReport),
+ 	GEN_CMD_CODE(_GetTXRateStatistics),
+ 	GEN_CMD_CODE(_SetUsbSuspend),
+ 	GEN_CMD_CODE(_SetH2cLbk),
+ 	GEN_CMD_CODE(_AddBAReq) , /*45*/
 	GEN_CMD_CODE(_SetChannel), /*46*/
-	GEN_CMD_CODE(_SetTxPower),
+	GEN_CMD_CODE(_SetTxPower), 
 	GEN_CMD_CODE(_SwitchAntenna),
 	GEN_CMD_CODE(_SetCrystalCap),
 	GEN_CMD_CODE(_SetSingleCarrierTx), /*50*/
-
+	
 	GEN_CMD_CODE(_SetSingleToneTx),/*51*/
 	GEN_CMD_CODE(_SetCarrierSuppressionTx),
 	GEN_CMD_CODE(_SetContinuousTx),
 	GEN_CMD_CODE(_SwitchBandwidth), /*54*/
 	GEN_CMD_CODE(_TX_Beacon), /*55*/
-
+	
 	GEN_CMD_CODE(_Set_MLME_EVT), /*56*/
 	GEN_CMD_CODE(_Set_Drv_Extra), /*57*/
 	GEN_CMD_CODE(_Set_H2C_MSG), /*58*/
-
+	
 	GEN_CMD_CODE(_SetChannelPlan), /*59*/
 	GEN_CMD_CODE(_LedBlink), /*60*/
 
 	GEN_CMD_CODE(_SetChannelSwitch), /*61*/
 	GEN_CMD_CODE(_TDLS), /*62*/
-
+	
 	MAX_H2CCMD
 };
 
@@ -1088,10 +1088,10 @@ enum rtw_h2c_cmd
 #define _SetRFReg_CMD_ 		_Write_RFREG_CMD_
 
 #ifdef _RTW_CMD_C_
-struct _cmd_callback 	rtw_cmd_callback[] =
+struct _cmd_callback 	rtw_cmd_callback[] = 
 {
 	{GEN_CMD_CODE(_Read_MACREG), NULL}, /*0*/
-	{GEN_CMD_CODE(_Write_MACREG), NULL},
+	{GEN_CMD_CODE(_Write_MACREG), NULL}, 
 	{GEN_CMD_CODE(_Read_BBREG), &rtw_getbbrfreg_cmdrsp_callback},
 	{GEN_CMD_CODE(_Write_BBREG), NULL},
 	{GEN_CMD_CODE(_Read_RFREG), &rtw_getbbrfreg_cmdrsp_callback},
@@ -1100,32 +1100,32 @@ struct _cmd_callback 	rtw_cmd_callback[] =
 	{GEN_CMD_CODE(_Write_EEPROM), NULL},
 	{GEN_CMD_CODE(_Read_EFUSE), NULL},
 	{GEN_CMD_CODE(_Write_EFUSE), NULL},
-
+	
 	{GEN_CMD_CODE(_Read_CAM),	NULL},	/*10*/
-	{GEN_CMD_CODE(_Write_CAM),	 NULL},
+	{GEN_CMD_CODE(_Write_CAM),	 NULL},	
 	{GEN_CMD_CODE(_setBCNITV), NULL},
-	{GEN_CMD_CODE(_setMBIDCFG), NULL},
+ 	{GEN_CMD_CODE(_setMBIDCFG), NULL},
 	{GEN_CMD_CODE(_JoinBss), &rtw_joinbss_cmd_callback},  /*14*/
 	{GEN_CMD_CODE(_DisConnect), &rtw_disassoc_cmd_callback}, /*15*/
 	{GEN_CMD_CODE(_CreateBss), &rtw_createbss_cmd_callback},
 	{GEN_CMD_CODE(_SetOpMode), NULL},
 	{GEN_CMD_CODE(_SiteSurvey), &rtw_survey_cmd_callback}, /*18*/
 	{GEN_CMD_CODE(_SetAuth), NULL},
-
+	
 	{GEN_CMD_CODE(_SetKey), NULL},	/*20*/
 	{GEN_CMD_CODE(_SetStaKey), &rtw_setstaKey_cmdrsp_callback},
 	{GEN_CMD_CODE(_SetAssocSta), &rtw_setassocsta_cmdrsp_callback},
-	{GEN_CMD_CODE(_DelAssocSta), NULL},
-	{GEN_CMD_CODE(_SetStaPwrState), NULL},
+	{GEN_CMD_CODE(_DelAssocSta), NULL},	
+	{GEN_CMD_CODE(_SetStaPwrState), NULL},	
 	{GEN_CMD_CODE(_SetBasicRate), NULL}, /*25*/
 	{GEN_CMD_CODE(_GetBasicRate), NULL},
 	{GEN_CMD_CODE(_SetDataRate), NULL},
 	{GEN_CMD_CODE(_GetDataRate), NULL},
 	{GEN_CMD_CODE(_SetPhyInfo), NULL},
-
+	
 	{GEN_CMD_CODE(_GetPhyInfo), NULL}, /*30*/
 	{GEN_CMD_CODE(_SetPhy), NULL},
-	{GEN_CMD_CODE(_GetPhy), NULL},
+	{GEN_CMD_CODE(_GetPhy), NULL},	
 	{GEN_CMD_CODE(_readRssi), NULL},
 	{GEN_CMD_CODE(_readGain), NULL},
 	{GEN_CMD_CODE(_SetAtim), NULL}, /*35*/
@@ -1133,19 +1133,19 @@ struct _cmd_callback 	rtw_cmd_callback[] =
 	{GEN_CMD_CODE(_JoinbssRpt), NULL},
 	{GEN_CMD_CODE(_SetRaTable), NULL},
 	{GEN_CMD_CODE(_GetRaTable) , NULL},
-
+ 	
 	{GEN_CMD_CODE(_GetCCXReport), NULL}, /*40*/
-	{GEN_CMD_CODE(_GetDTMReport),	NULL},
-	{GEN_CMD_CODE(_GetTXRateStatistics), NULL},
-	{GEN_CMD_CODE(_SetUsbSuspend), NULL},
-	{GEN_CMD_CODE(_SetH2cLbk), NULL},
-	{GEN_CMD_CODE(_AddBAReq), NULL}, /*45*/
+ 	{GEN_CMD_CODE(_GetDTMReport),	NULL},
+ 	{GEN_CMD_CODE(_GetTXRateStatistics), NULL}, 
+ 	{GEN_CMD_CODE(_SetUsbSuspend), NULL}, 
+ 	{GEN_CMD_CODE(_SetH2cLbk), NULL},
+ 	{GEN_CMD_CODE(_AddBAReq), NULL}, /*45*/
 	{GEN_CMD_CODE(_SetChannel), NULL},		/*46*/
 	{GEN_CMD_CODE(_SetTxPower), NULL},
 	{GEN_CMD_CODE(_SwitchAntenna), NULL},
 	{GEN_CMD_CODE(_SetCrystalCap), NULL},
 	{GEN_CMD_CODE(_SetSingleCarrierTx), NULL},	/*50*/
-
+	
 	{GEN_CMD_CODE(_SetSingleToneTx), NULL}, /*51*/
 	{GEN_CMD_CODE(_SetCarrierSuppressionTx), NULL},
 	{GEN_CMD_CODE(_SetContinuousTx), NULL},
@@ -1157,10 +1157,11 @@ struct _cmd_callback 	rtw_cmd_callback[] =
 	{GEN_CMD_CODE(_Set_H2C_MSG), NULL},/*58*/
 	{GEN_CMD_CODE(_SetChannelPlan), NULL},/*59*/
 	{GEN_CMD_CODE(_LedBlink), NULL},/*60*/
-
+	
 	{GEN_CMD_CODE(_SetChannelSwitch), NULL},/*61*/
 	{GEN_CMD_CODE(_TDLS), NULL},/*62*/
 };
 #endif
 
 #endif // _CMD_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_debug.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_debug.h
old mode 100644
new mode 100755
index 13db623..4453736
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_debug.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_debug.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -341,7 +341,7 @@
 	int proc_get_log_level(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data);
-
+			  
 	int proc_set_log_level(struct file *file, const char *buffer,
 			unsigned long count, void *data);
 
@@ -355,7 +355,7 @@
 			  off_t offset, int count,
 			  int *eof, void *data);
 
-	int proc_set_write_reg(struct file *file, const char *buffer,
+ 	int proc_set_write_reg(struct file *file, const char *buffer,
 		unsigned long count, void *data);
 
 	int proc_get_read_reg(char *page, char **start,
@@ -413,7 +413,7 @@
 	int proc_get_mac_reg_dump3(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data);
-
+	
 	int proc_get_bb_reg_dump1(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data);
@@ -421,11 +421,11 @@
 	int proc_get_bb_reg_dump2(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data);
-
+	
 	int proc_get_bb_reg_dump3(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data);
-
+	
 	int proc_get_rf_reg_dump1(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data);
@@ -470,36 +470,36 @@
 
 	int proc_set_rx_signal(struct file *file, const char *buffer,
 		unsigned long count, void *data);
-
+		
 	int proc_get_ht_enable(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data);
-
+			  
 	int proc_set_ht_enable(struct file *file, const char *buffer,
 		unsigned long count, void *data);
-
+			  
 	int proc_get_cbw40_enable(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data);
 
 	int proc_set_cbw40_enable(struct file *file, const char *buffer,
 		unsigned long count, void *data);
-
+	
 	int proc_get_ampdu_enable(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data);
-
+			  
 	int proc_set_ampdu_enable(struct file *file, const char *buffer,
 		unsigned long count, void *data);
-
+	
 	int proc_get_two_path_rssi(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data);
-
+	
 	int proc_get_rx_stbc(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data);
-
+		
 	int proc_set_rx_stbc(struct file *file, const char *buffer,
 		unsigned long count, void *data);
 
@@ -535,3 +535,4 @@ int proc_set_dm_adaptivity(struct file *file, const char *buffer,
 #endif //CONFIG_PROC_DEBUG
 
 #endif	//__RTW_DEBUG_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_eeprom.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_eeprom.h
old mode 100644
new mode 100755
index 4326109..ce834dd
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_eeprom.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_eeprom.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -26,7 +26,7 @@
 
 #define	RTL8712_EEPROM_ID			0x8712
 #define	EEPROM_MAX_SIZE			256
-#define	CLOCK_RATE					50			//100us
+#define	CLOCK_RATE					50			//100us		
 
 //- EEPROM opcodes
 #define EEPROM_READ_OPCODE		06
@@ -37,7 +37,7 @@
 
 //Country codes
 #define USA							0x555320
-#define EUROPE						0x1 //temp, should be provided later
+#define EUROPE						0x1 //temp, should be provided later	
 #define JAPAN						0x2 //temp, should be provided later
 
 #ifdef CONFIG_SDIO_HCI
@@ -60,9 +60,9 @@
 #define	EEPROM_CID_WHQL				0xFE // added by chiyoko for dtm, 20090108
 
 //
-// Customer ID, note that:
-// This variable is initiailzed through EEPROM or registry,
-// however, its definition may be different with that in EEPROM for
+// Customer ID, note that: 
+// This variable is initiailzed through EEPROM or registry, 
+// however, its definition may be different with that in EEPROM for 
 // EEPROM size consideration. So, we have to perform proper translation between them.
 // Besides, CustomerID of registry has precedence of that of EEPROM.
 // defined below. 060703, by rcnjko.
@@ -75,7 +75,7 @@
 	RT_CID_8187_HW_LED = 3,
 	RT_CID_8187_NETGEAR = 4,
 	RT_CID_WHQL = 5,
-	RT_CID_819x_CAMEO  = 6,
+	RT_CID_819x_CAMEO  = 6, 
 	RT_CID_819x_RUNTOP = 7,
 	RT_CID_819x_Senao = 8,
 	RT_CID_TOSHIBA = 9,	// Merge by Jacken, 2008/01/31.
@@ -88,10 +88,10 @@
 	RT_CID_819x_ALPHA = 16,
 	RT_CID_819x_Sitecom = 17,
 	RT_CID_CCX = 18, // It's set under CCX logo test and isn't demanded for CCX functions, but for test behavior like retry limit and tx report. By Bruce, 2009-02-17.
-	RT_CID_819x_Lenovo = 19,
+	RT_CID_819x_Lenovo = 19,	
 	RT_CID_819x_QMI = 20,
-	RT_CID_819x_Edimax_Belkin = 21,
-	RT_CID_819x_Sercomm_Belkin = 22,
+	RT_CID_819x_Edimax_Belkin = 21,		
+	RT_CID_819x_Sercomm_Belkin = 22,			
 	RT_CID_819x_CAMEO1 = 23,
 	RT_CID_819x_MSI = 24,
 	RT_CID_819x_Acer = 25,
@@ -108,15 +108,15 @@
 	RT_CID_819x_CAMEO_NETGEAR = 36,
 }RT_CUSTOMER_ID, *PRT_CUSTOMER_ID;
 
-struct eeprom_priv
-{
+struct eeprom_priv 
+{    
 	u8		bautoload_fail_flag;
 	//u8		bempty;
 	//u8		sys_config;
 	u8		mac_addr[6];	//PermanentAddress
 	//u8		config0;
 	u16		channel_plan;
-	//u8		country_string[3];
+	//u8		country_string[3];	
 	//u8		tx_power_b[15];
 	//u8		tx_power_g[15];
 	//u8		tx_power_a[201];
@@ -126,10 +126,10 @@ struct eeprom_priv
 	u8		efuse_eeprom_data[EEPROM_MAX_SIZE];
 
 #ifdef CONFIG_SDIO_HCI
-	u8		sdio_setting;
+	u8		sdio_setting;	
 	u32		ocr;
 	u8		cis0[eeprom_cis0_sz];
-	u8		cis1[eeprom_cis1_sz];
+	u8		cis1[eeprom_cis1_sz];	
 #endif
 };
 
@@ -137,7 +137,7 @@ struct eeprom_priv
 extern void eeprom_write16(_adapter *padapter, u16 reg, u16 data);
 extern u16 eeprom_read16(_adapter *padapter, u16 reg);
 extern void read_eeprom_content(_adapter *padapter);
-extern void eeprom_read_sz(_adapter * padapter, u16 reg,u8* data, u32 sz);
+extern void eeprom_read_sz(_adapter * padapter, u16 reg,u8* data, u32 sz); 
 
 extern void read_eeprom_content_by_attrib(_adapter *	padapter	);
 
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_efuse.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_efuse.h
old mode 100644
new mode 100755
index dd09b85..224aa4f
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_efuse.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_efuse.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -69,14 +69,14 @@ enum _EFUSE_DEF_TYPE {
 /*--------------------------Define Parameters-------------------------------*/
 #define		EFUSE_MAX_WORD_UNIT			4
 
-/*------------------------------Define structure----------------------------*/
+/*------------------------------Define structure----------------------------*/ 
 typedef struct PG_PKT_STRUCT_A{
 	u8 offset;
 	u8 word_en;
-	u8 data[8];
+	u8 data[8];	
 	u8 word_cnts;
 }PGPKT_STRUCT,*PPGPKT_STRUCT;
-/*------------------------------Define structure----------------------------*/
+/*------------------------------Define structure----------------------------*/ 
 
 
 /*------------------------Export global variable----------------------------*/
@@ -121,3 +121,4 @@ enum _EFUSE_DEF_TYPE {
 void	EFUSE_ShadowRead(PADAPTER pAdapter, u8 Type, u16 Offset, u32 *Value);
 
 #endif
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_event.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_event.h
old mode 100644
new mode 100755
index 3a0bbf3..4299ddc
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_event.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_event.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -58,8 +58,8 @@ struct survey_event	{
 
 */
 struct surveydone_event {
-	unsigned int	bss_cnt;
-
+	unsigned int	bss_cnt;	
+	
 };
 
 /*
@@ -86,7 +86,7 @@ struct stassoc_event {
 	unsigned char macaddr[6];
 	unsigned char rsvd[2];
 	int    cam_id;
-
+	
 };
 
 struct stadel_event {
@@ -97,7 +97,7 @@ struct stadel_event {
 
 struct addba_event
 {
-	unsigned int tid;
+ 	unsigned int tid;
 };
 
 
@@ -110,7 +110,7 @@ struct c2hlbk_event{
 	unsigned char	b0;
 	unsigned short  s2;
 	unsigned char	b1;
-	unsigned int	w1;
+	unsigned int	w1;	
 };
 #endif//CONFIG_H2CLBK
 
@@ -124,7 +124,7 @@ struct fwevent {
 };
 
 
-#define C2HEVENT_SZ			32
+#define C2HEVENT_SZ			32	
 
 struct event_node{
 	unsigned char *node;
@@ -146,8 +146,9 @@ struct c2hevent_queue {
 struct network_queue {
 	volatile int	head;
 	volatile int	tail;
-	WLAN_BSSID_EX networks[NETWORK_QUEUE_SZ];
+	WLAN_BSSID_EX networks[NETWORK_QUEUE_SZ];	
 };
 
 
 #endif // _WLANEVENT_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_ht.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_ht.h
old mode 100644
new mode 100755
index 74e416d..3cd904d
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_ht.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_ht.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -26,13 +26,13 @@
 
 struct ht_priv
 {
-	u32	ht_option;
+	u32	ht_option;	
 	u32	ampdu_enable;//for enable Tx A-MPDU
 	//u8	baddbareq_issued[16];
 	u32	tx_amsdu_enable;//for enable Tx A-MSDU
 	u32	tx_amdsu_maxlen; // 1: 8k, 0:4k ; default:8k, for tx
 	u32	rx_ampdu_maxlen; //for rx reordering ctrl win_sz, updated when join_callback.
-
+	
 	u8	bwmode;//
 	u8	ch_offset;//PRIME_CHNL_OFFSET
 	u8	sgi;//short GI
@@ -43,7 +43,8 @@ struct ht_priv
 	u8	candidate_tid_bitmap;
 
 	struct rtw_ieee80211_ht_cap ht_cap;
-
+	
 };
 
 #endif	//_RTL871X_HT_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_io.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_io.h
old mode 100644
new mode 100755
index daf342ac..c66845c
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_io.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_io.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -74,7 +74,7 @@
 #define _IO_CMDMASK_	(0x1F80)
 
 
-/*
+/* 
 	For prompt mode accessing, caller shall free io_req
 	Otherwise, io_handler will free io_req
 */
@@ -151,16 +151,16 @@ struct _io_ops
 
 		void (*_read_port_cancel)(struct intf_hdl *pintfhdl);
 		void (*_write_port_cancel)(struct intf_hdl *pintfhdl);
-
+		
 };
 
-struct io_req {
+struct io_req {	
 	_list	list;
-	u32	addr;
+	u32	addr;	
 	volatile u32	val;
 	u32	command;
 	u32	status;
-	u8	*pbuf;
+	u8	*pbuf;	
 	_sema	sema;
 
 #ifdef PLATFORM_OS_CE
@@ -169,31 +169,31 @@ struct io_req {
 	USB_TRANSFER usb_transfer_write_mem;
 #endif
 #endif
-
+	
 	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt);
-	u8 *cnxt;
+	u8 *cnxt;	
 
-#ifdef PLATFORM_OS_XP
+#ifdef PLATFORM_OS_XP	
 	PMDL pmdl;
-	PIRP  pirp;
+	PIRP  pirp; 
 
 #ifdef CONFIG_SDIO_HCI
 	PSDBUS_REQUEST_PACKET sdrp;
-#endif
+#endif	
 
-#endif
+#endif	
 
 
 };
 
 struct	intf_hdl {
 
-/*
+/*	
 	u32	intf_option;
 	u32	bus_status;
 	u32	do_flush;
 	u8	*adapter;
-	u8	*intf_dev;
+	u8	*intf_dev;	
 	struct intf_priv	*pintfpriv;
 	u8	cnt;
 	void (*intf_hdl_init)(u8 *priv);
@@ -203,7 +203,7 @@ struct	intf_hdl {
 	struct	_io_ops	io_ops;
 	//u8 intf_status;//moved to struct intf_priv
 	u16 len;
-	u16 done_len;
+	u16 done_len;	
 */
 	_adapter *padapter;
 	struct dvobj_priv *pintf_dev;//	pointer to &(padapter->dvobjpriv);
@@ -214,7 +214,7 @@ struct	intf_hdl {
 
 struct reg_protocol_rd {
 
-#ifdef CONFIG_LITTLE_ENDIAN
+#ifdef CONFIG_LITTLE_ENDIAN	
 
 	//DW1
 	u32		NumOfTrans:4;
@@ -239,22 +239,22 @@ struct reg_protocol_rd {
 
 //DW1
 	u32 Reserved1  :4;
-	u32 NumOfTrans :4;
+	u32 NumOfTrans :4;	
 
-	u32 Reserved2  :24;
+	u32 Reserved2  :24;	
 
 	//DW2
 	u32 WriteEnable : 1;
-	u32 ByteCount :7;
+	u32 ByteCount :7;	
 
 
 	u32 Reserved3 : 3;
-	u32 Byte4Access : 1;
+	u32 Byte4Access : 1;	
 
 	u32 Byte2Access : 1;
-	u32 Byte1Access : 1;
-	u32 BurstMode :1 ;
-	u32 FixOrContinuous : 1;
+	u32 Byte1Access : 1;	
+	u32 BurstMode :1 ;	
+	u32 FixOrContinuous : 1;	
 
 	u32 Reserved4 : 16;
 
@@ -265,12 +265,12 @@ struct reg_protocol_rd {
 	//u32		Value;
 
 #endif
-
+	
 };
 
 
 struct reg_protocol_wt {
-
+	
 
 #ifdef CONFIG_LITTLE_ENDIAN
 
@@ -296,21 +296,21 @@ struct reg_protocol_wt {
 #else
 	//DW1
 	u32 Reserved1  :4;
-	u32 NumOfTrans :4;
+	u32 NumOfTrans :4;	
 
-	u32 Reserved2  :24;
+	u32 Reserved2  :24;	
 
 	//DW2
 	u32 WriteEnable : 1;
-	u32 ByteCount :7;
-
+	u32 ByteCount :7;	
+		
 	u32 Reserved3 : 3;
-	u32 Byte4Access : 1;
+	u32 Byte4Access : 1;	
 
 	u32 Byte2Access : 1;
-	u32 Byte1Access : 1;
-	u32 BurstMode :1 ;
-	u32 FixOrContinuous : 1;
+	u32 Byte1Access : 1;	
+	u32 BurstMode :1 ;	
+	u32 FixOrContinuous : 1;	
 
 	u32 Reserved4 : 16;
 
@@ -331,10 +331,10 @@ struct reg_protocol_wt {
 
 */
 
-struct io_queue {
-	_lock	lock;
-	_list  	free_ioreqs;
-	_list		pending;		//The io_req list that will be served in the single protocol read/write.
+struct io_queue {	
+	_lock	lock;	
+	_list  	free_ioreqs;	
+	_list		pending;		//The io_req list that will be served in the single protocol read/write.	
 	_list		processing;
 	u8	*free_ioreqs_buf; // 4-byte aligned
 	u8	*pallocated_free_ioreqs_buf;
@@ -342,9 +342,9 @@ struct io_queue {
 };
 
 struct io_priv{
-
-	_adapter *padapter;
-
+	
+	_adapter *padapter;	
+		
 	struct intf_hdl intf;
 
 };
@@ -443,9 +443,9 @@ struct io_priv{
 
 extern void rtw_write_scsi(_adapter *adapter, u32 cnt, u8 *pmem);
 
-//ioreq
+//ioreq 
 extern void ioreq_read8(_adapter *adapter, u32 addr, u8 *pval);
-extern void ioreq_read16(_adapter *adapter, u32 addr, u16 *pval);
+extern void ioreq_read16(_adapter *adapter, u32 addr, u16 *pval);	
 extern void ioreq_read32(_adapter *adapter, u32 addr, u32 *pval);
 extern void ioreq_write8(_adapter *adapter, u32 addr, u8 val);
 extern void ioreq_write16(_adapter *adapter, u32 addr, u16 val);
@@ -453,11 +453,11 @@ struct io_priv{
 
 
 extern uint async_read8(_adapter *adapter, u32 addr, u8 *pbuff,
-	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt);
+	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt); 
 extern uint async_read16(_adapter *adapter, u32 addr,  u8 *pbuff,
-	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt);
+	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt); 
 extern uint async_read32(_adapter *adapter, u32 addr,  u8 *pbuff,
-	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt);
+	void (*_async_io_callback)(_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt); 
 
 extern void async_read_mem(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
 extern void async_read_port(_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_ioctl.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_ioctl.h
old mode 100644
new mode 100755
index 093e46b..c4da301
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_ioctl.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_ioctl.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -65,9 +65,9 @@
 
 #define DEBUG_OID(dbg, str)     		\
        if((!dbg))				    			\
-	{					    			\
+      	{					    			\
 	   RT_TRACE(_module_rtl871x_ioctl_c_,_drv_info_,("%s(%d): %s", __FUNCTION__, __LINE__, str));	\
-	}
+      	}			
 
 
 enum oid_type
@@ -79,10 +79,10 @@ enum oid_type
 struct oid_funs_node {
 	unsigned int oid_start; //the starting number for OID
 	unsigned int oid_end; //the ending number for OID
-	struct oid_obj_priv *node_array;
+	struct oid_obj_priv *node_array; 
 	unsigned int array_sz; //the size of node_array
-	int query_counter; //count the number of query hits for this segment
-	int set_counter; //count the number of set hits for this segment
+	int query_counter; //count the number of query hits for this segment  
+	int set_counter; //count the number of set hits for this segment  
 };
 
 struct oid_par_priv
@@ -98,8 +98,8 @@ struct oid_par_priv
 };
 
 struct oid_obj_priv {
-	unsigned char	dbg; // 0: without OID debug message  1: with OID debug message
-	NDIS_STATUS (*oidfuns)(struct oid_par_priv *poid_par_priv);
+	unsigned char	dbg; // 0: without OID debug message  1: with OID debug message 
+	NDIS_STATUS (*oidfuns)(struct oid_par_priv *poid_par_priv);	
 };
 
 #if (defined(CONFIG_MP_INCLUDED) && defined(_RTW_MP_IOCTL_C_)) || \
@@ -235,7 +235,7 @@ static NDIS_STATUS oid_null_function(struct oid_par_priv* poid_par_priv)
 NDIS_STATUS oid_802_11_statistics_hdl(struct oid_par_priv* poid_par_priv);
 
 
-//OID Handler for Segment ED
+//OID Handler for Segment ED 
 NDIS_STATUS oid_rt_mh_vender_id_hdl(struct oid_par_priv* poid_par_priv);
 
 void Set_802_3_MULTICAST_LIST(ADAPTER *pAdapter, UCHAR *MCListbuf, ULONG MCListlen, BOOLEAN bAcceptAllMulticast);
@@ -266,3 +266,4 @@ extern	NDIS_STATUS 	drv_set_info(
 	);
 
 #endif // #ifndef __INC_CEINFO_
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_ioctl_query.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_ioctl_query.h
old mode 100644
new mode 100755
index 3fcbc54..5b6018a
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_ioctl_query.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_ioctl_query.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -33,3 +33,4 @@
 
 
 #endif
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_ioctl_rtl.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_ioctl_rtl.h
old mode 100644
new mode 100755
index c017006..3bff766
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_ioctl_rtl.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_ioctl_rtl.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -24,7 +24,7 @@
 #include <osdep_service.h>
 #include <drv_types.h>
 
-//************** oid_rtl_seg_01_01 **************
+//************** oid_rtl_seg_01_01 ************** 
 NDIS_STATUS oid_rt_get_signal_quality_hdl(struct oid_par_priv* poid_par_priv);//84
 NDIS_STATUS oid_rt_get_small_packet_crc_hdl(struct oid_par_priv* poid_par_priv);
 NDIS_STATUS oid_rt_get_middle_packet_crc_hdl(struct oid_par_priv* poid_par_priv);
@@ -63,17 +63,17 @@
 NDIS_STATUS oid_rt_get_bss_wireless_mode_hdl(struct oid_par_priv* poid_par_priv);
 NDIS_STATUS oid_rt_scan_with_magic_packet_hdl(struct oid_par_priv* poid_par_priv);
 
-//**************  oid_rtl_seg_01_03 section start **************
+//**************  oid_rtl_seg_01_03 section start ************** 
 NDIS_STATUS oid_rt_ap_get_associated_station_list_hdl(struct oid_par_priv* poid_par_priv);
 NDIS_STATUS oid_rt_ap_switch_into_ap_mode_hdl(struct oid_par_priv* poid_par_priv);
 NDIS_STATUS oid_rt_ap_supported_hdl(struct oid_par_priv* poid_par_priv);
 NDIS_STATUS oid_rt_ap_set_passphrase_hdl(struct oid_par_priv* poid_par_priv);
 
-// oid_rtl_seg_01_11
+// oid_rtl_seg_01_11 
 NDIS_STATUS oid_rt_pro_rf_write_registry_hdl(struct oid_par_priv* poid_par_priv);
 NDIS_STATUS oid_rt_pro_rf_read_registry_hdl(struct oid_par_priv* poid_par_priv);
 
-//**************  oid_rtl_seg_03_00 section start **************
+//**************  oid_rtl_seg_03_00 section start **************  
 NDIS_STATUS oid_rt_get_connect_state_hdl(struct oid_par_priv* poid_par_priv);
 NDIS_STATUS oid_rt_set_default_key_id_hdl(struct oid_par_priv* poid_par_priv);
 
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_ioctl_set.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_ioctl_set.h
old mode 100644
new mode 100755
index 225cadc..82f9810
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_ioctl_set.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_ioctl_set.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -63,11 +63,10 @@
 u8 rtw_set_802_11_infrastructure_mode(_adapter * padapter, NDIS_802_11_NETWORK_INFRASTRUCTURE networktype);
 u8 rtw_set_802_11_remove_wep(_adapter * padapter, u32 keyindex);
 u8 rtw_set_802_11_ssid(_adapter * padapter, NDIS_802_11_SSID * ssid);
-u8 rtw_set_802_11_connect(_adapter *padapter, const u8 *bssid
-	, NDIS_802_11_SSID *ssid);
+u8 rtw_set_802_11_connect(_adapter* padapter, u8 *bssid, NDIS_802_11_SSID *ssid);
 u8 rtw_set_802_11_remove_key(_adapter * padapter, NDIS_802_11_REMOVE_KEY * key);
 
-u8 rtw_validate_bssid(const u8 *bssid);
+u8 rtw_validate_bssid(u8 *bssid);
 u8 rtw_validate_ssid(NDIS_802_11_SSID *ssid);
 
 u16 rtw_get_cur_max_rate(_adapter *adapter);
@@ -77,3 +76,4 @@ u8 rtw_set_802_11_connect(_adapter *padapter, const u8 *bssid
 int rtw_set_band(_adapter *adapter, enum _BAND band);
 
 #endif
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_iol.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_iol.h
old mode 100644
new mode 100755
index 59786ee..45fa5a2
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_iol.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_iol.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_led.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_led.h
old mode 100644
new mode 100755
index 7de268e..b5365ba
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_led.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_led.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -38,7 +38,7 @@
         LED_CTL_START_WPS = 9,
         LED_CTL_STOP_WPS = 10,
         LED_CTL_START_WPS_BOTTON = 11, //added for runtop
-        LED_CTL_STOP_WPS_FAIL = 12, //added for ALPHA
+        LED_CTL_STOP_WPS_FAIL = 12, //added for ALPHA	
 	 LED_CTL_STOP_WPS_FAIL_OVERLAP = 13, //added for BELKIN
 }LED_CTL_MODE;
 
@@ -58,9 +58,9 @@
 	LED_SCAN_BLINK = 6, // LED is blinking during scanning period, the # of times to blink is depend on time for scanning.
 	LED_NO_LINK_BLINK = 7, // LED is blinking during no link state.
 	LED_BLINK_StartToBlink = 8,// Customzied for Sercomm Printer Server case
-	LED_BLINK_WPS = 9,	// LED is blinkg during WPS communication
+	LED_BLINK_WPS = 9,	// LED is blinkg during WPS communication	
 	LED_TXRX_BLINK = 10,
-	LED_BLINK_WPS_STOP = 11,	//for ALPHA
+	LED_BLINK_WPS_STOP = 11,	//for ALPHA	
 	LED_BLINK_WPS_STOP_OVERLAP = 12,	//for BELKIN
 }LED_STATE_871x;
 
@@ -92,7 +92,7 @@
 	u8					bLedStartToLinkBlinkInProgress;
 	u8					bLedScanBlinkInProgress;
 	u8					bLedWPSBlinkInProgress;
-
+	
 	u32					BlinkTimes; // Number of times to toggle led state for blinking.
 	LED_STATE_871x		BlinkingLedState; // Next state for blinking, either RTW_LED_ON or RTW_LED_OFF are.
 
@@ -133,7 +133,7 @@
 	LED_POWER_ON_BLINK = 5,
 	LED_SCAN_BLINK = 6, // LED is blinking during scanning period, the # of times to blink is depend on time for scanning.
 	LED_NO_LINK_BLINK = 7, // LED is blinking during no link state.
-	LED_BLINK_StartToBlink = 8,
+	LED_BLINK_StartToBlink = 8, 
 	LED_BLINK_TXRX = 9,
 	LED_BLINK_RUNTOP = 10, // Customized for RunTop
 	LED_BLINK_CAMEO = 11,
@@ -162,7 +162,7 @@
 	LED_STATE_871x		BlinkingLedState; // Next state for blinking, either RTW_LED_ON or RTW_LED_OFF are.
 
 	_timer				BlinkTimer; // Timer object for led blinking.
-
+	
 	u8					bLedLinkBlinkInProgress;
 	u8					bLedNoLinkBlinkInProgress;
 	u8 					bLedScanBlinkInProgress;
@@ -183,7 +183,7 @@
 	SW_LED_MODE6, //added by vivi, for led new mode, PRONET
 	SW_LED_MODE7, //added by chiyokolin, for Lenovo, PCI Express Minicard Spec Rev.1.2 spec
 	SW_LED_MODE8, //added by chiyokolin, for QMI
-	SW_LED_MODE9, //added by chiyokolin, for BITLAND, PCI Express Minicard Spec Rev.1.1
+	SW_LED_MODE9, //added by chiyokolin, for BITLAND, PCI Express Minicard Spec Rev.1.1 
 	SW_LED_MODE10, //added by chiyokolin, for Edimax-ASUS
 	HW_LED, // HW control 2 LEDs, LED0 and LED1 (there are 4 different control modes)
 }LED_STRATEGY_871x, *PLED_STRATEGY_871x;
@@ -214,3 +214,4 @@ struct led_priv{
 extern void BlinkHandler(PLED_871x	 pLed);
 
 #endif //__RTW_LED_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_mlme.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_mlme.h
old mode 100644
new mode 100755
index 862326d..60e2ad6
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_mlme.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_mlme.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -214,7 +214,7 @@ struct wifi_display_info{
 	u8							wfd_pc;				//	WFD preferred connection
 													//	0 -> Prefer to use the P2P for WFD connection on peer side.
 													//	1 -> Prefer to use the TDLS for WFD connection on peer side.
-
+											
 	u8							wfd_device_type;	//	WFD Device Type
 													//	0 -> WFD Source Device
 													//	1 -> WFD Primary Sink Device
@@ -233,7 +233,7 @@ struct tx_provdisc_req_info{
 
 struct rx_provdisc_req_info{	//When peer device issue prov_disc_req first, we should store the following informations
 	u8					peerDevAddr[ ETH_ALEN ];		//	Peer device address
-	u8					strconfig_method_desc_of_prov_disc_req[4];	//	description for the config method located in the provisioning discovery request frame.
+	u8					strconfig_method_desc_of_prov_disc_req[4];	//	description for the config method located in the provisioning discovery request frame.	
 																	//	The UI must know this information to know which config method the remote p2p device is requiring.
 };
 
@@ -272,7 +272,7 @@ struct wifidirect_info{
 	_adapter*				padapter;
 	_timer					find_phase_timer;
 	_timer					restore_p2p_state_timer;
-
+	
 	//	Used to do the scanning. After confirming the peer is availalble, the driver transmits the P2P frame to peer.
 	_timer					pre_tx_scan_timer;
 	_timer					reset_ch_sitesurvey;
@@ -292,7 +292,7 @@ struct wifidirect_info{
 	struct scan_limit_info		p2p_info;		//	Used for get the limit scan channel from the P2P negotiation handshake
 #ifdef CONFIG_WFD
 	struct wifi_display_info		*wfd_info;
-#endif
+#endif	
 	enum P2P_ROLE			role;
 	enum P2P_STATE			pre_p2p_state;
 	enum P2P_STATE			p2p_state;
@@ -339,7 +339,7 @@ struct wifidirect_info{
 
 	enum	P2P_WPSINFO		ui_got_wps_info;			//	This field will store the WPS value (PIN value or PBC) that UI had got from the user.
 	u16						supported_wps_cm;			//	This field describes the WPS config method which this driver supported.
-														//	The value should be the combination of config method defined in page104 of WPS v2.0 spec.
+														//	The value should be the combination of config method defined in page104 of WPS v2.0 spec.	
 	u8						external_uuid;				//  UUID flag
 	u8						uuid[16];					//  UUID
 	uint						channel_list_attr_len;		//	This field will contain the length of body of P2P Channel List attribute of group negotitation response frame.
@@ -390,7 +390,7 @@ struct tdls_info{
 	u8					enable;
 #ifdef CONFIG_WFD
 	struct wifi_display_info		*wfd_info;
-#endif
+#endif		
 };
 
 struct mlme_priv {
@@ -442,7 +442,7 @@ struct mlme_priv {
 	int num_sta_no_ht;
 
 	/* Number of HT AP/stations 20 MHz */
-	//int num_sta_ht_20mhz;
+	//int num_sta_ht_20mhz; 
 
 
 	int num_FortyMHzIntolerant;
@@ -458,7 +458,7 @@ struct mlme_priv {
 	u8	ChannelPlan;
 	RT_SCAN_TYPE 	scan_mode; // active: 1, passive: 0
 
-	//u8 probereq_wpsie[MAX_WPS_IE_LEN];//added in probe req
+	//u8 probereq_wpsie[MAX_WPS_IE_LEN];//added in probe req	
 	//int probereq_wpsie_len;
 	u8 *wps_probe_req_ie;
 	u32 wps_probe_req_ie_len;
@@ -487,17 +487,17 @@ struct mlme_priv {
 
 	/* Overlapping BSS information */
 	int olbc_ht;
-
+	
 #ifdef CONFIG_80211N_HT
 	u16 ht_op_mode;
-#endif /* CONFIG_80211N_HT */
+#endif /* CONFIG_80211N_HT */	
 
 	u8 *assoc_req;
 	u32 assoc_req_len;
 	u8 *assoc_rsp;
 	u32 assoc_rsp_len;
 
-	u8 *wps_beacon_ie;
+	u8 *wps_beacon_ie;	
 	//u8 *wps_probe_req_ie;
 	u8 *wps_probe_resp_ie;
 	u8 *wps_assoc_resp_ie; // for CONFIG_IOCTL_CFG80211, this IE could include p2p ie / wfd ie
@@ -506,11 +506,11 @@ struct mlme_priv {
 	//u32 wps_probe_req_ie_len;
 	u32 wps_probe_resp_ie_len;
 	u32 wps_assoc_resp_ie_len; // for CONFIG_IOCTL_CFG80211, this IE len could include p2p ie / wfd ie
-
+	
 	u8 *p2p_beacon_ie;
 	u8 *p2p_probe_req_ie;
-	u8 *p2p_probe_resp_ie;
-	u8 *p2p_go_probe_resp_ie; //for GO
+	u8 *p2p_probe_resp_ie;	
+	u8 *p2p_go_probe_resp_ie; //for GO	
 	u8 *p2p_assoc_req_ie;
 
 	u32 p2p_beacon_ie_len;
@@ -530,19 +530,19 @@ struct mlme_priv {
 	u32 wps_p2p_assoc_resp_ie_len;
 #endif
 */
-
+	
 	_lock	bcn_update_lock;
 	u8		update_bcn;
-
-
+	
+	
 #endif //#if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
 
 #if defined(CONFIG_WFD) && defined(CONFIG_IOCTL_CFG80211)
-
+	
 	u8 *wfd_beacon_ie;
 	u8 *wfd_probe_req_ie;
-	u8 *wfd_probe_resp_ie;
-	u8 *wfd_go_probe_resp_ie; //for GO
+	u8 *wfd_probe_resp_ie;	
+	u8 *wfd_go_probe_resp_ie; //for GO	
 	u8 *wfd_assoc_req_ie;
 
 	u32 wfd_beacon_ie_len;
@@ -600,8 +600,8 @@ struct hostapd_priv
 #ifdef CONFIG_HOSTAPD_MLME
 	struct net_device *pmgnt_netdev;
 	struct usb_anchor anchored;
-#endif
-
+#endif	
+	
 };
 
 extern int hostapd_mode_init(_adapter *padapter);
@@ -639,8 +639,14 @@ extern void _rtw_scan_timeout_handler (
 
 #if defined (PLATFORM_LINUX)|| defined (PLATFORM_FREEBSD)
 extern int event_thread(void *context);
-extern void rtw_join_timeout_handler(void* FunctionContext);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+extern void rtw_join_timeout_handler(void *FunctionContext);
 extern void _rtw_scan_timeout_handler(void* FunctionContext);
+#else
+extern void rtw_join_timeout_handler(struct timer_list *t);
+extern void _rtw_scan_timeout_handler(struct timer_list *t);
+#endif
 #endif
 
 extern void rtw_free_network_queue(_adapter *adapter,u8 isfreeall);
@@ -841,3 +847,4 @@ __inline static void set_scanned_network_val(struct mlme_priv *pmlmepriv, sint v
 void rtw_proxim_send_packet(_adapter *padapter,u8 *pbuf,u16 len,u8 hw_rate);
 #endif //CONFIG_INTEL_PROXIM
 #endif //__RTL871X_MLME_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_mlme_ext.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_mlme_ext.h
old mode 100644
new mode 100755
index 4403244..5cddca4
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_mlme_ext.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_mlme_ext.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -44,7 +44,7 @@
 #define REASSOC_LIMIT	(4)
 #define READDBA_LIMIT	(2)
 
-//#define	IOCMD_REG0		0x10250370
+//#define	IOCMD_REG0		0x10250370		 	
 //#define	IOCMD_REG1		0x10250374
 //#define	IOCMD_REG2		0x10250378
 
@@ -94,12 +94,12 @@
 
 //
 // Channel Plan Type.
-// Note:
-//	We just add new channel plan when the new channel plan is different from any of the following
-//	channel plan.
+// Note: 
+//	We just add new channel plan when the new channel plan is different from any of the following 
+//	channel plan. 
 //	If you just wnat to customize the acitions(scan period or join actions) about one of the channel plan,
 //	customize them in RT_CHANNEL_INFO in the RT_CHANNEL_LIST.
-//
+// 
 typedef enum _RT_CHANNEL_DOMAIN
 {
 	//===== old channel plan mapping =====//
@@ -123,7 +123,7 @@
 	RT_CHANNEL_DOMAIN_FCC_NO_DFS = 0x11,
 	RT_CHANNEL_DOMAIN_JAPAN_NO_DFS = 0x12,
 	RT_CHANNEL_DOMAIN_WORLD_WIDE_5G = 0x13,
-	RT_CHANNEL_DOMAIN_TAIWAN_NO_DFS = 0x14,
+	RT_CHANNEL_DOMAIN_TAIWAN_NO_DFS = 0x14,	
 
 	//===== new channel plan mapping, (2GDOMAIN_5GDOMAIN) =====//
 	RT_CHANNEL_DOMAIN_WORLD_NULL = 0x20,
@@ -253,7 +253,7 @@ struct action_handler {
 	unsigned int (*func)(_adapter *padapter, union recv_frame *precv_frame);
 };
 
-struct	ss_res
+struct	ss_res	
 {
 	int	state;
 	int	bss_cnt;
@@ -329,17 +329,17 @@ struct FW_Sta_Info
 
 /*
  * Usage:
- * When one iface acted as AP mode and the other iface is STA mode and scanning,
+ * When one iface acted as AP mode and the other iface is STA mode and scanning, 
  * it should switch back to AP's operating channel periodically.
  * Parameters info:
  * When the driver scanned RTW_SCAN_NUM_OF_CH channels, it would switch back to AP's operating channel for
  * RTW_STAY_AP_CH_MILLISECOND * SURVEY_TO milliseconds.
  * Example:
- * For chip supports 2.4G + 5GHz and AP mode is operating in channel 1,
+ * For chip supports 2.4G + 5GHz and AP mode is operating in channel 1, 
  * RTW_SCAN_NUM_OF_CH is 8, RTW_STAY_AP_CH_MILLISECOND is 3 and SURVEY_TO is 100.
- * When it's STA mode gets set_scan command,
- * it would
- * 1. Doing the scan on channel 1.2.3.4.5.6.7.8
+ * When it's STA mode gets set_scan command, 
+ * it would 
+ * 1. Doing the scan on channel 1.2.3.4.5.6.7.8 
  * 2. Back to channel 1 for 300 milliseconds
  * 3. Go through doing site survey on channel 9.10.11.36.40.44.48.52
  * 4. Back to channel 1 for 300 milliseconds
@@ -347,8 +347,8 @@ struct FW_Sta_Info
  */
 #if defined CONFIG_STA_MODE_SCAN_UNDER_AP_MODE && defined CONFIG_CONCURRENT_MODE
 #define RTW_SCAN_NUM_OF_CH			8
-#define RTW_STAY_AP_CH_MILLISECOND	3	// this value is a multiplier,for example, when this value is 3, it would stay AP's op ch for
-											// 3 * SURVEY_TO millisecond.
+#define RTW_STAY_AP_CH_MILLISECOND	3	// this value is a multiplier,for example, when this value is 3, it would stay AP's op ch for 
+											// 3 * SURVEY_TO millisecond. 
 #endif //defined CONFIG_STA_MODE_SCAN_UNDER_AP_MODE && defined CONFIG_CONCURRENT_MODE
 
 struct mlme_ext_info
@@ -374,7 +374,7 @@ struct mlme_ext_info
 	u8	ERP_enable;
 	u8	ERP_IE;
 	u8	HT_enable;
-	u8	HT_caps_enable;
+	u8	HT_caps_enable;	
 	u8	HT_info_enable;
 	u8	HT_protection;
 	u8	turboMode_cts2self;
@@ -462,19 +462,19 @@ struct mlme_ext_priv
 	u64 mgnt_80211w_IPN_rx;
 #endif //CONFIG_IEEE80211W
 	//struct fw_priv 	fwpriv;
-
+	
 	unsigned char	cur_channel;
 	unsigned char	cur_bwmode;
 	unsigned char	cur_ch_offset;//PRIME_CHNL_OFFSET
-	unsigned char	cur_wireless_mode;
+	unsigned char	cur_wireless_mode;	
 
 	unsigned char	max_chan_nums;
 	RT_CHANNEL_INFO		channel_set[MAX_CHANNEL_NUM];
 	struct p2p_channels channel_list;
 	unsigned char	basicrate[NumRates];
 	unsigned char	datarate[NumRates];
-
-	struct ss_res		sitesurvey_res;
+	
+	struct ss_res		sitesurvey_res;		
 	struct mlme_ext_info	mlmext_info;//for sta/adhoc mode, including current scanning/connecting/connected related info.
                                                      //for ap mode, network includes ap's cap_info
 	_timer		survey_timer;
@@ -489,10 +489,10 @@ struct mlme_ext_priv
 	u8	tx_rate; // TXRATE when USERATE is set.
 
 	u32	retry; //retry for issue probereq
-
+	
 	u64 TSFValue;
 
-#ifdef CONFIG_AP_MODE
+#ifdef CONFIG_AP_MODE	
 	unsigned char bstart_bss;
 #endif
 
@@ -507,7 +507,7 @@ struct mlme_ext_priv
 #ifdef CONFIG_ACTIVE_KEEP_ALIVE_CHECK
 	u8 active_keep_alive_check;
 #endif
-
+	
 };
 
 int init_mlme_ext_priv(_adapter* padapter);
@@ -755,7 +755,7 @@ struct mlme_ext_priv
 
 struct cmd_hdl {
 	uint	parmsize;
-	u8 (*h2cfuns)(struct _ADAPTER *padapter, u8 *pbuf);
+	u8 (*h2cfuns)(struct _ADAPTER *padapter, u8 *pbuf);	
 };
 
 
@@ -772,7 +772,7 @@ struct cmd_hdl {
 u8 disconnect_hdl(_adapter *padapter, u8 *pbuf);
 u8 createbss_hdl(_adapter *padapter, u8 *pbuf);
 u8 setopmode_hdl(_adapter *padapter, u8 *pbuf);
-u8 sitesurvey_cmd_hdl(_adapter *padapter, u8 *pbuf);
+u8 sitesurvey_cmd_hdl(_adapter *padapter, u8 *pbuf);	
 u8 setauth_hdl(_adapter *padapter, u8 *pbuf);
 u8 setkey_hdl(_adapter *padapter, u8 *pbuf);
 u8 set_stakey_hdl(_adapter *padapter, u8 *pbuf);
@@ -795,7 +795,7 @@ struct cmd_hdl {
 
 #ifdef _RTW_CMD_C_
 
-struct cmd_hdl wlancmds[] =
+struct cmd_hdl wlancmds[] = 
 {
 	GEN_DRV_CMD_HANDLER(0, NULL) /*0*/
 	GEN_DRV_CMD_HANDLER(0, NULL)
@@ -810,7 +810,7 @@ struct cmd_hdl wlancmds[] =
 	GEN_MLME_EXT_HANDLER(0, NULL) /*10*/
 	GEN_MLME_EXT_HANDLER(0, NULL)
 	GEN_MLME_EXT_HANDLER(0, NULL)
-	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)		
 	GEN_MLME_EXT_HANDLER(sizeof (struct joinbss_parm), join_cmd_hdl) /*14*/
 	GEN_MLME_EXT_HANDLER(sizeof (struct disconnect_parm), disconnect_hdl)
 	GEN_MLME_EXT_HANDLER(sizeof (struct createbss_parm), createbss_hdl)
@@ -842,7 +842,7 @@ struct cmd_hdl wlancmds[] =
 	GEN_MLME_EXT_HANDLER(0, NULL)
 	GEN_MLME_EXT_HANDLER(0, NULL)
 	GEN_MLME_EXT_HANDLER(0, NULL)
-	GEN_MLME_EXT_HANDLER(sizeof(struct addBaReq_parm), add_ba_hdl)
+	GEN_MLME_EXT_HANDLER(sizeof(struct addBaReq_parm), add_ba_hdl)	
 	GEN_MLME_EXT_HANDLER(sizeof(struct set_ch_parm), set_ch_hdl) /* 46 */
 	GEN_MLME_EXT_HANDLER(0, NULL)
 	GEN_MLME_EXT_HANDLER(0, NULL)
@@ -851,7 +851,7 @@ struct cmd_hdl wlancmds[] =
 	GEN_MLME_EXT_HANDLER(0, NULL)
 	GEN_MLME_EXT_HANDLER(0, NULL)
 	GEN_MLME_EXT_HANDLER(0, NULL)
-	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL) 
 	GEN_MLME_EXT_HANDLER(sizeof(struct Tx_Beacon_param), tx_beacon_hdl) /*55*/
 
 	GEN_MLME_EXT_HANDLER(0, mlme_evt_hdl) /*56*/
@@ -874,13 +874,13 @@ struct C2HEvent_Header
 	unsigned int len:16;
 	unsigned int ID:8;
 	unsigned int seq:8;
-
+	
 #elif defined(CONFIG_BIG_ENDIAN)
 
 	unsigned int seq:8;
 	unsigned int ID:8;
 	unsigned int len:16;
-
+	
 #else
 
 #  error "Must be LITTLE or BIG Endian"
@@ -898,37 +898,37 @@ enum rtw_c2h_event
 {
 	GEN_EVT_CODE(_Read_MACREG)=0, /*0*/
 	GEN_EVT_CODE(_Read_BBREG),
-	GEN_EVT_CODE(_Read_RFREG),
-	GEN_EVT_CODE(_Read_EEPROM),
-	GEN_EVT_CODE(_Read_EFUSE),
+ 	GEN_EVT_CODE(_Read_RFREG),
+ 	GEN_EVT_CODE(_Read_EEPROM),
+ 	GEN_EVT_CODE(_Read_EFUSE),
 	GEN_EVT_CODE(_Read_CAM),			/*5*/
-	GEN_EVT_CODE(_Get_BasicRate),
-	GEN_EVT_CODE(_Get_DataRate),
-	GEN_EVT_CODE(_Survey),	 /*8*/
-	GEN_EVT_CODE(_SurveyDone),	 /*9*/
-
-	GEN_EVT_CODE(_JoinBss) , /*10*/
-	GEN_EVT_CODE(_AddSTA),
-	GEN_EVT_CODE(_DelSTA),
-	GEN_EVT_CODE(_AtimDone) ,
-	GEN_EVT_CODE(_TX_Report),
+ 	GEN_EVT_CODE(_Get_BasicRate),  
+ 	GEN_EVT_CODE(_Get_DataRate),   
+ 	GEN_EVT_CODE(_Survey),	 /*8*/
+ 	GEN_EVT_CODE(_SurveyDone),	 /*9*/
+ 	
+ 	GEN_EVT_CODE(_JoinBss) , /*10*/
+ 	GEN_EVT_CODE(_AddSTA),
+ 	GEN_EVT_CODE(_DelSTA),
+ 	GEN_EVT_CODE(_AtimDone) ,
+ 	GEN_EVT_CODE(_TX_Report),  
 	GEN_EVT_CODE(_CCX_Report),			/*15*/
-	GEN_EVT_CODE(_DTM_Report),
-	GEN_EVT_CODE(_TX_Rate_Statistics),
-	GEN_EVT_CODE(_C2HLBK),
-	GEN_EVT_CODE(_FWDBG),
+ 	GEN_EVT_CODE(_DTM_Report),
+ 	GEN_EVT_CODE(_TX_Rate_Statistics),
+ 	GEN_EVT_CODE(_C2HLBK), 
+ 	GEN_EVT_CODE(_FWDBG),
 	GEN_EVT_CODE(_C2HFEEDBACK),               /*20*/
 	GEN_EVT_CODE(_ADDBA),
 	GEN_EVT_CODE(_C2HBCN),
-	GEN_EVT_CODE(_ReportPwrState),		//filen: only for PCIE, USB
+	GEN_EVT_CODE(_ReportPwrState),		//filen: only for PCIE, USB	
 	GEN_EVT_CODE(_CloseRF),				//filen: only for PCIE, work around ASPM
-	MAX_C2HEVT
+ 	MAX_C2HEVT
 };
 
 
-#ifdef _RTW_MLME_EXT_C_
+#ifdef _RTW_MLME_EXT_C_		
 
-static struct fwevent wlanevents[] =
+static struct fwevent wlanevents[] = 
 {
 	{0, rtw_dummy_event_callback}, 	/*0*/
 	{0, NULL},
@@ -940,10 +940,10 @@ enum rtw_c2h_event
 	{0, NULL},
 	{0, &rtw_survey_event_callback},		/*8*/
 	{sizeof (struct surveydone_event), &rtw_surveydone_event_callback},	/*9*/
-
+		
 	{0, &rtw_joinbss_event_callback},		/*10*/
 	{sizeof(struct stassoc_event), &rtw_stassoc_event_callback},
-	{sizeof(struct stadel_event), &rtw_stadel_event_callback},
+	{sizeof(struct stadel_event), &rtw_stadel_event_callback},	
 	{0, &rtw_atimdone_event_callback},
 	{0, rtw_dummy_event_callback},
 	{0, NULL},	/*15*/
@@ -953,10 +953,11 @@ enum rtw_c2h_event
 	{0, rtw_fwdbg_event_callback},
 	{0, NULL},	 /*20*/
 	{0, NULL},
-	{0, NULL},
+	{0, NULL},	
 	{0, &rtw_cpwm_event_callback},
 };
 
 #endif//_RTL8192C_CMD_C_
 
 #endif
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_mp.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_mp.h
old mode 100644
new mode 100755
index 06d43b5..0ebb1ba
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_mp.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_mp.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -267,13 +267,13 @@ struct mp_tx
 	ULONG			MptRCR;
 	// TRUE if we only receive packets with specific pattern.
 	BOOLEAN			bMptFilterPattern;
-	// Rx OK count, statistics used in Mass Production Test.
-	ULONG			MptRxOkCnt;
-	// Rx CRC32 error count, statistics used in Mass Production Test.
-	ULONG			MptRxCrcErrCnt;
+ 	// Rx OK count, statistics used in Mass Production Test.
+ 	ULONG			MptRxOkCnt;
+ 	// Rx CRC32 error count, statistics used in Mass Production Test.
+ 	ULONG			MptRxCrcErrCnt;
 
 	BOOLEAN			bCckContTx;	// TRUE if we are in CCK Continuous Tx test.
-	BOOLEAN			bOfdmContTx;	// TRUE if we are in OFDM Continuous Tx test.
+ 	BOOLEAN			bOfdmContTx;	// TRUE if we are in OFDM Continuous Tx test.
 	BOOLEAN			bStartContTx; 	// TRUE if we have start Continuous Tx test.
 	// TRUE if we are in Single Carrier Tx test.
 	BOOLEAN			bSingleCarrier;
@@ -319,7 +319,7 @@ struct mp_tx
 /* end of E-Fuse */
 
 //#define RTPRIV_IOCTL_MP 					( SIOCIWFIRSTPRIV + 0x17)
-enum {
+enum {	  
 	WRITE_REG = 1,
 	READ_REG,
 	WRITE_RF,
@@ -607,7 +607,7 @@ struct bb_reg_param {
 }ENCRY_CTRL_STATE;
 
 typedef enum _OFDM_TX_MODE {
-	OFDM_ALL_OFF		= 0,
+	OFDM_ALL_OFF		= 0,	
 	OFDM_ContinuousTx	= 1,
 	OFDM_SingleCarrier	= 2,
 	OFDM_SingleTone 	= 4,
@@ -709,3 +709,4 @@ struct bb_reg_param {
 extern void Hal_ProSetCrystalCap (PADAPTER pAdapter , u32 CrystalCapVal);
 
 #endif //_RTW_MP_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_mp_ioctl.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_mp_ioctl.h
old mode 100644
new mode 100755
index 3016a9c..962bc38
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_mp_ioctl.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_mp_ioctl.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -528,7 +528,7 @@ enum RTL871X_MP_IOCTL_SUBCODE {
 	GEN_MP_IOCTL_SUBCODE(TRIGGER_GPIO),
 	GEN_MP_IOCTL_SUBCODE(SET_DM_BT),		/*35*/
 	GEN_MP_IOCTL_SUBCODE(DEL_BA),			/*36*/
-	GEN_MP_IOCTL_SUBCODE(GET_WIFI_STATUS),	/*37*/
+	GEN_MP_IOCTL_SUBCODE(GET_WIFI_STATUS),	/*37*/	
 	MAX_MP_IOCTL_SUBCODE,
 };
 
@@ -593,3 +593,4 @@ struct mp_ioctl_handler mp_ioctl_hdl[] = {
 #endif /* _RTW_MP_IOCTL_C_ */
 
 #endif
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_mp_phy_regdef.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_mp_phy_regdef.h
old mode 100644
new mode 100755
index 24e6624..0b47cb5
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_mp_phy_regdef.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_mp_phy_regdef.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -27,18 +27,18 @@
  *			3. PMAC/BB register bit mask.
  *			4. RF reg bit mask.
  *			5. Other BB/RF relative definition.
- *
+ *			
  *
  * Export:	Constants, macro, functions(API), global variables(None).
  *
- * Abbrev:
+ * Abbrev:	
  *
  * History:
- *	Data			Who		Remark
+ *	Data			Who		Remark 
  *	08/07/2007	MHC		1. Porting from 9x series PHYCFG.h.
  *						2. Reorganize code architecture.
  *	09/25/2008	MH		1. Add RL6052 register definition
- *
+ * 
  *****************************************************************************/
 #ifndef __RTW_MP_PHY_REGDEF_H_
 #define __RTW_MP_PHY_REGDEF_H_
@@ -212,7 +212,7 @@
 #define		rOFDM0_XDRxIQImbalance    	0xc2c
 
 #define		rOFDM0_RxDetector1			0xc30  //PD,BW & SBD	// DM tune init gain
-#define		rOFDM0_RxDetector2			0xc34  //SBD & Fame Sync.
+#define		rOFDM0_RxDetector2			0xc34  //SBD & Fame Sync. 
 #define		rOFDM0_RxDetector3			0xc38  //Frame Sync.
 #define		rOFDM0_RxDetector4			0xc3c  //PD, SBD, Frame Sync & Short-GI
 
@@ -221,7 +221,7 @@
 #define		rOFDM0_CCADropThreshold	0xc48 //CCA Drop threshold
 #define		rOFDM0_ECCAThreshold		0xc4c // energy CCA
 
-#define		rOFDM0_XAAGCCore1			0xc50	// DIG
+#define		rOFDM0_XAAGCCore1			0xc50	// DIG  
 #define		rOFDM0_XAAGCCore2			0xc54
 #define		rOFDM0_XBAGCCore1			0xc58
 #define		rOFDM0_XBAGCCore2			0xc5c
@@ -342,47 +342,47 @@
 //
 // RL6052 Register definition
 //
-#define		RF_AC						0x00	//
+#define		RF_AC						0x00	// 
 
-#define		RF_IQADJ_G1				0x01	//
-#define		RF_IQADJ_G2				0x02	//
-#define		RF_POW_TRSW				0x05	//
+#define		RF_IQADJ_G1				0x01	// 
+#define		RF_IQADJ_G2				0x02	// 
+#define		RF_POW_TRSW				0x05	// 
 
-#define		RF_GAIN_RX					0x06	//
-#define		RF_GAIN_TX					0x07	//
+#define		RF_GAIN_RX					0x06	// 
+#define		RF_GAIN_TX					0x07	// 
 
-#define		RF_TXM_IDAC				0x08	//
-#define		RF_BS_IQGEN				0x0F	//
+#define		RF_TXM_IDAC				0x08	// 
+#define		RF_BS_IQGEN				0x0F	// 
 
-#define		RF_MODE1					0x10	//
-#define		RF_MODE2					0x11	//
+#define		RF_MODE1					0x10	// 
+#define		RF_MODE2					0x11	// 
 
-#define		RF_RX_AGC_HP				0x12	//
-#define		RF_TX_AGC					0x13	//
-#define		RF_BIAS						0x14	//
-#define		RF_IPA						0x15	//
-#define		RF_POW_ABILITY			0x17	//
-#define		RF_MODE_AG				0x18	//
+#define		RF_RX_AGC_HP				0x12	// 
+#define		RF_TX_AGC					0x13	// 
+#define		RF_BIAS						0x14	// 
+#define		RF_IPA						0x15	// 
+#define		RF_POW_ABILITY			0x17	// 
+#define		RF_MODE_AG				0x18	// 
 #define		rRfChannel					0x18	// RF channel and BW switch
 #define		RF_CHNLBW					0x18	// RF channel and BW switch
-#define		RF_TOP						0x19	//
+#define		RF_TOP						0x19	// 
 
-#define		RF_RX_G1					0x1A	//
-#define		RF_RX_G2					0x1B	//
+#define		RF_RX_G1					0x1A	// 
+#define		RF_RX_G2					0x1B	// 
 
-#define		RF_RX_BB2					0x1C	//
-#define		RF_RX_BB1					0x1D	//
+#define		RF_RX_BB2					0x1C	// 
+#define		RF_RX_BB1					0x1D	// 
 
-#define		RF_RCK1					0x1E	//
-#define		RF_RCK2					0x1F	//
+#define		RF_RCK1					0x1E	// 
+#define		RF_RCK2					0x1F	// 
 
-#define		RF_TX_G1					0x20	//
-#define		RF_TX_G2					0x21	//
-#define		RF_TX_G3					0x22	//
+#define		RF_TX_G1					0x20	// 
+#define		RF_TX_G2					0x21	// 
+#define		RF_TX_G3					0x22	// 
 
-#define		RF_TX_BB1					0x23	//
+#define		RF_TX_BB1					0x23	// 
 
-#define		RF_T_METER					0x24	//
+#define		RF_T_METER					0x24	// 
 
 #define		RF_SYN_G1					0x25	// RF TX Power control
 #define		RF_SYN_G2					0x26	// RF TX Power control
@@ -464,7 +464,7 @@
 #define		bXBTxAGC                  			0xf00	// Reg 80c rFPGA0_TxGainStage
 #define		bXCTxAGC                  			0xf000
 #define		bXDTxAGC                  			0xf0000
-
+       		
 #define		bPAStart                  			0xf0000000	// Useless now
 #define		bTRStart                  			0x00f00000
 #define		bRFStart                  			0x0000f000
@@ -510,7 +510,7 @@
 #define		bRFSI_ANTSW               		0x100
 #define		bRFSI_ANTSWB              		0x200
 #define		bRFSI_PAPE                			0x400
-#define		bRFSI_PAPE5G              		0x800
+#define		bRFSI_PAPE5G              		0x800 
 #define		bBandSelect               			0x1
 #define		bHTSIG2_GI                			0x80
 #define		bHTSIG2_Smoothing         		0x01
@@ -540,7 +540,7 @@
 #define		bLSSIReadBackData         		0xfffff		// T65 RF
 #endif
 #define		bLSSIReadOKFlag           		0x1000	// Useless now
-#define		bCCKSampleRate            		0x8       //0: 44MHz, 1:88MHz
+#define		bCCKSampleRate            		0x8       //0: 44MHz, 1:88MHz       		
 #define		bRegulator0Standby        		0x1
 #define		bRegulatorPLLStandby      		0x2
 #define		bRegulator1Standby        		0x4
@@ -585,8 +585,8 @@
 #define		bAD11PowerUpAtTx          		0x1
 #define		bDA10PSAtTx               		0x10
 #define		bAD11PowerUpAtRx          		0x100
-#define		bDA10PSAtRx               		0x1000
-#define		bCCKRxAGCFormat           		0x200
+#define		bDA10PSAtRx               		0x1000       		
+#define		bCCKRxAGCFormat           		0x200       		
 #define		bPSDFFTSamplepPoint       		0xc000
 #define		bPSDAverageNum            		0x3000
 #define		bIQPathControl            		0xc00
@@ -685,9 +685,9 @@
 #define		bCCKRxFACounterLower      	0xff
 #define		bCCKRxFACounterUpper      	0xff000000
 #define		bCCKRxHPAGCStart          		0xe000
-#define		bCCKRxHPAGCFinal          		0x1c00
+#define		bCCKRxHPAGCFinal          		0x1c00       		
 #define		bCCKRxFalseAlarmEnable    	0x8000
-#define		bCCKFACounterFreeze       		0x4000
+#define		bCCKFACounterFreeze       		0x4000       		
 #define		bCCKTxPathSel             		0x10000000
 #define		bCCKDefaultRxPath         		0xc000000
 #define		bCCKOptionRxPath          		0x3000000
@@ -839,16 +839,16 @@
 #define		bRxSGI_TH                0xc0000000
 #define		bDFSCnt0                 0xff
 #define		bDFSCnt1                 0xff00
-#define		bDFSFlag                 0xf0000
+#define		bDFSFlag                 0xf0000       		
 #define		bMFWeightSum             0x300000
-#define		bMinIdxTH                0x7f000000
-#define		bDAFormat                0x40000
-#define		bTxChEmuEnable           0x01000000
+#define		bMinIdxTH                0x7f000000       		
+#define		bDAFormat                0x40000       		
+#define		bTxChEmuEnable           0x01000000       		
 #define		bTRSWIsolation_A         0x7f
 #define		bTRSWIsolation_B         0x7f00
 #define		bTRSWIsolation_C         0x7f0000
-#define		bTRSWIsolation_D         0x7f000000
-#define		bExtLNAGain              0x7c00
+#define		bTRSWIsolation_D         0x7f000000       		
+#define		bExtLNAGain              0x7c00          
 
 // 6. PageE(0xE00)
 #define		bSTBCEn                  0x4	// Useless
@@ -885,7 +885,7 @@
 #define		bLongCFOFLength          11
 #define		bTailCFO                 0x1fff
 #define		bTailCFOTLength          13
-#define		bTailCFOFLength          12
+#define		bTailCFOFLength          12       		
 #define		bmax_en_pwdB             0xffff
 #define		bCC_power_dB             0xffff0000
 #define		bnoise_pwdB              0xffff
@@ -893,27 +893,27 @@
 #define		bPowerMeasFLength        3
 #define		bRx_HT_BW                0x1
 #define		bRxSC                    0x6
-#define		bRx_HT                   0x8
+#define		bRx_HT                   0x8       		
 #define		bNB_intf_det_on          0x1
 #define		bIntf_win_len_cfg        0x30
-#define		bNB_Intf_TH_cfg          0x1c0
+#define		bNB_Intf_TH_cfg          0x1c0       		
 #define		bRFGain                  0x3f
 #define		bTableSel                0x40
-#define		bTRSW                    0x80
+#define		bTRSW                    0x80       		
 #define		bRxSNR_A                 0xff
 #define		bRxSNR_B                 0xff00
 #define		bRxSNR_C                 0xff0000
 #define		bRxSNR_D                 0xff000000
 #define		bSNREVMTLength           8
-#define		bSNREVMFLength           1
+#define		bSNREVMFLength           1       		
 #define		bCSI1st                  0xff
 #define		bCSI2nd                  0xff00
 #define		bRxEVM1st                0xff0000
-#define		bRxEVM2nd                0xff000000
+#define		bRxEVM2nd                0xff000000       		
 #define		bSIGEVM                  0xff
 #define		bPWDB                    0xff00
 #define		bSGIEN                   0x10000
-
+       		
 #define		bSFactorQAM1             0xf	// Useless
 #define		bSFactorQAM2             0xf0
 #define		bSFactorQAM3             0xf00
@@ -924,7 +924,7 @@
 #define		bSFactorQAM8             0xf000000
 #define		bSFactorQAM9             0xf0000000
 #define		bCSIScheme               0x100000
-
+       		
 #define		bNoiseLvlTopSet          0x3	// Useless
 #define		bChSmooth                0x4
 #define		bChSmoothCfg1            0x38
@@ -933,7 +933,7 @@
 #define		bChSmoothCfg4            0x7000
 #define		bMRCMode                 0x800000
 #define		bTHEVMCfg                0x7000000
-
+       		
 #define		bLoopFitType             0x1	// Useless
 #define		bUpdCFO                  0x40
 #define		bUpdCFOOffData           0x80
@@ -1015,7 +1015,7 @@
 #define		bMaskHWord		0xffff0000
 #define		bMaskLWord		0x0000ffff
 #define		bMaskDWord		0xffffffff
-#define		bMaskH4Bits		0xf0000000
+#define		bMaskH4Bits		0xf0000000	
 #define 	bMaskOFDM_D		0xffc00000
 #define		bMaskCCK		0x3f3f3f3f
 #define		bMask12Bits		0xfff
@@ -1024,21 +1024,21 @@
 #if (RTL92SE_FPGA_VERIFY == 1)
 //#define		bMask12Bits               0xfff	// RF Reg mask bits
 //#define		bMask20Bits               0xfff	// RF Reg mask bits T65 RF
-#define 		bRFRegOffsetMask	0xfff
+#define 		bRFRegOffsetMask	0xfff		
 #else
 //#define		bMask12Bits               0xfffff	// RF Reg mask bits
 //#define		bMask20Bits               0xfffff	// RF Reg mask bits T65 RF
-#define 		bRFRegOffsetMask	0xfffff
-#endif
+#define 		bRFRegOffsetMask	0xfffff		
+#endif       		
 #define		bEnable                   0x1	// Useless
 #define		bDisable                  0x0
-
+       		
 #define		LeftAntenna               0x0	// Useless
 #define		RightAntenna              0x1
-
+       		
 #define		tCheckTxStatus            500   //500ms // Useless
 #define		tUpdateRxCounter          100   //100ms
-
+       		
 #define		rateCCK     0	// Useless
 #define		rateOFDM    1
 #define		rateHT      2
@@ -1094,3 +1094,4 @@
 
 
 #endif	//__INC_HAL8192SPHYREG_H
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_p2p.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_p2p.h
old mode 100644
new mode 100755
index b230faf..4249bc9
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_p2p.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_p2p.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -158,3 +158,4 @@ static inline bool _rtw_p2p_chk_role(struct wifidirect_info *wdinfo, enum P2P_RO
 	(wdinfo)->find_phase_state_exchange_cnt != P2P_FINDPHASE_EX_NONE)
 
 #endif
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_pwrctrl.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_pwrctrl.h
old mode 100644
new mode 100755
index a867da2..a4cb292
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_pwrctrl.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_pwrctrl.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -21,7 +21,7 @@
 #define __RTW_PWRCTRL_H_
 
 #include <drv_conf.h>
-#include <osdep_service.h>
+#include <osdep_service.h>		
 #include <drv_types.h>
 
 #ifdef CONFIG_HAS_EARLYSUSPEND
@@ -29,13 +29,13 @@
 #endif //CONFIG_HAS_EARLYSUSPEND
 
 
-#define FW_PWR0	0
+#define FW_PWR0	0	
 #define FW_PWR1 	1
 #define FW_PWR2 	2
 #define FW_PWR3 	3
 
 
-#define HW_PWR0	7
+#define HW_PWR0	7	
 #define HW_PWR1 	6
 #define HW_PWR2 	2
 #define HW_PWR3	0
@@ -108,7 +108,7 @@ struct reportpwrstate_parm {
 	unsigned char mode;
 	unsigned char state; //the CPWM value
 	unsigned short rsvd;
-};
+}; 
 
 
 typedef _sema _pwrlock;
@@ -179,7 +179,7 @@ enum _PS_BBRegBackup_ {
 enum { // for ips_mode
 	IPS_NONE=0,
 	IPS_NORMAL,
-	IPS_LEVEL_2,
+	IPS_LEVEL_2,	
 };
 
 struct pwrctrl_priv
@@ -206,7 +206,7 @@ struct pwrctrl_priv
 
 #ifdef CONFIG_PCI_HCI
 	//just for PCIE ASPM
-	u8	b_support_aspm; // If it supports ASPM, Offset[560h] = 0x40, otherwise Offset[560h] = 0x00.
+	u8	b_support_aspm; // If it supports ASPM, Offset[560h] = 0x40, otherwise Offset[560h] = 0x00. 
 	u8	b_support_backdoor;
 
 	//just for PCIE ASPM
@@ -216,7 +216,7 @@ struct pwrctrl_priv
 	uint 	ips_enter_cnts;
 	uint 	ips_leave_cnts;
 
-	u8	ips_mode;
+	u8	ips_mode; 
 	u8	ips_mode_req; // used to accept the mode setting request, will update to ipsmode later
 	uint bips_processing;
 	u32 ips_deny_time; /* will deny IPS when system time is smaller than this */
@@ -234,7 +234,7 @@ struct pwrctrl_priv
 
 	u8		bInternalAutoSuspend;
 	u8		bInSuspend;
-	u8		bSupportRemoteWakeup;
+	u8		bSupportRemoteWakeup;	
 #ifdef CONFIG_WOWLAN
 	u8		wowlan_mode;
 	u8		wowlan_pattern;
@@ -248,17 +248,17 @@ struct pwrctrl_priv
 	u8		pwr_state_check_cnts;
 
 	int 		ps_flag;
-
+	
 	rt_rf_power_state	rf_pwrstate;//cur power state
 	//rt_rf_power_state 	current_rfpwrstate;
 	rt_rf_power_state	change_rfpwrstate;
 
 	u8		bHWPowerdown;//if support hw power down
 	u8		bHWPwrPindetect;
-	u8		bkeepfwalive;
+	u8		bkeepfwalive;		
 	u8		brfoffbyhw;
 	unsigned long PS_BBRegBackup[PSBBREG_TOTALCNT];
-
+	
 	#ifdef CONFIG_RESUME_IN_WORKQUEUE
 	struct workqueue_struct *rtw_workqueue;
 	_workitem resume_work;
@@ -268,12 +268,12 @@ struct pwrctrl_priv
 	struct early_suspend early_suspend;
 	u8 do_late_resume;
 	#endif //CONFIG_HAS_EARLYSUSPEND
-
+	
 	#ifdef CONFIG_ANDROID_POWER
 	android_early_suspend_t early_suspend;
 	u8 do_late_resume;
 	#endif
-
+	
 };
 
 #define rtw_get_ips_mode_req(pwrctrlpriv) \
@@ -289,7 +289,7 @@ struct pwrctrl_priv
 		/*DBG_871X("%s _rtw_set_pwr_state_check_timer(%p, %d)\n", __FUNCTION__, (pwrctrlpriv), (ms));*/ \
 		_set_timer(&(pwrctrlpriv)->pwr_state_check_timer, (ms)); \
 	} while(0)
-
+	
 #define rtw_set_pwr_state_check_timer(pwrctrlpriv) \
 	_rtw_set_pwr_state_check_timer((pwrctrlpriv), (pwrctrlpriv)->pwr_state_check_interval)
 
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_qos.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_qos.h
old mode 100644
new mode 100755
index bd15f93..a359c5f
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_qos.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_qos.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -30,10 +30,11 @@
 
 
 struct	qos_priv	{
-
-	unsigned int	  qos_option;	//bit mask option: u-apsd, s-apsd, ts, block ack...
+	
+	unsigned int	  qos_option;	//bit mask option: u-apsd, s-apsd, ts, block ack...		
 
 };
 
 
 #endif	//_RTL871X_QOS_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_recv.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_recv.h
old mode 100644
new mode 100755
index 28dca00..3a4b14b
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_recv.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_recv.h
@@ -96,10 +96,10 @@ struct smooth_rssi_data {
 };
 
 struct signal_stat {
-	u8	update_req;		//used to indicate
+	u8	update_req;		//used to indicate 
 	u8	avg_val;		//avg of valid elements
 	u32	total_num;		//num of valid elements
-	u32	total_val;		//sum of valid elements
+	u32	total_val;		//sum of valid elements	
 };
 
 struct rx_pkt_attrib
@@ -134,9 +134,9 @@ struct rx_pkt_attrib
 	u8 	ta[ETH_ALEN];
 	u8 	ra[ETH_ALEN];
 	u8 	bssid[ETH_ALEN];
-
+	
 	u8 ack_policy;
-
+	
 //#ifdef CONFIG_TCP_CSUM_OFFLOAD_RX
 	u8	tcpchk_valid; // 0: invalid, 1: valid
 	u8	ip_chkrpt; //0: incorrect, 1: correct
@@ -212,7 +212,7 @@ struct rtw_rx_ring {
 */
 struct recv_priv
 {
-	  _lock	lock;
+  	  _lock	lock;
 
 #ifdef CONFIG_RECV_THREAD_MODE
 	_sema	recv_sema;
@@ -332,7 +332,7 @@ struct recv_priv
 	u32 recvbuf_null_cnt;
 	u32 read_port_complete_EINPROGRESS_cnt;
 	u32 read_port_complete_other_urb_err_cnt;
-
+	
 
 };
 
@@ -577,7 +577,7 @@ __inline static u8 *recvframe_put(union recv_frame *precvframe, sint sz)
 
 	//used for append sz bytes from ptr to rx_tail, update rx_tail and return the updated rx_tail to the caller
 	//after putting, rx_tail must be still larger than rx_end.
-	unsigned char * prev_rx_tail;
+ 	unsigned char * prev_rx_tail;
 
 	if(precvframe==NULL)
 		return NULL;
@@ -728,3 +728,4 @@ __inline static s32 translate_percentage_to_dbm(u32 SignalStrengthIndex)
 extern void  mgt_dispatcher(_adapter *padapter, union recv_frame *precv_frame);
 
 #endif
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_rf.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_rf.h
old mode 100644
new mode 100755
index b8acf93..697dd4e
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_rf.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_rf.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -17,7 +17,7 @@
  *
  *
  ******************************************************************************/
-#ifndef	__RTW_RF_H_
+#ifndef	__RTW_RF_H_ 
 #define __RTW_RF_H_
 
 #include <drv_conf.h>
@@ -51,11 +51,11 @@
 
 //Country codes
 #define USA							0x555320
-#define EUROPE						0x1 //temp, should be provided later
-#define JAPAN						0x2 //temp, should be provided later
+#define EUROPE						0x1 //temp, should be provided later	
+#define JAPAN						0x2 //temp, should be provided later	
 
 struct	regulatory_class {
-	u32	starting_freq;					//MHz,
+	u32	starting_freq;					//MHz, 
 	u8	channel_set[MAX_CHANNEL_NUM];
 	u8	channel_cck_power[MAX_CHANNEL_NUM];//dbm
 	u8	channel_ofdm_power[MAX_CHANNEL_NUM];//dbm
@@ -141,7 +141,7 @@ enum _RTL8712_RF_MIMO_CONFIG_{
 	RF_PATH_B = 1,			//Radio Path B
 	RF_PATH_C = 2,			//Radio Path C
 	RF_PATH_D = 3,			//Radio Path D
-	//RF_PATH_MAX				//Max RF number 90 support
+	//RF_PATH_MAX				//Max RF number 90 support 
 }RF_RADIO_PATH_E, *PRF_RADIO_PATH_E;
 
 u32 rtw_ch2freq(u32 ch);
@@ -149,3 +149,4 @@ enum _RTL8712_RF_MIMO_CONFIG_{
 
 
 #endif //_RTL8711_RF_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_security.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_security.h
old mode 100644
new mode 100755
index 0d99c9a..835677c3
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_security.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_security.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -33,7 +33,7 @@
 #define _AES_			0x4
 #define _WEP104_		0x5
 #ifdef CONFIG_IEEE80211W
-#define _BIP_				0x8
+#define _BIP_				0x8 
 #endif //CONFIG_IEEE80211W
 #define is_wep_enc(alg) (((alg) == _WEP40_) || ((alg) == _WEP104_))
 
@@ -53,9 +53,9 @@
 #endif
 
 union pn48	{
-
+	
 	u64	val;
-
+	
 #ifdef CONFIG_LITTLE_ENDIAN
 
 struct {
@@ -68,7 +68,7 @@ struct {
   u8 TSC6;
   u8 TSC7;
 } _byte_;
-
+ 
 #elif defined(CONFIG_BIG_ENDIAN)
 
 struct {
@@ -81,7 +81,7 @@ struct {
   u8 TSC1;
   u8 TSC0;
 } _byte_;
-
+ 
 #endif
 
 };
@@ -105,18 +105,18 @@ struct {
 
 struct security_priv
 {
-	u32	  dot11AuthAlgrthm;		// 802.11 auth, could be open, shared, 8021x and authswitch
+	u32	  dot11AuthAlgrthm;		// 802.11 auth, could be open, shared, 8021x and authswitch 
 	u32	  dot11PrivacyAlgrthm;	// This specify the privacy for shared auth. algorithm.
 
 	/* WEP */
 	u32	  dot11PrivacyKeyIndex;	// this is only valid for legendary wep, 0~3 for key id. (tx key index)
-	union Keytype dot11DefKey[4];			// this is only valid for def. key
+	union Keytype dot11DefKey[4];			// this is only valid for def. key	
 	u32 	dot11DefKeylen[4];
 	u8 	key_mask; /* use to restore wep key after hal_init */
 
-	u32 dot118021XGrpPrivacy;	// This specify the privacy algthm. used for Grp key
+	u32 dot118021XGrpPrivacy;	// This specify the privacy algthm. used for Grp key 
 	u32	dot118021XGrpKeyid;		// key id used for Grp Key ( tx key index)
-	union Keytype	dot118021XGrpKey[4];	// 802.1x Group Key, for inx0 and inx1
+	union Keytype	dot118021XGrpKey[4];	// 802.1x Group Key, for inx0 and inx1	
 	union Keytype	dot118021XGrptxmickey[4];
 	union Keytype	dot118021XGrprxmickey[4];
 	union pn48		dot11Grptxpn;			// PN48 used for Grp Key xmit.
@@ -128,19 +128,19 @@ struct security_priv
 	union pn48		dot11wBIPrxpn;			// PN48 used for Grp Key recv.
 #endif //CONFIG_IEEE80211W
 #ifdef CONFIG_AP_MODE
-	//extend security capabilities for AP_MODE
+	//extend security capabilities for AP_MODE 
 	unsigned int dot8021xalg;//0:disable, 1:psk, 2:802.1x
 	unsigned int wpa_psk;//0:disable, bit(0): WPA, bit(1):WPA2
 	unsigned int wpa_group_cipher;
 	unsigned int wpa2_group_cipher;
 	unsigned int wpa_pairwise_cipher;
-	unsigned int wpa2_pairwise_cipher;
+	unsigned int wpa2_pairwise_cipher;	
 #endif
 
 	u8 wps_ie[MAX_WPS_IE_LEN];//added in assoc req
 	int wps_ie_len;
-
-
+	
+	
 	u8	binstallGrpkey;
 #ifdef CONFIG_IEEE80211W
 	u8	binstallBIPkey;
@@ -149,12 +149,12 @@ struct security_priv
 	//_timer tkip_timer;
 	u8	bcheck_grpkey;
 	u8	bgrpkey_handshake;
-
+	
 	//u8	packet_cnt;//unused, removed
-
+	
 	s32	sw_encrypt;//from registry_priv
 	s32	sw_decrypt;//from registry_priv
-
+	
 	s32 	hw_decrypted;//if the rx packets is hw_decrypted==_FALSE, it means the hw has not been ready.
 
 
@@ -177,7 +177,7 @@ struct security_priv
 
 
 	//for tkip countermeasure
-	u32 last_mic_err_time;
+	u32 last_mic_err_time;	
 	u8	btkip_countermeasure;
 	u8	btkip_wait_report;
 	u32 btkip_countermeasure_time;
@@ -350,7 +350,7 @@ static inline u32 rotr(u32 val, int bits)
 		(a)[6] = (u8) (((u64) (val)) >> 8);	\
 		(a)[7] = (u8) (((u64) (val)) & 0xff);	\
 	} while (0)
-
+	
 /* ===== start - public domain SHA256 implementation ===== */
 
 /* This is based on SHA256 implementation in LibTomCrypt that was released into
@@ -379,7 +379,7 @@ static inline u32 rotr(u32 val, int bits)
 ( ((((unsigned long) (x) & 0xFFFFFFFFUL) >> (unsigned long) ((y) & 31)) | \
    ((unsigned long) (x) << (unsigned long) (32 - ((y) & 31)))) & 0xFFFFFFFFUL)
 #define Ch(x,y,z)       (z ^ (x & (y ^ z)))
-#define Maj(x,y,z)      (((x | y) & z) | (x & y))
+#define Maj(x,y,z)      (((x | y) & z) | (x & y)) 
 #define S(x, n)         RORc((x), (n))
 #define R(x, n)         (((x)&0xFFFFFFFFUL)>>(n))
 #define Sigma0(x)       (S(x, 2) ^ S(x, 13) ^ S(x, 22))
@@ -417,10 +417,10 @@ void rtw_seccalctkipmic(
 #endif //CONFIG_IEEE80211W
 #ifdef CONFIG_TDLS
 void wpa_tdls_generate_tpk(_adapter *padapter, struct sta_info *psta);
-int wpa_tdls_ftie_mic(u8 *kck, u8 trans_seq,
+int wpa_tdls_ftie_mic(u8 *kck, u8 trans_seq, 
 						u8 *lnkid, u8 *rsnie, u8 *timeoutie, u8 *ftie,
 						u8 *mic);
-int tdls_verify_mic(u8 *kck, u8 trans_seq,
+int tdls_verify_mic(u8 *kck, u8 trans_seq, 
 						u8 *lnkid, u8 *rsnie, u8 *timeoutie, u8 *ftie);
 #endif //CONFIG_TDLS
 
@@ -444,3 +444,4 @@ void rtw_use_tkipkey_handler (
 u8 rtw_handle_tkip_countermeasure(_adapter* adapter, const char *caller);
 
 #endif	//__RTL871X_SECURITY_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_sreset.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_sreset.h
old mode 100644
new mode 100755
index f2d5dc7..45dd2bf
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_sreset.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_sreset.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -57,7 +57,7 @@ struct sreset_priv {
 #define	USB_VEN_REQ_CMD_FAIL 	BIT0
 #define	USB_READ_PORT_FAIL 		BIT1
 #define	USB_WRITE_PORT_FAIL		BIT2
-#define	WIFI_MAC_TXDMA_ERROR 	BIT3
+#define	WIFI_MAC_TXDMA_ERROR 	BIT3			
 #define   WIFI_TX_HANG				BIT4
 #define	WIFI_RX_HANG				BIT5
 #define 	WIFI_IF_NOT_EXIST			BIT6
@@ -71,3 +71,4 @@ struct sreset_priv {
 void sreset_reset(_adapter *padapter);
 
 #endif
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_tdls.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_tdls.h
old mode 100644
new mode 100755
index cbf996f..1005331
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_tdls.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_tdls.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -140,3 +140,4 @@ struct wpa_tdls_lnkid {
 #endif //CONFIG_TDLS
 
 #endif
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_xmit.h b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_xmit.h
old mode 100644
new mode 100755
index 11c67c4..f7eaf4a
--- a/drivers/net/wireless/realtek/rtl8192cu/include/rtw_xmit.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/rtw_xmit.h
@@ -751,3 +751,4 @@ struct	xmit_priv	{
 #include <xmit_osdep.h>
 
 #endif	//_RTL871X_XMIT_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/sta_info.h b/drivers/net/wireless/realtek/rtl8192cu/include/sta_info.h
old mode 100644
new mode 100755
index 9cbf934..75763db
--- a/drivers/net/wireless/realtek/rtl8192cu/include/sta_info.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/sta_info.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -75,7 +75,7 @@ struct	stainfo_stats	{
 		u64 last_rx_probersp_uo_pkts;
 	u64	last_rx_ctrl_pkts;
 	u64	last_rx_data_pkts;
-
+	
 	u64	rx_bytes;
 	u64	rx_drops;
 
@@ -100,24 +100,24 @@ struct sta_info {
 	//_list asoc_list; //20061114
 	//_list sleep_list;//sleep_q
 	//_list wakeup_list;//wakeup_q
-
+	
 	struct sta_xmit_priv sta_xmitpriv;
 	struct sta_recv_priv sta_recvpriv;
-
+	
 	_queue sleep_q;
 	unsigned int sleepq_len;
-
+	
 	uint state;
 	uint aid;
 	uint mac_id;
 	uint qos_option;
 	u8	hwaddr[ETH_ALEN];
 
-	uint	ieee8021x_blocked;	//0: allowed, 1:blocked
+	uint	ieee8021x_blocked;	//0: allowed, 1:blocked 
 	uint	dot118021XPrivacy; //aes, tkip...
 	union Keytype	dot11tkiptxmickey;
 	union Keytype	dot11tkiprxmickey;
-	union Keytype	dot118021x_UncstKey;
+	union Keytype	dot118021x_UncstKey;	
 	union pn48		dot11txpn;			// PN48 used for Unicast xmit.
 #ifdef CONFIG_IEEE80211W
 	union pn48		dot11wtxpn;			// PN48 used for Unicast mgmt xmit.
@@ -129,7 +129,7 @@ struct sta_info {
 	u32	bssratelen;
 	s32  rssi;
 	s32	signal_quality;
-
+	
 	u8	cts2self;
 	u8	rtsen;
 
@@ -164,49 +164,49 @@ struct sta_info {
 	u8 alive_count;
 #endif //CONFIG_TDLS
 
-	//for A-MPDU TX, ADDBA timeout check
+	//for A-MPDU TX, ADDBA timeout check	
 	_timer addba_retry_timer;
-
-	//for A-MPDU Rx reordering buffer control
+	
+	//for A-MPDU Rx reordering buffer control 
 	struct recv_reorder_ctrl recvreorder_ctrl[16];
 
 	//for A-MPDU Tx
 	//unsigned char		ampdu_txen_bitmap;
 	u16	BA_starting_seqctrl[16];
-
+	
 
 #ifdef CONFIG_80211N_HT
-	struct ht_priv	htpriv;
+	struct ht_priv	htpriv;	
 #endif
-
-	//Notes:
+	
+	//Notes:	
 	//STA_Mode:
-	//curr_network(mlme_priv/security_priv/qos/ht) + sta_info: (STA & AP) CAP/INFO
+	//curr_network(mlme_priv/security_priv/qos/ht) + sta_info: (STA & AP) CAP/INFO	
 	//scan_q: AP CAP/INFO
 
 	//AP_Mode:
 	//curr_network(mlme_priv/security_priv/qos/ht) : AP CAP/INFO
 	//sta_info: (AP & STA) CAP/INFO
-
+		
 #ifdef CONFIG_AP_MODE
 
 	_list asoc_list;
 	_list auth_list;
-
+	 
 	unsigned int expire_to;
 	unsigned int auth_seq;
 	unsigned int authalg;
 	unsigned char chg_txt[128];
 
-	u16 capability;
-	int flags;
+	u16 capability;	
+	int flags;	
 
 	int dot8021xalg;//0:disable, 1:psk, 2:802.1x
 	int wpa_psk;//0:disable, bit(0): WPA, bit(1):WPA2
 	int wpa_group_cipher;
 	int wpa2_group_cipher;
 	int wpa_pairwise_cipher;
-	int wpa2_pairwise_cipher;
+	int wpa2_pairwise_cipher;	
 
 	u8 bpairwise_key_installed;
 
@@ -228,7 +228,7 @@ struct sta_info {
 	u8 uapsd_bk;//BIT(0): Delivery enabled, BIT(1): Trigger enabled
 	u8 uapsd_be;
 	u8 uapsd_vi;
-	u8 uapsd_vo;
+	u8 uapsd_vo;	
 
 	u8 has_legacy_ac;
 	unsigned int sleepq_ac_len;
@@ -247,16 +247,16 @@ struct sta_info {
 	u8 num_of_secdev_type;
 	u8 secdev_types_list[32];// 32/8 == 4;
 	u16 dev_name_len;
-	u8 dev_name[32];
+	u8 dev_name[32];	
 #endif //CONFIG_P2P
 
 #ifdef CONFIG_TX_MCAST2UNI
 	u8 under_exist_checking;
 #endif	// CONFIG_TX_MCAST2UNI
-
+	
 	u8 keep_alive_trycnt;
 
-#endif	// CONFIG_AP_MODE
+#endif	// CONFIG_AP_MODE	
 
 #ifdef CONFIG_IOCTL_CFG80211
 	u8 *passoc_req;
@@ -265,7 +265,7 @@ struct sta_info {
 
 	//for DM
 	RSSI_STA	 rssi_stat;
-
+	
         /* To store the sequence number of received management frame */
 	u16 RxMgmtFrameSeqNum;
 };
@@ -350,21 +350,21 @@ struct sta_info {
 	, sta->sta_stats.rx_data_pkts -sta->sta_stats.last_rx_data_pkts
 
 #define STA_PKTS_FMT "(m:%llu, c:%llu, d:%llu)"
-
+	
 struct	sta_priv {
-
+	
 	u8 *pallocated_stainfo_buf;
 	u8 *pstainfo_buf;
 	_queue	free_sta_queue;
-
+	
 	_lock sta_hash_lock;
 	_list   sta_hash[NUM_STA];
 	int asoc_sta_count;
 	_queue sleep_q;
 	_queue wakeup_q;
-
+	
 	_adapter *padapter;
-
+	
 
 #ifdef CONFIG_AP_MODE
 	_list asoc_list;
@@ -377,7 +377,7 @@ struct	sta_priv {
 	unsigned int auth_to;  //sec, time to expire in authenticating.
 	unsigned int assoc_to; //sec, time to expire before associating.
 	unsigned int expire_to; //sec , time to expire after associated.
-
+	
 	/* pointers to STA info; based on allocated AID or NULL if AID free
 	 * AID is in the range 1-2007, so sta_aid[0] corresponders to AID 1
 	 * and so on
@@ -385,17 +385,17 @@ struct	sta_priv {
 	struct sta_info *sta_aid[NUM_STA];
 
 	u16 sta_dz_bitmap;//only support 15 stations, staion aid bitmap for sleeping sta.
-	u16 tim_bitmap;//only support 15 stations, aid=0~15 mapping bit0~bit15
+	u16 tim_bitmap;//only support 15 stations, aid=0~15 mapping bit0~bit15	
 
 	u16 max_num_sta;
 
 	struct wlan_acl_pool acl_list;
-#endif
-
+#endif		
+	
 };
 
 
-__inline static u32 wifi_mac_hash(const u8 *mac)
+__inline static u32 wifi_mac_hash(u8 *mac)
 {
         u32 x;
 
@@ -408,7 +408,7 @@ __inline static u32 wifi_mac_hash(const u8 *mac)
 
         x ^= x >> 8;
         x  = x & (NUM_STA - 1);
-
+		
         return x;
 }
 
@@ -423,9 +423,10 @@ __inline static u32 wifi_mac_hash(const u8 *mac)
 extern struct sta_info *rtw_alloc_stainfo(struct	sta_priv *pstapriv, u8 *hwaddr);
 extern u32	rtw_free_stainfo(_adapter *padapter , struct sta_info *psta);
 extern void rtw_free_all_stainfo(_adapter *padapter);
-extern struct sta_info *rtw_get_stainfo(struct sta_priv *pstapriv, const u8 *hwaddr);
+extern struct sta_info *rtw_get_stainfo(struct sta_priv *pstapriv, u8 *hwaddr);
 extern u32 rtw_init_bcmc_stainfo(_adapter* padapter);
 extern struct sta_info* rtw_get_bcmc_stainfo(_adapter* padapter);
 extern u8 rtw_access_ctrl(_adapter *padapter, u8 *mac_addr);
 
 #endif //_STA_INFO_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/usb_hal.h b/drivers/net/wireless/realtek/rtl8192cu/include/usb_hal.h
old mode 100644
new mode 100755
index ff29ea8..d765b82
--- a/drivers/net/wireless/realtek/rtl8192cu/include/usb_hal.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/usb_hal.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -24,7 +24,7 @@
 void rtl8192cu_set_hal_ops(_adapter * padapter);
 
 void rtl8192du_set_hal_ops(_adapter * padapter);
-#ifdef CONFIG_INTEL_PROXIM
+#ifdef CONFIG_INTEL_PROXIM	
 extern _adapter  *rtw_usb_get_sw_pointer(void);
 #endif	//CONFIG_INTEL_PROXIM
 #ifdef CONFIG_WOWLAN
@@ -34,3 +34,4 @@
 #endif // CONFIG_WOWLAN_MANUAL
 #endif //CONFIG_WOWLAN
 #endif //__USB_HAL_H__
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/usb_ops.h b/drivers/net/wireless/realtek/rtl8192cu/include/usb_ops.h
old mode 100644
new mode 100755
index 3160fc9..8bbec2d
--- a/drivers/net/wireless/realtek/rtl8192cu/include/usb_ops.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/usb_ops.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -39,18 +39,18 @@ enum{
 #define MAX_USB_IO_CTL_SIZE		(MAX_VENDOR_REQ_CMD_SIZE +ALIGNMENT_UNIT)
 
 #ifdef PLATFORM_LINUX
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,12))
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,12)) 
 #define rtw_usb_control_msg(dev, pipe, request, requesttype, value, index, data, size, timeout_ms) \
-	usb_control_msg((dev), (pipe), (request), (requesttype), (value), (index), (data), (size), (timeout_ms))
+	usb_control_msg((dev), (pipe), (request), (requesttype), (value), (index), (data), (size), (timeout_ms)) 
 #define rtw_usb_bulk_msg(usb_dev, pipe, data, len, actual_length, timeout_ms) \
 	usb_bulk_msg((usb_dev), (pipe), (data), (len), (actual_length), (timeout_ms))
 #else
 #define rtw_usb_control_msg(dev, pipe, request, requesttype, value, index, data, size,timeout_ms) \
 	usb_control_msg((dev), (pipe), (request), (requesttype), (value), (index), (data), (size), \
-		((timeout_ms) == 0) ||((timeout_ms)*HZ/1000>0)?((timeout_ms)*HZ/1000):1)
+		((timeout_ms) == 0) ||((timeout_ms)*HZ/1000>0)?((timeout_ms)*HZ/1000):1) 
 #define rtw_usb_bulk_msg(usb_dev, pipe, data, len, actual_length, timeout_ms) \
 	usb_bulk_msg((usb_dev), (pipe), (data), (len), (actual_length), \
-		((timeout_ms) == 0) ||((timeout_ms)*HZ/1000>0)?((timeout_ms)*HZ/1000):1)
+		((timeout_ms) == 0) ||((timeout_ms)*HZ/1000>0)?((timeout_ms)*HZ/1000):1) 
 #endif
 #include <usb_ops_linux.h>
 #endif //PLATFORM_LINUX
@@ -103,7 +103,8 @@ static inline int rtw_inc_and_chk_continual_urb_error(struct dvobj_priv *dvobj)
 */
 static inline void rtw_reset_continual_urb_error(struct dvobj_priv *dvobj)
 {
-	ATOMIC_SET(&dvobj->continual_urb_error, 0);
+	ATOMIC_SET(&dvobj->continual_urb_error, 0);	
 }
 
 #endif //__USB_OPS_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/usb_ops_linux.h b/drivers/net/wireless/realtek/rtl8192cu/include/usb_ops_linux.h
old mode 100644
new mode 100755
index d3a5507..d418ba2
--- a/drivers/net/wireless/realtek/rtl8192cu/include/usb_ops_linux.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/usb_ops_linux.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -60,3 +60,4 @@
 void usb_write_port_cancel(struct intf_hdl *pintfhdl);
 
 #endif
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/usb_osintf.h b/drivers/net/wireless/realtek/rtl8192cu/include/usb_osintf.h
old mode 100644
new mode 100755
index 6003ebb..753013dd
--- a/drivers/net/wireless/realtek/rtl8192cu/include/usb_osintf.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/usb_osintf.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -35,3 +35,4 @@
 
 
 #endif
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/usb_vendor_req.h b/drivers/net/wireless/realtek/rtl8192cu/include/usb_vendor_req.h
old mode 100644
new mode 100755
index 0f67122..f33e982
--- a/drivers/net/wireless/realtek/rtl8192cu/include/usb_vendor_req.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/usb_vendor_req.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/wifi.h b/drivers/net/wireless/realtek/rtl8192cu/include/wifi.h
old mode 100644
new mode 100755
index c0a7488..0bb55bb
--- a/drivers/net/wireless/realtek/rtl8192cu/include/wifi.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/wifi.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -60,7 +60,7 @@ enum WIFI_FRAME_TYPE {
 	WIFI_MGT_TYPE  =	(0),
 	WIFI_CTRL_TYPE =	(BIT(2)),
 	WIFI_DATA_TYPE =	(BIT(3)),
-	WIFI_QOS_DATA_TYPE	= (BIT(7)|BIT(3)),	//!< QoS Data
+	WIFI_QOS_DATA_TYPE	= (BIT(7)|BIT(3)),	//!< QoS Data	
 };
 
 enum WIFI_FRAME_SUBTYPE {
@@ -189,7 +189,7 @@ enum WIFI_STATUS_CODE {
 #define WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA 17
 #define WLAN_STATUS_ASSOC_DENIED_RATES 18
 #endif
-//entended
+//entended 
 /* IEEE 802.11b */
 #define WLAN_STATUS_ASSOC_DENIED_NOSHORT 19
 #define WLAN_STATUS_ASSOC_DENIED_NOPBCC 20
@@ -404,7 +404,7 @@ enum WIFI_REG_DOMAIN {
 #define SetAMsdu(pbuf, amsdu)	\
 	do	{	\
 		*(unsigned short *)(pbuf) |= cpu_to_le16( (amsdu & 1) << 7); \
-	} while(0)
+	} while(0)	
 
 #define GetAid(pbuf)	(cpu_to_le16(*(unsigned short *)((SIZE_PTR)(pbuf) + 2)) & 0x3fff)
 
@@ -425,7 +425,7 @@ enum WIFI_REG_DOMAIN {
 		(addr[4] == 0xff) && (addr[5] == 0xff) )  ? _TRUE : _FALSE \
 )
 
-__inline static int IS_MCAST(const unsigned char *da)
+__inline static int IS_MCAST(unsigned char *da)
 {
 	if ((*da) & 0x01)
 		return _TRUE;
@@ -499,7 +499,7 @@ __inline static unsigned char * get_hdr_bssid(unsigned char *pframe)
 		case 0x03:	// ToDs=1, FromDs=1
 			sa = GetAddr1Ptr(pframe);
 			break;
-		default:
+		default:	
 			sa =NULL; //???????
 			break;
 	}
@@ -631,7 +631,7 @@ __inline static int IsFrameTypeCtrl(unsigned char *pframe)
 
 #ifdef CONFIG_IEEE80211W
 #define _MME_IE_LENGTH_  18
-#endif //CONFIG_IEEE80211W
+#endif //CONFIG_IEEE80211W				
 /*-----------------------------------------------------------------------------
 				Below is the definition for WMM
 ------------------------------------------------------------------------------*/
@@ -640,7 +640,7 @@ __inline static int IsFrameTypeCtrl(unsigned char *pframe)
 
 
 /*-----------------------------------------------------------------------------
-				Below is the definition for 802.11n
+				Below is the definition for 802.11n 
 ------------------------------------------------------------------------------*/
 
 /* block-ack parameters */
@@ -692,7 +692,7 @@ struct rtw_ieee80211_bar {
  * This structure refers to "HT capabilities element" as
  * described in 802.11n draft section 7.3.2.52
  */
-
+ 
 struct rtw_ieee80211_ht_cap {
 	unsigned short 	cap_info;
 	unsigned char 	ampdu_params_info;
@@ -720,9 +720,9 @@ struct ieee80211_ht_addt_info {
 struct HT_caps_element
 {
 	union
-	{
-		struct
-		{
+	{ 
+		struct 
+		{ 	
 			unsigned short	HT_caps_info;
 			unsigned char	AMPDU_para;
 			unsigned char	MCS_rate[16];
@@ -793,9 +793,9 @@ struct ieee80211_ht_addt_info {
 struct HT_caps_element
 {
 	union
-	{
-		struct
-		{
+	{ 
+		struct 
+		{ 	
 			unsigned short	HT_caps_info;
 			unsigned char	AMPDU_para;
 			unsigned char	MCS_rate[16];
@@ -1112,7 +1112,7 @@ struct ADDBA_request
 
 #define	P2P_FINDPHASE_EX_NONE				0	// default value, used when: (1)p2p disabed or (2)p2p enabled but only do 1 scan phase
 #define	P2P_FINDPHASE_EX_FULL				1	// used when p2p enabled and want to do 1 scan phase and P2P_FINDPHASE_EX_MAX-1 find phase
-#define	P2P_FINDPHASE_EX_SOCIAL_FIRST		(P2P_FINDPHASE_EX_FULL+1)
+#define	P2P_FINDPHASE_EX_SOCIAL_FIRST		(P2P_FINDPHASE_EX_FULL+1) 
 #define	P2P_FINDPHASE_EX_MAX					4
 #define	P2P_FINDPHASE_EX_SOCIAL_LAST		P2P_FINDPHASE_EX_MAX
 
@@ -1146,7 +1146,7 @@ enum P2P_ROLE {
 	P2P_ROLE_DISABLE = 0,
 	P2P_ROLE_DEVICE = 1,
 	P2P_ROLE_CLIENT = 2,
-	P2P_ROLE_GO = 3
+	P2P_ROLE_GO = 3	
 };
 
 enum P2P_STATE {
@@ -1158,7 +1158,7 @@ enum P2P_STATE {
 	P2P_STATE_FIND_PHASE_SEARCH = 5,				//	In the search state of find phase
 	P2P_STATE_TX_PROVISION_DIS_REQ = 6,			//	In P2P provisioning discovery
 	P2P_STATE_RX_PROVISION_DIS_RSP = 7,
-	P2P_STATE_RX_PROVISION_DIS_REQ = 8,
+	P2P_STATE_RX_PROVISION_DIS_REQ = 8,	
 	P2P_STATE_GONEGO_ING = 9,						//	Doing the group owner negoitation handshake
 	P2P_STATE_GONEGO_OK = 10,						//	finish the group negoitation handshake with success
 	P2P_STATE_GONEGO_FAIL = 11,					//	finish the group negoitation handshake with failure
@@ -1189,7 +1189,7 @@ enum P2P_PROTO_WK_ID
 	P2P_FIND_PHASE_WK = 0,
 	P2P_RESTORE_STATE_WK = 1,
 	P2P_PRE_TX_PROVDISC_PROCESS_WK = 2,
-	P2P_PRE_TX_NEGOREQ_PROCESS_WK = 3,
+	P2P_PRE_TX_NEGOREQ_PROCESS_WK = 3,	
 	P2P_PRE_TX_INVITEREQ_PROCESS_WK = 4,
 	P2P_AP_P2P_CH_SWITCH_PROCESS_WK =5,
 	P2P_RO_CH_WK = 6,
@@ -1243,3 +1243,4 @@ enum P2P_PS_MODE
 
 
 #endif // _WIFI_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/wlan_bssdef.h b/drivers/net/wireless/realtek/rtl8192cu/include/wlan_bssdef.h
old mode 100644
new mode 100755
index 641b7e9..1cf93dc
--- a/drivers/net/wireless/realtek/rtl8192cu/include/wlan_bssdef.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/wlan_bssdef.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -62,11 +62,11 @@
     ULONG           HopSet;             // to one if non-802.11
     ULONG           DwellTime;          // units are Kusec
 } NDIS_802_11_CONFIGURATION_FH, *PNDIS_802_11_CONFIGURATION_FH;
-
+ 
 
 /*
 	FW will only save the channel number in DSConfig.
-	ODI Handler will convert the channel number to freq. number.
+	ODI Handler will convert the channel number to freq. number.	
 */
 typedef struct _NDIS_802_11_CONFIGURATION
 {
@@ -222,7 +222,7 @@
 typedef struct _NDIS_802_11_KEY
 {
     ULONG           Length;             // Length of this structure
-    ULONG           KeyIndex;
+    ULONG           KeyIndex;           
     ULONG           KeyLength;          // length of key in bytes
     NDIS_802_11_MAC_ADDRESS BSSID;
     NDIS_802_11_KEY_RSC KeyRSC;
@@ -232,8 +232,8 @@
 typedef struct _NDIS_802_11_REMOVE_KEY
 {
     ULONG                   Length;        // Length of this structure
-    ULONG                   KeyIndex;
-    NDIS_802_11_MAC_ADDRESS BSSID;
+    ULONG                   KeyIndex;           
+    NDIS_802_11_MAC_ADDRESS BSSID;      
 } NDIS_802_11_REMOVE_KEY, *PNDIS_802_11_REMOVE_KEY;
 
 typedef struct _NDIS_802_11_WEP
@@ -255,7 +255,7 @@
 {
 	Ndis802_11StatusType_Authentication,
 	Ndis802_11StatusType_MediaStreamMode,
-	Ndis802_11StatusType_PMKID_CandidateList,
+	Ndis802_11StatusType_PMKID_CandidateList,		
 	Ndis802_11StatusTypeMax    // not a real type, defined as an upper bound
 } NDIS_802_11_STATUS_TYPE, *PNDIS_802_11_STATUS_TYPE;
 
@@ -279,7 +279,7 @@
     NDIS_802_11_STATUS_INDICATION       Status;
     NDIS_802_11_AUTHENTICATION_REQUEST  Request[1];
 } NDIS_802_11_AUTHENTICATION_EVENT, *PNDIS_802_11_AUTHENTICATION_EVENT;
-
+        
 typedef struct _NDIS_802_11_TEST
 {
     ULONG Length;
@@ -332,11 +332,11 @@
     ULONG           HopSet;             // to one if non-802.11
     ULONG           DwellTime;          // units are Kusec
 } NDIS_802_11_CONFIGURATION_FH, *PNDIS_802_11_CONFIGURATION_FH;
-
+ 
 
 /*
 	FW will only save the channel number in DSConfig.
-	ODI Handler will convert the channel number to freq. number.
+	ODI Handler will convert the channel number to freq. number.	
 */
 typedef struct _NDIS_802_11_CONFIGURATION
 {
@@ -492,7 +492,7 @@
 typedef struct _NDIS_802_11_KEY
 {
     ULONG           Length;             // Length of this structure
-    ULONG           KeyIndex;
+    ULONG           KeyIndex;           
     ULONG           KeyLength;          // length of key in bytes
     NDIS_802_11_MAC_ADDRESS BSSID;
     NDIS_802_11_KEY_RSC KeyRSC;
@@ -502,8 +502,8 @@
 typedef struct _NDIS_802_11_REMOVE_KEY
 {
     ULONG                   Length;        // Length of this structure
-    ULONG                   KeyIndex;
-    NDIS_802_11_MAC_ADDRESS BSSID;
+    ULONG                   KeyIndex;           
+    NDIS_802_11_MAC_ADDRESS BSSID;      
 } NDIS_802_11_REMOVE_KEY, *PNDIS_802_11_REMOVE_KEY;
 
 typedef struct _NDIS_802_11_WEP
@@ -525,7 +525,7 @@
 {
 	Ndis802_11StatusType_Authentication,
 	Ndis802_11StatusType_MediaStreamMode,
-	Ndis802_11StatusType_PMKID_CandidateList,
+	Ndis802_11StatusType_PMKID_CandidateList,		
 	Ndis802_11StatusTypeMax    // not a real type, defined as an upper bound
 } NDIS_802_11_STATUS_TYPE, *PNDIS_802_11_STATUS_TYPE;
 
@@ -549,7 +549,7 @@
     NDIS_802_11_STATUS_INDICATION       Status;
     NDIS_802_11_AUTHENTICATION_REQUEST  Request[1];
 } NDIS_802_11_AUTHENTICATION_EVENT, *PNDIS_802_11_AUTHENTICATION_EVENT;
-
+        
 typedef struct _NDIS_802_11_TEST
 {
     ULONG Length;
@@ -570,9 +570,9 @@
 typedef struct _WLAN_PHY_INFO
 {
 	u8	SignalStrength;//(in percentage)
-	u8	SignalQuality;//(in percentage)
-	u8	Optimum_antenna;  //for Antenna diversity
-	u8  	Reserved_0;
+  	u8	SignalQuality;//(in percentage)
+  	u8	Optimum_antenna;  //for Antenna diversity
+  	u8  	Reserved_0;
 }WLAN_PHY_INFO,*PWLAN_PHY_INFO;
 
 /* temporally add #pragma pack for structure alignment issue of
@@ -597,7 +597,7 @@
   WLAN_PHY_INFO	PhyInfo;
   ULONG  IELength;
   UCHAR  IEs[MAX_IE_SZ];	//(timestamp, beacon interval, and capability information)
-}
+} 
 #ifndef PLATFORM_WINDOWS
 __attribute__((packed))
 #endif
@@ -612,14 +612,14 @@ __inline  static uint get_WLAN_BSSID_EX_sz(WLAN_BSSID_EX *bss)
 }
 
 struct	wlan_network {
-	_list	list;
+	_list	list;	
 	int	network_type;	//refer to ieee80211.h for WIRELESS_11A/B/G
 	int	fixed;			// set to fixed when not to be removed as site-surveying
 	unsigned long	last_scanned; //timestamp for the network
 	int	aid;			//will only be valid when a BSS is joinned.
 	int	join_res;
 	WLAN_BSSID_EX	network; //must be the last item
-#ifdef PLATFORM_WINDOWS
+#ifdef PLATFORM_WINDOWS	
 	unsigned char  iebuf[MAX_IE_SZ];
 #endif
 
@@ -627,16 +627,16 @@ struct	wlan_network {
 
 enum VRTL_CARRIER_SENSE
 {
-    DISABLE_VCS,
-    ENABLE_VCS,
+    DISABLE_VCS,	
+    ENABLE_VCS,	
     AUTO_VCS
 };
 
 enum VCS_TYPE
 {
-    NONE_VCS,
+    NONE_VCS,	
     RTS_CTS,
-    CTS_TO_SELF
+    CTS_TO_SELF 
 };
 
 
@@ -684,19 +684,20 @@ enum UAPSD_MAX_SP
 {
 	NDIS_802_11_AUTHENTICATION_MODE AuthModeSupported;
 	NDIS_802_11_ENCRYPTION_STATUS EncryptStatusSupported;
-
+	
 } NDIS_802_11_AUTHENTICATION_ENCRYPTION, *PNDIS_802_11_AUTHENTICATION_ENCRYPTION;
 
-typedef struct _NDIS_802_11_CAPABILITY
+typedef struct _NDIS_802_11_CAPABILITY 
 {
 	ULONG  Length;
 	ULONG  Version;
 	ULONG  NoOfPMKIDs;
 	ULONG  NoOfAuthEncryptPairsSupported;
 	NDIS_802_11_AUTHENTICATION_ENCRYPTION AuthenticationEncryptionSupported[1];
-
+	
 } NDIS_802_11_CAPABILITY, *PNDIS_802_11_CAPABILITY;
 #endif
 
 
 #endif //#ifndef WLAN_BSSDEF_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/include/xmit_osdep.h b/drivers/net/wireless/realtek/rtl8192cu/include/xmit_osdep.h
old mode 100644
new mode 100755
index 0f6d092..e5848ec
--- a/drivers/net/wireless/realtek/rtl8192cu/include/xmit_osdep.h
+++ b/drivers/net/wireless/realtek/rtl8192cu/include/xmit_osdep.h
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -92,3 +92,4 @@ extern NDIS_STATUS rtw_xmit_entry(
 extern void rtw_os_xmit_complete(_adapter *padapter, struct xmit_frame *pxframe);
 
 #endif //__XMIT_OSDEP_H_
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/ioctl_cfg80211.c b/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/ioctl_cfg80211.c
old mode 100644
new mode 100755
index b131a49..f488cab
--- a/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/ioctl_cfg80211.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/ioctl_cfg80211.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -29,7 +29,7 @@
 
 #ifdef CONFIG_IOCTL_CFG80211
 
-#include "ioctl_cfg80211.h"
+#include "ioctl_cfg80211.h"	
 
 #define RTW_MAX_MGMT_TX_CNT (8)
 
@@ -57,7 +57,7 @@
 	}
 
 #define CHAN2G(_channel, _freq, _flags) {			\
-	.band			= NL80211_BAND_2GHZ,		\
+	.band			= IEEE80211_BAND_2GHZ,		\
 	.center_freq		= (_freq),			\
 	.hw_value		= (_channel),			\
 	.flags			= (_flags),			\
@@ -66,7 +66,7 @@
 }
 
 #define CHAN5G(_channel, _flags) {				\
-	.band			= NL80211_BAND_5GHZ,		\
+	.band			= IEEE80211_BAND_5GHZ,		\
 	.center_freq		= 5000 + (5 * (_channel)),	\
 	.hw_value		= (_channel),			\
 	.flags			= (_flags),			\
@@ -166,18 +166,18 @@ void rtw_5g_rates_init(struct ieee80211_rate *rates)
 }
 
 struct ieee80211_supported_band *rtw_spt_band_alloc(
-	enum nl80211_band band
+	enum ieee80211_band band
 	)
 {
 	struct ieee80211_supported_band *spt_band = NULL;
 	int n_channels, n_bitrates;
 
-	if(band == NL80211_BAND_2GHZ)
+	if(band == IEEE80211_BAND_2GHZ)
 	{
 		n_channels = RTW_2G_CHANNELS_NUM;
 		n_bitrates = RTW_G_RATES_NUM;
 	}
-	else if(band == NL80211_BAND_5GHZ)
+	else if(band == IEEE80211_BAND_5GHZ)
 	{
 		n_channels = RTW_5G_CHANNELS_NUM;
 		n_bitrates = RTW_A_RATES_NUM;
@@ -201,19 +201,19 @@ struct ieee80211_supported_band *rtw_spt_band_alloc(
 	spt_band->n_channels = n_channels;
 	spt_band->n_bitrates = n_bitrates;
 
-	if(band == NL80211_BAND_2GHZ)
+	if(band == IEEE80211_BAND_2GHZ)
 	{
 		rtw_2g_channels_init(spt_band->channels);
 		rtw_2g_rates_init(spt_band->bitrates);
 	}
-	else if(band == NL80211_BAND_5GHZ)
+	else if(band == IEEE80211_BAND_5GHZ)
 	{
 		rtw_5g_channels_init(spt_band->channels);
 		rtw_5g_rates_init(spt_band->bitrates);
 	}
 
 	//spt_band.ht_cap
-
+	
 exit:
 
 	return spt_band;
@@ -221,26 +221,26 @@ struct ieee80211_supported_band *rtw_spt_band_alloc(
 
 void rtw_spt_band_free(struct ieee80211_supported_band *spt_band)
 {
-	u32 size = 0;
+	u32 size;
 
 	if(!spt_band)
 		return;
-
-	if(spt_band->band == NL80211_BAND_2GHZ)
+	
+	if(spt_band->band == IEEE80211_BAND_2GHZ)
 	{
 		size = sizeof(struct ieee80211_supported_band)
 			+ sizeof(struct ieee80211_channel)*RTW_2G_CHANNELS_NUM
 			+ sizeof(struct ieee80211_rate)*RTW_G_RATES_NUM;
 	}
-	else if(spt_band->band == NL80211_BAND_5GHZ)
+	else if(spt_band->band == IEEE80211_BAND_5GHZ)
 	{
 		size = sizeof(struct ieee80211_supported_band)
 			+ sizeof(struct ieee80211_channel)*RTW_5G_CHANNELS_NUM
-			+ sizeof(struct ieee80211_rate)*RTW_A_RATES_NUM;
+			+ sizeof(struct ieee80211_rate)*RTW_A_RATES_NUM;		
 	}
 	else
 	{
-
+		
 	}
 	rtw_mfree((u8*)spt_band, size);
 }
@@ -300,13 +300,13 @@ static int rtw_ieee80211_channel_to_frequency(int chan, int band)
 {
 	/* see 802.11 17.3.8.3.2 and Annex J
 	* there are overlapping channel numbers in 5GHz and 2GHz bands */
-
-	if (band == NL80211_BAND_5GHZ) {
-	if (chan >= 182 && chan <= 196)
+           
+	if (band == IEEE80211_BAND_5GHZ) {
+       	if (chan >= 182 && chan <= 196)
 			return 4000 + chan * 5;
              else
                     return 5000 + chan * 5;
-       } else { /* NL80211_BAND_2GHZ */
+       } else { /* IEEE80211_BAND_2GHZ */
 		if (chan == 14)
 			return 2484;
              else if (chan < 14)
@@ -319,10 +319,10 @@ static int rtw_ieee80211_channel_to_frequency(int chan, int band)
 #define MAX_BSSINFO_LEN 1000
 static int rtw_cfg80211_inform_bss(_adapter *padapter, struct wlan_network *pnetwork)
 {
-	int ret=0;
+	int ret=0;	
 	struct ieee80211_channel *notify_channel;
 	struct cfg80211_bss *bss;
-	//struct ieee80211_supported_band *band;
+	//struct ieee80211_supported_band *band;       
 	u16 channel;
 	u32 freq;
 	u64 notify_timestamp;
@@ -331,12 +331,12 @@ static int rtw_cfg80211_inform_bss(_adapter *padapter, struct wlan_network *pnet
 	u8 *notify_ie;
 	size_t notify_ielen;
 	s32 notify_signal;
-	u8 *buf, *pbuf;
+	u8 buf[MAX_BSSINFO_LEN], *pbuf;
 	size_t len,bssinf_len=0;
 	struct rtw_ieee80211_hdr *pwlanhdr;
 	unsigned short *fctrl;
 	u8	bc_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
-
+		
 	struct wireless_dev *wdev = padapter->rtw_wdev;
 	struct wiphy *wiphy = wdev->wiphy;
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
@@ -359,19 +359,19 @@ static int rtw_cfg80211_inform_bss(_adapter *padapter, struct wlan_network *pnet
 		struct cfg80211_scan_request *request = wdev_to_priv(wdev)->scan_request;
 		struct cfg80211_ssid *ssids = request->ssids;
 		u32 wpsielen=0;
-		u8 *wpsie=NULL;
-
+		u8 *wpsie=NULL;	
+		
 		wpsie = rtw_get_wps_ie(pnetwork->network.IEs+_FIXED_IE_LENGTH_, pnetwork->network.IELength-_FIXED_IE_LENGTH_, NULL, &wpsielen);
-
+		
 		if(wpsie && wpsielen>0)
 			psr = rtw_get_wps_attr_content(wpsie,  wpsielen, WPS_ATTR_SELECTED_REGISTRAR, (u8*)(&sr), NULL);
-
+		
 		if (sr != 0)
-		{
+		{			
 			if(request->n_ssids == 1  && request->n_channels == 1) // it means under processing WPS
 			{
 				DBG_8192C("ssid=%s, len=%d\n", pssid->Ssid, pssid->SsidLength);
-
+			
 				if(pssid->SsidLength == ssids[0].ssid_len &&
 					_rtw_memcmp(pssid->Ssid, ssids[0].ssid, ssids[0].ssid_len))
 				{
@@ -381,8 +381,8 @@ static int rtw_cfg80211_inform_bss(_adapter *padapter, struct wlan_network *pnet
 				{
 					if(psr !=NULL)
 						*psr = 0; //clear sr
-
-#if 0
+				
+#if 0			
 					WLAN_BSSID_EX  *pselect_network = &pnetwork->network;
 					struct cfg80211_bss *pselect_bss = NULL;
 					struct ieee80211_channel *notify_channel = NULL;
@@ -391,14 +391,14 @@ static int rtw_cfg80211_inform_bss(_adapter *padapter, struct wlan_network *pnet
 					DBG_871X("%s, got sr, but ssid mismatch, to remove this bss\n", __func__);
 
 					if (pselect_network->Configuration.DSConfig <= RTW_CH_MAX_2G_CHANNEL)
-						freq = rtw_ieee80211_channel_to_frequency(pselect_network->Configuration.DSConfig, NL80211_BAND_2GHZ);
+						freq = rtw_ieee80211_channel_to_frequency(pselect_network->Configuration.DSConfig, IEEE80211_BAND_2GHZ);
 					else
-						freq = rtw_ieee80211_channel_to_frequency(pselect_network->Configuration.DSConfig, NL80211_BAND_5GHZ);
+						freq = rtw_ieee80211_channel_to_frequency(pselect_network->Configuration.DSConfig, IEEE80211_BAND_5GHZ);
 
 					notify_channel = ieee80211_get_channel(wiphy, freq);
 					pselect_bss = cfg80211_get_bss(wiphy, NULL/*notify_channel*/,
 								pselect_network->MacAddress, pselect_network->Ssid.Ssid,
-								pselect_network->Ssid.SsidLength, 0/*WLAN_CAPABILITY_ESS*/,
+								pselect_network->Ssid.SsidLength, 0/*WLAN_CAPABILITY_ESS*/, 
 								0/*WLAN_CAPABILITY_ESS*/);
 
 					if(pselect_bss)
@@ -411,32 +411,32 @@ static int rtw_cfg80211_inform_bss(_adapter *padapter, struct wlan_network *pnet
 #else
 						cfg80211_put_bss(pselect_bss);
 #endif
-
+						
 					}
-
+					
 					goto exit;
-#endif
-				}
-			}
-		}
+#endif 					
+				}			
+			}			
+		}		
 	}
 	//_exit_critical_bh(&pwdev_priv->scan_req_lock, &irqL);
 
 	channel = pnetwork->network.Configuration.DSConfig;
 	if (channel <= RTW_CH_MAX_2G_CHANNEL)
-		freq = rtw_ieee80211_channel_to_frequency(channel, NL80211_BAND_2GHZ);
+		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_2GHZ);
 	else
-		freq = rtw_ieee80211_channel_to_frequency(channel, NL80211_BAND_5GHZ);
-
+		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_5GHZ);
+	
 	notify_channel = ieee80211_get_channel(wiphy, freq);
 
 	//rtw_get_timestampe_from_ie()
 	notify_timestamp = jiffies_to_msecs(jiffies)*1000; /* uSec */
 
 	notify_interval = le16_to_cpu(*(u16*)rtw_get_beacon_interval_from_ie(pnetwork->network.IEs));
-	notify_capability = le16_to_cpu(*(u16*)rtw_get_capability_from_ie(pnetwork->network.IEs));
-
+	notify_capability = le16_to_cpu(*(u16*)rtw_get_capability_from_ie(pnetwork->network.IEs));		
 
+	
 	notify_ie = pnetwork->network.IEs+_FIXED_IE_LENGTH_;
 	notify_ielen = pnetwork->network.IELength-_FIXED_IE_LENGTH_;
 
@@ -447,7 +447,7 @@ static int rtw_cfg80211_inform_bss(_adapter *padapter, struct wlan_network *pnet
 	} else {
 		notify_signal = 100*translate_percentage_to_dbm(pnetwork->network.PhyInfo.SignalStrength);//dbm
 	}
-
+		
 /*
 	DBG_8192C("bssid: %2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X\n",
                         pnetwork->network.MacAddress[0], pnetwork->network.MacAddress[1], pnetwork->network.MacAddress[2],
@@ -459,18 +459,17 @@ static int rtw_cfg80211_inform_bss(_adapter *padapter, struct wlan_network *pnet
 	DBG_8192C("notify_timestamp: %#018llx\n", notify_timestamp);
 */
 
-	buf = rtw_zmalloc(MAX_BSSINFO_LEN);
 	pbuf = buf;
-
-	pwlanhdr = (struct rtw_ieee80211_hdr *)pbuf;
+	
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pbuf;	
 	fctrl = &(pwlanhdr->frame_ctl);
-	*(fctrl) = 0;
+	*(fctrl) = 0;	
 
 	SetSeqNum(pwlanhdr, 0/*pmlmeext->mgnt_seq*/);
 	//pmlmeext->mgnt_seq++;
 
 	if (pnetwork->network.Reserved[0] == 1) { // WIFI_BEACON
-		_rtw_memcpy(pwlanhdr->addr1, bc_addr, ETH_ALEN);
+		_rtw_memcpy(pwlanhdr->addr1, bc_addr, ETH_ALEN);		
 		SetFrameSubType(pbuf, WIFI_BEACON);
 	} else {
 		_rtw_memcpy(pwlanhdr->addr1, myid(&(padapter->eeprompriv)), ETH_ALEN);
@@ -481,27 +480,25 @@ static int rtw_cfg80211_inform_bss(_adapter *padapter, struct wlan_network *pnet
 	_rtw_memcpy(pwlanhdr->addr3, pnetwork->network.MacAddress, ETH_ALEN);
 
 
-	pbuf += sizeof(struct rtw_ieee80211_hdr_3addr);
+	pbuf += sizeof(struct rtw_ieee80211_hdr_3addr);	
 	len = sizeof (struct rtw_ieee80211_hdr_3addr);
 
 	_rtw_memcpy(pbuf, pnetwork->network.IEs, pnetwork->network.IELength);
 	len += pnetwork->network.IELength;
 
-	rtw_mfree(buf, MAX_BSSINFO_LEN);
-
 	//#ifdef CONFIG_P2P
 	//if(rtw_get_p2p_ie(pnetwork->network.IEs+12, pnetwork->network.IELength-12, NULL, NULL))
 	//{
 	//	DBG_8192C("%s, got p2p_ie\n", __func__);
 	//}
 	//#endif
+	
 
-
-#if 1
+#if 1	
 	bss = cfg80211_inform_bss_frame(wiphy, notify_channel, (struct ieee80211_mgmt *)buf,
 		len, notify_signal, GFP_ATOMIC);
-#else
-
+#else			 
+			
 	bss = cfg80211_inform_bss(wiphy, notify_channel, (const u8 *)pnetwork->network.MacAddress,
                 notify_timestamp, notify_capability, notify_interval, notify_ie,
                 notify_ielen, notify_signal, GFP_ATOMIC/*GFP_KERNEL*/);
@@ -516,29 +513,29 @@ static int rtw_cfg80211_inform_bss(_adapter *padapter, struct wlan_network *pnet
 #ifndef COMPAT_KERNEL_RELEASE
 	//patch for cfg80211, update beacon ies to information_elements
 	if (pnetwork->network.Reserved[0] == 1) { // WIFI_BEACON
-
+	
 		 if(bss->len_information_elements != bss->len_beacon_ies)
 		 {
-			bss->information_elements = bss->beacon_ies;
+			bss->information_elements = bss->beacon_ies;			
 			bss->len_information_elements =  bss->len_beacon_ies;
-		 }
+		 }		
 	}
 #endif //COMPAT_KERNEL_RELEASE
 #endif //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
 
-/*
+/*	
 	{
-		if( bss->information_elements == bss->proberesp_ies)
+		if( bss->information_elements == bss->proberesp_ies) 
 		{
 			if( bss->len_information_elements !=  bss->len_proberesp_ies)
 			{
 				DBG_8192C("error!, len_information_elements !=  bss->len_proberesp_ies\n");
 			}
-
+							
 		}
 		else if(bss->len_information_elements <  bss->len_beacon_ies)
 		{
-			bss->information_elements = bss->beacon_ies;
+			bss->information_elements = bss->beacon_ies;			
 			bss->len_information_elements =  bss->len_beacon_ies;
 		}
 	}
@@ -550,15 +547,15 @@ static int rtw_cfg80211_inform_bss(_adapter *padapter, struct wlan_network *pnet
 	cfg80211_put_bss(bss);
 #endif
 
-exit:
+exit:	
 	return ret;
-
+	
 }
 
 /*
 	Check the given bss is valid by kernel API cfg80211_get_bss()
 	@padapter : the given adapter
-
+	
 	return _TRUE if bss is valid,  _FALSE for not found.
 */
 int rtw_cfg80211_check_bss(_adapter *padapter)
@@ -572,19 +569,15 @@ int rtw_cfg80211_check_bss(_adapter *padapter)
 		return _FALSE;
 
 	if (pnetwork->Configuration.DSConfig <= RTW_CH_MAX_2G_CHANNEL)
-		freq = rtw_ieee80211_channel_to_frequency(pnetwork->Configuration.DSConfig, NL80211_BAND_2GHZ);
+		freq = rtw_ieee80211_channel_to_frequency(pnetwork->Configuration.DSConfig, IEEE80211_BAND_2GHZ);
 	else
-		freq = rtw_ieee80211_channel_to_frequency(pnetwork->Configuration.DSConfig, NL80211_BAND_5GHZ);
+		freq = rtw_ieee80211_channel_to_frequency(pnetwork->Configuration.DSConfig, IEEE80211_BAND_5GHZ);
 
 	notify_channel = ieee80211_get_channel(padapter->rtw_wdev->wiphy, freq);
 	bss = cfg80211_get_bss(padapter->rtw_wdev->wiphy, notify_channel,
 			pnetwork->MacAddress, pnetwork->Ssid.Ssid,
 			pnetwork->Ssid.SsidLength,
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 1, 0)
 			WLAN_CAPABILITY_ESS, WLAN_CAPABILITY_ESS);
-#else
-			IEEE80211_BSS_TYPE_ESS, IEEE80211_PRIVACY_ANY);
-#endif
 
 	return 	(bss!=NULL);
 }
@@ -633,9 +626,9 @@ void rtw_cfg80211_indicate_connect(_adapter *padapter)
 		u16 channel = cur_network->network.Configuration.DSConfig;
 
 		if (channel <= RTW_CH_MAX_2G_CHANNEL)
-			freq = rtw_ieee80211_channel_to_frequency(channel, NL80211_BAND_2GHZ);
+			freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_2GHZ);
 		else
-			freq = rtw_ieee80211_channel_to_frequency(channel, NL80211_BAND_5GHZ);
+			freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_5GHZ);
 
 		notify_channel = ieee80211_get_channel(wiphy, freq);
 		#endif
@@ -655,7 +648,7 @@ void rtw_cfg80211_indicate_connect(_adapter *padapter)
 		}
 		#else
 		cfg80211_roamed(padapter->pnetdev
-			#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 39)
+			#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 39) || defined(COMPAT_KERNEL_RELEASE)
 			, notify_channel
 			#endif
 			, cur_network->network.MacAddress
@@ -666,7 +659,7 @@ void rtw_cfg80211_indicate_connect(_adapter *padapter)
 			, GFP_ATOMIC);
 		#endif
 	}
-	else
+	else 
 	#endif
 	{
 		DBG_8192C("pwdev->sme_state(b)=%d\n", pwdev->sme_state);
@@ -690,7 +683,7 @@ void rtw_cfg80211_indicate_disconnect(_adapter *padapter)
 
 	DBG_871X(FUNC_ADPT_FMT"\n", FUNC_ADPT_ARG(padapter));
 
-	if (pwdev->iftype != NL80211_IFTYPE_STATION
+	if (pwdev->iftype != NL80211_IFTYPE_STATION 
 		#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
 		&& pwdev->iftype != NL80211_IFTYPE_P2P_CLIENT
 		#endif
@@ -701,7 +694,7 @@ void rtw_cfg80211_indicate_disconnect(_adapter *padapter)
 	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
 		return;
 
-#ifdef CONFIG_P2P
+#ifdef CONFIG_P2P	
 	if( pwdinfo->driver_interface == DRIVER_CFG80211 )
 	{
 		if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
@@ -709,7 +702,7 @@ void rtw_cfg80211_indicate_disconnect(_adapter *padapter)
 			_cancel_timer_ex( &pwdinfo->find_phase_timer );
 			_cancel_timer_ex( &pwdinfo->restore_p2p_state_timer );
 			_cancel_timer_ex( &pwdinfo->pre_tx_scan_timer);
-
+	
 			rtw_p2p_set_state(pwdinfo, rtw_p2p_pre_state(pwdinfo));
 			rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
 
@@ -721,28 +714,25 @@ void rtw_cfg80211_indicate_disconnect(_adapter *padapter)
 	if (!padapter->mlmepriv.not_indic_disco) {
 		DBG_8192C("pwdev->sme_state(b)=%d\n", pwdev->sme_state);
 
-		if (check_fwstate(pmlmepriv, WIFI_UNDER_LINKING)) {
-			cfg80211_connect_result(padapter->pnetdev, NULL, NULL, 0, NULL, 0,
+		if(pwdev->sme_state==CFG80211_SME_CONNECTING)
+			cfg80211_connect_result(padapter->pnetdev, NULL, NULL, 0, NULL, 0, 
 				WLAN_STATUS_UNSPECIFIED_FAILURE, GFP_ATOMIC/*GFP_KERNEL*/);
-		} else {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4,2,0)
+		else if(pwdev->sme_state==CFG80211_SME_CONNECTED)
 			cfg80211_disconnected(padapter->pnetdev, 0, NULL, 0, GFP_ATOMIC);
-#else
-			cfg80211_disconnected(padapter->pnetdev, 0, NULL, 0, false, GFP_ATOMIC);
-#endif
-        }
+		//else
+			//DBG_8192C("pwdev->sme_state=%d\n", pwdev->sme_state);
 
 		DBG_8192C("pwdev->sme_state(a)=%d\n", pwdev->sme_state);
 	}
 }
-
+ 	
 
 #ifdef CONFIG_AP_MODE
 static u8 set_pairwise_key(_adapter *padapter, struct sta_info *psta)
 {
 	struct cmd_obj*			ph2c;
 	struct set_stakey_parm	*psetstakey_para;
-	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;
+	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;	
 	u8	res=_SUCCESS;
 
 	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
@@ -763,17 +753,17 @@ static u8 set_pairwise_key(_adapter *padapter, struct sta_info *psta)
 
 	psetstakey_para->algorithm = (u8)psta->dot118021XPrivacy;
 
-	_rtw_memcpy(psetstakey_para->addr, psta->hwaddr, ETH_ALEN);
-
+	_rtw_memcpy(psetstakey_para->addr, psta->hwaddr, ETH_ALEN);	
+	
 	_rtw_memcpy(psetstakey_para->key, &psta->dot118021x_UncstKey, 16);
 
-
-	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+	
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);	
 
 exit:
 
 	return res;
-
+	
 }
 
 static int set_group_key(_adapter *padapter, u8 *key, u8 alg, int keyid)
@@ -781,11 +771,11 @@ static int set_group_key(_adapter *padapter, u8 *key, u8 alg, int keyid)
 	u8 keylen;
 	struct cmd_obj* pcmd;
 	struct setkey_parm *psetkeyparm;
-	struct cmd_priv	*pcmdpriv=&(padapter->cmdpriv);
+	struct cmd_priv	*pcmdpriv=&(padapter->cmdpriv);	
 	int res=_SUCCESS;
 
 	DBG_8192C("%s\n", __FUNCTION__);
-
+	
 	pcmd = (struct cmd_obj*)rtw_zmalloc(sizeof(struct	cmd_obj));
 	if(pcmd==NULL){
 		res= _FAIL;
@@ -799,7 +789,7 @@ static int set_group_key(_adapter *padapter, u8 *key, u8 alg, int keyid)
 	}
 
 	_rtw_memset(psetkeyparm, 0, sizeof(struct setkey_parm));
-
+		
 	psetkeyparm->keyid=(u8)keyid;
 	if (is_wep_enc(alg))
 		padapter->securitypriv.key_mask |= BIT(psetkeyparm->keyid);
@@ -810,25 +800,25 @@ static int set_group_key(_adapter *padapter, u8 *key, u8 alg, int keyid)
 
 	switch(alg)
 	{
-		case _WEP40_:
+		case _WEP40_:					
 			keylen = 5;
 			break;
 		case _WEP104_:
-			keylen = 13;
+			keylen = 13;			
 			break;
 		case _TKIP_:
-		case _TKIP_WTMIC_:
+		case _TKIP_WTMIC_:		
 		case _AES_:
-			keylen = 16;
+			keylen = 16;		
 		default:
-			keylen = 16;
+			keylen = 16;		
 	}
 
 	_rtw_memcpy(&(psetkeyparm->key[0]), key, keylen);
-
+	
 	pcmd->cmdcode = _SetKey_CMD_;
-	pcmd->parmbuf = (u8 *)psetkeyparm;
-	pcmd->cmdsz =  (sizeof(struct setkey_parm));
+	pcmd->parmbuf = (u8 *)psetkeyparm;   
+	pcmd->cmdsz =  (sizeof(struct setkey_parm));  
 	pcmd->rsp = NULL;
 	pcmd->rspsz = 0;
 
@@ -840,24 +830,24 @@ static int set_group_key(_adapter *padapter, u8 *key, u8 alg, int keyid)
 exit:
 
 	return res;
-
+	
 
 }
 
 static int set_wep_key(_adapter *padapter, u8 *key, u8 keylen, int keyid)
-{
+{	
 	u8 alg;
 
 	switch(keylen)
 	{
 		case 5:
-			alg =_WEP40_;
+			alg =_WEP40_;			
 			break;
 		case 13:
-			alg =_WEP104_;
+			alg =_WEP104_;			
 			break;
 		default:
-			alg =_NO_PRIVACY_;
+			alg =_NO_PRIVACY_;			
 	}
 
 	return set_group_key(padapter, key, alg, keyid);
@@ -868,7 +858,7 @@ static int rtw_cfg80211_ap_set_encryption(struct net_device *dev, struct ieee_pa
 {
 	int ret = 0;
 	u32 wep_key_idx, wep_key_len,wep_total_len;
-	struct sta_info *psta = NULL, *pbcmc_sta = NULL;
+	struct sta_info *psta = NULL, *pbcmc_sta = NULL;	
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct mlme_priv 	*pmlmepriv = &padapter->mlmepriv;
 	struct security_priv* psecuritypriv=&(padapter->securitypriv);
@@ -889,23 +879,23 @@ static int rtw_cfg80211_ap_set_encryption(struct net_device *dev, struct ieee_pa
 
 	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
 	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
-	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff)
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) 
 	{
 		if (param->u.crypt.idx >= WEP_KEYS)
 		{
 			ret = -EINVAL;
 			goto exit;
-		}
+		}	
 	}
-	else
-	{
+	else 
+	{		
 		psta = rtw_get_stainfo(pstapriv, param->sta_addr);
 		if(!psta)
 		{
 			//ret = -EINVAL;
 			DBG_8192C("rtw_set_encryption(), sta has already been removed or never been added\n");
 			goto exit;
-		}
+		}			
 	}
 
 	if (strcmp(param->u.crypt.alg, "none") == 0 && (psta==NULL))
@@ -913,18 +903,18 @@ static int rtw_cfg80211_ap_set_encryption(struct net_device *dev, struct ieee_pa
 		//todo:clear default encryption keys
 
 		DBG_8192C("clear default encryption keys, keyid=%d\n", param->u.crypt.idx);
-
+		
 		goto exit;
 	}
 
 
 	if (strcmp(param->u.crypt.alg, "WEP") == 0 && (psta==NULL))
-	{
+	{		
 		DBG_8192C("r871x_set_encryption, crypt.alg = WEP\n");
-
+		
 		wep_key_idx = param->u.crypt.idx;
 		wep_key_len = param->u.crypt.key_len;
-
+					
 		DBG_8192C("r871x_set_encryption, wep_key_idx=%d, len=%d\n", wep_key_idx, wep_key_len);
 
 		if((wep_key_idx >= WEP_KEYS) || (wep_key_len<=0))
@@ -932,12 +922,12 @@ static int rtw_cfg80211_ap_set_encryption(struct net_device *dev, struct ieee_pa
 			ret = -EINVAL;
 			goto exit;
 		}
-
-		if (wep_key_len > 0)
-		{
-			wep_key_len = wep_key_len <= 5 ? 5 : 13;
+			
+		if (wep_key_len > 0) 
+		{			
+		 	wep_key_len = wep_key_len <= 5 ? 5 : 13;
 		}
-
+		
 		if (psecuritypriv->bWepDefaultKeyIdxSet == 0)
 		{
 			//wep default key has not been set, so use this key index as default key.
@@ -945,7 +935,7 @@ static int rtw_cfg80211_ap_set_encryption(struct net_device *dev, struct ieee_pa
 			psecuritypriv->ndisencryptstatus = Ndis802_11Encryption1Enabled;
 			psecuritypriv->dot11PrivacyAlgrthm=_WEP40_;
 			psecuritypriv->dot118021XGrpPrivacy=_WEP40_;
-
+			
 			if(wep_key_len == 13)
 			{
 				psecuritypriv->dot11PrivacyAlgrthm=_WEP104_;
@@ -954,18 +944,18 @@ static int rtw_cfg80211_ap_set_encryption(struct net_device *dev, struct ieee_pa
 
 			psecuritypriv->dot11PrivacyKeyIndex = wep_key_idx;
 		}
-
+			
 		_rtw_memcpy(&(psecuritypriv->dot11DefKey[wep_key_idx].skey[0]), param->u.crypt.key, wep_key_len);
-
+					
 		psecuritypriv->dot11DefKeylen[wep_key_idx] = wep_key_len;
 
 		set_wep_key(padapter, param->u.crypt.key, wep_key_len, wep_key_idx);
 
 		goto exit;
-
+		
 	}
 
-
+	
 	if(!psta && check_fwstate(pmlmepriv, WIFI_AP_STATE)) // //group key
 	{
 		if(param->u.crypt.set_tx == 0) //group key
@@ -973,36 +963,36 @@ static int rtw_cfg80211_ap_set_encryption(struct net_device *dev, struct ieee_pa
 			if(strcmp(param->u.crypt.alg, "WEP") == 0)
 			{
 				DBG_8192C("%s, set group_key, WEP\n", __FUNCTION__);
-
+				
 				_rtw_memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
-
+					
 				psecuritypriv->dot118021XGrpPrivacy = _WEP40_;
 				if(param->u.crypt.key_len==13)
-				{
+				{						
 						psecuritypriv->dot118021XGrpPrivacy = _WEP104_;
 				}
-
+				
 			}
 			else if(strcmp(param->u.crypt.alg, "TKIP") == 0)
-			{
+			{						
 				DBG_8192C("%s, set group_key, TKIP\n", __FUNCTION__);
-
+				
 				psecuritypriv->dot118021XGrpPrivacy = _TKIP_;
 
 				_rtw_memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
-
+				
 				//DEBUG_ERR("set key length :param->u.crypt.key_len=%d\n", param->u.crypt.key_len);
 				//set mic key
 				_rtw_memcpy(psecuritypriv->dot118021XGrptxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[16]), 8);
 				_rtw_memcpy(psecuritypriv->dot118021XGrprxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[24]), 8);
 
 				psecuritypriv->busetkipkey = _TRUE;
-
+											
 			}
 			else if(strcmp(param->u.crypt.alg, "CCMP") == 0)
 			{
 				DBG_8192C("%s, set group_key, CCMP\n", __FUNCTION__);
-
+			
 				psecuritypriv->dot118021XGrpPrivacy = _AES_;
 
 				_rtw_memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
@@ -1010,7 +1000,7 @@ static int rtw_cfg80211_ap_set_encryption(struct net_device *dev, struct ieee_pa
 			else
 			{
 				DBG_8192C("%s, set group_key, none\n", __FUNCTION__);
-
+				
 				psecuritypriv->dot118021XGrpPrivacy = _NO_PRIVACY_;
 			}
 
@@ -1019,100 +1009,100 @@ static int rtw_cfg80211_ap_set_encryption(struct net_device *dev, struct ieee_pa
 			psecuritypriv->binstallGrpkey = _TRUE;
 
 			psecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;//!!!
-
+								
 			set_group_key(padapter, param->u.crypt.key, psecuritypriv->dot118021XGrpPrivacy, param->u.crypt.idx);
-
+			
 			pbcmc_sta=rtw_get_bcmc_stainfo(padapter);
 			if(pbcmc_sta)
 			{
 				pbcmc_sta->ieee8021x_blocked = _FALSE;
-				pbcmc_sta->dot118021XPrivacy= psecuritypriv->dot118021XGrpPrivacy;//rx will use bmc_sta's dot118021XPrivacy
-			}
-
+				pbcmc_sta->dot118021XPrivacy= psecuritypriv->dot118021XGrpPrivacy;//rx will use bmc_sta's dot118021XPrivacy			
+			}	
+						
 		}
 
 		goto exit;
-
-	}
+		
+	}	
 
 	if(psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X && psta) // psk/802_1x
 	{
 		if(check_fwstate(pmlmepriv, WIFI_AP_STATE))
 		{
 			if(param->u.crypt.set_tx ==1) //pairwise key
-			{
+			{ 
 				_rtw_memcpy(psta->dot118021x_UncstKey.skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
-
+				
 				if(strcmp(param->u.crypt.alg, "WEP") == 0)
 				{
 					DBG_8192C("%s, set pairwise key, WEP\n", __FUNCTION__);
-
+					
 					psta->dot118021XPrivacy = _WEP40_;
 					if(param->u.crypt.key_len==13)
-					{
+					{						
 						psta->dot118021XPrivacy = _WEP104_;
 					}
 				}
 				else if(strcmp(param->u.crypt.alg, "TKIP") == 0)
-				{
+				{						
 					DBG_8192C("%s, set pairwise key, TKIP\n", __FUNCTION__);
-
+					
 					psta->dot118021XPrivacy = _TKIP_;
-
+				
 					//DEBUG_ERR("set key length :param->u.crypt.key_len=%d\n", param->u.crypt.key_len);
 					//set mic key
 					_rtw_memcpy(psta->dot11tkiptxmickey.skey, &(param->u.crypt.key[16]), 8);
 					_rtw_memcpy(psta->dot11tkiprxmickey.skey, &(param->u.crypt.key[24]), 8);
 
 					psecuritypriv->busetkipkey = _TRUE;
-
+											
 				}
 				else if(strcmp(param->u.crypt.alg, "CCMP") == 0)
 				{
 
 					DBG_8192C("%s, set pairwise key, CCMP\n", __FUNCTION__);
-
+					
 					psta->dot118021XPrivacy = _AES_;
 				}
 				else
 				{
 					DBG_8192C("%s, set pairwise key, none\n", __FUNCTION__);
-
+					
 					psta->dot118021XPrivacy = _NO_PRIVACY_;
 				}
-
+						
 				set_pairwise_key(padapter, psta);
-
+					
 				psta->ieee8021x_blocked = _FALSE;
-
+					
 				psta->bpairwise_key_installed = _TRUE;
-
-			}
+					
+			}			
 			else//group key???
-			{
+			{ 
 				if(strcmp(param->u.crypt.alg, "WEP") == 0)
 				{
 					_rtw_memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
-
+					
 					psecuritypriv->dot118021XGrpPrivacy = _WEP40_;
 					if(param->u.crypt.key_len==13)
-					{
+					{						
 						psecuritypriv->dot118021XGrpPrivacy = _WEP104_;
 					}
 				}
 				else if(strcmp(param->u.crypt.alg, "TKIP") == 0)
-				{
+				{						
 					psecuritypriv->dot118021XGrpPrivacy = _TKIP_;
 
 					_rtw_memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
-
+				
 					//DEBUG_ERR("set key length :param->u.crypt.key_len=%d\n", param->u.crypt.key_len);
 					//set mic key
 					_rtw_memcpy(psecuritypriv->dot118021XGrptxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[16]), 8);
 					_rtw_memcpy(psecuritypriv->dot118021XGrprxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[24]), 8);
 
 					psecuritypriv->busetkipkey = _TRUE;
-
+											
 				}
 				else if(strcmp(param->u.crypt.alg, "CCMP") == 0)
 				{
@@ -1127,29 +1117,29 @@ static int rtw_cfg80211_ap_set_encryption(struct net_device *dev, struct ieee_pa
 
 				psecuritypriv->dot118021XGrpKeyid = param->u.crypt.idx;
 
-				psecuritypriv->binstallGrpkey = _TRUE;
-
+				psecuritypriv->binstallGrpkey = _TRUE;	
+								
 				psecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;//!!!
-
+								
 				set_group_key(padapter, param->u.crypt.key, psecuritypriv->dot118021XGrpPrivacy, param->u.crypt.idx);
-
+			
 				pbcmc_sta=rtw_get_bcmc_stainfo(padapter);
 				if(pbcmc_sta)
 				{
 					pbcmc_sta->ieee8021x_blocked = _FALSE;
-					pbcmc_sta->dot118021XPrivacy= psecuritypriv->dot118021XGrpPrivacy;//rx will use bmc_sta's dot118021XPrivacy
-				}
+					pbcmc_sta->dot118021XPrivacy= psecuritypriv->dot118021XGrpPrivacy;//rx will use bmc_sta's dot118021XPrivacy			
+				}					
 
 			}
-
+			
 		}
-
+				
 	}
 
 exit:
 
 	return ret;
-
+	
 }
 #endif
 
@@ -1158,7 +1148,7 @@ static int rtw_cfg80211_set_encryption(struct net_device *dev, struct ieee_param
 	int ret = 0;
 	u32 wep_key_idx, wep_key_len,wep_total_len;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
-	struct mlme_priv 	*pmlmepriv = &padapter->mlmepriv;
+	struct mlme_priv 	*pmlmepriv = &padapter->mlmepriv;		
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
 #ifdef CONFIG_P2P
 	struct wifidirect_info* pwdinfo = &padapter->wdinfo;
@@ -1173,13 +1163,13 @@ static int rtw_cfg80211_set_encryption(struct net_device *dev, struct ieee_param
 
 	if (param_len < (u32) ((u8 *) param->u.crypt.key - (u8 *) param) + param->u.crypt.key_len)
 	{
-		ret =  -EINVAL;
+		ret =  -EINVAL;		
 		goto exit;
 	}
 
 	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
 	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
-	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff)
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) 
 	{
 		if (param->u.crypt.idx >= WEP_KEYS
 #ifdef CONFIG_IEEE80211W
@@ -1191,7 +1181,7 @@ static int rtw_cfg80211_set_encryption(struct net_device *dev, struct ieee_param
 			goto exit;
 		}
 	} else {
-		ret = -EINVAL;
+		ret = -EINVAL;		
 		goto exit;
 	}
 
@@ -1215,7 +1205,7 @@ static int rtw_cfg80211_set_encryption(struct net_device *dev, struct ieee_param
 
 			wep_key_len = wep_key_len <= 5 ? 5 : 13;
 
-		psecuritypriv->ndisencryptstatus = Ndis802_11Encryption1Enabled;
+              	psecuritypriv->ndisencryptstatus = Ndis802_11Encryption1Enabled;
 			psecuritypriv->dot11PrivacyAlgrthm = _WEP40_;
 			psecuritypriv->dot118021XGrpPrivacy = _WEP40_;
 
@@ -1227,14 +1217,14 @@ static int rtw_cfg80211_set_encryption(struct net_device *dev, struct ieee_param
 
 			psecuritypriv->dot11PrivacyKeyIndex = wep_key_idx;
 		}
-
+			
 		_rtw_memcpy(&(psecuritypriv->dot11DefKey[wep_key_idx].skey[0]), param->u.crypt.key, wep_key_len);
-
+			
 		psecuritypriv->dot11DefKeylen[wep_key_idx] = wep_key_len;
-
+			
 		rtw_set_key(padapter, psecuritypriv, wep_key_idx, 0);
 
-		goto exit;
+		goto exit;		
 	}
 
 	if(padapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X) // 802_1x
@@ -1246,7 +1236,7 @@ static int rtw_cfg80211_set_encryption(struct net_device *dev, struct ieee_param
 
 		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_MP_STATE) == _TRUE) //sta mode
 		{
-			psta = rtw_get_stainfo(pstapriv, get_bssid(pmlmepriv));
+			psta = rtw_get_stainfo(pstapriv, get_bssid(pmlmepriv));				
 			if (psta == NULL) {
 				//DEBUG_ERR( ("Set wpa_set_encryption: Obtain Sta_info fail \n"));
 				DBG_8192C("%s, : Obtain Sta_info fail \n", __func__);
@@ -1254,36 +1244,36 @@ static int rtw_cfg80211_set_encryption(struct net_device *dev, struct ieee_param
 			else
 			{
 				//Jeff: don't disable ieee8021x_blocked while clearing key
-				if (strcmp(param->u.crypt.alg, "none") != 0)
+				if (strcmp(param->u.crypt.alg, "none") != 0) 
 					psta->ieee8021x_blocked = _FALSE;
 
-
+				
 				if((padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption2Enabled)||
 						(padapter->securitypriv.ndisencryptstatus ==  Ndis802_11Encryption3Enabled))
 				{
 					psta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;
-				}
+				}		
 
 				if(param->u.crypt.set_tx ==1)//pairwise key
-				{
+				{ 
 
 					DBG_8192C("%s, : param->u.crypt.set_tx ==1 \n", __func__);
-
+					
 					_rtw_memcpy(psta->dot118021x_UncstKey.skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
-
+					
 					if(strcmp(param->u.crypt.alg, "TKIP") == 0)//set mic key
-					{
+					{						
 						//DEBUG_ERR(("\nset key length :param->u.crypt.key_len=%d\n", param->u.crypt.key_len));
 						_rtw_memcpy(psta->dot11tkiptxmickey.skey, &(param->u.crypt.key[16]), 8);
 						_rtw_memcpy(psta->dot11tkiprxmickey.skey, &(param->u.crypt.key[24]), 8);
 
 						padapter->securitypriv.busetkipkey=_FALSE;
-						//_set_timer(&padapter->securitypriv.tkip_timer, 50);
+						//_set_timer(&padapter->securitypriv.tkip_timer, 50);						
 					}
 
 					//DEBUG_ERR((" param->u.crypt.key_len=%d\n",param->u.crypt.key_len));
 					DBG_871X(" ~~~~set sta key:unicastkey\n");
-
+					
 					rtw_setstakey_cmd(padapter, (unsigned char *)psta, _TRUE);
 				}
 				else//group key
@@ -1293,12 +1283,12 @@ static int rtw_cfg80211_set_encryption(struct net_device *dev, struct ieee_param
 						_rtw_memcpy(padapter->securitypriv.dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key,(param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
 						_rtw_memcpy(padapter->securitypriv.dot118021XGrptxmickey[param->u.crypt.idx].skey,&(param->u.crypt.key[16]),8);
 						_rtw_memcpy(padapter->securitypriv.dot118021XGrprxmickey[param->u.crypt.idx].skey,&(param->u.crypt.key[24]),8);
-	                                        padapter->securitypriv.binstallGrpkey = _TRUE;
+	                                        padapter->securitypriv.binstallGrpkey = _TRUE;	
 						//DEBUG_ERR((" param->u.crypt.key_len=%d\n", param->u.crypt.key_len));
 						DBG_871X(" ~~~~set sta key:groupkey\n");
-
+	
 						padapter->securitypriv.dot118021XGrpKeyid = param->u.crypt.idx;
-
+	
 						rtw_set_key(padapter,&padapter->securitypriv,param->u.crypt.idx, 1);
 					}
 #ifdef CONFIG_IEEE80211W
@@ -1317,7 +1307,7 @@ static int rtw_cfg80211_set_encryption(struct net_device *dev, struct ieee_param
 						DBG_871X(" ~~~~set sta key:IGKT\n");
 					}
 #endif //CONFIG_IEEE80211W
-
+					
 #ifdef CONFIG_P2P
 					if(pwdinfo->driver_interface == DRIVER_CFG80211 )
 					{
@@ -1327,8 +1317,8 @@ static int rtw_cfg80211_set_encryption(struct net_device *dev, struct ieee_param
 						}
 					}
 #endif //CONFIG_P2P
-
-				}
+					
+				}						
 			}
 
 			pbcmc_sta=rtw_get_bcmc_stainfo(padapter);
@@ -1339,28 +1329,28 @@ static int rtw_cfg80211_set_encryption(struct net_device *dev, struct ieee_param
 			else
 			{
 				//Jeff: don't disable ieee8021x_blocked while clearing key
-				if (strcmp(param->u.crypt.alg, "none") != 0)
+				if (strcmp(param->u.crypt.alg, "none") != 0) 
 					pbcmc_sta->ieee8021x_blocked = _FALSE;
-
+				
 				if((padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption2Enabled)||
 						(padapter->securitypriv.ndisencryptstatus ==  Ndis802_11Encryption3Enabled))
-				{
+				{							
 					pbcmc_sta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;
-				}
-			}
+				}					
+			}				
 		}
 		else if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) //adhoc mode
-		{
-		}
+		{		
+		}			
 	}
 
 exit:
 
 	DBG_8192C("%s, ret=%d\n", __func__, ret);
-
+	
 	_func_exit_;
-
-	return ret;
+	
+	return ret;	
 }
 
 static int cfg80211_rtw_add_key(struct wiphy *wiphy, struct net_device *ndev,
@@ -1373,12 +1363,12 @@ static int cfg80211_rtw_add_key(struct wiphy *wiphy, struct net_device *ndev,
 {
 	char *alg_name;
 	u32 param_len;
-	struct ieee_param *param = NULL;
+	struct ieee_param *param = NULL;	
 	int ret=0;
 	struct wireless_dev *rtw_wdev = wiphy_to_wdev(wiphy);
 	_adapter *padapter = wiphy_to_adapter(wiphy);
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-
+	
 	DBG_871X(FUNC_NDEV_FMT" adding key for %pM\n", FUNC_NDEV_ARG(ndev), mac_addr);
 	DBG_871X("cipher=0x%x\n", params->cipher);
 	DBG_871X("key_len=0x%x\n", params->key_len);
@@ -1392,7 +1382,7 @@ static int cfg80211_rtw_add_key(struct wiphy *wiphy, struct net_device *ndev,
 	param = (struct ieee_param *)rtw_malloc(param_len);
 	if (param == NULL)
 		return -1;
-
+	
 	_rtw_memset(param, 0, param_len);
 
 	param->cmd = IEEE_CMD_SET_ENCRYPTION;
@@ -1400,8 +1390,8 @@ static int cfg80211_rtw_add_key(struct wiphy *wiphy, struct net_device *ndev,
 
 	switch (params->cipher) {
 	case IW_AUTH_CIPHER_NONE:
-		//todo: remove key
-		//remove = 1;
+		//todo: remove key 
+		//remove = 1;	
 		alg_name = "none";
 		break;
 	case WLAN_CIPHER_SUITE_WEP40:
@@ -1419,12 +1409,12 @@ static int cfg80211_rtw_add_key(struct wiphy *wiphy, struct net_device *ndev,
 		alg_name = "BIP";
 		break;
 #endif //CONFIG_IEEE80211W
-	default:
+	default:	
 		return -ENOTSUPP;
 	}
-
+	
 	strncpy((char *)param->u.crypt.alg, alg_name, IEEE_CRYPT_ALG_NAME_LEN);
-
+	
 
 	if (!mac_addr || is_broadcast_ether_addr(mac_addr))
 	{
@@ -1432,39 +1422,39 @@ static int cfg80211_rtw_add_key(struct wiphy *wiphy, struct net_device *ndev,
 	} else {
 		param->u.crypt.set_tx = 1; //for wpa/wpa2 pairwise key
 	}
-
-
+	
+	
 	//param->u.crypt.idx = key_index - 1;
 	param->u.crypt.idx = key_index;
-
-	if (params->seq_len && params->seq)
-	{
+	
+	if (params->seq_len && params->seq) 
+	{	
 		_rtw_memcpy(param->u.crypt.seq, params->seq, params->seq_len);
 	}
 
 	if(params->key_len && params->key)
 	{
-		param->u.crypt.key_len = params->key_len;
+		param->u.crypt.key_len = params->key_len;		
 		_rtw_memcpy(param->u.crypt.key, params->key, params->key_len);
-	}
+	}	
 
 	if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)
 	{
-		ret =  rtw_cfg80211_set_encryption(ndev, param, param_len);
+		ret =  rtw_cfg80211_set_encryption(ndev, param, param_len);	
 	}
 	else if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
 	{
 #ifdef CONFIG_AP_MODE
 		if(mac_addr)
 			_rtw_memcpy(param->sta_addr, (void*)mac_addr, ETH_ALEN);
-
+	
 		ret = rtw_cfg80211_ap_set_encryption(ndev, param, param_len);
 #endif
 	}
 	else
 	{
 		DBG_8192C("error! fw_state=0x%x, iftype=%d\n", pmlmepriv->fw_state, rtw_wdev->iftype);
-
+		
 	}
 
 	if(param)
@@ -1516,7 +1506,7 @@ static int cfg80211_rtw_del_key(struct wiphy *wiphy, struct net_device *ndev,
 				u8 key_index, const u8 *mac_addr)
 #endif	// (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
 {
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);		
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
 
 	DBG_871X(FUNC_NDEV_FMT" key_index=%d\n", FUNC_NDEV_ARG(ndev), key_index);
@@ -1537,7 +1527,7 @@ static int cfg80211_rtw_set_default_key(struct wiphy *wiphy,
 	#endif
 	)
 {
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);		
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
 
 		DBG_871X(FUNC_NDEV_FMT" key_index=%d"
@@ -1573,7 +1563,7 @@ static int cfg80211_rtw_set_default_key(struct wiphy *wiphy,
 
 static int cfg80211_rtw_get_station(struct wiphy *wiphy,
 				    struct net_device *ndev,
-				    const u8 *mac, struct station_info *sinfo)
+				    u8 *mac, struct station_info *sinfo)
 {
 	int ret = 0;
 	_adapter *padapter = wiphy_to_adapter(wiphy);
@@ -1613,32 +1603,16 @@ static int cfg80211_rtw_get_station(struct wiphy *wiphy,
 			goto exit;
 		}
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,0,0))
-		sinfo->filled |= BIT(NL80211_STA_INFO_SIGNAL);
-#else
 		sinfo->filled |= STATION_INFO_SIGNAL;
-#endif
 		sinfo->signal = translate_percentage_to_dbm(padapter->recvpriv.signal_strength);
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,0,0))
-		sinfo->filled |= BIT(NL80211_STA_INFO_TX_BITRATE);
-#else
 		sinfo->filled |= STATION_INFO_TX_BITRATE;
-#endif
 		sinfo->txrate.legacy = rtw_get_cur_max_rate(padapter);
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,0,0))
-		sinfo->filled |= BIT(NL80211_STA_INFO_RX_PACKETS);
-#else
 		sinfo->filled |= STATION_INFO_RX_PACKETS;
-#endif
 		sinfo->rx_packets = sta_rx_data_pkts(psta);
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,0,0))
-		sinfo->filled |= BIT(NL80211_STA_INFO_TX_PACKETS);
-#else
 		sinfo->filled |= STATION_INFO_TX_PACKETS;
-#endif
 		sinfo->tx_packets = psta->sta_stats.tx_pkts;
 
 	}
@@ -1674,7 +1648,7 @@ enum nl80211_iftype {
        NL80211_IFTYPE_MESH_POINT,
        NL80211_IFTYPE_P2P_CLIENT, //8
 	NL80211_IFTYPE_P2P_GO, //9
-       //keep last
+       //keep last 
        NUM_NL80211_IFTYPES,
        NL80211_IFTYPE_MAX = NUM_NL80211_IFTYPES - 1
 };
@@ -1743,8 +1717,8 @@ static int cfg80211_rtw_change_iface(struct wiphy *wiphy,
 		change = _TRUE;
 		pmlmeext->action_public_rxseq = 0xffff;
 		pmlmeext->action_public_dialog_token = 0xff;
-	}
-
+	}	
+		
 	switch (type) {
 	case NL80211_IFTYPE_ADHOC:
 		networkType = Ndis802_11IBSS;
@@ -1787,16 +1761,16 @@ static int cfg80211_rtw_change_iface(struct wiphy *wiphy,
 			}
 		}
 		#endif //CONFIG_P2P
-		break;
+		break;		
 	default:
 		return -EOPNOTSUPP;
 	}
 
 	rtw_wdev->iftype = type;
-
+	
 	_enter_critical_bh(&pmlmepriv->lock, &irqL);
 	_enter_critical_bh(&queue->lock, &irqL);
-
+	
 	if (rtw_set_802_11_infrastructure_mode(padapter, networkType) ==_FALSE)
 	{
 		rtw_wdev->iftype = old_type;
@@ -1808,8 +1782,8 @@ static int cfg80211_rtw_change_iface(struct wiphy *wiphy,
 	_exit_critical_bh(&queue->lock, &irqL);
 	_exit_critical_bh(&pmlmepriv->lock, &irqL);
 
-	rtw_setopmode_cmd(padapter, networkType);
-
+	rtw_setopmode_cmd(padapter, networkType);	
+	
 exit:
 
 	return ret;
@@ -1823,9 +1797,9 @@ void rtw_cfg80211_indicate_scan_done(struct rtw_wdev_priv *pwdev_priv, bool abor
 	if(pwdev_priv->scan_request != NULL)
 	{
 		//struct cfg80211_scan_request *scan_request = pwdev_priv->scan_request;
-
+	
 		#ifdef CONFIG_DEBUG_CFG80211
-		DBG_871X("%s with scan req\n", __FUNCTION__);
+		DBG_871X("%s with scan req\n", __FUNCTION__);	
 		#endif
 
 		//avoid WARN_ON(request != wiphy_to_dev(request->wiphy)->scan_req);
@@ -1836,19 +1810,18 @@ void rtw_cfg80211_indicate_scan_done(struct rtw_wdev_priv *pwdev_priv, bool abor
 		}
 		else
 		{
-			#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0))
-			cfg80211_scan_done(pwdev_priv->scan_request, aborted);
-			#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,8,0)
 			struct cfg80211_scan_info info = {
-				.aborted = aborted,
+				.aborted = aborted
 			};
- 	 
 			cfg80211_scan_done(pwdev_priv->scan_request, &info);
-			#endif
+#else			
+			cfg80211_scan_done(pwdev_priv->scan_request, aborted);
+#endif
 		}
 
 		pwdev_priv->scan_request = NULL;
-
+		
 	} else {
 		#ifdef CONFIG_DEBUG_CFG80211
 		DBG_871X("%s without scan req\n", __FUNCTION__);
@@ -1860,9 +1833,9 @@ void rtw_cfg80211_indicate_scan_done(struct rtw_wdev_priv *pwdev_priv, bool abor
 void rtw_cfg80211_surveydone_event_callback(_adapter *padapter)
 {
 	_irqL	irqL;
-	_list					*plist, *phead;
-	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
-	_queue				*queue	= &(pmlmepriv->scanned_queue);
+	_list					*plist, *phead;	
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);	
+	_queue				*queue	= &(pmlmepriv->scanned_queue);	
 	struct	wlan_network	*pnetwork = NULL;
 	u32 cnt=0;
 	u32 wait_for_surveydone;
@@ -1881,7 +1854,7 @@ void rtw_cfg80211_surveydone_event_callback(_adapter *padapter)
 
 	phead = get_list_head(queue);
 	plist = get_next(phead);
-
+       
 	while(1)
 	{
 		if (rtw_end_of_queue_search(phead,plist)== _TRUE)
@@ -1894,17 +1867,17 @@ void rtw_cfg80211_surveydone_event_callback(_adapter *padapter)
 			&& rtw_mlme_band_check(padapter, pnetwork->network.Configuration.DSConfig) == _TRUE
 			&& _TRUE == rtw_validate_ssid(&(pnetwork->network.Ssid))
 		)
-		{
+		{		
 			//ev=translate_scan(padapter, a, pnetwork, ev, stop);
-			rtw_cfg80211_inform_bss(padapter, pnetwork);
+			rtw_cfg80211_inform_bss(padapter, pnetwork);		
 		}
 
 		plist = get_next(plist);
-
+	
 	}
-
+	
 	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
-
+	
 	//call this after other things have been done
 	rtw_cfg80211_indicate_scan_done(wdev_to_priv(padapter->rtw_wdev), _FALSE);
 }
@@ -1914,16 +1887,16 @@ static int rtw_cfg80211_set_probe_req_wpsp2pie(_adapter *padapter, char *buf, in
 	int ret = 0;
 	uint wps_ielen = 0;
 	u8 *wps_ie;
-	u32	p2p_ielen = 0;
+	u32	p2p_ielen = 0;	
 	u8 *p2p_ie;
-	u32	wfd_ielen = 0;
+	u32	wfd_ielen = 0;	
 	u8 *wfd_ie;
-	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);	
 
 #ifdef CONFIG_DEBUG_CFG80211
 	DBG_8192C("%s, ielen=%d\n", __func__, len);
 #endif
-
+	
 	if(len>0)
 	{
 		if((wps_ie = rtw_get_wps_ie(buf, len, NULL, &wps_ielen)))
@@ -1931,20 +1904,20 @@ static int rtw_cfg80211_set_probe_req_wpsp2pie(_adapter *padapter, char *buf, in
 			#ifdef CONFIG_DEBUG_CFG80211
 			DBG_8192C("probe_req_wps_ielen=%d\n", wps_ielen);
 			#endif
-
+			
 			if(pmlmepriv->wps_probe_req_ie)
 			{
 				u32 free_len = pmlmepriv->wps_probe_req_ie_len;
 				pmlmepriv->wps_probe_req_ie_len = 0;
 				rtw_mfree(pmlmepriv->wps_probe_req_ie, free_len);
-				pmlmepriv->wps_probe_req_ie = NULL;
-			}
+				pmlmepriv->wps_probe_req_ie = NULL;			
+			}	
 
 			pmlmepriv->wps_probe_req_ie = rtw_malloc(wps_ielen);
 			if ( pmlmepriv->wps_probe_req_ie == NULL) {
 				DBG_8192C("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
 				return -EINVAL;
-
+			
 			}
 			_rtw_memcpy(pmlmepriv->wps_probe_req_ie, wps_ie, wps_ielen);
 			pmlmepriv->wps_probe_req_ie_len = wps_ielen;
@@ -1954,7 +1927,7 @@ static int rtw_cfg80211_set_probe_req_wpsp2pie(_adapter *padapter, char *buf, in
 		//len -= wps_ielen;
 
 		#ifdef CONFIG_P2P
-		if((p2p_ie=rtw_get_p2p_ie(buf, len, NULL, &p2p_ielen)))
+		if((p2p_ie=rtw_get_p2p_ie(buf, len, NULL, &p2p_ielen))) 
 		{
 			struct wifidirect_info *wdinfo = &padapter->wdinfo;
 			u32 attr_contentlen = 0;
@@ -1963,20 +1936,20 @@ static int rtw_cfg80211_set_probe_req_wpsp2pie(_adapter *padapter, char *buf, in
 			#ifdef CONFIG_DEBUG_CFG80211
 			DBG_8192C("probe_req_p2p_ielen=%d\n", p2p_ielen);
 			#endif
-
+			
 			if(pmlmepriv->p2p_probe_req_ie)
 			{
 				u32 free_len = pmlmepriv->p2p_probe_req_ie_len;
 				pmlmepriv->p2p_probe_req_ie_len = 0;
 				rtw_mfree(pmlmepriv->p2p_probe_req_ie, free_len);
 				pmlmepriv->p2p_probe_req_ie = NULL;
-			}
+			}	
 
 			pmlmepriv->p2p_probe_req_ie = rtw_malloc(p2p_ielen);
 			if ( pmlmepriv->p2p_probe_req_ie == NULL) {
 				DBG_8192C("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
 				return -EINVAL;
-
+			
 			}
 			_rtw_memcpy(pmlmepriv->p2p_probe_req_ie, p2p_ie, p2p_ielen);
 			pmlmepriv->p2p_probe_req_ie_len = p2p_ielen;
@@ -1993,39 +1966,39 @@ static int rtw_cfg80211_set_probe_req_wpsp2pie(_adapter *padapter, char *buf, in
 			}
 		}
 		#endif //CONFIG_P2P
-
+		
 		//buf += p2p_ielen;
 		//len -= p2p_ielen;
 
 		#ifdef CONFIG_WFD
-		if(rtw_get_wfd_ie(buf, len, NULL, &wfd_ielen))
+		if(rtw_get_wfd_ie(buf, len, NULL, &wfd_ielen)) 
 		{
 			#ifdef CONFIG_DEBUG_CFG80211
 			DBG_8192C("probe_req_wfd_ielen=%d\n", wfd_ielen);
 			#endif
-
+			
 			if(pmlmepriv->wfd_probe_req_ie)
 			{
 				u32 free_len = pmlmepriv->wfd_probe_req_ie_len;
 				pmlmepriv->wfd_probe_req_ie_len = 0;
 				rtw_mfree(pmlmepriv->wfd_probe_req_ie, free_len);
 				pmlmepriv->wfd_probe_req_ie = NULL;
-			}
+			}	
 
 			pmlmepriv->wfd_probe_req_ie = rtw_malloc(wfd_ielen);
 			if ( pmlmepriv->wfd_probe_req_ie == NULL) {
 				DBG_8192C("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
 				return -EINVAL;
-
+			
 			}
-			rtw_get_wfd_ie(buf, len, pmlmepriv->wfd_probe_req_ie, &pmlmepriv->wfd_probe_req_ie_len);
+			rtw_get_wfd_ie(buf, len, pmlmepriv->wfd_probe_req_ie, &pmlmepriv->wfd_probe_req_ie_len);			
 		}
 		#endif //CONFIG_WFD
-
+		
 	}
 
 	return ret;
-
+	
 }
 
 static int cfg80211_rtw_scan(struct wiphy *wiphy
@@ -2036,26 +2009,26 @@ static int cfg80211_rtw_scan(struct wiphy *wiphy
 {
 	int i;
 	u8 _status = _FALSE;
-	int ret = 0;
+	int ret = 0;	
 	_adapter *padapter = wiphy_to_adapter(wiphy);
 	struct mlme_priv *pmlmepriv= &padapter->mlmepriv;
 	NDIS_802_11_SSID ssid[RTW_SSID_SCAN_AMOUNT];
 	struct rtw_ieee80211_channel ch[RTW_CHANNEL_SCAN_AMOUNT];
 	_irqL	irqL;
 	u8 *wps_ie=NULL;
-	uint wps_ielen=0;
+	uint wps_ielen=0;	
 	u8 *p2p_ie=NULL;
 	uint p2p_ielen=0;
 	u8 survey_times=3;
 	u8 survey_times_for_one_ch=6;
 #ifdef CONFIG_P2P
-	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
+	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);	
 #endif //CONFIG_P2P
 	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(padapter->rtw_wdev);
 	struct cfg80211_ssid *ssids = request->ssids;
 	int social_channel = 0, j = 0;
 	bool need_indicate_scan_done = _FALSE;
-#ifdef CONFIG_CONCURRENT_MODE
+#ifdef CONFIG_CONCURRENT_MODE	
 	PADAPTER pbuddy_adapter = NULL;
 	struct mlme_priv *pbuddy_mlmepriv = NULL;
 #endif //CONFIG_CONCURRENT_MODE
@@ -2067,7 +2040,7 @@ static int cfg80211_rtw_scan(struct wiphy *wiphy
 #ifdef CONFIG_CONCURRENT_MODE
 	if (padapter->pbuddy_adapter) {
 		pbuddy_adapter = padapter->pbuddy_adapter;
-		pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
+		pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);	
 	}
 #endif //CONFIG_CONCURRENT_MODE
 
@@ -2132,7 +2105,7 @@ static int cfg80211_rtw_scan(struct wiphy *wiphy
 				#endif
 			}
 			rtw_p2p_set_state(pwdinfo, P2P_STATE_LISTEN);
-
+		
 			if(request->n_channels == 3 &&
 				request->channels[0]->hw_value == 1 &&
 				request->channels[1]->hw_value == 6 &&
@@ -2163,7 +2136,7 @@ static int cfg80211_rtw_scan(struct wiphy *wiphy
 	}
 
 #ifdef CONFIG_CONCURRENT_MODE
-	if(pbuddy_mlmepriv && (pbuddy_mlmepriv->LinkDetectInfo.bBusyTraffic == _TRUE))
+	if(pbuddy_mlmepriv && (pbuddy_mlmepriv->LinkDetectInfo.bBusyTraffic == _TRUE))	
 	{
 		DBG_8192C("%s, bBusyTraffic == _TRUE at buddy_intf\n", __func__);
 		need_indicate_scan_done = _TRUE;
@@ -2176,20 +2149,20 @@ static int cfg80211_rtw_scan(struct wiphy *wiphy
 		DBG_8192C("%s, fwstate=0x%x\n", __func__, pmlmepriv->fw_state);
 		need_indicate_scan_done = _TRUE;
 		goto check_need_indicate_scan_done;
-	}
+	} 
 
 #ifdef CONFIG_CONCURRENT_MODE
 	if (check_buddy_fwstate(padapter,
 		_FW_UNDER_SURVEY|_FW_UNDER_LINKING|WIFI_UNDER_WPS) == _TRUE)
-	{
+	{		
 		if(check_buddy_fwstate(padapter, _FW_UNDER_SURVEY))
 		{
 			DBG_8192C("scanning_via_buddy_intf\n");
 			pmlmepriv->scanning_via_buddy_intf = _TRUE;
-		}
+		}		
 
 		DBG_8192C("buddy_intf's mlme state:0x%x\n", pbuddy_mlmepriv->fw_state);
-
+		
 		need_indicate_scan_done = _TRUE;
 		goto check_need_indicate_scan_done;
 	}
@@ -2220,9 +2193,9 @@ static int cfg80211_rtw_scan(struct wiphy *wiphy
 		DBG_8192C("ssid=%s, len=%d\n", ssids[i].ssid, ssids[i].ssid_len);
 		#endif
 		_rtw_memcpy(ssid[i].Ssid, ssids[i].ssid, ssids[i].ssid_len);
-		ssid[i].SsidLength = ssids[i].ssid_len;
+		ssid[i].SsidLength = ssids[i].ssid_len;	
 	}
-
+	
 
 	/* parsing channels, n_channels */
 	_rtw_memset(ch, 0, sizeof(struct rtw_ieee80211_channel)*RTW_CHANNEL_SCAN_AMOUNT);
@@ -2264,7 +2237,7 @@ static int cfg80211_rtw_scan(struct wiphy *wiphy
 exit:
 
 	return ret;
-
+	
 }
 
 static int cfg80211_rtw_set_wiphy_params(struct wiphy *wiphy, u32 changed)
@@ -2324,7 +2297,7 @@ static int cfg80211_rtw_join_ibss(struct wiphy *wiphy, struct net_device *ndev,
 	memcpy(iwm->umac_profile->ssid.ssid, params->ssid, params->ssid_len);
 
 	return iwm_send_mlme_profile(iwm);
-#endif
+#endif	
 	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 	return 0;
 }
@@ -2342,23 +2315,23 @@ static int cfg80211_rtw_leave_ibss(struct wiphy *wiphy, struct net_device *ndev)
 }
 
 static int rtw_cfg80211_set_wpa_version(struct security_priv *psecuritypriv, u32 wpa_version)
-{
+{	
 	DBG_8192C("%s, wpa_version=%d\n", __func__, wpa_version);
-
-	if (!wpa_version) {
-		psecuritypriv->ndisauthtype = Ndis802_11AuthModeOpen;
+	
+	if (!wpa_version) {		
+		psecuritypriv->ndisauthtype = Ndis802_11AuthModeOpen;		
 		return 0;
 	}
 
 
 	if (wpa_version & (NL80211_WPA_VERSION_1 | NL80211_WPA_VERSION_2))
-	{
-		psecuritypriv->ndisauthtype = Ndis802_11AuthModeWPAPSK;
+	{		
+		psecuritypriv->ndisauthtype = Ndis802_11AuthModeWPAPSK;		
 	}
 
 /*
 	if (wpa_version & NL80211_WPA_VERSION_2)
-	{
+	{		
 		psecuritypriv->ndisauthtype = Ndis802_11AuthModeWPA2PSK;
 	}
 */
@@ -2380,12 +2353,12 @@ static int rtw_cfg80211_set_auth_type(struct security_priv *psecuritypriv,
 
 		break;
 	case NL80211_AUTHTYPE_OPEN_SYSTEM:
-
+	
 		psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open;
 
 		if(psecuritypriv->ndisauthtype>Ndis802_11AuthModeWPA)
 			psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;
-
+		
 		break;
 	case NL80211_AUTHTYPE_SHARED_KEY:
 
@@ -2395,7 +2368,7 @@ static int rtw_cfg80211_set_auth_type(struct security_priv *psecuritypriv,
 
 
 		break;
-	default:
+	default:		
 		psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open;
 		//return -ENOTSUPP;
 	}
@@ -2419,7 +2392,7 @@ static int rtw_cfg80211_set_cipher(struct security_priv *psecuritypriv, u32 ciph
 		psecuritypriv->ndisencryptstatus = ndisencryptstatus;
 		return 0;
 	}
-
+	
 	switch (cipher) {
 	case IW_AUTH_CIPHER_NONE:
 		*profile_cipher = _NO_PRIVACY_;
@@ -2449,10 +2422,10 @@ static int rtw_cfg80211_set_cipher(struct security_priv *psecuritypriv, u32 ciph
 	if(ucast)
 	{
 		psecuritypriv->ndisencryptstatus = ndisencryptstatus;
-
+		
 		//if(psecuritypriv->dot11PrivacyAlgrthm >= _AES_)
 		//	psecuritypriv->ndisauthtype = Ndis802_11AuthModeWPA2PSK;
-	}
+	}	
 
 	return 0;
 }
@@ -2474,10 +2447,10 @@ static int rtw_cfg80211_set_key_mgt(struct security_priv *psecuritypriv, u32 key
 	return 0;
 }
 
-static int rtw_cfg80211_set_wpa_ie(_adapter *padapter, const u8 *pie, size_t ielen)
+static int rtw_cfg80211_set_wpa_ie(_adapter *padapter, u8 *pie, size_t ielen)
 {
-	u8 *buf=NULL, *pos=NULL;
-	u32 left;
+	u8 *buf=NULL, *pos=NULL;	
+	u32 left; 	
 	int group_cipher = 0, pairwise_cipher = 0;
 	int ret = 0;
 	int wpa_ielen=0;
@@ -2527,7 +2500,7 @@ static int rtw_cfg80211_set_wpa_ie(_adapter *padapter, const u8 *pie, size_t iel
 			padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_8021X;
 			padapter->securitypriv.ndisauthtype=Ndis802_11AuthModeWPAPSK;
 			_rtw_memcpy(padapter->securitypriv.supplicant_ie, &pwpa[0], wpa_ielen+2);
-
+			
 			DBG_8192C("got wpa_ie, wpa_ielen:%u\n", wpa_ielen);
 		}
 	}
@@ -2538,7 +2511,7 @@ static int rtw_cfg80211_set_wpa_ie(_adapter *padapter, const u8 *pie, size_t iel
 		if(rtw_parse_wpa2_ie(pwpa2, wpa2_ielen+2, &group_cipher, &pairwise_cipher) == _SUCCESS)
 		{
 			padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_8021X;
-			padapter->securitypriv.ndisauthtype=Ndis802_11AuthModeWPA2PSK;
+			padapter->securitypriv.ndisauthtype=Ndis802_11AuthModeWPA2PSK;	
 			_rtw_memcpy(padapter->securitypriv.supplicant_ie, &pwpa2[0], wpa2_ielen+2);
 
 			DBG_8192C("got wpa2_ie, wpa2_ielen:%u\n", wpa2_ielen);
@@ -2553,7 +2526,7 @@ static int rtw_cfg80211_set_wpa_ie(_adapter *padapter, const u8 *pie, size_t iel
 	{
 		pairwise_cipher = WPA_CIPHER_NONE;
 	}
-
+	
 	switch(group_cipher)
 	{
 		case WPA_CIPHER_NONE:
@@ -2572,7 +2545,7 @@ static int rtw_cfg80211_set_wpa_ie(_adapter *padapter, const u8 *pie, size_t iel
 			padapter->securitypriv.dot118021XGrpPrivacy=_AES_;
 			padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption3Enabled;
 			break;
-		case WPA_CIPHER_WEP104:
+		case WPA_CIPHER_WEP104:	
 			padapter->securitypriv.dot118021XGrpPrivacy=_WEP104_;
 			padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
 			break;
@@ -2596,14 +2569,14 @@ static int rtw_cfg80211_set_wpa_ie(_adapter *padapter, const u8 *pie, size_t iel
 			padapter->securitypriv.dot11PrivacyAlgrthm=_AES_;
 			padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption3Enabled;
 			break;
-		case WPA_CIPHER_WEP104:
+		case WPA_CIPHER_WEP104:	
 			padapter->securitypriv.dot11PrivacyAlgrthm=_WEP104_;
 			padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
 			break;
 	}
-
+	
 	{/* handle wps_ie */
-		uint wps_ielen;
+		uint wps_ielen;	
 		u8 *wps_ie;
 
 		wps_ie = rtw_get_wps_ie(buf, ielen, NULL, &wps_ielen);
@@ -2618,7 +2591,7 @@ static int rtw_cfg80211_set_wpa_ie(_adapter *padapter, const u8 *pie, size_t iel
 	}
 
 	#ifdef CONFIG_P2P
-	{//check p2p_ie for assoc req;
+	{//check p2p_ie for assoc req; 
 		uint p2p_ielen=0;
 		u8 *p2p_ie;
 		struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
@@ -2649,7 +2622,7 @@ static int rtw_cfg80211_set_wpa_ie(_adapter *padapter, const u8 *pie, size_t iel
 	#endif //CONFIG_P2P
 
 	#ifdef CONFIG_WFD
-	{//check wfd_ie for assoc req;
+	{//check wfd_ie for assoc req; 
 		uint wfd_ielen=0;
 		u8 *wfd_ie;
 		struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
@@ -2673,7 +2646,7 @@ static int rtw_cfg80211_set_wpa_ie(_adapter *padapter, const u8 *pie, size_t iel
 				DBG_8192C("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
 				goto exit;
 			}
-			rtw_get_wfd_ie(buf, ielen, pmlmepriv->wfd_assoc_req_ie, &pmlmepriv->wfd_assoc_req_ie_len);
+			rtw_get_wfd_ie(buf, ielen, pmlmepriv->wfd_assoc_req_ie, &pmlmepriv->wfd_assoc_req_ie_len);			
 		}
 	}
 	#endif //CONFIG_WFD
@@ -2702,21 +2675,21 @@ static int cfg80211_rtw_connect(struct wiphy *wiphy, struct net_device *ndev,
 				 struct cfg80211_connect_params *sme)
 {
 	int ret=0;
-	_irqL irqL;
-	_list *phead;
+	_irqL irqL;	
+	_list *phead;	
 	struct wlan_network *pnetwork = NULL;
-	NDIS_802_11_AUTHENTICATION_MODE authmode;
-	NDIS_802_11_SSID ndis_ssid;
+	NDIS_802_11_AUTHENTICATION_MODE authmode;	
+	NDIS_802_11_SSID ndis_ssid;	
 	u8 *dst_ssid, *src_ssid;
 	u8 *dst_bssid, *src_bssid;
 	//u8 matched_by_bssid=_FALSE;
 	//u8 matched_by_ssid=_FALSE;
 	u8 matched=_FALSE;
 	_adapter *padapter = wiphy_to_adapter(wiphy);
-	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;	
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
-	_queue *queue = &pmlmepriv->scanned_queue;
-
+	_queue *queue = &pmlmepriv->scanned_queue;	
+	
 	DBG_871X("=>"FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 	DBG_871X("privacy=%d, key=%p, key_len=%d, key_idx=%d\n",
 		sme->privacy, sme->key, sme->key_len, sme->key_idx);
@@ -2734,14 +2707,14 @@ static int cfg80211_rtw_connect(struct wiphy *wiphy, struct net_device *ndev,
 	if((wdev_to_priv(padapter->rtw_wdev))->bandroid_scan == _FALSE)
 	{
 #ifdef CONFIG_P2P
-		struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
+		struct wifidirect_info *pwdinfo= &(padapter->wdinfo);	
 		if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 #endif //CONFIG_P2P
 		{
 			ret = -EBUSY;
 			printk("Android hasn't attached yet!\n");
 			goto exit;
-		}
+		}	
 	}
 #endif
 
@@ -2777,13 +2750,13 @@ static int cfg80211_rtw_connect(struct wiphy *wiphy, struct net_device *ndev,
 		ret= -E2BIG;
 		goto exit;
 	}
-
-	_rtw_memset(&ndis_ssid, 0, sizeof(NDIS_802_11_SSID));
+	
+	_rtw_memset(&ndis_ssid, 0, sizeof(NDIS_802_11_SSID));			
 	ndis_ssid.SsidLength = sme->ssid_len;
 	_rtw_memcpy(ndis_ssid.Ssid, sme->ssid, sme->ssid_len);
 
 	DBG_8192C("ssid=%s, len=%zu\n", ndis_ssid.Ssid, sme->ssid_len);
-
+	
 
 	if (sme->bssid)
 		DBG_8192C("bssid="MAC_FMT"\n", MAC_ARG(sme->bssid));
@@ -2792,7 +2765,7 @@ static int cfg80211_rtw_connect(struct wiphy *wiphy, struct net_device *ndev,
 	if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == _TRUE) {
 		ret = -EBUSY;
 		DBG_8192C("%s, fw_state=0x%x, goto exit\n", __FUNCTION__, pmlmepriv->fw_state);
-		goto exit;
+		goto exit;		
 	}
 	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == _TRUE) {
 		rtw_scan_abort(padapter);
@@ -2814,12 +2787,12 @@ static int cfg80211_rtw_connect(struct wiphy *wiphy, struct net_device *ndev,
 		goto exit;
 
 	DBG_8192C("%s, ie_len=%zu\n", __func__, sme->ie_len);
-
+			
 	ret = rtw_cfg80211_set_wpa_ie(padapter, sme->ie, sme->ie_len);
 	if (ret < 0)
 		goto exit;
 
-	if (sme->crypto.n_ciphers_pairwise) {
+	if (sme->crypto.n_ciphers_pairwise) {		
 		ret = rtw_cfg80211_set_cipher(psecuritypriv, sme->crypto.ciphers_pairwise[0], _TRUE);
 		if (ret < 0)
 			goto exit;
@@ -2842,20 +2815,20 @@ static int cfg80211_rtw_connect(struct wiphy *wiphy, struct net_device *ndev,
 			goto exit;
 		}
 
-		if (wep_key_len > 0)
+		if (wep_key_len > 0) 
 		{
-			wep_key_len = wep_key_len <= 5 ? 5 : 13;
+		 	wep_key_len = wep_key_len <= 5 ? 5 : 13;
 			wep_total_len = wep_key_len + FIELD_OFFSET(NDIS_802_11_WEP, KeyMaterial);
-			pwep =(NDIS_802_11_WEP	 *) rtw_malloc(wep_total_len);
+		 	pwep =(NDIS_802_11_WEP	 *) rtw_malloc(wep_total_len);
 			if(pwep == NULL){
 				DBG_871X(" wpa_set_encryption: pwep allocate fail !!!\n");
 				ret = -ENOMEM;
 				goto exit;
 			}
 
-			_rtw_memset(pwep, 0, wep_total_len);
+		 	_rtw_memset(pwep, 0, wep_total_len);
 
-			pwep->KeyLength = wep_key_len;
+		 	pwep->KeyLength = wep_key_len;
 			pwep->Length = wep_total_len;
 
 			if(wep_key_len==13)
@@ -2864,7 +2837,7 @@ static int cfg80211_rtw_connect(struct wiphy *wiphy, struct net_device *ndev,
 				padapter->securitypriv.dot118021XGrpPrivacy=_WEP104_;
 			}
 		}
-		else {
+		else {		
 			ret = -EINVAL;
 			goto exit;
 		}
@@ -2880,7 +2853,7 @@ static int cfg80211_rtw_connect(struct wiphy *wiphy, struct net_device *ndev,
 		}
 
 		if (pwep) {
-			rtw_mfree((u8 *)pwep,wep_total_len);
+			rtw_mfree((u8 *)pwep,wep_total_len);		
 		}
 
 		if(ret < 0)
@@ -2908,11 +2881,11 @@ static int cfg80211_rtw_connect(struct wiphy *wiphy, struct net_device *ndev,
 	}
 
 	DBG_8192C("set ssid:dot11AuthAlgrthm=%d, dot11PrivacyAlgrthm=%d, dot118021XGrpPrivacy=%d\n", psecuritypriv->dot11AuthAlgrthm, psecuritypriv->dot11PrivacyAlgrthm, psecuritypriv->dot118021XGrpPrivacy);
-
+	
 exit:
 
 	DBG_8192C("<=%s, ret %d\n",__FUNCTION__, ret);
-
+	
 	return ret;
 }
 
@@ -2925,21 +2898,21 @@ static int cfg80211_rtw_disconnect(struct wiphy *wiphy, struct net_device *ndev,
 
 	rtw_set_roaming(padapter, 0);
 
-	if(check_fwstate(&padapter->mlmepriv, _FW_LINKED))
+	if(check_fwstate(&padapter->mlmepriv, _FW_LINKED)) 
 	{
 		rtw_scan_abort(padapter);
 		LeaveAllPowerSaveMode(padapter);
 		rtw_disassoc_cmd(padapter, 500, _FALSE);
-
+		
 		DBG_871X("%s...call rtw_indicate_disconnect\n", __FUNCTION__);
-
+		
 		padapter->mlmepriv.not_indic_disco = _TRUE;
 		rtw_indicate_disconnect(padapter);
 		padapter->mlmepriv.not_indic_disco = _FALSE;
-
+		
 		rtw_free_assoc_resources(padapter, 1);
 	}
-
+	
 	return 0;
 }
 
@@ -2994,7 +2967,7 @@ static int cfg80211_rtw_get_txpower(struct wiphy *wiphy,
 	DBG_8192C("%s\n", __func__);
 
 	*dbm = (12);
-
+	
 	return 0;
 }
 
@@ -3010,7 +2983,7 @@ static int cfg80211_rtw_set_power_mgmt(struct wiphy *wiphy,
 {
 	_adapter *padapter = wiphy_to_adapter(wiphy);
 	struct rtw_wdev_priv *rtw_wdev_priv = wdev_to_priv(padapter->rtw_wdev);
-
+	
 	DBG_871X(FUNC_NDEV_FMT" enabled:%u, timeout:%d\n", FUNC_NDEV_ARG(ndev),
 		enabled, timeout);
 
@@ -3041,7 +3014,7 @@ static int cfg80211_rtw_set_pmksa(struct wiphy *wiphy,
 	}
 
 	blInserted = _FALSE;
-
+	
 	//overwrite PMKID
 	for(index=0 ; index<NUM_PMKID_CACHE; index++)
 	{
@@ -3054,7 +3027,7 @@ static int cfg80211_rtw_set_pmksa(struct wiphy *wiphy,
 			psecuritypriv->PMKIDIndex = index+1;
 			blInserted = _TRUE;
 			break;
-		}
+		}	
 	}
 
 	if(!blInserted)
@@ -3071,8 +3044,8 @@ static int cfg80211_rtw_set_pmksa(struct wiphy *wiphy,
 		if(psecuritypriv->PMKIDIndex==16)
 		{
 			psecuritypriv->PMKIDIndex =0;
-		}
-	}
+		} 
+	} 
 
 	return 0;
 }
@@ -3090,13 +3063,13 @@ static int cfg80211_rtw_del_pmksa(struct wiphy *wiphy,
 	for(index=0 ; index<NUM_PMKID_CACHE; index++)
 	{
 		if( _rtw_memcmp( psecuritypriv->PMKIDList[index].Bssid, pmksa->bssid, ETH_ALEN) ==_TRUE )
-		{ // BSSID is matched, the same AP => Remove this PMKID information and reset it.
+		{ // BSSID is matched, the same AP => Remove this PMKID information and reset it. 
 			_rtw_memset( psecuritypriv->PMKIDList[index].Bssid, 0x00, ETH_ALEN );
 			_rtw_memset( psecuritypriv->PMKIDList[index].PMKID, 0x00, WLAN_PMKID_LEN );
 			psecuritypriv->PMKIDList[index].bUsed = _FALSE;
 			bMatched = _TRUE;
 			break;
-		}
+		}	
 	}
 
 	if(_FALSE == bMatched)
@@ -3129,7 +3102,7 @@ void rtw_cfg80211_indicate_sta_assoc(_adapter *padapter, u8 *pmgmt_frame, uint f
 	s32 freq;
 	int channel;
 	struct wireless_dev *pwdev = padapter->rtw_wdev;
-	struct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);	
 	struct net_device *ndev = padapter->pnetdev;
 
 	DBG_871X(FUNC_ADPT_FMT"\n", FUNC_ADPT_ARG(padapter));
@@ -3142,11 +3115,9 @@ void rtw_cfg80211_indicate_sta_assoc(_adapter *padapter, u8 *pmgmt_frame, uint f
 			ie_offset = _ASOCREQ_IE_OFFSET_;
 		else // WIFI_REASSOCREQ
 			ie_offset = _REASOCREQ_IE_OFFSET_;
-
+	
 		sinfo.filled = 0;
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0))
 		sinfo.filled = STATION_INFO_ASSOC_REQ_IES;
-#endif
 		sinfo.assoc_req_ies = pmgmt_frame + WLAN_HDR_A3_LEN + ie_offset;
 		sinfo.assoc_req_ies_len = frame_len - WLAN_HDR_A3_LEN - ie_offset;
 		cfg80211_new_sta(ndev, GetAddr2Ptr(pmgmt_frame), &sinfo, GFP_ATOMIC);
@@ -3154,9 +3125,9 @@ void rtw_cfg80211_indicate_sta_assoc(_adapter *padapter, u8 *pmgmt_frame, uint f
 #else /* defined(RTW_USE_CFG80211_STA_EVENT) */
 	channel = pmlmeext->cur_channel;
 	if (channel <= RTW_CH_MAX_2G_CHANNEL)
-		freq = rtw_ieee80211_channel_to_frequency(channel, NL80211_BAND_2GHZ);
+		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_2GHZ);
 	else
-		freq = rtw_ieee80211_channel_to_frequency(channel, NL80211_BAND_5GHZ);
+		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_5GHZ);
 
 	#ifdef COMPAT_KERNEL_RELEASE
 	rtw_cfg80211_rx_mgmt(padapter, freq, 0, pmgmt_frame, frame_len, GFP_ATOMIC);
@@ -3186,12 +3157,12 @@ void rtw_cfg80211_indicate_sta_disassoc(_adapter *padapter, unsigned char *da, u
 	u8 *pmgmt_frame;
 	uint frame_len;
 	struct rtw_ieee80211_hdr *pwlanhdr;
-	unsigned short *fctrl;
+	unsigned short *fctrl;	
 	u8 mgmt_buf[128] = {0};
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct net_device *ndev = padapter->pnetdev;
-
+	
 	DBG_871X(FUNC_ADPT_FMT"\n", FUNC_ADPT_ARG(padapter));
 
 #if defined(RTW_USE_CFG80211_STA_EVENT) || defined(COMPAT_KERNEL_RELEASE)
@@ -3199,11 +3170,11 @@ void rtw_cfg80211_indicate_sta_disassoc(_adapter *padapter, unsigned char *da, u
 #else /* defined(RTW_USE_CFG80211_STA_EVENT) */
 	channel = pmlmeext->cur_channel;
 	if (channel <= RTW_CH_MAX_2G_CHANNEL)
-		freq = rtw_ieee80211_channel_to_frequency(channel, NL80211_BAND_2GHZ);
+		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_2GHZ);
 	else
-		freq = rtw_ieee80211_channel_to_frequency(channel, NL80211_BAND_5GHZ);
+		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_5GHZ);
 
-	pmgmt_frame = mgmt_buf;
+	pmgmt_frame = mgmt_buf;	
 	pwlanhdr = (struct rtw_ieee80211_hdr *)pmgmt_frame;
 
 	fctrl = &(pwlanhdr->frame_ctl);
@@ -3212,7 +3183,7 @@ void rtw_cfg80211_indicate_sta_disassoc(_adapter *padapter, unsigned char *da, u
 	//_rtw_memcpy(pwlanhdr->addr1, da, ETH_ALEN);
 	//_rtw_memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);
 	_rtw_memcpy(pwlanhdr->addr1, myid(&(padapter->eeprompriv)), ETH_ALEN);
-	_rtw_memcpy(pwlanhdr->addr2, da, ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr2, da, ETH_ALEN);	
 	_rtw_memcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
 
 	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
@@ -3230,7 +3201,7 @@ void rtw_cfg80211_indicate_sta_disassoc(_adapter *padapter, unsigned char *da, u
 	#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) && !defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER)
 	rtw_cfg80211_rx_mgmt(padapter, freq, 0, mgmt_buf, frame_len, GFP_ATOMIC);
 	#else //COMPAT_KERNEL_RELEASE
-	cfg80211_send_disassoc(padapter->pnetdev, mgmt_buf, frame_len);
+	cfg80211_send_disassoc(padapter->pnetdev, mgmt_buf, frame_len);	
 	//cfg80211_rx_action(padapter->pnetdev, freq, mgmt_buf, frame_len, GFP_ATOMIC);
 	#endif //COMPAT_KERNEL_RELEASE
 #endif /* defined(RTW_USE_CFG80211_STA_EVENT) */
@@ -3241,7 +3212,7 @@ static int rtw_cfg80211_monitor_if_open(struct net_device *ndev)
 	int ret = 0;
 
 	DBG_8192C("%s\n", __func__);
-
+	
 	return ret;
 }
 
@@ -3250,12 +3221,12 @@ static int rtw_cfg80211_monitor_if_close(struct net_device *ndev)
 	int ret = 0;
 
 	DBG_8192C("%s\n", __func__);
-
+	
 	return ret;
 }
 
 static int rtw_cfg80211_monitor_if_xmit_entry(struct sk_buff *skb, struct net_device *ndev)
-{
+{	
 	int ret = 0;
 	int rtap_len;
 	int qos_len = 0;
@@ -3268,7 +3239,7 @@ static int rtw_cfg80211_monitor_if_xmit_entry(struct sk_buff *skb, struct net_de
 	struct ieee80211_hdr *dot11_hdr;
 	struct ieee80211_radiotap_header *rtap_hdr;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
-
+	
 	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
 	if (skb)
@@ -3289,7 +3260,7 @@ static int rtw_cfg80211_monitor_if_xmit_entry(struct sk_buff *skb, struct net_de
 	{
 		DBG_8192C("radiotap len (should be 14): %d\n", rtap_len);
 		goto fail;
-	}
+	}	
 
 	/* Skip the ratio tap header */
 	skb_pull(skb, rtap_len);
@@ -3319,7 +3290,7 @@ static int rtw_cfg80211_monitor_if_xmit_entry(struct sk_buff *skb, struct net_de
 
 		DBG_8192C("should be eapol packet\n");
 
-		/* Use the real net device to transmit the packet */
+		/* Use the real net device to transmit the packet */		
 		ret = _rtw_xmit_entry(skb, padapter->pnetdev);
 
 		return ret;
@@ -3327,15 +3298,15 @@ static int rtw_cfg80211_monitor_if_xmit_entry(struct sk_buff *skb, struct net_de
 	}
 	else if ((frame_ctl & (RTW_IEEE80211_FCTL_FTYPE|RTW_IEEE80211_FCTL_STYPE))
 		== (RTW_IEEE80211_FTYPE_MGMT|RTW_IEEE80211_STYPE_ACTION)
-	)
+	) 
 	{
 		//only for action frames
 		struct xmit_frame		*pmgntframe;
 		struct pkt_attrib	*pattrib;
-		unsigned char	*pframe;
+		unsigned char	*pframe;	
 		//u8 category, action, OUI_Subtype, dialogToken=0;
 		//unsigned char	*frame_body;
-		struct rtw_ieee80211_hdr *pwlanhdr;
+		struct rtw_ieee80211_hdr *pwlanhdr;	
 		struct xmit_priv	*pxmitpriv = &(padapter->xmitpriv);
 		struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 		u8 *buf = skb->data;
@@ -3348,7 +3319,7 @@ static int rtw_cfg80211_monitor_if_xmit_entry(struct sk_buff *skb, struct net_de
 				le16_to_cpu(((struct rtw_ieee80211_hdr_3addr *)buf)->frame_ctl));
 			goto fail;
 		}
-
+		
 		DBG_8192C("RTW_Tx:da="MAC_FMT" via "FUNC_NDEV_FMT"\n",
 			MAC_ARG(GetAddr1Ptr(buf)), FUNC_NDEV_ARG(ndev));
 		#ifdef CONFIG_P2P
@@ -3363,7 +3334,7 @@ static int rtw_cfg80211_monitor_if_xmit_entry(struct sk_buff *skb, struct net_de
 dump:
 		//starting alloc mgmt frame to dump it
 		if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
-		{
+		{			
 			goto fail;
 		}
 
@@ -3381,41 +3352,41 @@ static int rtw_cfg80211_monitor_if_xmit_entry(struct sk_buff *skb, struct net_de
 		if (type >= 0)
 		{
 			struct wifi_display_info		*pwfd_info;
-
+			
 			pwfd_info = padapter->wdinfo.wfd_info;
-
+			
 			if ( _TRUE == pwfd_info->wfd_enable )
 			{
 				rtw_append_wfd_ie( padapter, pframe, &len );
 			}
 		}
 		#endif // CONFIG_WFD
-		pattrib->pktlen = len;
-
+		pattrib->pktlen = len;	
+	
 		pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
 		//update seq number
 		pmlmeext->mgnt_seq = GetSequence(pwlanhdr);
 		pattrib->seqnum = pmlmeext->mgnt_seq;
 		pmlmeext->mgnt_seq++;
 
-
+	
 		pattrib->last_txcmdsz = pattrib->pktlen;
-
+	
 		dump_mgntframe(padapter, pmgntframe);
-
+		
 	}
 	else
 	{
 		DBG_8192C("frame_ctl=0x%x\n", frame_ctl & (RTW_IEEE80211_FCTL_FTYPE|RTW_IEEE80211_FCTL_STYPE));
 	}
 
-
+	
 fail:
-
+	
 	dev_kfree_skb(skb);
 
 	return 0;
-
+	
 }
 
 static void rtw_cfg80211_monitor_if_set_multicast_list(struct net_device *ndev)
@@ -3426,9 +3397,9 @@ static void rtw_cfg80211_monitor_if_set_multicast_list(struct net_device *ndev)
 static int rtw_cfg80211_monitor_if_set_mac_address(struct net_device *ndev, void *addr)
 {
 	int ret = 0;
-
+	
 	DBG_8192C("%s\n", __func__);
-
+	
 	return ret;
 }
 
@@ -3440,22 +3411,18 @@ static int rtw_cfg80211_monitor_if_set_mac_address(struct net_device *ndev, void
        #if (LINUX_VERSION_CODE < KERNEL_VERSION(3,2,0))
        .ndo_set_multicast_list = rtw_cfg80211_monitor_if_set_multicast_list,
        #endif
-       .ndo_set_mac_address = rtw_cfg80211_monitor_if_set_mac_address,
+       .ndo_set_mac_address = rtw_cfg80211_monitor_if_set_mac_address,       
 };
 #endif
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,1,0))
-static int rtw_cfg80211_add_monitor_if(_adapter *padapter, char *name, unsigned char name_assign_type, struct net_device **ndev)
-#else
 static int rtw_cfg80211_add_monitor_if(_adapter *padapter, char *name, struct net_device **ndev)
-#endif
 {
 	int ret = 0;
 	struct net_device* mon_ndev = NULL;
 	struct wireless_dev* mon_wdev = NULL;
 	struct rtw_netdev_priv_indicator *pnpi;
 	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(padapter->rtw_wdev);
-
+		
 	if (!name ) {
 		DBG_871X(FUNC_ADPT_FMT" without specific name\n", FUNC_ADPT_ARG(padapter));
 		ret = -EINVAL;
@@ -3479,12 +3446,8 @@ static int rtw_cfg80211_add_monitor_if(_adapter *padapter, char *name, struct ne
 	mon_ndev->type = ARPHRD_IEEE80211_RADIOTAP;
 	strncpy(mon_ndev->name, name, IFNAMSIZ);
 	mon_ndev->name[IFNAMSIZ - 1] = 0;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,1,0))
-	mon_ndev->name_assign_type = name_assign_type;
-#endif
-	mon_ndev->needs_free_netdev = true;
-	mon_ndev->priv_destructor = rtw_ndev_destructor;
-
+	mon_ndev->destructor = rtw_ndev_destructor;
+	
 #if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,29))
 	mon_ndev->netdev_ops = &rtw_cfg80211_monitor_if_ops;
 #else
@@ -3547,9 +3510,6 @@ static int rtw_cfg80211_add_monitor_if(_adapter *padapter, char *name, struct ne
 	#else
 		char *name,
 	#endif
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,1,0))
-		unsigned char name_assign_type,
-#endif
 	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0))
 		enum nl80211_iftype type, struct vif_params *params)
 	#else
@@ -3571,11 +3531,7 @@ static int rtw_cfg80211_add_monitor_if(_adapter *padapter, char *name, struct ne
 		ret = -ENODEV;
 		break;
 	case NL80211_IFTYPE_MONITOR:
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,1,0))
-		ret = rtw_cfg80211_add_monitor_if(padapter, (char *)name, name_assign_type, &ndev);
-#else
 		ret = rtw_cfg80211_add_monitor_if(padapter, (char *)name, &ndev);
-#endif
 		break;
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
@@ -3641,35 +3597,35 @@ static int rtw_add_beacon(_adapter *adapter, const u8 *head, size_t head_len, co
 {
 	int ret=0;
 	u8 *pbuf = NULL;
-	uint len, wps_ielen=0;
+	uint len, wps_ielen=0;	
 	uint p2p_ielen=0;
 	u8 *p2p_ie;
 	u8 got_p2p_ie = _FALSE;
 	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
 	//struct sta_priv *pstapriv = &padapter->stapriv;
-
+	
 
 	DBG_8192C("%s beacon_head_len=%zu, beacon_tail_len=%zu\n", __FUNCTION__, head_len, tail_len);
 
-
+	
 	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
 		return -EINVAL;
 
 	if(head_len<24)
 		return -EINVAL;
-
+	
 
 	pbuf = rtw_zmalloc(head_len+tail_len);
 	if(!pbuf)
 		return -ENOMEM;
-
+	
 
 	//_rtw_memcpy(&pstapriv->max_num_sta, param->u.bcn_ie.reserved, 2);
 
 	//if((pstapriv->max_num_sta>NUM_STA) || (pstapriv->max_num_sta<=0))
 	//	pstapriv->max_num_sta = NUM_STA;
 
-
+	
 	_rtw_memcpy(pbuf, (void *)head+24, head_len-24);// 24=beacon header len.
 	_rtw_memcpy(pbuf+head_len-24, (void *)tail, tail_len);
 
@@ -3691,9 +3647,9 @@ static int rtw_add_beacon(_adapter *adapter, const u8 *head, size_t head_len, co
 
 			DBG_8192C("got p2p_ie, len=%d\n", p2p_ielen);
 			got_p2p_ie = _TRUE;
-
+		
 			if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
-			{
+			{			
 				DBG_8192C("Enable P2P function for the first time\n");
 				rtw_p2p_enable(adapter, P2P_ROLE_GO);
 				wdev_to_priv(adapter->rtw_wdev)->p2p_enabled = _TRUE;
@@ -3702,13 +3658,13 @@ static int rtw_add_beacon(_adapter *adapter, const u8 *head, size_t head_len, co
 			{
 				_cancel_timer_ex( &pwdinfo->find_phase_timer );
 				_cancel_timer_ex( &pwdinfo->restore_p2p_state_timer );
-				_cancel_timer_ex( &pwdinfo->pre_tx_scan_timer);
+				_cancel_timer_ex( &pwdinfo->pre_tx_scan_timer);	
 
-				DBG_8192C("enter GO Mode, p2p_ielen=%d\n", p2p_ielen);
+				DBG_8192C("enter GO Mode, p2p_ielen=%d\n", p2p_ielen);			
 
 				rtw_p2p_set_role(pwdinfo, P2P_ROLE_GO);
 				rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_OK);
-				pwdinfo->intent = 15;
+				pwdinfo->intent = 15;		
 			}
 		}
 	}
@@ -3720,7 +3676,7 @@ static int rtw_add_beacon(_adapter *adapter, const u8 *head, size_t head_len, co
 
 	if (rtw_check_beacon_data(adapter, pbuf,  len) == _SUCCESS)
 	{
-#ifdef  CONFIG_P2P
+#ifdef  CONFIG_P2P		
 		//check p2p if enable
 		if(got_p2p_ie == _TRUE)
 		{
@@ -3730,16 +3686,16 @@ static int rtw_add_beacon(_adapter *adapter, const u8 *head, size_t head_len, co
 		}
 #endif //CONFIG_P2P
 		ret = 0;
-	}
+	}	
 	else
 	{
 		ret = -EINVAL;
-	}
-
+	}	
+	
 
-	rtw_mfree(pbuf, head_len+tail_len);
-
-	return ret;
+	rtw_mfree(pbuf, head_len+tail_len);	
+	
+	return ret;	
 }
 
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0)) && !defined(COMPAT_KERNEL_RELEASE)
@@ -3758,22 +3714,22 @@ static int	cfg80211_rtw_add_beacon(struct wiphy *wiphy, struct net_device *ndev,
 static int	cfg80211_rtw_set_beacon(struct wiphy *wiphy, struct net_device *ndev,
 			      struct beacon_parameters *info)
 {
-	_adapter *padapter = wiphy_to_adapter(wiphy);
+	_adapter *padapter = wiphy_to_adapter(wiphy);	
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
-
+	
 	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
 	pmlmeext->bstart_bss = _TRUE;
 
 	cfg80211_rtw_add_beacon(wiphy, ndev, info);
-
+	
 	return 0;
 }
 
 static int	cfg80211_rtw_del_beacon(struct wiphy *wiphy, struct net_device *ndev)
 {
 	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
-
+	
 	return 0;
 }
 #else
@@ -3782,7 +3738,7 @@ static int cfg80211_rtw_start_ap(struct wiphy *wiphy, struct net_device *ndev,
 {
 	int ret = 0;
 	_adapter *adapter = wiphy_to_adapter(wiphy);
-
+	
 	DBG_871X(FUNC_NDEV_FMT" hidden_ssid:%d, auth_type:%d\n", FUNC_NDEV_ARG(ndev),
 		settings->hidden_ssid, settings->auth_type);
 
@@ -3790,7 +3746,7 @@ static int cfg80211_rtw_start_ap(struct wiphy *wiphy, struct net_device *ndev,
 		settings->beacon.tail, settings->beacon.tail_len);
 
 	adapter->mlmeextpriv.mlmext_info.hidden_ssid_mode = settings->hidden_ssid;
-
+	
 	if (settings->ssid && settings->ssid_len) {
 		WLAN_BSSID_EX *pbss_network = &adapter->mlmepriv.cur_network.network;
 		WLAN_BSSID_EX *pbss_network_ext = &adapter->mlmeextpriv.mlmext_info.network;
@@ -3836,27 +3792,20 @@ static int cfg80211_rtw_stop_ap(struct wiphy *wiphy, struct net_device *ndev)
 #endif //(LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0))
 
 static int	cfg80211_rtw_add_station(struct wiphy *wiphy, struct net_device *ndev,
-			       const u8 *mac, struct station_parameters *params)
+			       u8 *mac, struct station_parameters *params)
 {
 	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
-
+	
 	return 0;
 }
 
 static int	cfg80211_rtw_del_station(struct wiphy *wiphy, struct net_device *ndev,
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,15,0))
-			       u8 *mac) {
-#elif (LINUX_VERSION_CODE < KERNEL_VERSION(4,1,0))
-                   const u8 *mac) {
-#else
-                   struct station_del_parameters *params)
+			       u8 *mac)
 {
-    const u8 *mac = params->mac;
-#endif
-	int ret=0;
+	int ret=0;	
 	_irqL irqL;
 	_list	*phead, *plist;
-	u8 updated = _FALSE;
+	u8 updated;
 	struct sta_info *psta = NULL;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
@@ -3864,10 +3813,10 @@ static int	cfg80211_rtw_del_station(struct wiphy *wiphy, struct net_device *ndev
 
 	DBG_871X("+"FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 
-	if(check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != _TRUE)
+	if(check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != _TRUE)		
 	{
 		DBG_8192C("%s, fw_state != FW_LINKED|WIFI_AP_STATE\n", __func__);
-		return -EINVAL;
+		return -EINVAL;		
 	}
 
 
@@ -3878,34 +3827,34 @@ static int	cfg80211_rtw_del_station(struct wiphy *wiphy, struct net_device *ndev
 		flush_all_cam_entry(padapter);	//clear CAM
 
 		ret = rtw_sta_flush(padapter);
-
+		
 		return ret;
-	}
+	}	
 
 
 	DBG_8192C("free sta macaddr =" MAC_FMT "\n", MAC_ARG(mac));
 
 	if (mac[0] == 0xff && mac[1] == 0xff &&
 	    mac[2] == 0xff && mac[3] == 0xff &&
-	    mac[4] == 0xff && mac[5] == 0xff)
+	    mac[4] == 0xff && mac[5] == 0xff) 
 	{
-		return -EINVAL;
+		return -EINVAL;	
 	}
 
 
 	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
-
+	
 	phead = &pstapriv->asoc_list;
 	plist = get_next(phead);
 
 	//check asoc_queue
-	while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
+	while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)	
 	{
 		psta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);
-
-		plist = get_next(plist);
-
-		if(_rtw_memcmp(mac, psta->hwaddr, ETH_ALEN))
+		
+		plist = get_next(plist);	
+	
+		if(_rtw_memcmp(mac, psta->hwaddr, ETH_ALEN))		
 		{
 			if(psta->dot8021xalg == 1 && psta->bpairwise_key_installed == _FALSE)
 			{
@@ -3925,10 +3874,10 @@ static int	cfg80211_rtw_del_station(struct wiphy *wiphy, struct net_device *ndev
 				psta = NULL;
 
 				break;
-			}
-
+			}		
+					
 		}
-
+		
 	}
 
 	_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
@@ -3936,16 +3885,16 @@ static int	cfg80211_rtw_del_station(struct wiphy *wiphy, struct net_device *ndev
 	associated_clients_update(padapter, updated);
 
 	DBG_871X("-"FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
-
-	return ret;
+	
+	return ret;	
 
 }
 
 static int	cfg80211_rtw_change_station(struct wiphy *wiphy, struct net_device *ndev,
-				  const u8 *mac, struct station_parameters *params)
+				  u8 *mac, struct station_parameters *params)
 {
 	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
-
+	
 	return 0;
 }
 
@@ -3973,13 +3922,13 @@ static int	cfg80211_rtw_change_bss(struct wiphy *wiphy, struct net_device *ndev,
 
 	DBG_8192C("basic_rates_len=%d\n", params->basic_rates_len);
 	for(i=0; i<params->basic_rates_len; i++)
-	{
+	{		
 		DBG_8192C("basic_rates=%d\n", params->basic_rates[i]);
-
-	}
-*/
+		
+	}	
+*/	
 	return 0;
-
+	
 }
 
 static int	cfg80211_rtw_set_channel(struct wiphy *wiphy
@@ -3991,7 +3940,7 @@ static int	cfg80211_rtw_set_channel(struct wiphy *wiphy
 	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
 	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
 	#endif
-
+	
 	return 0;
 }
 
@@ -3999,7 +3948,7 @@ static int	cfg80211_rtw_auth(struct wiphy *wiphy, struct net_device *ndev,
 			struct cfg80211_auth_request *req)
 {
 	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
-
+	
 	return 0;
 }
 
@@ -4007,7 +3956,7 @@ static int	cfg80211_rtw_assoc(struct wiphy *wiphy, struct net_device *ndev,
 			 struct cfg80211_assoc_request *req)
 {
 	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
-
+	
 	return 0;
 }
 #endif //CONFIG_AP_MODE
@@ -4033,9 +3982,9 @@ void rtw_cfg80211_rx_action_p2p(_adapter *padapter, u8 *pmgmt_frame, uint frame_
 
 indicate:
 	if (channel <= RTW_CH_MAX_2G_CHANNEL)
-		freq = rtw_ieee80211_channel_to_frequency(channel, NL80211_BAND_2GHZ);
+		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_2GHZ);
 	else
-		freq = rtw_ieee80211_channel_to_frequency(channel, NL80211_BAND_5GHZ);
+		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_5GHZ);
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
 	rtw_cfg80211_rx_mgmt(padapter, freq, 0, pmgmt_frame, frame_len, GFP_ATOMIC);
@@ -4073,9 +4022,9 @@ void rtw_cfg80211_rx_p2p_action_public(_adapter *padapter, u8 *pmgmt_frame, uint
 
 indicate:
 	if (channel <= RTW_CH_MAX_2G_CHANNEL)
-		freq = rtw_ieee80211_channel_to_frequency(channel, NL80211_BAND_2GHZ);
+		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_2GHZ);
 	else
-		freq = rtw_ieee80211_channel_to_frequency(channel, NL80211_BAND_5GHZ);
+		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_5GHZ);
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
 	rtw_cfg80211_rx_mgmt(padapter, freq, 0, pmgmt_frame, frame_len, GFP_ATOMIC);
@@ -4088,7 +4037,7 @@ void rtw_cfg80211_rx_action(_adapter *adapter, u8 *frame, uint frame_len, const
 {
 	s32 freq;
 	int channel;
-	struct mlme_ext_priv *pmlmeext = &(adapter->mlmeextpriv);
+	struct mlme_ext_priv *pmlmeext = &(adapter->mlmeextpriv);	
 	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(adapter->rtw_wdev);
 	u8 category, action;
 
@@ -4103,9 +4052,9 @@ void rtw_cfg80211_rx_action(_adapter *adapter, u8 *frame, uint frame_len, const
 		DBG_871X("RTW_Rx:category(%u), action(%u)\n", category, action);
 
 	if (channel <= RTW_CH_MAX_2G_CHANNEL)
-		freq = rtw_ieee80211_channel_to_frequency(channel, NL80211_BAND_2GHZ);
+		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_2GHZ);
 	else
-		freq = rtw_ieee80211_channel_to_frequency(channel, NL80211_BAND_5GHZ);
+		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_5GHZ);
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
 	rtw_cfg80211_rx_mgmt(adapter, freq, 0, frame, frame_len, GFP_ATOMIC);
@@ -4127,17 +4076,17 @@ void rtw_cfg80211_issue_p2p_provision_request(_adapter *padapter, const u8 *buf,
 	u8	devinfo_content[64] = { 0x00 };
 	u16	capability = 0;
 	uint capability_len = 0;
-
+	
 	unsigned char category = RTW_WLAN_CATEGORY_PUBLIC;
 	u8			action = P2P_PUB_ACTION_ACTION;
 	u8			dialogToken = 1;
 	u32			p2poui = cpu_to_be32(P2POUI);
-	u8			oui_subtype = P2P_PROVISION_DISC_REQ;
+	u8			oui_subtype = P2P_PROVISION_DISC_REQ;	
 	u32			p2pielen = 0;
 #ifdef CONFIG_WFD
 	u32					wfdielen = 0;
-#endif //CONFIG_WFD
-
+#endif //CONFIG_WFD		
+	
 	struct xmit_frame			*pmgntframe;
 	struct pkt_attrib			*pattrib;
 	unsigned char					*pframe;
@@ -4146,7 +4095,7 @@ void rtw_cfg80211_issue_p2p_provision_request(_adapter *padapter, const u8 *buf,
 	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-
+	
 	struct wifidirect_info *pwdinfo = &(padapter->wdinfo);
 	u8 *frame_body = (unsigned char *)(buf + sizeof(struct rtw_ieee80211_hdr_3addr));
 	size_t frame_body_len = len - sizeof(struct rtw_ieee80211_hdr_3addr);
@@ -4154,17 +4103,17 @@ void rtw_cfg80211_issue_p2p_provision_request(_adapter *padapter, const u8 *buf,
 
 	DBG_871X( "[%s] In\n", __FUNCTION__ );
 
-	//prepare for building provision_request frame
+	//prepare for building provision_request frame	
 	_rtw_memcpy(pwdinfo->tx_prov_disc_info.peerIFAddr, GetAddr1Ptr(buf), ETH_ALEN);
 	_rtw_memcpy(pwdinfo->tx_prov_disc_info.peerDevAddr, GetAddr1Ptr(buf), ETH_ALEN);
-
+	
 	pwdinfo->tx_prov_disc_info.wps_config_method_request = WPS_CM_PUSH_BUTTON;
-
+		
 	rtw_get_wps_ie( frame_body + _PUBLIC_ACTION_IE_OFFSET_, frame_body_len - _PUBLIC_ACTION_IE_OFFSET_, wpsie, &wpsielen);
 	rtw_get_wps_attr_content( wpsie, wpsielen, WPS_ATTR_DEVICE_PWID, (u8*) &wps_devicepassword_id, &wps_devicepassword_id_len);
 	wps_devicepassword_id = be16_to_cpu( wps_devicepassword_id );
 
-	switch(wps_devicepassword_id)
+	switch(wps_devicepassword_id) 
 	{
 		case WPS_DPID_PIN:
 			pwdinfo->tx_prov_disc_info.wps_config_method_request = WPS_CM_LABEL;
@@ -4188,25 +4137,25 @@ void rtw_cfg80211_issue_p2p_provision_request(_adapter *padapter, const u8 *buf,
 
 
 	if ( rtw_get_p2p_ie( frame_body + _PUBLIC_ACTION_IE_OFFSET_, frame_body_len - _PUBLIC_ACTION_IE_OFFSET_, p2p_ie, &p2p_ielen ) )
-	{
+	{	
 
-		rtw_get_p2p_attr_content( p2p_ie, p2p_ielen, P2P_ATTR_DEVICE_INFO, devinfo_content, &devinfo_contentlen);
+		rtw_get_p2p_attr_content( p2p_ie, p2p_ielen, P2P_ATTR_DEVICE_INFO, devinfo_content, &devinfo_contentlen);					
 		rtw_get_p2p_attr_content( p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8*)&capability, &capability_len);
-
+						
 	}
 
 
-	//start to build provision_request frame
+	//start to build provision_request frame	
 	_rtw_memset(wpsie, 0, sizeof(wpsie));
 	_rtw_memset(p2p_ie, 0, sizeof(p2p_ie));
-	p2p_ielen = 0;
-
+	p2p_ielen = 0;	
+	
 	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
 	{
 		return;
 	}
 
-
+	
 	//update attribute
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
@@ -4220,7 +4169,7 @@ void rtw_cfg80211_issue_p2p_provision_request(_adapter *padapter, const u8 *buf,
 	*(fctrl) = 0;
 
 	_rtw_memcpy(pwlanhdr->addr1, pwdinfo->tx_prov_disc_info.peerDevAddr, ETH_ALEN);
-	_rtw_memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);
+	_rtw_memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);	
 	_rtw_memcpy(pwlanhdr->addr3, pwdinfo->tx_prov_disc_info.peerDevAddr, ETH_ALEN);
 
 	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
@@ -4233,11 +4182,11 @@ void rtw_cfg80211_issue_p2p_provision_request(_adapter *padapter, const u8 *buf,
 	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 4, (unsigned char *) &(p2poui), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));
-	pframe = rtw_set_fixed_ie(pframe, 1, &(dialogToken), &(pattrib->pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));	
+	pframe = rtw_set_fixed_ie(pframe, 1, &(dialogToken), &(pattrib->pktlen));		
 
 
-	//build_prov_disc_request_p2p_ie
+	//build_prov_disc_request_p2p_ie	
 	//	P2P OUI
 	p2pielen = 0;
 	p2p_ie[ p2pielen++ ] = 0x50;
@@ -4252,7 +4201,7 @@ void rtw_cfg80211_issue_p2p_provision_request(_adapter *padapter, const u8 *buf,
 	//	3. Group ID ( When joining an operating P2P Group )
 
 	//	P2P Capability ATTR
-	//	Type:
+	//	Type:	
 	p2p_ie[ p2pielen++ ] = P2P_ATTR_CAPABILITY;
 
 	//	Length:
@@ -4265,14 +4214,14 @@ void rtw_cfg80211_issue_p2p_provision_request(_adapter *padapter, const u8 *buf,
 	//	Group Capability Bitmap, 1 byte
 	_rtw_memcpy(p2p_ie + p2pielen, &capability, 2);
 	p2pielen += 2;
-
+	
 
 	//	Device Info ATTR
 	//	Type:
 	p2p_ie[ p2pielen++ ] = P2P_ATTR_DEVICE_INFO;
 
 	//	Length:
-	//	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes)
+	//	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) 
 	//	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes)
 	//*(u16*) ( p2pie + p2pielen ) = cpu_to_le16( 21 + pwdinfo->device_name_len );
 	RTW_PUT_LE16(p2p_ie + p2pielen, devinfo_contentlen);
@@ -4283,7 +4232,7 @@ void rtw_cfg80211_issue_p2p_provision_request(_adapter *padapter, const u8 *buf,
 	p2pielen += devinfo_contentlen;
 
 
-	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2p_ie, &p2p_ielen);
+	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2p_ie, &p2p_ielen);			
 	//p2pielen = build_prov_disc_request_p2p_ie( pwdinfo, pframe, NULL, 0, pwdinfo->tx_prov_disc_info.peerDevAddr);
 	//pframe += p2pielen;
 	pattrib->pktlen += p2p_ielen;
@@ -4337,7 +4286,7 @@ void rtw_cfg80211_issue_p2p_provision_request(_adapter *padapter, const u8 *buf,
 	//{
 	//	DBG_8192C("waiting for p2p peer key-in PIN CODE\n");
 	//	rtw_msleep_os(15000); // 15 sec for key in PIN CODE, workaround for GS2 before issuing Nego Req.
-	//}
+	//}	
 
 }
 
@@ -4367,12 +4316,12 @@ static s32 cfg80211_rtw_remain_on_channel(struct wiphy *wiphy,
 	if(pcfg80211_wdinfo->is_ro_ch == _TRUE)
 	{
 		DBG_8192C("%s, cancel ro ch timer\n", __func__);
-
+		
 		_cancel_timer_ex(&padapter->cfg80211_wdinfo.remain_on_ch_timer);
 
 #ifdef CONFIG_CONCURRENT_MODE
-                ATOMIC_SET(&pwdev_priv->ro_ch_to, 1);
-#endif //CONFIG_CONCURRENT_MODE
+                ATOMIC_SET(&pwdev_priv->ro_ch_to, 1);			
+#endif //CONFIG_CONCURRENT_MODE	
 
 		p2p_protocol_wk_hdl(padapter, P2P_RO_CH_WK);
 	}
@@ -4391,9 +4340,9 @@ static s32 cfg80211_rtw_remain_on_channel(struct wiphy *wiphy,
 	pcfg80211_wdinfo->remain_on_ch_cookie= *cookie;
 
 	rtw_scan_abort(padapter);
-#ifdef CONFIG_CONCURRENT_MODE
-	if(rtw_buddy_adapter_up(padapter))
-		rtw_scan_abort(padapter->pbuddy_adapter);
+#ifdef CONFIG_CONCURRENT_MODE		
+	if(rtw_buddy_adapter_up(padapter))	
+		rtw_scan_abort(padapter->pbuddy_adapter);			
 #endif //CONFIG_CONCURRENT_MODE
 
 	//if(!rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT) && !rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
@@ -4405,22 +4354,22 @@ static s32 cfg80211_rtw_remain_on_channel(struct wiphy *wiphy,
 	else
 	{
 		rtw_p2p_set_pre_state(pwdinfo, rtw_p2p_state(pwdinfo));
-#ifdef CONFIG_DEBUG_CFG80211
+#ifdef CONFIG_DEBUG_CFG80211		
 		DBG_8192C("%s, role=%d, p2p_state=%d\n", __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo));
 #endif
 	}
 
 
 	rtw_p2p_set_state(pwdinfo, P2P_STATE_LISTEN);
-
-
+	
+	
 	if(duration < 400)
 		duration = duration*3;//extend from exper.
 
 
 #ifdef	CONFIG_CONCURRENT_MODE
 	if(check_buddy_fwstate(padapter, _FW_LINKED) &&
-		(duration<pwdinfo->ext_listen_interval))
+		(duration<pwdinfo->ext_listen_interval)) 
 	{
 		duration = duration + 	pwdinfo->ext_listen_interval;
 	}
@@ -4432,42 +4381,42 @@ static s32 cfg80211_rtw_remain_on_channel(struct wiphy *wiphy,
 #ifdef	CONFIG_CONCURRENT_MODE
 		if ( check_buddy_fwstate(padapter, _FW_LINKED ) )
 		{
-			PADAPTER pbuddy_adapter = padapter->pbuddy_adapter;
-			struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
+			PADAPTER pbuddy_adapter = padapter->pbuddy_adapter;			
+			struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;	
 
 			if(remain_ch != pbuddy_mlmeext->cur_channel)
-			{
+			{	
 				if(ATOMIC_READ(&pwdev_priv->switch_ch_to)==1 ||
 					(remain_ch != pmlmeext->cur_channel))
 				{
-					DBG_8192C("%s, issue nulldata pwrbit=1\n", __func__);
+					DBG_8192C("%s, issue nulldata pwrbit=1\n", __func__);		
 					issue_nulldata(padapter->pbuddy_adapter, NULL, 1, 3, 500);
-
+				
 					ATOMIC_SET(&pwdev_priv->switch_ch_to, 0);
-
+			
 					DBG_8192C("%s, set switch ch timer, duration=%d\n", __func__, duration-pwdinfo->ext_listen_interval);
-					_set_timer(&pwdinfo->ap_p2p_switch_timer, duration-pwdinfo->ext_listen_interval);
-				}
+					_set_timer(&pwdinfo->ap_p2p_switch_timer, duration-pwdinfo->ext_listen_interval);	
+				}			
 			}
-
+		
 			ready_on_channel = _TRUE;
-			//pmlmeext->cur_channel = remain_ch;
+			//pmlmeext->cur_channel = remain_ch;			
 			//set_channel_bwmode(padapter, remain_ch, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
-		}else
+		}else 
 #endif //CONFIG_CONCURRENT_MODE
 		if(remain_ch != pmlmeext->cur_channel )
 		{
 			ready_on_channel = _TRUE;
-			//pmlmeext->cur_channel = remain_ch;
+			//pmlmeext->cur_channel = remain_ch;			
 			//set_channel_bwmode(padapter, remain_ch, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 		}
 	} else {
 		DBG_871X("%s remain_ch:%u not in channel plan!!!!\n", __FUNCTION__, remain_ch);
 	}
-
+	
 
 	//call this after other things have been done
-#ifdef	CONFIG_CONCURRENT_MODE
+#ifdef	CONFIG_CONCURRENT_MODE	
 	if(ATOMIC_READ(&pwdev_priv->ro_ch_to)==1 ||
 		(remain_ch != pmlmeext->cur_channel))
 	{
@@ -4476,10 +4425,10 @@ static s32 cfg80211_rtw_remain_on_channel(struct wiphy *wiphy,
 #endif
 
 		if(ready_on_channel == _TRUE)
-		{
+		{			
 			if ( !check_fwstate(&padapter->mlmepriv, _FW_LINKED ) )
 				pmlmeext->cur_channel = remain_ch;
-
+			
 #ifdef	CONFIG_CONCURRENT_MODE
 			co_channel = rtw_get_oper_ch(padapter);
 
@@ -4487,7 +4436,7 @@ static s32 cfg80211_rtw_remain_on_channel(struct wiphy *wiphy,
 #endif
 			{
 				if (!padapter->mlmepriv.LinkDetectInfo.bBusyTraffic)
-					set_channel_bwmode(padapter, remain_ch, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
+					set_channel_bwmode(padapter, remain_ch, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);			
 			}
 		}
 		DBG_8192C("%s, set ro ch timer, duration=%d\n", __func__, duration);
@@ -4541,7 +4490,7 @@ static s32 cfg80211_rtw_cancel_remain_on_channel(struct wiphy *wiphy,
 			_cancel_timer_ex( &pwdinfo->find_phase_timer );
 			_cancel_timer_ex( &pwdinfo->restore_p2p_state_timer );
 			_cancel_timer_ex( &pwdinfo->pre_tx_scan_timer);
-
+			
 			rtw_p2p_set_state(pwdinfo, P2P_STATE_NONE);
 			_rtw_memset(pwdinfo, 0x00, sizeof(struct wifidirect_info));
 		}
@@ -4550,7 +4499,7 @@ static s32 cfg80211_rtw_cancel_remain_on_channel(struct wiphy *wiphy,
 	#endif
 	{
 		 rtw_p2p_set_state(pwdinfo, rtw_p2p_pre_state(pwdinfo));
-#ifdef CONFIG_DEBUG_CFG80211
+#ifdef CONFIG_DEBUG_CFG80211		 
 		 DBG_8192C("%s, role=%d, p2p_state=%d\n", __func__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo));
 #endif
 	}
@@ -4571,7 +4520,7 @@ static int _cfg80211_rtw_mgmt_tx(_adapter *padapter, u8 tx_ch, const u8 *buf, si
 	struct rtw_ieee80211_hdr *pwlanhdr;
 	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(padapter->rtw_wdev);
 	struct xmit_priv	*pxmitpriv = &(padapter->xmitpriv);
-	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);	
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct wifidirect_info *pwdinfo = &padapter->wdinfo;
 	//struct cfg80211_wifidirect_info *pcfg80211_wdinfo = &padapter->cfg80211_wdinfo;
@@ -4584,8 +4533,8 @@ static int _cfg80211_rtw_mgmt_tx(_adapter *padapter, u8 tx_ch, const u8 *buf, si
 	rtw_set_scan_deny(padapter, 1000);
 
 	rtw_scan_abort(padapter);
-	#ifdef CONFIG_CONCURRENT_MODE
-	if(rtw_buddy_adapter_up(padapter))
+	#ifdef CONFIG_CONCURRENT_MODE		
+	if(rtw_buddy_adapter_up(padapter))	
 		rtw_scan_abort(padapter->pbuddy_adapter);
 	#endif /* CONFIG_CONCURRENT_MODE */
 
@@ -4593,20 +4542,20 @@ static int _cfg80211_rtw_mgmt_tx(_adapter *padapter, u8 tx_ch, const u8 *buf, si
 		//DBG_8192C("%s, cancel ro ch timer\n", __func__);
 		//_cancel_timer_ex(&padapter->cfg80211_wdinfo.remain_on_ch_timer);
 		//padapter->cfg80211_wdinfo.is_ro_ch = _FALSE;
-		#ifdef CONFIG_CONCURRENT_MODE
+		#ifdef CONFIG_CONCURRENT_MODE			
 		if (!check_fwstate(&padapter->mlmepriv, _FW_LINKED ))
 		{
 			DBG_8192C("%s, extend ro ch time\n", __func__);
 			_set_timer( &padapter->cfg80211_wdinfo.remain_on_ch_timer, pwdinfo->ext_listen_period);
-		}
-		#endif //CONFIG_CONCURRENT_MODE
+		}	
+		#endif //CONFIG_CONCURRENT_MODE			
 	}
 
 #ifdef CONFIG_CONCURRENT_MODE
 	if (check_buddy_fwstate(padapter, _FW_LINKED )) {
 		u8 co_channel=0xff;
-		PADAPTER pbuddy_adapter = padapter->pbuddy_adapter;
-		struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
+		PADAPTER pbuddy_adapter = padapter->pbuddy_adapter;			
+		struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;	
 
 		co_channel = rtw_get_oper_ch(padapter);
 
@@ -4627,15 +4576,15 @@ static int _cfg80211_rtw_mgmt_tx(_adapter *padapter, u8 tx_ch, const u8 *buf, si
 			if (check_fwstate(&padapter->mlmepriv, _FW_LINKED ))
 			{
 				ext_listen_period = 500;// 500ms
-			}
+			}	
 			else
-			{
+			{				
 				ext_listen_period = pwdinfo->ext_listen_period;
 			}
 
 			DBG_8192C("%s, set switch ch timer, period=%d\n", __func__, ext_listen_period);
-			_set_timer(&pwdinfo->ap_p2p_switch_timer, ext_listen_period);
-
+			_set_timer(&pwdinfo->ap_p2p_switch_timer, ext_listen_period);	
+			
 		}
 
 		if (!check_fwstate(&padapter->mlmepriv, _FW_LINKED ))
@@ -4643,7 +4592,7 @@ static int _cfg80211_rtw_mgmt_tx(_adapter *padapter, u8 tx_ch, const u8 *buf, si
 
 		if (tx_ch != co_channel)
 			set_channel_bwmode(padapter, tx_ch, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
-	}else
+	}else 
 #endif //CONFIG_CONCURRENT_MODE
 	//if (tx_ch != pmlmeext->cur_channel) {
 	if(tx_ch != rtw_get_oper_ch(padapter)) {
@@ -4670,8 +4619,8 @@ static int _cfg80211_rtw_mgmt_tx(_adapter *padapter, u8 tx_ch, const u8 *buf, si
 	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
 
 	_rtw_memcpy(pframe, (void*)buf, len);
-	pattrib->pktlen = len;
-
+	pattrib->pktlen = len;	
+	
 	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
 	//update seq number
 	pmlmeext->mgnt_seq = GetSequence(pwlanhdr);
@@ -4681,19 +4630,19 @@ static int _cfg80211_rtw_mgmt_tx(_adapter *padapter, u8 tx_ch, const u8 *buf, si
 #ifdef CONFIG_WFD
 	{
 		struct wifi_display_info	*pwfd_info;
-
+			
 		pwfd_info = padapter->wdinfo.wfd_info;
-
+			
 		if ( _TRUE == pwfd_info->wfd_enable )
 		{
 			rtw_append_wfd_ie( padapter, pframe, &pattrib->pktlen );
 		}
 	}
 #endif // CONFIG_WFD
-
+	
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
-	if (dump_mgntframe_and_wait_ack(padapter, pmgntframe) != _SUCCESS)
+	if (dump_mgntframe_and_wait_ack(padapter, pmgntframe) != _SUCCESS) 
 	{
 		ack = _FALSE;
 		ret = _FAIL;
@@ -4702,22 +4651,22 @@ static int _cfg80211_rtw_mgmt_tx(_adapter *padapter, u8 tx_ch, const u8 *buf, si
 		DBG_8192C("%s, ack == _FAIL\n", __func__);
 		#endif
 	}
-	else
+	else 
 	{
 		#ifdef CONFIG_DEBUG_CFG80211
 		DBG_8192C("%s, ack=%d, ok!\n", __func__, ack);
 		#endif
 		ret = _SUCCESS;
 	}
-
+	
 exit:
 
 	#ifdef CONFIG_DEBUG_CFG80211
 	DBG_8192C("%s, ret=%d\n", __func__, ret);
 	#endif
-
-	return ret;
-
+	
+	return ret;		
+	
 }
 
 static int cfg80211_rtw_mgmt_tx(struct wiphy *wiphy,
@@ -4726,9 +4675,6 @@ static int cfg80211_rtw_mgmt_tx(struct wiphy *wiphy,
 #else
 	struct net_device *ndev,
 #endif
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0))
-	struct cfg80211_mgmt_tx_params *params,
-#else
 	struct ieee80211_channel *chan,
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)) || defined(COMPAT_KERNEL_RELEASE)
 	bool offchan,
@@ -4749,15 +4695,8 @@ static int cfg80211_rtw_mgmt_tx(struct wiphy *wiphy,
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,3,0))
 	bool dont_wait_for_ack,
 #endif
-#endif
 	u64 *cookie)
 {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0))
-	struct ieee80211_channel *chan = params->chan;
-	const u8 *buf = params->buf;
-	size_t len = params->len;
-#endif
-
 	_adapter *padapter = (_adapter *)wiphy_to_adapter(wiphy);
 	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(padapter->rtw_wdev);
 	int ret = 0;
@@ -4777,7 +4716,7 @@ static int cfg80211_rtw_mgmt_tx(struct wiphy *wiphy,
 	DBG_871X(FUNC_ADPT_FMT" len=%zu, ch=%d"
 	#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,8,0))
 		", ch_type=%d"
-		#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
+		#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)	
 		", channel_type_valid=%d"
 		#endif
 	#endif
@@ -4785,7 +4724,7 @@ static int cfg80211_rtw_mgmt_tx(struct wiphy *wiphy,
 		len, tx_ch
 	#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,8,0))
 		, channel_type
-		#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
+		#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)	
 		, channel_type_valid
 		#endif
 	#endif
@@ -4833,7 +4772,7 @@ static int cfg80211_rtw_mgmt_tx(struct wiphy *wiphy,
 		break;
 	case P2P_INVIT_RESP:
 		if (pwdev_priv->invit_info.flags & BIT(0)
-			&& pwdev_priv->invit_info.status == 0)
+			&& pwdev_priv->invit_info.status == 0) 
 		{
 			DBG_871X(FUNC_ADPT_FMT" agree with invitation of persistent group\n",
 				FUNC_ADPT_ARG(padapter));
@@ -4842,7 +4781,7 @@ static int cfg80211_rtw_mgmt_tx(struct wiphy *wiphy,
 			rtw_clear_scan_deny(padapter);
 		}
 		break;
-	}
+	}	
 
 exit:
 	return ret;
@@ -4870,47 +4809,47 @@ static void cfg80211_rtw_mgmt_frame_register(struct wiphy *wiphy,
 }
 
 static int rtw_cfg80211_set_beacon_wpsp2pie(struct net_device *ndev, char *buf, int len)
-{
+{	
 	int ret = 0;
 	uint wps_ielen = 0;
 	u8 *wps_ie;
 	u32	p2p_ielen = 0;
-	u8 wps_oui[8]={0x0,0x50,0xf2,0x04};
+	u8 wps_oui[8]={0x0,0x50,0xf2,0x04};	
 	u8 *p2p_ie;
-	u32	wfd_ielen = 0;
+	u32	wfd_ielen = 0;	
 	u8 *wfd_ie;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(ndev);
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	struct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);
 
 	DBG_871X(FUNC_NDEV_FMT" ielen=%d\n", FUNC_NDEV_ARG(ndev), len);
-
+	
 	if(len>0)
 	{
 		if((wps_ie = rtw_get_wps_ie(buf, len, NULL, &wps_ielen)))
-		{
+		{	
 			#ifdef CONFIG_DEBUG_CFG80211
 			DBG_8192C("bcn_wps_ielen=%d\n", wps_ielen);
 			#endif
-
+		
 			if(pmlmepriv->wps_beacon_ie)
 			{
 				u32 free_len = pmlmepriv->wps_beacon_ie_len;
 				pmlmepriv->wps_beacon_ie_len = 0;
 				rtw_mfree(pmlmepriv->wps_beacon_ie, free_len);
-				pmlmepriv->wps_beacon_ie = NULL;
-			}
+				pmlmepriv->wps_beacon_ie = NULL;			
+			}	
 
 			pmlmepriv->wps_beacon_ie = rtw_malloc(wps_ielen);
 			if ( pmlmepriv->wps_beacon_ie == NULL) {
 				DBG_8192C("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
 				return -EINVAL;
-
+			
 			}
-
+			
 			_rtw_memcpy(pmlmepriv->wps_beacon_ie, wps_ie, wps_ielen);
 			pmlmepriv->wps_beacon_ie_len = wps_ielen;
-
+	
 			update_beacon(padapter, _VENDOR_SPECIFIC_IE_, wps_oui, _TRUE);
 
 		}
@@ -4924,62 +4863,62 @@ static int rtw_cfg80211_set_beacon_wpsp2pie(struct net_device *ndev, char *buf,
 			#ifdef CONFIG_DEBUG_CFG80211
 			DBG_8192C("bcn_p2p_ielen=%d\n", p2p_ielen);
 			#endif
-
+		
 			if(pmlmepriv->p2p_beacon_ie)
 			{
 				u32 free_len = pmlmepriv->p2p_beacon_ie_len;
 				pmlmepriv->p2p_beacon_ie_len = 0;
 				rtw_mfree(pmlmepriv->p2p_beacon_ie, free_len);
-				pmlmepriv->p2p_beacon_ie = NULL;
-			}
+				pmlmepriv->p2p_beacon_ie = NULL;			
+			}	
 
 			pmlmepriv->p2p_beacon_ie = rtw_malloc(p2p_ielen);
 			if ( pmlmepriv->p2p_beacon_ie == NULL) {
 				DBG_8192C("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
 				return -EINVAL;
-
+			
 			}
-
+			
 			_rtw_memcpy(pmlmepriv->p2p_beacon_ie, p2p_ie, p2p_ielen);
 			pmlmepriv->p2p_beacon_ie_len = p2p_ielen;
-
+			
 		}
 		#endif //CONFIG_P2P
-
+		
 		//buf += p2p_ielen;
 		//len -= p2p_ielen;
 
 		#ifdef CONFIG_WFD
-		if(rtw_get_wfd_ie(buf, len, NULL, &wfd_ielen))
+		if(rtw_get_wfd_ie(buf, len, NULL, &wfd_ielen)) 
 		{
 			#ifdef CONFIG_DEBUG_CFG80211
 			DBG_8192C("bcn_wfd_ielen=%d\n", wfd_ielen);
 			#endif
-
+			
 			if(pmlmepriv->wfd_beacon_ie)
 			{
 				u32 free_len = pmlmepriv->wfd_beacon_ie_len;
 				pmlmepriv->wfd_beacon_ie_len = 0;
 				rtw_mfree(pmlmepriv->wfd_beacon_ie, free_len);
 				pmlmepriv->wfd_beacon_ie = NULL;
-			}
+			}	
 
 			pmlmepriv->wfd_beacon_ie = rtw_malloc(wfd_ielen);
 			if ( pmlmepriv->wfd_beacon_ie == NULL) {
 				DBG_8192C("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
 				return -EINVAL;
-
+			
 			}
-			rtw_get_wfd_ie(buf, len, pmlmepriv->wfd_beacon_ie, &pmlmepriv->wfd_beacon_ie_len);
+			rtw_get_wfd_ie(buf, len, pmlmepriv->wfd_beacon_ie, &pmlmepriv->wfd_beacon_ie_len);			
 		}
 		#endif //CONFIG_WFD
-
+		
 		pmlmeext->bstart_bss = _TRUE;
-
+		
 	}
 
 	return ret;
-
+	
 }
 
 static int rtw_cfg80211_set_probe_resp_wpsp2pie(struct net_device *net, char *buf, int len)
@@ -4987,25 +4926,25 @@ static int rtw_cfg80211_set_probe_resp_wpsp2pie(struct net_device *net, char *bu
 	int ret = 0;
 	uint wps_ielen = 0;
 	u8 *wps_ie;
-	u32	p2p_ielen = 0;
+	u32	p2p_ielen = 0;	
 	u8 *p2p_ie;
-	u32	wfd_ielen = 0;
+	u32	wfd_ielen = 0;	
 	u8 *wfd_ie;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(net);
-	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);	
 
 #ifdef CONFIG_DEBUG_CFG80211
 	DBG_8192C("%s, ielen=%d\n", __func__, len);
 #endif
-
+	
 	if(len>0)
 	{
 		if((wps_ie = rtw_get_wps_ie(buf, len, NULL, &wps_ielen)))
-		{
+		{	
 			uint	attr_contentlen = 0;
 			u16	uconfig_method, *puconfig_method = NULL;
 
-			#ifdef CONFIG_DEBUG_CFG80211
+			#ifdef CONFIG_DEBUG_CFG80211			
 			DBG_8192C("probe_resp_wps_ielen=%d\n", wps_ielen);
 			#endif
 
@@ -5030,47 +4969,47 @@ static int rtw_cfg80211_set_probe_resp_wpsp2pie(struct net_device *net, char *bu
 				u32 free_len = pmlmepriv->wps_probe_resp_ie_len;
 				pmlmepriv->wps_probe_resp_ie_len = 0;
 				rtw_mfree(pmlmepriv->wps_probe_resp_ie, free_len);
-				pmlmepriv->wps_probe_resp_ie = NULL;
-			}
+				pmlmepriv->wps_probe_resp_ie = NULL;			
+			}	
 
 			pmlmepriv->wps_probe_resp_ie = rtw_malloc(wps_ielen);
 			if ( pmlmepriv->wps_probe_resp_ie == NULL) {
 				DBG_8192C("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
 				return -EINVAL;
-
+			
 			}
-
-			//add PUSH_BUTTON config_method by driver self in wpsie of probe_resp at GO Mode
+			
+			//add PUSH_BUTTON config_method by driver self in wpsie of probe_resp at GO Mode 
 			if ( (puconfig_method = (u16*)rtw_get_wps_attr_content( wps_ie, wps_ielen, WPS_ATTR_CONF_METHOD , NULL, &attr_contentlen)) != NULL )
 			{
-				#ifdef CONFIG_DEBUG_CFG80211
+				#ifdef CONFIG_DEBUG_CFG80211		
 				//printk("config_method in wpsie of probe_resp = 0x%x\n", be16_to_cpu(*puconfig_method));
 				#endif
-
+				
 				uconfig_method = WPS_CM_PUSH_BUTTON;
 				uconfig_method = cpu_to_be16( uconfig_method );
 
-				*puconfig_method |= uconfig_method;
+				*puconfig_method |= uconfig_method;			
 			}
-
+			
 			_rtw_memcpy(pmlmepriv->wps_probe_resp_ie, wps_ie, wps_ielen);
 			pmlmepriv->wps_probe_resp_ie_len = wps_ielen;
-
+			
 		}
 
 		//buf += wps_ielen;
 		//len -= wps_ielen;
 
 		#ifdef CONFIG_P2P
-		if((p2p_ie=rtw_get_p2p_ie(buf, len, NULL, &p2p_ielen)))
+		if((p2p_ie=rtw_get_p2p_ie(buf, len, NULL, &p2p_ielen))) 
 		{
-			u8 is_GO = _FALSE;
+			u8 is_GO = _FALSE;			
 			u32 attr_contentlen = 0;
 			u16 cap_attr=0;
 
 			#ifdef CONFIG_DEBUG_CFG80211
 			DBG_8192C("probe_resp_p2p_ielen=%d\n", p2p_ielen);
-			#endif
+			#endif			
 
 			//Check P2P Capability ATTR
 			if( rtw_get_p2p_attr_content( p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8*)&cap_attr, (uint*) &attr_contentlen) )
@@ -5079,7 +5018,7 @@ static int rtw_cfg80211_set_probe_resp_wpsp2pie(struct net_device *net, char *bu
 				//DBG_8192C( "[%s] Got P2P Capability Attr!!\n", __FUNCTION__ );
 				cap_attr = le16_to_cpu(cap_attr);
 				grp_cap = (u8)((cap_attr >> 8)&0xff);
-
+				
 				is_GO = (grp_cap&BIT(0)) ? _TRUE:_FALSE;
 
 				if(is_GO)
@@ -5094,18 +5033,18 @@ static int rtw_cfg80211_set_probe_resp_wpsp2pie(struct net_device *net, char *bu
 					u32 free_len = pmlmepriv->p2p_probe_resp_ie_len;
 					pmlmepriv->p2p_probe_resp_ie_len = 0;
 					rtw_mfree(pmlmepriv->p2p_probe_resp_ie, free_len);
-					pmlmepriv->p2p_probe_resp_ie = NULL;
-				}
+					pmlmepriv->p2p_probe_resp_ie = NULL;		
+				}	
 
 				pmlmepriv->p2p_probe_resp_ie = rtw_malloc(p2p_ielen);
 				if ( pmlmepriv->p2p_probe_resp_ie == NULL) {
 					DBG_8192C("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
 					return -EINVAL;
-
+				
 				}
 				_rtw_memcpy(pmlmepriv->p2p_probe_resp_ie, p2p_ie, p2p_ielen);
 				pmlmepriv->p2p_probe_resp_ie_len = p2p_ielen;
-			}
+			}		
 			else
 			{
 				if(pmlmepriv->p2p_go_probe_resp_ie)
@@ -5113,54 +5052,54 @@ static int rtw_cfg80211_set_probe_resp_wpsp2pie(struct net_device *net, char *bu
 					u32 free_len = pmlmepriv->p2p_go_probe_resp_ie_len;
 					pmlmepriv->p2p_go_probe_resp_ie_len = 0;
 					rtw_mfree(pmlmepriv->p2p_go_probe_resp_ie, free_len);
-					pmlmepriv->p2p_go_probe_resp_ie = NULL;
-				}
+					pmlmepriv->p2p_go_probe_resp_ie = NULL;			
+				}	
 
 				pmlmepriv->p2p_go_probe_resp_ie = rtw_malloc(p2p_ielen);
 				if ( pmlmepriv->p2p_go_probe_resp_ie == NULL) {
 					DBG_8192C("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
 					return -EINVAL;
-
+			
 				}
 				_rtw_memcpy(pmlmepriv->p2p_go_probe_resp_ie, p2p_ie, p2p_ielen);
 				pmlmepriv->p2p_go_probe_resp_ie_len = p2p_ielen;
 			}
-
+			
 		}
 		#endif //CONFIG_P2P
-
+		
 		//buf += p2p_ielen;
 		//len -= p2p_ielen;
 
 		#ifdef CONFIG_WFD
-		if(rtw_get_wfd_ie(buf, len, NULL, &wfd_ielen))
+		if(rtw_get_wfd_ie(buf, len, NULL, &wfd_ielen)) 
 		{
 			#ifdef CONFIG_DEBUG_CFG80211
 			DBG_8192C("probe_resp_wfd_ielen=%d\n", wfd_ielen);
 			#endif
-
+			
 			if(pmlmepriv->wfd_probe_resp_ie)
 			{
 				u32 free_len = pmlmepriv->wfd_probe_resp_ie_len;
 				pmlmepriv->wfd_probe_resp_ie_len = 0;
 				rtw_mfree(pmlmepriv->wfd_probe_resp_ie, free_len);
 				pmlmepriv->wfd_probe_resp_ie = NULL;
-			}
+			}	
 
 			pmlmepriv->wfd_probe_resp_ie = rtw_malloc(wfd_ielen);
 			if ( pmlmepriv->wfd_probe_resp_ie == NULL) {
 				DBG_8192C("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
 				return -EINVAL;
-
+			
 			}
-			rtw_get_wfd_ie(buf, len, pmlmepriv->wfd_probe_resp_ie, &pmlmepriv->wfd_probe_resp_ie_len);
+			rtw_get_wfd_ie(buf, len, pmlmepriv->wfd_probe_resp_ie, &pmlmepriv->wfd_probe_resp_ie_len);			
 		}
 		#endif //CONFIG_WFD
-
+		
 	}
 
 	return ret;
-
+	
 }
 
 static int rtw_cfg80211_set_assoc_resp_wpsp2pie(struct net_device *net, char *buf, int len)
@@ -5170,7 +5109,7 @@ static int rtw_cfg80211_set_assoc_resp_wpsp2pie(struct net_device *net, char *bu
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 
 	DBG_8192C("%s, ielen=%d\n", __func__, len);
-
+	
 	if(len>0)
 	{
 		if(pmlmepriv->wps_assoc_resp_ie)
@@ -5179,20 +5118,20 @@ static int rtw_cfg80211_set_assoc_resp_wpsp2pie(struct net_device *net, char *bu
 			pmlmepriv->wps_assoc_resp_ie_len = 0;
 			rtw_mfree(pmlmepriv->wps_assoc_resp_ie, free_len);
 			pmlmepriv->wps_assoc_resp_ie = NULL;
-		}
+		}	
 
 		pmlmepriv->wps_assoc_resp_ie = rtw_malloc(len);
 		if ( pmlmepriv->wps_assoc_resp_ie == NULL) {
 			DBG_8192C("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
 			return -EINVAL;
-
+			
 		}
 		_rtw_memcpy(pmlmepriv->wps_assoc_resp_ie, buf, len);
 		pmlmepriv->wps_assoc_resp_ie_len = len;
 	}
 
 	return ret;
-
+	
 }
 
 int rtw_cfg80211_set_mgnt_wpsp2pie(struct net_device *net, char *buf, int len,
@@ -5210,11 +5149,11 @@ int rtw_cfg80211_set_mgnt_wpsp2pie(struct net_device *net, char *buf, int len,
 		#ifdef CONFIG_P2P
 		|| (rtw_get_p2p_ie(buf, len, NULL, &p2p_ielen) && (p2p_ielen>0))
 		#endif
-	)
-	{
-		if (net != NULL)
+	)		
+	{	
+		if (net != NULL) 
 		{
-			switch (type)
+			switch (type) 
 			{
 				case 0x1: //BEACON
 				ret = rtw_cfg80211_set_beacon_wpsp2pie(net, buf, len);
@@ -5225,12 +5164,12 @@ int rtw_cfg80211_set_mgnt_wpsp2pie(struct net_device *net, char *buf, int len,
 				case 0x4: //ASSOC_RESP
 				ret = rtw_cfg80211_set_assoc_resp_wpsp2pie(net, buf, len);
 				break;
-			}
+			}		
 		}
-	}
+	}	
 
 	return ret;
-
+	
 }
 
 static struct cfg80211_ops rtw_cfg80211_ops = {
@@ -5252,7 +5191,7 @@ int rtw_cfg80211_set_mgnt_wpsp2pie(struct net_device *net, char *buf, int len,
 	.set_pmksa = cfg80211_rtw_set_pmksa,
 	.del_pmksa = cfg80211_rtw_del_pmksa,
 	.flush_pmksa = cfg80211_rtw_flush_pmksa,
-
+	
 #ifdef CONFIG_AP_MODE
 	.add_virtual_intf = cfg80211_rtw_add_virtual_intf,
 	.del_virtual_intf = cfg80211_rtw_del_virtual_intf,
@@ -5266,7 +5205,7 @@ int rtw_cfg80211_set_mgnt_wpsp2pie(struct net_device *net, char *buf, int len,
 	.change_beacon = cfg80211_rtw_change_beacon,
 	.stop_ap = cfg80211_rtw_stop_ap,
 	#endif
-
+	
 	.add_station = cfg80211_rtw_add_station,
 	.del_station = cfg80211_rtw_del_station,
 	.change_station = cfg80211_rtw_change_station,
@@ -5276,7 +5215,7 @@ int rtw_cfg80211_set_mgnt_wpsp2pie(struct net_device *net, char *buf, int len,
 	.set_channel = cfg80211_rtw_set_channel,
 	#endif
 	//.auth = cfg80211_rtw_auth,
-	//.assoc = cfg80211_rtw_assoc,
+	//.assoc = cfg80211_rtw_assoc,	
 #endif //CONFIG_AP_MODE
 
 #ifdef CONFIG_P2P
@@ -5284,7 +5223,7 @@ int rtw_cfg80211_set_mgnt_wpsp2pie(struct net_device *net, char *buf, int len,
 	.cancel_remain_on_channel = cfg80211_rtw_cancel_remain_on_channel,
 #endif
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)	 
 	.mgmt_tx = cfg80211_rtw_mgmt_tx,
 	.mgmt_frame_register = cfg80211_rtw_mgmt_frame_register,
 #elif  (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,34) && LINUX_VERSION_CODE<=KERNEL_VERSION(2,6,35))
@@ -5292,7 +5231,7 @@ int rtw_cfg80211_set_mgnt_wpsp2pie(struct net_device *net, char *buf, int len,
 #endif
 };
 
-static void rtw_cfg80211_init_ht_capab(struct ieee80211_sta_ht_cap *ht_cap, enum nl80211_band band, u8 rf_type)
+static void rtw_cfg80211_init_ht_capab(struct ieee80211_sta_ht_cap *ht_cap, enum ieee80211_band band, u8 rf_type)
 {
 
 #define MAX_BIT_RATE_40MHZ_MCS15 	300	/* Mbps */
@@ -5301,8 +5240,8 @@ static void rtw_cfg80211_init_ht_capab(struct ieee80211_sta_ht_cap *ht_cap, enum
 	ht_cap->ht_supported = _TRUE;
 
 	ht_cap->cap = IEEE80211_HT_CAP_SUP_WIDTH_20_40 |
-					IEEE80211_HT_CAP_SGI_40 | IEEE80211_HT_CAP_SGI_20 |
-					IEEE80211_HT_CAP_DSSSCCK40 | IEEE80211_HT_CAP_MAX_AMSDU;
+	    				IEEE80211_HT_CAP_SGI_40 | IEEE80211_HT_CAP_SGI_20 |
+	    				IEEE80211_HT_CAP_DSSSCCK40 | IEEE80211_HT_CAP_MAX_AMSDU;
 
 	/*
 	 *Maximum length of AMPDU that the STA can receive.
@@ -5316,7 +5255,7 @@ static void rtw_cfg80211_init_ht_capab(struct ieee80211_sta_ht_cap *ht_cap, enum
 	ht_cap->mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;
 
 	/*
-	 *hw->wiphy->bands[NL80211_BAND_2GHZ]
+	 *hw->wiphy->bands[IEEE80211_BAND_2GHZ]
 	 *base on ant_num
 	 *rx_mask: RX mask
 	 *if rx_ant =1 rx_mask[0]=0xff;==>MCS0-MCS7
@@ -5344,8 +5283,8 @@ static void rtw_cfg80211_init_ht_capab(struct ieee80211_sta_ht_cap *ht_cap, enum
 	else
 	{
 		DBG_8192C("%s, error rf_type=%d\n", __func__, rf_type);
-	}
-
+	}	
+	
 }
 
 void rtw_cfg80211_init_wiphy(_adapter *padapter)
@@ -5354,23 +5293,23 @@ void rtw_cfg80211_init_wiphy(_adapter *padapter)
 	struct ieee80211_supported_band *bands;
 	struct wireless_dev *pwdev = padapter->rtw_wdev;
 	struct wiphy *wiphy = pwdev->wiphy;
-
+	
 	rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
 
 	DBG_8192C("%s:rf_type=%d\n", __func__, rf_type);
 
 	/* if (padapter->registrypriv.wireless_mode & WIRELESS_11G) */
 	{
-		bands = wiphy->bands[NL80211_BAND_2GHZ];
+		bands = wiphy->bands[IEEE80211_BAND_2GHZ];
 		if(bands)
-			rtw_cfg80211_init_ht_capab(&bands->ht_cap, NL80211_BAND_2GHZ, rf_type);
+			rtw_cfg80211_init_ht_capab(&bands->ht_cap, IEEE80211_BAND_2GHZ, rf_type);
 	}
 
 	/* if (padapter->registrypriv.wireless_mode & WIRELESS_11A) */
 	{
-		bands = wiphy->bands[NL80211_BAND_5GHZ];
+		bands = wiphy->bands[IEEE80211_BAND_5GHZ];
 		if(bands)
-			rtw_cfg80211_init_ht_capab(&bands->ht_cap, NL80211_BAND_5GHZ, rf_type);
+			rtw_cfg80211_init_ht_capab(&bands->ht_cap, IEEE80211_BAND_5GHZ, rf_type);
 	}
 }
 
@@ -5403,13 +5342,13 @@ static void rtw_cfg80211_preinit_wiphy(_adapter *padapter, struct wiphy *wiphy)
 	wiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;
 
 	wiphy->max_scan_ssids = RTW_SSID_SCAN_AMOUNT;
-	wiphy->max_scan_ie_len = RTW_SCAN_IE_LEN_MAX;
+	wiphy->max_scan_ie_len = RTW_SCAN_IE_LEN_MAX;	
 	wiphy->max_num_pmkids = RTW_MAX_NUM_PMKIDS;
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)) || defined(COMPAT_KERNEL_RELEASE)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)) || defined(COMPAT_KERNEL_RELEASE)	 
 	wiphy->max_remain_on_channel_duration = RTW_MAX_REMAIN_ON_CHANNEL_DURATION;
 #endif
-
+	
 	wiphy->interface_modes =	BIT(NL80211_IFTYPE_STATION)
 								| BIT(NL80211_IFTYPE_ADHOC)
 #ifdef CONFIG_AP_MODE
@@ -5422,11 +5361,11 @@ static void rtw_cfg80211_preinit_wiphy(_adapter *padapter, struct wiphy *wiphy)
 #endif
 								;
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined(COMPAT_KERNEL_RELEASE)	
 #ifdef CONFIG_AP_MODE
 	wiphy->mgmt_stypes = rtw_cfg80211_default_mgmt_stypes;
-#endif //CONFIG_AP_MODE
-#endif
+#endif //CONFIG_AP_MODE	
+#endif		
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0))
 	wiphy->software_iftypes |= BIT(NL80211_IFTYPE_MONITOR);
@@ -5441,10 +5380,10 @@ static void rtw_cfg80211_preinit_wiphy(_adapter *padapter, struct wiphy *wiphy)
 	wiphy->n_cipher_suites = ARRAY_SIZE(rtw_cipher_suites);
 
 	/* if (padapter->registrypriv.wireless_mode & WIRELESS_11G) */
-		wiphy->bands[NL80211_BAND_2GHZ] = rtw_spt_band_alloc(NL80211_BAND_2GHZ);
+		wiphy->bands[IEEE80211_BAND_2GHZ] = rtw_spt_band_alloc(IEEE80211_BAND_2GHZ);
 	/* if (padapter->registrypriv.wireless_mode & WIRELESS_11A) */
-		wiphy->bands[NL80211_BAND_5GHZ] = rtw_spt_band_alloc(NL80211_BAND_5GHZ);
-
+		wiphy->bands[IEEE80211_BAND_5GHZ] = rtw_spt_band_alloc(IEEE80211_BAND_5GHZ);
+	
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38) && LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0))
 	wiphy->flags |= WIPHY_FLAG_SUPPORTS_SEPARATE_DEFAULT_KEYS;
 #endif
@@ -5456,7 +5395,7 @@ static void rtw_cfg80211_preinit_wiphy(_adapter *padapter, struct wiphy *wiphy)
 
 	if(padapter->registrypriv.power_mgnt != PS_MODE_ACTIVE)
 		wiphy->flags |= WIPHY_FLAG_PS_ON_BY_DEFAULT;
-	else
+	else 
 		wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;
 }
 
@@ -5467,7 +5406,7 @@ int rtw_wdev_alloc(_adapter *padapter, struct device *dev)
 	struct wireless_dev *wdev;
 	struct rtw_wdev_priv *pwdev_priv;
 	struct net_device *pnetdev = padapter->pnetdev;
-
+	
 	DBG_8192C("%s(padapter=%p)\n", __func__, padapter);
 
 	/* wiphy */
@@ -5495,11 +5434,8 @@ int rtw_wdev_alloc(_adapter *padapter, struct device *dev)
 	}
 	wdev->wiphy = wiphy;
 	wdev->netdev = pnetdev;
-
-	wdev->iftype = NL80211_IFTYPE_STATION; // will be init in rtw_hal_init()
-	                                       // Must sync with _rtw_init_mlme_priv()
-	                                       // pmlmepriv->fw_state = WIFI_STATION_STATE
-	//wdev->iftype = NL80211_IFTYPE_MONITOR; // for rtw_setopmode_cmd() in cfg80211_rtw_change_iface()
+	//wdev->iftype = NL80211_IFTYPE_STATION;
+	wdev->iftype = NL80211_IFTYPE_MONITOR; // for rtw_setopmode_cmd() in cfg80211_rtw_change_iface()
 	padapter->rtw_wdev = wdev;
 	pnetdev->ieee80211_ptr = wdev;
 
@@ -5511,22 +5447,22 @@ int rtw_wdev_alloc(_adapter *padapter, struct device *dev)
 	pwdev_priv->padapter = padapter;
 	pwdev_priv->scan_request = NULL;
 	_rtw_spinlock_init(&pwdev_priv->scan_req_lock);
-
+		
 	pwdev_priv->p2p_enabled = _FALSE;
 	pwdev_priv->provdisc_req_issued = _FALSE;
 	rtw_wdev_invit_info_init(&pwdev_priv->invit_info);
 	rtw_wdev_nego_info_init(&pwdev_priv->nego_info);
-
+		
 	pwdev_priv->bandroid_scan = _FALSE;
 
 	if(padapter->registrypriv.power_mgnt != PS_MODE_ACTIVE)
 		pwdev_priv->power_mgmt = _TRUE;
 	else
 		pwdev_priv->power_mgmt = _FALSE;
-
+	
 #ifdef CONFIG_CONCURRENT_MODE
-	ATOMIC_SET(&pwdev_priv->switch_ch_to, 1);
-	ATOMIC_SET(&pwdev_priv->ro_ch_to, 1);
+	ATOMIC_SET(&pwdev_priv->switch_ch_to, 1);	
+	ATOMIC_SET(&pwdev_priv->ro_ch_to, 1);	
 #endif
 
 	return ret;
@@ -5535,10 +5471,10 @@ int rtw_wdev_alloc(_adapter *padapter, struct device *dev)
 unregister_wiphy:
 	wiphy_unregister(wiphy);
  free_wiphy:
-	wiphy_free(wiphy);
+ 	wiphy_free(wiphy);
 exit:
 	return ret;
-
+	
 }
 
 void rtw_wdev_free(struct wireless_dev *wdev)
@@ -5552,9 +5488,9 @@ void rtw_wdev_free(struct wireless_dev *wdev)
 
 	pwdev_priv = wdev_to_priv(wdev);
 
-	rtw_spt_band_free(wdev->wiphy->bands[NL80211_BAND_2GHZ]);
-	rtw_spt_band_free(wdev->wiphy->bands[NL80211_BAND_5GHZ]);
-
+	rtw_spt_band_free(wdev->wiphy->bands[IEEE80211_BAND_2GHZ]);
+	rtw_spt_band_free(wdev->wiphy->bands[IEEE80211_BAND_5GHZ]);
+	
 	wiphy_free(wdev->wiphy);
 
 	rtw_mfree((u8*)wdev, sizeof(struct wireless_dev));
@@ -5582,3 +5518,4 @@ void rtw_wdev_unregister(struct wireless_dev *wdev)
 }
 
 #endif //CONFIG_IOCTL_CFG80211
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/ioctl_linux.c b/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/ioctl_linux.c
old mode 100644
new mode 100755
index 1413b27..9adbeaf
--- a/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/ioctl_linux.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/ioctl_linux.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -81,9 +81,9 @@
 u32 rtw_rates[] = {1000000,2000000,5500000,11000000,
 	6000000,9000000,12000000,18000000,24000000,36000000,48000000,54000000};
 
-static const char * const iw_operation_mode[] =
-{
-	"Auto", "Ad-Hoc", "Managed",  "Master", "Repeater", "Secondary", "Monitor"
+static const char * const iw_operation_mode[] = 
+{ 
+	"Auto", "Ad-Hoc", "Managed",  "Master", "Repeater", "Secondary", "Monitor" 
 };
 
 static int hex2num_i(char c)
@@ -246,17 +246,17 @@ void rtw_indicate_wx_disassoc_event(_adapter *padapter)
 
 /*
 uint	rtw_is_cckrates_included(u8 *rate)
-{
-		u32	i = 0;
+{	
+		u32	i = 0;			
 
 		while(rate[i]!=0)
-		{
-			if  (  (((rate[i]) & 0x7f) == 2)	|| (((rate[i]) & 0x7f) == 4) ||
-			(((rate[i]) & 0x7f) == 11)  || (((rate[i]) & 0x7f) == 22) )
-			return _TRUE;
+		{		
+			if  (  (((rate[i]) & 0x7f) == 2)	|| (((rate[i]) & 0x7f) == 4) ||		
+			(((rate[i]) & 0x7f) == 11)  || (((rate[i]) & 0x7f) == 22) )		
+			return _TRUE;	
 			i++;
 		}
-
+		
 		return _FALSE;
 }
 
@@ -268,15 +268,15 @@ uint	rtw_is_cckratesonly_included(u8 *rate)
 	{
 			if  (  (((rate[i]) & 0x7f) != 2) && (((rate[i]) & 0x7f) != 4) &&
 				(((rate[i]) & 0x7f) != 11)  && (((rate[i]) & 0x7f) != 22) )
-			return _FALSE;
+			return _FALSE;		
 			i++;
 	}
-
+	
 	return _TRUE;
 }
 */
 
-static char *translate_scan(_adapter *padapter,
+static char *translate_scan(_adapter *padapter, 
 				struct iw_request_info* info, struct wlan_network *pnetwork,
 				char *start, char *stop)
 {
@@ -286,7 +286,7 @@ static char *translate_scan(_adapter *padapter,
 	char custom[MAX_CUSTOM_LEN];
 	char *p;
 	u16 max_rate=0, rate, ht_cap=_FALSE;
-	u32 i = 0;
+	u32 i = 0;	
 	char	*current_val;
 	long rssi;
 	u8 bw_40MHz=0, short_GI=0;
@@ -302,14 +302,14 @@ static char *translate_scan(_adapter *padapter,
 	{
 
 	}
-	else if ( ( SCAN_RESULT_P2P_ONLY == pwdinfo->wfd_info->scan_result_type ) ||
+	else if ( ( SCAN_RESULT_P2P_ONLY == pwdinfo->wfd_info->scan_result_type ) || 
 		      ( SCAN_RESULT_WFD_TYPE == pwdinfo->wfd_info->scan_result_type ) )
 #endif // CONFIG_WFD
 	{
 		if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 		{
 			u32	blnGotP2PIE = _FALSE;
-
+			
 			//	User is doing the P2P device discovery
 			//	The prefix of SSID should be "DIRECT-" and the IE should contains the P2P IE.
 			//	If not, the driver should ignore this AP and go to the next AP.
@@ -330,7 +330,7 @@ static char *translate_scan(_adapter *padapter,
 			{
 				return start;
 			}
-
+			
 		}
 	}
 
@@ -340,12 +340,12 @@ static char *translate_scan(_adapter *padapter,
 		u32	blnGotWFD = _FALSE;
 		u8	wfd_ie[ 128 ] = { 0x00 };
 		uint	wfd_ielen = 0;
-
+		
 		if ( rtw_get_wfd_ie( &pnetwork->network.IEs[12], pnetwork->network.IELength - 12,  wfd_ie, &wfd_ielen ) )
 		{
 			u8	wfd_devinfo[ 6 ] = { 0x00 };
 			uint	wfd_devlen = 6;
-
+			
 			if ( rtw_get_wfd_attr_content( wfd_ie, wfd_ielen, WFD_ATTR_DEVICE_INFO, wfd_devinfo, &wfd_devlen) )
 			{
 				if ( pwdinfo->wfd_info->wfd_device_type == WFD_DEVINFO_PSINK )
@@ -369,7 +369,7 @@ static char *translate_scan(_adapter *padapter,
 				}
 			}
 		}
-
+		
 		if ( blnGotWFD == _FALSE )
 		{
 			return start;
@@ -387,7 +387,7 @@ static char *translate_scan(_adapter *padapter,
 
 	/* Add the ESSID */
 	iwe.cmd = SIOCGIWESSID;
-	iwe.u.data.flags = 1;
+	iwe.u.data.flags = 1;	
 	iwe.u.data.length = min((u16)pnetwork->network.Ssid.SsidLength, (u16)32);
 	start = iwe_stream_add_point(info, start, stop, &iwe, pnetwork->network.Ssid.Ssid);
 
@@ -397,8 +397,8 @@ static char *translate_scan(_adapter *padapter,
 	if(p && ht_ielen>0)
 	{
 		struct rtw_ieee80211_ht_cap *pht_capie;
-		ht_cap = _TRUE;
-		pht_capie = (struct rtw_ieee80211_ht_cap *)(p+2);
+		ht_cap = _TRUE;			
+		pht_capie = (struct rtw_ieee80211_ht_cap *)(p+2);		
 		_rtw_memcpy(&mcs_rate , pht_capie->supp_mcs_set, 2);
 		bw_40MHz = (pht_capie->cap_info&IEEE80211_HT_CAP_SUP_WIDTH) ? 1:0;
 		short_GI = (pht_capie->cap_info&(IEEE80211_HT_CAP_SGI_20|IEEE80211_HT_CAP_SGI_40)) ? 1:0;
@@ -406,20 +406,20 @@ static char *translate_scan(_adapter *padapter,
 
 	/* Add the protocol name */
 	iwe.cmd = SIOCGIWNAME;
-	if ((rtw_is_cckratesonly_included((u8*)&pnetwork->network.SupportedRates)) == _TRUE)
+	if ((rtw_is_cckratesonly_included((u8*)&pnetwork->network.SupportedRates)) == _TRUE)		
 	{
 		if(ht_cap == _TRUE)
 			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bn");
 		else
 		snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11b");
-	}
-	else if ((rtw_is_cckrates_included((u8*)&pnetwork->network.SupportedRates)) == _TRUE)
+	}	
+	else if ((rtw_is_cckrates_included((u8*)&pnetwork->network.SupportedRates)) == _TRUE)	
 	{
 		if(ht_cap == _TRUE)
 			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bgn");
 		else
 		snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bg");
-	}
+	}	
 	else
 	{
 		if(pnetwork->network.Configuration.DSConfig > 14)
@@ -436,7 +436,7 @@ static char *translate_scan(_adapter *padapter,
 			else
 				snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11g");
 		}
-	}
+	}	
 
 	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_CHAR_LEN);
 
@@ -481,20 +481,20 @@ static char *translate_scan(_adapter *padapter,
 	p += snprintf(p, MAX_CUSTOM_LEN - (p - custom), " Rates (Mb/s): ");
 	while(pnetwork->network.SupportedRates[i]!=0)
 	{
-		rate = pnetwork->network.SupportedRates[i]&0x7F;
+		rate = pnetwork->network.SupportedRates[i]&0x7F; 
 		if (rate > max_rate)
 			max_rate = rate;
 		p += snprintf(p, MAX_CUSTOM_LEN - (p - custom),
 			      "%d%s ", rate >> 1, (rate & 1) ? ".5" : "");
 		i++;
 	}
-
+	
 	if(ht_cap == _TRUE)
 	{
 		if(mcs_rate&0x8000)//MCS15
 		{
 			max_rate = (bw_40MHz) ? ((short_GI)?300:270):((short_GI)?144:130);
-
+			
 		}
 		else if(mcs_rate&0x0080)//MCS7
 		{
@@ -506,7 +506,7 @@ static char *translate_scan(_adapter *padapter,
 			max_rate = (bw_40MHz) ? ((short_GI)?150:135):((short_GI)?72:65);
 		}
 
-		max_rate = max_rate*2;//Mbps/2;
+		max_rate = max_rate*2;//Mbps/2;		
 	}
 
 	iwe.cmd = SIOCGIWRATE;
@@ -533,16 +533,16 @@ static char *translate_scan(_adapter *padapter,
 			for (i = 0; i < wpa_len; i++) {
 				p += sprintf(p, "%02x", wpa_ie[i]);
 			}
-
+	
 			_rtw_memset(&iwe, 0, sizeof(iwe));
 			iwe.cmd = IWEVCUSTOM;
 			iwe.u.data.length = strlen(buf);
 			start = iwe_stream_add_point(info, start, stop, &iwe,buf);
-
+			
 			_rtw_memset(&iwe, 0, sizeof(iwe));
 			iwe.cmd =IWEVGENIE;
 			iwe.u.data.length = wpa_len;
-			start = iwe_stream_add_point(info, start, stop, &iwe, wpa_ie);
+			start = iwe_stream_add_point(info, start, stop, &iwe, wpa_ie);			
 		}
 		if (rsn_len > 0)
 		{
@@ -556,32 +556,32 @@ static char *translate_scan(_adapter *padapter,
 			iwe.cmd = IWEVCUSTOM;
 			iwe.u.data.length = strlen(buf);
 			start = iwe_stream_add_point(info, start, stop, &iwe,buf);
-
+		
 			_rtw_memset(&iwe, 0, sizeof(iwe));
 			iwe.cmd =IWEVGENIE;
 			iwe.u.data.length = rsn_len;
-			start = iwe_stream_add_point(info, start, stop, &iwe, rsn_ie);
+			start = iwe_stream_add_point(info, start, stop, &iwe, rsn_ie);		
 		}
 	}
 
 	{ //parsing WPS IE
-		uint cnt = 0,total_ielen;
+		uint cnt = 0,total_ielen;	
 		u8 *wpsie_ptr=NULL;
-		uint wps_ielen = 0;
+		uint wps_ielen = 0;		
 
 		u8 *ie_ptr = pnetwork->network.IEs +_FIXED_IE_LENGTH_;
 		total_ielen= pnetwork->network.IELength - _FIXED_IE_LENGTH_;
 
 		while(cnt < total_ielen)
 		{
-			if(rtw_is_wps_ie(&ie_ptr[cnt], &wps_ielen) && (wps_ielen>2))
+			if(rtw_is_wps_ie(&ie_ptr[cnt], &wps_ielen) && (wps_ielen>2))			
 			{
 				wpsie_ptr = &ie_ptr[cnt];
 				iwe.cmd =IWEVGENIE;
 				iwe.u.data.length = (u16)wps_ielen;
-				start = iwe_stream_add_point(info, start, stop, &iwe, wpsie_ptr);
-			}
-			cnt+=ie_ptr[cnt+1]+2; //goto next
+				start = iwe_stream_add_point(info, start, stop, &iwe, wpsie_ptr);						
+			}			
+			cnt+=ie_ptr[cnt+1]+2; //goto next		
 		}
 	}
 
@@ -589,7 +589,7 @@ static char *translate_scan(_adapter *padapter,
 {
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	u8 ss, sq;
-
+	
 	/* Add quality statistics */
 	iwe.cmd = IWEVQUAL;
 	iwe.u.qual.updated = IW_QUAL_QUAL_UPDATED | IW_QUAL_LEVEL_UPDATED | IW_QUAL_NOISE_INVALID
@@ -606,32 +606,32 @@ static char *translate_scan(_adapter *padapter,
 		ss = pnetwork->network.PhyInfo.SignalStrength;
 		sq = pnetwork->network.PhyInfo.SignalQuality;
 	}
-
-
+	
+	
 	#ifdef CONFIG_SIGNAL_DISPLAY_DBM
 	iwe.u.qual.level = (u8) translate_percentage_to_dbm(ss);//dbm
 	#else
 	iwe.u.qual.level = (u8)ss;//%
 	#endif
-
+	
 	iwe.u.qual.qual = (u8)sq;   // signal quality
 
 	#ifdef CONFIG_PLATFORM_ROCKCHIPS
 	iwe.u.qual.noise = -100; // noise level suggest by zhf@rockchips
-	#else
+	#else 
 	iwe.u.qual.noise = 0; // noise level
 	#endif //CONFIG_PLATFORM_ROCKCHIPS
-
+	
 	//DBG_871X("iqual=%d, ilevel=%d, inoise=%d, iupdated=%d\n", iwe.u.qual.qual, iwe.u.qual.level , iwe.u.qual.noise, iwe.u.qual.updated);
 
 	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_QUAL_LEN);
 }
-
-	return start;
+	
+	return start;	
 }
 
 static int wpa_set_auth_algs(struct net_device *dev, u32 value)
-{
+{	
 	_adapter *padapter = (_adapter *) rtw_netdev_priv(dev);
 	int ret = 0;
 
@@ -641,7 +641,7 @@ static int wpa_set_auth_algs(struct net_device *dev, u32 value)
 		padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
 		padapter->securitypriv.ndisauthtype = Ndis802_11AuthModeAutoSwitch;
 		padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Auto;
-	}
+	} 
 	else if (value & AUTH_ALG_SHARED_KEY)
 	{
 		DBG_871X("wpa_set_auth_algs, AUTH_ALG_SHARED_KEY  [value:0x%x]\n",value);
@@ -654,7 +654,7 @@ static int wpa_set_auth_algs(struct net_device *dev, u32 value)
 		padapter->securitypriv.ndisauthtype = Ndis802_11AuthModeShared;
 		padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Shared;
 #endif
-	}
+	} 
 	else if(value & AUTH_ALG_OPEN_SYSTEM)
 	{
 		DBG_871X("wpa_set_auth_algs, AUTH_ALG_OPEN_SYSTEM\n");
@@ -666,10 +666,10 @@ static int wpa_set_auth_algs(struct net_device *dev, u32 value)
 			padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Auto;
 #else
 			padapter->securitypriv.ndisauthtype = Ndis802_11AuthModeOpen;
-			padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Open;
+ 			padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Open;
 #endif
 		}
-
+		
 	}
 	else if(value & AUTH_ALG_LEAP)
 	{
@@ -682,16 +682,16 @@ static int wpa_set_auth_algs(struct net_device *dev, u32 value)
 	}
 
 	return ret;
-
+	
 }
 
 static int wpa_set_encryption(struct net_device *dev, struct ieee_param *param, u32 param_len)
 {
 	int ret = 0;
 	u32 wep_key_idx, wep_key_len,wep_total_len;
-	NDIS_802_11_WEP	 *pwep = NULL;
+	NDIS_802_11_WEP	 *pwep = NULL;	
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
-	struct mlme_priv 	*pmlmepriv = &padapter->mlmepriv;
+	struct mlme_priv 	*pmlmepriv = &padapter->mlmepriv;		
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
 #ifdef CONFIG_P2P
 	struct wifidirect_info* pwdinfo = &padapter->wdinfo;
@@ -710,7 +710,7 @@ static int wpa_set_encryption(struct net_device *dev, struct ieee_param *param,
 
 	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
 	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
-	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff)
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) 
 	{
 
 		if (param->u.crypt.idx >= WEP_KEYS
@@ -722,8 +722,8 @@ static int wpa_set_encryption(struct net_device *dev, struct ieee_param *param,
 			ret = -EINVAL;
 			goto exit;
 		}
-	}
-	else
+	} 
+	else 
 	{
 
 		{
@@ -752,19 +752,19 @@ static int wpa_set_encryption(struct net_device *dev, struct ieee_param *param,
 
 		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_info_,("(2)wep_key_idx=%d\n", wep_key_idx));
 
-		if (wep_key_len > 0)
+		if (wep_key_len > 0) 
 		{
-			wep_key_len = wep_key_len <= 5 ? 5 : 13;
+		 	wep_key_len = wep_key_len <= 5 ? 5 : 13;
 			wep_total_len = wep_key_len + FIELD_OFFSET(NDIS_802_11_WEP, KeyMaterial);
-			pwep =(NDIS_802_11_WEP	 *) rtw_malloc(wep_total_len);
+		 	pwep =(NDIS_802_11_WEP	 *) rtw_malloc(wep_total_len);
 			if(pwep == NULL){
 				RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,(" wpa_set_encryption: pwep allocate fail !!!\n"));
 				goto exit;
 			}
 
-			_rtw_memset(pwep, 0, wep_total_len);
+		 	_rtw_memset(pwep, 0, wep_total_len);
 
-			pwep->KeyLength = wep_key_len;
+		 	pwep->KeyLength = wep_key_len;
 			pwep->Length = wep_total_len;
 
 			if(wep_key_len==13)
@@ -773,7 +773,7 @@ static int wpa_set_encryption(struct net_device *dev, struct ieee_param *param,
 				padapter->securitypriv.dot118021XGrpPrivacy=_WEP104_;
 			}
 		}
-		else {
+		else {		
 			ret = -EINVAL;
 			goto exit;
 		}
@@ -795,21 +795,21 @@ static int wpa_set_encryption(struct net_device *dev, struct ieee_param *param,
 		else
 		{
 			DBG_871X("wep, set_tx=0\n");
-
-			//don't update "psecuritypriv->dot11PrivacyAlgrthm" and
+			
+			//don't update "psecuritypriv->dot11PrivacyAlgrthm" and 
 			//"psecuritypriv->dot11PrivacyKeyIndex=keyid", but can rtw_set_key to fw/cam
-
+			
 			if (wep_key_idx >= WEP_KEYS) {
 				ret = -EOPNOTSUPP ;
 				goto exit;
-			}
-
+			}				
+			
 		      _rtw_memcpy(&(psecuritypriv->dot11DefKey[wep_key_idx].skey[0]), pwep->KeyMaterial, pwep->KeyLength);
-			psecuritypriv->dot11DefKeylen[wep_key_idx]=pwep->KeyLength;
+			psecuritypriv->dot11DefKeylen[wep_key_idx]=pwep->KeyLength;	
 			rtw_set_key(padapter, psecuritypriv, wep_key_idx, 0);
 		}
 
-		goto exit;
+		goto exit;		
 	}
 
 	if(padapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X) // 802_1x
@@ -819,44 +819,44 @@ static int wpa_set_encryption(struct net_device *dev, struct ieee_param *param,
 
 		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_MP_STATE) == _TRUE) //sta mode
 		{
-			psta = rtw_get_stainfo(pstapriv, get_bssid(pmlmepriv));
+			psta = rtw_get_stainfo(pstapriv, get_bssid(pmlmepriv));				
 			if (psta == NULL) {
 				//DEBUG_ERR( ("Set wpa_set_encryption: Obtain Sta_info fail \n"));
 			}
 			else
 			{
 				//Jeff: don't disable ieee8021x_blocked while clearing key
-				if (strcmp(param->u.crypt.alg, "none") != 0)
+				if (strcmp(param->u.crypt.alg, "none") != 0) 
 					psta->ieee8021x_blocked = _FALSE;
-
+				
 				if((padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption2Enabled)||
 						(padapter->securitypriv.ndisencryptstatus ==  Ndis802_11Encryption3Enabled))
 				{
 					psta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;
-				}
+				}		
 
 				if(param->u.crypt.set_tx ==1)//pairwise key
-				{
+				{ 
 					_rtw_memcpy(psta->dot118021x_UncstKey.skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
-
+					
 					if(strcmp(param->u.crypt.alg, "TKIP") == 0)//set mic key
-					{
+					{						
 						//DEBUG_ERR(("\nset key length :param->u.crypt.key_len=%d\n", param->u.crypt.key_len));
 						_rtw_memcpy(psta->dot11tkiptxmickey.skey, &(param->u.crypt.key[16]), 8);
 						_rtw_memcpy(psta->dot11tkiprxmickey.skey, &(param->u.crypt.key[24]), 8);
 
 						padapter->securitypriv.busetkipkey=_FALSE;
-						//_set_timer(&padapter->securitypriv.tkip_timer, 50);
+						//_set_timer(&padapter->securitypriv.tkip_timer, 50);						
 					}
 
 					//DEBUG_ERR(("\n param->u.crypt.key_len=%d\n",param->u.crypt.key_len));
 					//DEBUG_ERR(("\n ~~~~stastakey:unicastkey\n"));
 					DBG_871X("\n ~~~~stastakey:unicastkey\n");
-
+					
 					rtw_setstakey_cmd(padapter, (unsigned char *)psta, _TRUE);
 				}
 				else//group key
-				{
+				{ 					
 					if(strcmp(param->u.crypt.alg, "TKIP") == 0 || strcmp(param->u.crypt.alg, "CCMP") == 0)
 					{
 						_rtw_memcpy(padapter->securitypriv.dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key,(param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
@@ -866,12 +866,12 @@ static int wpa_set_encryption(struct net_device *dev, struct ieee_param *param,
 							_rtw_memcpy(padapter->securitypriv.dot118021XGrptxmickey[param->u.crypt.idx].skey,&(param->u.crypt.key[16]),8);
 							_rtw_memcpy(padapter->securitypriv.dot118021XGrprxmickey[param->u.crypt.idx].skey,&(param->u.crypt.key[24]),8);
 						}
-						padapter->securitypriv.binstallGrpkey = _TRUE;
+						padapter->securitypriv.binstallGrpkey = _TRUE;	
 						//DEBUG_ERR((" param->u.crypt.key_len=%d\n", param->u.crypt.key_len));
 						DBG_871X(" ~~~~set sta key:groupkey\n");
-
+	
 						padapter->securitypriv.dot118021XGrpKeyid = param->u.crypt.idx;
-
+	
 						rtw_set_key(padapter,&padapter->securitypriv,param->u.crypt.idx, 1);
 					}
 #ifdef CONFIG_IEEE80211W
@@ -890,15 +890,15 @@ static int wpa_set_encryption(struct net_device *dev, struct ieee_param *param,
 						DBG_871X(" ~~~~set sta key:IGKT\n");
 					}
 #endif //CONFIG_IEEE80211W
-
+					
 #ifdef CONFIG_P2P
 					if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_PROVISIONING_ING))
 					{
 						rtw_p2p_set_state(pwdinfo, P2P_STATE_PROVISIONING_DONE);
 					}
 #endif //CONFIG_P2P
-
-				}
+					
+				}						
 			}
 
 			pbcmc_sta=rtw_get_bcmc_stainfo(padapter);
@@ -909,36 +909,36 @@ static int wpa_set_encryption(struct net_device *dev, struct ieee_param *param,
 			else
 			{
 				//Jeff: don't disable ieee8021x_blocked while clearing key
-				if (strcmp(param->u.crypt.alg, "none") != 0)
+				if (strcmp(param->u.crypt.alg, "none") != 0) 
 					pbcmc_sta->ieee8021x_blocked = _FALSE;
-
+				
 				if((padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption2Enabled)||
 						(padapter->securitypriv.ndisencryptstatus ==  Ndis802_11Encryption3Enabled))
-				{
+				{							
 					pbcmc_sta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;
-				}
-			}
+				}					
+			}				
 		}
 		else if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) //adhoc mode
-		{
-		}
+		{		
+		}			
 	}
 
 exit:
-
+	
 	if (pwep) {
-		rtw_mfree((u8 *)pwep, wep_total_len);
-	}
-
+		rtw_mfree((u8 *)pwep, wep_total_len);		
+	}	
+	
 	_func_exit_;
-
-	return ret;
+	
+	return ret;	
 }
 
 static int rtw_set_wpa_ie(_adapter *padapter, char *pie, unsigned short ielen)
 {
-	u8 *buf=NULL, *pos=NULL;
-	u32 left;
+	u8 *buf=NULL, *pos=NULL;	
+	u32 left; 	
 	int group_cipher = 0, pairwise_cipher = 0;
 	int ret = 0;
 	u8	null_addr[]= {0,0,0,0,0,0};
@@ -948,20 +948,20 @@ static int rtw_set_wpa_ie(_adapter *padapter, char *pie, unsigned short ielen)
 
 	if((ielen > MAX_WPA_IE_LEN) || (pie == NULL)){
 		_clr_fwstate_(&padapter->mlmepriv, WIFI_UNDER_WPS);
-		if(pie == NULL)
+		if(pie == NULL)	
 			return ret;
 		else
 			return -EINVAL;
 	}
 
 	if(ielen)
-	{
+	{		
 		buf = rtw_zmalloc(ielen);
 		if (buf == NULL){
 			ret =  -ENOMEM;
 			goto exit;
 		}
-
+	
 		_rtw_memcpy(buf, pie , ielen);
 
 		//dump
@@ -971,7 +971,7 @@ static int rtw_set_wpa_ie(_adapter *padapter, char *pie, unsigned short ielen)
 			for(i=0;i<ielen;i=i+8)
 				DBG_871X("0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x \n",buf[i],buf[i+1],buf[i+2],buf[i+3],buf[i+4],buf[i+5],buf[i+6],buf[i+7]);
 		}
-
+	
 		pos = buf;
 		if(ielen < RSN_HEADER_LEN){
 			RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("Ie len too short %d\n", ielen));
@@ -982,32 +982,32 @@ static int rtw_set_wpa_ie(_adapter *padapter, char *pie, unsigned short ielen)
 #if 0
 		pos += RSN_HEADER_LEN;
 		left  = ielen - RSN_HEADER_LEN;
-
+		
 		if (left >= RSN_SELECTOR_LEN){
 			pos += RSN_SELECTOR_LEN;
 			left -= RSN_SELECTOR_LEN;
-		}
+		}		
 		else if (left > 0){
 			RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("Ie length mismatch, %u too much \n", left));
 			ret =-1;
 			goto exit;
 		}
-#endif
-
+#endif		
+		
 		if(rtw_parse_wpa_ie(buf, ielen, &group_cipher, &pairwise_cipher) == _SUCCESS)
 		{
 			padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_8021X;
 			padapter->securitypriv.ndisauthtype=Ndis802_11AuthModeWPAPSK;
-			_rtw_memcpy(padapter->securitypriv.supplicant_ie, &buf[0], ielen);
+			_rtw_memcpy(padapter->securitypriv.supplicant_ie, &buf[0], ielen);	
 		}
-
+	
 		if(rtw_parse_wpa2_ie(buf, ielen, &group_cipher, &pairwise_cipher) == _SUCCESS)
 		{
 			padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_8021X;
-			padapter->securitypriv.ndisauthtype=Ndis802_11AuthModeWPA2PSK;
-			_rtw_memcpy(padapter->securitypriv.supplicant_ie, &buf[0], ielen);
+			padapter->securitypriv.ndisauthtype=Ndis802_11AuthModeWPA2PSK;	
+			_rtw_memcpy(padapter->securitypriv.supplicant_ie, &buf[0], ielen);	
 		}
-
+			
 		if (group_cipher == 0)
 		{
 			group_cipher = WPA_CIPHER_NONE;
@@ -1016,7 +1016,7 @@ static int rtw_set_wpa_ie(_adapter *padapter, char *pie, unsigned short ielen)
 		{
 			pairwise_cipher = WPA_CIPHER_NONE;
 		}
-
+			
 		switch(group_cipher)
 		{
 			case WPA_CIPHER_NONE:
@@ -1035,7 +1035,7 @@ static int rtw_set_wpa_ie(_adapter *padapter, char *pie, unsigned short ielen)
 				padapter->securitypriv.dot118021XGrpPrivacy=_AES_;
 				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption3Enabled;
 				break;
-			case WPA_CIPHER_WEP104:
+			case WPA_CIPHER_WEP104:	
 				padapter->securitypriv.dot118021XGrpPrivacy=_WEP104_;
 				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
 				break;
@@ -1059,31 +1059,31 @@ static int rtw_set_wpa_ie(_adapter *padapter, char *pie, unsigned short ielen)
 				padapter->securitypriv.dot11PrivacyAlgrthm=_AES_;
 				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption3Enabled;
 				break;
-			case WPA_CIPHER_WEP104:
+			case WPA_CIPHER_WEP104:	
 				padapter->securitypriv.dot11PrivacyAlgrthm=_WEP104_;
 				padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
 				break;
 		}
-
+		
 		_clr_fwstate_(&padapter->mlmepriv, WIFI_UNDER_WPS);
-		{//set wps_ie
-			u16 cnt = 0;
+		{//set wps_ie	
+			u16 cnt = 0;	
 			u8 eid, wps_oui[4]={0x0,0x50,0xf2,0x04};
-
+			 
 			while( cnt < ielen )
 			{
 				eid = buf[cnt];
-
+		
 				if((eid==_VENDOR_SPECIFIC_IE_)&&(_rtw_memcmp(&buf[cnt+2], wps_oui, 4)==_TRUE))
 				{
 					DBG_871X("SET WPS_IE\n");
 
 					padapter->securitypriv.wps_ie_len = ( (buf[cnt+1]+2) < (MAX_WPA_IE_LEN<<2)) ? (buf[cnt+1]+2):(MAX_WPA_IE_LEN<<2);
-
+					
 					_rtw_memcpy(padapter->securitypriv.wps_ie, &buf[cnt], padapter->securitypriv.wps_ie_len);
-
+					
 					set_fwstate(&padapter->mlmepriv, WIFI_UNDER_WPS);
-
+					
 #ifdef CONFIG_P2P
 					if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_OK))
 					{
@@ -1091,18 +1091,18 @@ static int rtw_set_wpa_ie(_adapter *padapter, char *pie, unsigned short ielen)
 					}
 #endif //CONFIG_P2P
 					cnt += buf[cnt+1]+2;
-
+					
 					break;
 				} else {
-					cnt += buf[cnt+1]+2; //goto next
-				}
-			}
-		}
+					cnt += buf[cnt+1]+2; //goto next	
+				}				
+			}			
+		}		
 	}
 
 	//TKIP and AES disallow multicast packets until installing group key
-	if(padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_
-		|| padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_WTMIC_
+	if(padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_ 
+		|| padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_WTMIC_ 
 		|| padapter->securitypriv.dot11PrivacyAlgrthm == _AES_)
 		//WPS open need to enable multicast
 		//|| check_fwstate(&padapter->mlmepriv, WIFI_UNDER_WPS) == _TRUE)
@@ -1111,16 +1111,16 @@ static int rtw_set_wpa_ie(_adapter *padapter, char *pie, unsigned short ielen)
 	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
 		 ("rtw_set_wpa_ie: pairwise_cipher=0x%08x padapter->securitypriv.ndisencryptstatus=%d padapter->securitypriv.ndisauthtype=%d\n",
 		  pairwise_cipher, padapter->securitypriv.ndisencryptstatus, padapter->securitypriv.ndisauthtype));
-
+ 	
 exit:
 
 	if (buf) rtw_mfree(buf, ielen);
-
-	return ret;
+	
+	return ret;	
 }
 
-static int rtw_wx_get_name(struct net_device *dev,
-			     struct iw_request_info *info,
+static int rtw_wx_get_name(struct net_device *dev, 
+			     struct iw_request_info *info, 
 			     union iwreq_data *wrqu, char *extra)
 {
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
@@ -1134,7 +1134,7 @@ static int rtw_wx_get_name(struct net_device *dev,
 
 	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("cmd_code=%x\n", info->cmd));
 
-	_func_enter_;
+	_func_enter_;	
 
 	if (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE) == _TRUE)
 	{
@@ -1191,27 +1191,27 @@ static int rtw_wx_get_name(struct net_device *dev,
 	return 0;
 }
 
-static int rtw_wx_set_freq(struct net_device *dev,
-			     struct iw_request_info *info,
+static int rtw_wx_set_freq(struct net_device *dev, 
+			     struct iw_request_info *info, 
 			     union iwreq_data *wrqu, char *extra)
-{
+{	
 	_func_enter_;
 
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_, ("+rtw_wx_set_freq\n"));
 
 	_func_exit_;
-
+	
 	return 0;
 }
 
-static int rtw_wx_get_freq(struct net_device *dev,
-			     struct iw_request_info *info,
+static int rtw_wx_get_freq(struct net_device *dev, 
+			     struct iw_request_info *info, 
 			     union iwreq_data *wrqu, char *extra)
 {
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
 	WLAN_BSSID_EX  *pcur_bss = &pmlmepriv->cur_network.network;
-
+	
 	if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE)
 	{
 		//wrqu->freq.m = ieee80211_wlan_frequencies[pcur_bss->Configuration.DSConfig-1] * 100000;
@@ -1239,7 +1239,7 @@ static int rtw_wx_set_mode(struct net_device *dev, struct iw_request_info *a,
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	_queue *queue = &pmlmepriv->scanned_queue;
 	_func_enter_;
-
+	
 	if(_FAIL == rtw_pwr_wakeup(padapter)) {
 		ret= -EPERM;
 		goto exit;
@@ -1249,41 +1249,41 @@ static int rtw_wx_set_mode(struct net_device *dev, struct iw_request_info *a,
 		ret = -EPERM;
 		goto exit;
 	}
-
+	
 	switch(wrqu->mode)
 	{
 		case IW_MODE_AUTO:
 			networkType = Ndis802_11AutoUnknown;
-			DBG_871X("set_mode = IW_MODE_AUTO\n");
-			break;
-		case IW_MODE_ADHOC:
+			DBG_871X("set_mode = IW_MODE_AUTO\n");	
+			break;				
+		case IW_MODE_ADHOC:		
 			networkType = Ndis802_11IBSS;
-			DBG_871X("set_mode = IW_MODE_ADHOC\n");
+			DBG_871X("set_mode = IW_MODE_ADHOC\n");			
 			break;
-		case IW_MODE_MASTER:
+		case IW_MODE_MASTER:		
 			networkType = Ndis802_11APMode;
 			DBG_871X("set_mode = IW_MODE_MASTER\n");
-                        //rtw_setopmode_cmd(padapter, networkType);
-			break;
+                        //rtw_setopmode_cmd(padapter, networkType);	
+			break;				
 		case IW_MODE_INFRA:
 			networkType = Ndis802_11Infrastructure;
-			DBG_871X("set_mode = IW_MODE_INFRA\n");
+			DBG_871X("set_mode = IW_MODE_INFRA\n");			
 			break;
-
+	
 		default :
 			ret = -EINVAL;;
 			RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("\n Mode: %s is not supported  \n", iw_operation_mode[wrqu->mode]));
 			goto exit;
 	}
-
-/*
+	
+/*	
 	if(Ndis802_11APMode == networkType)
 	{
 		rtw_setopmode_cmd(padapter, networkType);
-	}
+	}	
 	else
 	{
-		rtw_setopmode_cmd(padapter, Ndis802_11AutoUnknown);
+		rtw_setopmode_cmd(padapter, Ndis802_11AutoUnknown);	
 	}
 */
 	_enter_critical_bh(&pmlmepriv->lock, &irqL);
@@ -1301,11 +1301,11 @@ static int rtw_wx_set_mode(struct net_device *dev, struct iw_request_info *a,
 	rtw_setopmode_cmd(padapter, networkType);
 
 exit:
-
+	
 	_func_exit_;
-
+	
 	return ret;
-
+	
 }
 
 static int rtw_wx_get_mode(struct net_device *dev, struct iw_request_info *a,
@@ -1313,18 +1313,18 @@ static int rtw_wx_get_mode(struct net_device *dev, struct iw_request_info *a,
 {
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
-
+	
 	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,(" rtw_wx_get_mode \n"));
 
 	_func_enter_;
-
+	
 	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == _TRUE)
 	{
 		wrqu->mode = IW_MODE_INFRA;
 	}
 	else if  ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == _TRUE) ||
 		       (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE))
-
+		
 	{
 		wrqu->mode = IW_MODE_ADHOC;
 	}
@@ -1338,9 +1338,9 @@ static int rtw_wx_get_mode(struct net_device *dev, struct iw_request_info *a,
 	}
 
 	_func_exit_;
-
+	
 	return 0;
-
+	
 }
 
 
@@ -1356,7 +1356,7 @@ static int rtw_wx_set_pmkid(struct net_device *dev,
         struct iw_pmksa*  pPMK = ( struct iw_pmksa* ) extra;
         u8     strZeroMacAddress[ ETH_ALEN ] = { 0x00 };
         u8     strIssueBssid[ ETH_ALEN ] = { 0x00 };
-
+        
 /*
         struct iw_pmksa
         {
@@ -1383,13 +1383,13 @@ static int rtw_wx_set_pmkid(struct net_device *dev,
                     intReturn = _TRUE;
                 }
 		blInserted = _FALSE;
-
+		
 		//overwrite PMKID
 		for(j=0 ; j<NUM_PMKID_CACHE; j++)
 		{
 			if( _rtw_memcmp( psecuritypriv->PMKIDList[j].Bssid, strIssueBssid, ETH_ALEN) ==_TRUE )
 			{ // BSSID is matched, the same AP => rewrite with new PMKID.
-
+                                
                                 DBG_871X( "[rtw_wx_set_pmkid] BSSID exists in the PMKList.\n" );
 
 				_rtw_memcpy( psecuritypriv->PMKIDList[j].PMKID, pPMK->pmkid, IW_PMKID_LEN);
@@ -1397,7 +1397,7 @@ static int rtw_wx_set_pmkid(struct net_device *dev,
 				psecuritypriv->PMKIDIndex = j+1;
 				blInserted = _TRUE;
 				break;
-			}
+			}	
 	        }
 
 	        if(!blInserted)
@@ -1424,14 +1424,14 @@ static int rtw_wx_set_pmkid(struct net_device *dev,
 		for(j=0 ; j<NUM_PMKID_CACHE; j++)
 		{
 			if( _rtw_memcmp( psecuritypriv->PMKIDList[j].Bssid, strIssueBssid, ETH_ALEN) ==_TRUE )
-			{ // BSSID is matched, the same AP => Remove this PMKID information and reset it.
+			{ // BSSID is matched, the same AP => Remove this PMKID information and reset it. 
                                 _rtw_memset( psecuritypriv->PMKIDList[ j ].Bssid, 0x00, ETH_ALEN );
                                 psecuritypriv->PMKIDList[ j ].bUsed = _FALSE;
 				break;
-			}
+			}	
 	        }
         }
-        else if ( pPMK->cmd == IW_PMKSA_FLUSH )
+        else if ( pPMK->cmd == IW_PMKSA_FLUSH ) 
         {
             DBG_871X( "[rtw_wx_set_pmkid] IW_PMKSA_FLUSH!\n" );
             _rtw_memset( &psecuritypriv->PMKIDList[ 0 ], 0x00, sizeof( RT_PMKID_LIST ) * NUM_PMKID_CACHE );
@@ -1441,14 +1441,14 @@ static int rtw_wx_set_pmkid(struct net_device *dev,
     return( intReturn );
 }
 
-static int rtw_wx_get_sens(struct net_device *dev,
-			     struct iw_request_info *info,
+static int rtw_wx_get_sens(struct net_device *dev, 
+			     struct iw_request_info *info, 
 			     union iwreq_data *wrqu, char *extra)
 {
 	#ifdef CONFIG_PLATFORM_ROCKCHIPS
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
-	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv); 
+	
 	/*
 	*  20110311 Commented by Jeff
 	*  For rockchip platform's wpa_driver_wext_get_rssi
@@ -1457,8 +1457,8 @@ static int rtw_wx_get_sens(struct net_device *dev,
 		//wrqu->sens.value=-padapter->recvpriv.signal_strength;
 		wrqu->sens.value=-padapter->recvpriv.rssi;
 		//DBG_871X("%s: %d\n", __FUNCTION__, wrqu->sens.value);
-		wrqu->sens.fixed = 0; /* no auto select */
-	} else
+		wrqu->sens.fixed = 0; /* no auto select */ 
+	} else 
 	#endif
 	{
 		wrqu->sens.value = 0;
@@ -1468,8 +1468,8 @@ static int rtw_wx_get_sens(struct net_device *dev,
 	return 0;
 }
 
-static int rtw_wx_get_range(struct net_device *dev,
-				struct iw_request_info *info,
+static int rtw_wx_get_range(struct net_device *dev, 
+				struct iw_request_info *info, 
 				union iwreq_data *wrqu, char *extra)
 {
 	struct iw_range *range = (struct iw_range *)extra;
@@ -1478,9 +1478,9 @@ static int rtw_wx_get_range(struct net_device *dev,
 
 	u16 val;
 	int i;
-
+	
 	_func_enter_;
-
+	
 	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_wx_get_range. cmd_code=%x\n", info->cmd));
 
 	wrqu->data.length = sizeof(*range);
@@ -1495,7 +1495,7 @@ static int rtw_wx_get_range(struct net_device *dev,
 	 */
 
 	/* ~5 Mb/s real (802.11b) */
-	range->throughput = 5 * 1000 * 1000;
+	range->throughput = 5 * 1000 * 1000;     
 
 	// TODO: Not used in 802.11b?
 //	range->min_nwid;	/* Minimal NWID we are able to set */
@@ -1503,14 +1503,14 @@ static int rtw_wx_get_range(struct net_device *dev,
 //	range->max_nwid;	/* Maximal NWID we are able to set */
 
         /* Old Frequency (backward compat - moved lower ) */
-//	range->old_num_channels;
+//	range->old_num_channels; 
 //	range->old_num_frequency;
 //	range->old_freq[6]; /* Filler to keep "version" at the same offset */
 
 	/* signal level threshold range */
 
 	//percent values between 0 and 100.
-	range->max_qual.qual = 100;
+	range->max_qual.qual = 100;	
 	range->max_qual.level = 100;
 	range->max_qual.noise = 100;
 	range->max_qual.updated = 7; /* Updated all three */
@@ -1615,7 +1615,7 @@ static int rtw_wx_set_wap(struct net_device *dev,
 	_queue	*queue	= &(pmlmepriv->scanned_queue);
 	struct	wlan_network	*pnetwork = NULL;
 	NDIS_802_11_AUTHENTICATION_MODE	authmode;
-
+	
 	_func_enter_;
 /*
 #ifdef CONFIG_CONCURRENT_MODE
@@ -1624,16 +1624,16 @@ static int rtw_wx_set_wap(struct net_device *dev,
 		ret = -EINVAL;
 		goto exit;
 	}
-#endif
-*/
+#endif	
+*/	
 
 #ifdef CONFIG_CONCURRENT_MODE
 	if (check_buddy_fwstate(padapter, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE)
-	{
+	{		
 		printk("set bssid, but buddy_intf is under scanning or linking\n");
 
 		ret = -EINVAL;
-
+		
 		goto exit;
 	}
 #endif
@@ -1652,13 +1652,13 @@ static int rtw_wx_set_wap(struct net_device *dev,
 		ret= -1;
 		goto exit;
 	}
-
+	
 	if(!padapter->bup){
 		ret = -1;
 		goto exit;
 	}
 
-
+	
 	if (temp->sa_family != ARPHRD_ETHER){
 		ret = -EINVAL;
 		goto exit;
@@ -1672,17 +1672,17 @@ static int rtw_wx_set_wap(struct net_device *dev,
 
 	while (1)
 	 {
-
+			
 		if ((rtw_end_of_queue_search(phead, pmlmepriv->pscanned)) == _TRUE)
 		{
-#if 0
+#if 0		
 			ret = -EINVAL;
 			goto exit;
 
 			if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE)
 			{
-				rtw_set_802_11_bssid(padapter, temp->sa_data);
-				goto exit;
+	            		rtw_set_802_11_bssid(padapter, temp->sa_data);
+	    			goto exit;                    
 			}
 			else
 			{
@@ -1693,7 +1693,7 @@ static int rtw_wx_set_wap(struct net_device *dev,
 
 			break;
 		}
-
+	
 		pnetwork = LIST_CONTAINOR(pmlmepriv->pscanned, struct wlan_network, list);
 
 		pmlmepriv->pscanned = get_next(pmlmepriv->pscanned);
@@ -1703,7 +1703,7 @@ static int rtw_wx_set_wap(struct net_device *dev,
 		src_bssid = temp->sa_data;
 
 		if ((_rtw_memcmp(dst_bssid, src_bssid, ETH_ALEN)) == _TRUE)
-		{
+		{			
 			if(!rtw_set_802_11_infrastructure_mode(padapter, pnetwork->network.InfrastructureMode))
 			{
 				ret = -1;
@@ -1712,44 +1712,44 @@ static int rtw_wx_set_wap(struct net_device *dev,
 				goto exit;
 			}
 
-				break;
+				break;			
 		}
 
-	}
+	}		
 	_exit_critical_bh(&queue->lock, &irqL);
 	_exit_critical_bh(&pmlmepriv->lock, &irqL);
 	rtw_set_802_11_authentication_mode(padapter, authmode);
 	//set_802_11_encryption_mode(padapter, padapter->securitypriv.ndisencryptstatus);
 	if (rtw_set_802_11_bssid(padapter, temp->sa_data) == _FALSE) {
 		ret = -1;
-		goto exit;
-	}
-
+		goto exit;		
+	}	
+	
 exit:
-
+	
 	_func_exit_;
-
-	return ret;
+	
+	return ret;	
 }
 
-static int rtw_wx_get_wap(struct net_device *dev,
-			    struct iw_request_info *info,
+static int rtw_wx_get_wap(struct net_device *dev, 
+			    struct iw_request_info *info, 
 			    union iwreq_data *wrqu, char *extra)
 {
 
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
 	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
-	WLAN_BSSID_EX  *pcur_bss = &pmlmepriv->cur_network.network;
-
+	WLAN_BSSID_EX  *pcur_bss = &pmlmepriv->cur_network.network;	
+	
 	wrqu->ap_addr.sa_family = ARPHRD_ETHER;
-
+	
 	_rtw_memset(wrqu->ap_addr.sa_data, 0, ETH_ALEN);
-
+	
 	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_wx_get_wap\n"));
 
 	_func_enter_;
 
-	if  ( ((check_fwstate(pmlmepriv, _FW_LINKED)) == _TRUE) ||
+	if  ( ((check_fwstate(pmlmepriv, _FW_LINKED)) == _TRUE) || 
 			((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) == _TRUE) ||
 			((check_fwstate(pmlmepriv, WIFI_AP_STATE)) == _TRUE) )
 	{
@@ -1758,17 +1758,17 @@ static int rtw_wx_get_wap(struct net_device *dev,
 	}
 	else
 	{
-		_rtw_memset(wrqu->ap_addr.sa_data, 0, ETH_ALEN);
-	}
+	 	_rtw_memset(wrqu->ap_addr.sa_data, 0, ETH_ALEN);
+	}		
 
 	_func_exit_;
-
+	
 	return 0;
-
+	
 }
 
-static int rtw_wx_set_mlme(struct net_device *dev,
-			     struct iw_request_info *info,
+static int rtw_wx_set_mlme(struct net_device *dev, 
+			     struct iw_request_info *info, 
 			     union iwreq_data *wrqu, char *extra)
 {
 #if 0
@@ -1785,7 +1785,7 @@ struct	iw_mlme
 	u16 reason;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct iw_mlme *mlme = (struct iw_mlme *) extra;
-
+	
 
 	if(mlme==NULL)
 		return -1;
@@ -1797,38 +1797,38 @@ struct	iw_mlme
 
 	printk("%s, cmd=%d, reason=%d\n", __FUNCTION__, mlme->cmd, reason);
 
-	switch (mlme->cmd)
+	switch (mlme->cmd) 
 	{
-		case IW_MLME_DEAUTH:
+		case IW_MLME_DEAUTH:			
 				if(!rtw_set_802_11_disassociate(padapter))
-				ret = -1;
+				ret = -1;						
 				break;
-
-		case IW_MLME_DISASSOC:
+				
+		case IW_MLME_DISASSOC:			
 				if(!rtw_set_802_11_disassociate(padapter))
-						ret = -1;
-
+						ret = -1;		
+				
 				break;
-
+				
 		default:
 			return -EOPNOTSUPP;
 	}
-
+	
 	return ret;
-
+	
 }
 
 static int rtw_wx_set_scan(struct net_device *dev, struct iw_request_info *a,
 			     union iwreq_data *wrqu, char *extra)
 {
 	u8 _status = _FALSE;
-	int ret = 0;
+	int ret = 0;	
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct mlme_priv *pmlmepriv= &padapter->mlmepriv;
 	NDIS_802_11_SSID ssid[RTW_SSID_SCAN_AMOUNT];
 	_irqL	irqL;
 #ifdef CONFIG_P2P
-	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
+	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);	
 #endif //CONFIG_P2P
 	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("rtw_wx_set_scan\n"));
 
@@ -1866,12 +1866,12 @@ static int rtw_wx_set_scan(struct net_device *dev, struct iw_request_info *a,
 		ret= -1;
 		goto exit;
 	}
-
+	
 	if(!padapter->bup){
 		ret = -1;
 		goto exit;
 	}
-
+	
 	if (padapter->hw_init_completed==_FALSE){
 		ret = -1;
 		goto exit;
@@ -1884,26 +1884,26 @@ static int rtw_wx_set_scan(struct net_device *dev, struct iw_request_info *a,
 	{
 		indicate_wx_scan_complete_event(padapter);
 		goto exit;
-	}
+	} 
 
 	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE)
 	{
 		indicate_wx_scan_complete_event(padapter);
 		goto exit;
-	}
+	} 
 
 #ifdef CONFIG_CONCURRENT_MODE
 	if (check_buddy_fwstate(padapter,
 		_FW_UNDER_SURVEY|_FW_UNDER_LINKING|WIFI_UNDER_WPS) == _TRUE)
-	{
+	{		
 		if(check_buddy_fwstate(padapter, _FW_UNDER_SURVEY))
 		{
 			printk("scanning_via_buddy_intf\n");
 			pmlmepriv->scanning_via_buddy_intf = _TRUE;
-		}
+		}		
 
 		indicate_wx_scan_complete_event(padapter);
-
+		
 		goto exit;
 	}
 #endif
@@ -1931,7 +1931,7 @@ static int rtw_wx_set_scan(struct net_device *dev, struct iw_request_info *a,
 		ret = 0;
 		goto exit;
 	}
-
+		
 */
 #ifdef CONFIG_P2P
 	if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
@@ -1946,31 +1946,31 @@ static int rtw_wx_set_scan(struct net_device *dev, struct iw_request_info *a,
 	_rtw_memset(ssid, 0, sizeof(NDIS_802_11_SSID)*RTW_SSID_SCAN_AMOUNT);
 
 #if WIRELESS_EXT >= 17
-	if (wrqu->data.length == sizeof(struct iw_scan_req))
+	if (wrqu->data.length == sizeof(struct iw_scan_req)) 
 	{
 		struct iw_scan_req *req = (struct iw_scan_req *)extra;
-
+	
 		if (wrqu->data.flags & IW_SCAN_THIS_ESSID)
 		{
 			int len = min((int)req->essid_len, IW_ESSID_MAX_SIZE);
 
 			_rtw_memcpy(ssid[0].Ssid, req->essid, len);
-			ssid[0].SsidLength = len;
+			ssid[0].SsidLength = len;	
 
 			DBG_871X("IW_SCAN_THIS_ESSID, ssid=%s, len=%d\n", req->essid, req->essid_len);
-
-			_enter_critical_bh(&pmlmepriv->lock, &irqL);
-
+		
+			_enter_critical_bh(&pmlmepriv->lock, &irqL);				
+		
 			_status = rtw_sitesurvey_cmd(padapter, ssid, 1, NULL, 0);
-
+		
 			_exit_critical_bh(&pmlmepriv->lock, &irqL);
-
+			
 		}
 		else if (req->scan_type == IW_SCAN_TYPE_PASSIVE)
 		{
 			DBG_871X("rtw_wx_set_scan, req->scan_type == IW_SCAN_TYPE_PASSIVE\n");
 		}
-
+		
 	}
 	else
 #endif
@@ -1986,7 +1986,7 @@ static int rtw_wx_set_scan(struct net_device *dev, struct iw_request_info *a,
 		int ssid_index = 0;
 
 		//DBG_871X("%s COMBO_SCAN header is recognized\n", __FUNCTION__);
-
+		
 		while(len >= 1) {
 			section = *(pos++); len-=1;
 
@@ -1997,7 +1997,7 @@ static int rtw_wx_set_scan(struct net_device *dev, struct iw_request_info *a,
 						len = 0;
 						break;
 					}
-
+					
 					sec_len = *(pos++); len-=1;
 
 					if(sec_len>0 && sec_len<=len) {
@@ -2007,11 +2007,11 @@ static int rtw_wx_set_scan(struct net_device *dev, struct iw_request_info *a,
 						//	, ssid[ssid_index].Ssid, ssid[ssid_index].SsidLength);
 						ssid_index++;
 					}
-
+					
 					pos+=sec_len; len-=sec_len;
 					break;
-
-
+					
+				
 				case WEXT_CSCAN_CHANNEL_SECTION:
 					//DBG_871X("WEXT_CSCAN_CHANNEL_SECTION\n");
 					pos+=1; len-=1;
@@ -2022,7 +2022,7 @@ static int rtw_wx_set_scan(struct net_device *dev, struct iw_request_info *a,
 					break;
 				case WEXT_CSCAN_PASV_DWELL_SECTION:
 					//DBG_871X("WEXT_CSCAN_PASV_DWELL_SECTION\n");
-					pos+=2; len-=2;
+					pos+=2; len-=2;					
 					break;
 				case WEXT_CSCAN_HOME_DWELL_SECTION:
 					//DBG_871X("WEXT_CSCAN_HOME_DWELL_SECTION\n");
@@ -2037,20 +2037,20 @@ static int rtw_wx_set_scan(struct net_device *dev, struct iw_request_info *a,
 					DBG_871X("WEXT_CSCAN_NPROBE_SECTION\n");
 					break;
 				#endif
-
+				
 				default:
 					//DBG_871X("Unknown CSCAN section %c\n", section);
 					len = 0; // stop parsing
 			}
 			//DBG_871X("len:%d\n", len);
-
+			
 		}
-
+		
 		//jeff: it has still some scan paramater to parse, we only do this now...
 		_status = rtw_set_802_11_bssid_list_scan(padapter, ssid, RTW_SSID_SCAN_AMOUNT);
-
+		
 	} else
-
+	
 	{
 		_status = rtw_set_802_11_bssid_list_scan(padapter, NULL, 0);
 	}
@@ -2065,7 +2065,7 @@ static int rtw_wx_set_scan(struct net_device *dev, struct iw_request_info *a,
 
 _func_exit_;
 
-	return ret;
+	return ret;	
 }
 
 static int rtw_wx_get_scan(struct net_device *dev, struct iw_request_info *a,
@@ -2075,18 +2075,18 @@ static int rtw_wx_get_scan(struct net_device *dev, struct iw_request_info *a,
 	_list					*plist, *phead;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
-	_queue				*queue	= &(pmlmepriv->scanned_queue);
+	_queue				*queue	= &(pmlmepriv->scanned_queue);	
 	struct	wlan_network	*pnetwork = NULL;
 	char *ev = extra;
 	char *stop = ev + wrqu->data.length;
-	u32 ret = 0;
+	u32 ret = 0;	
 	u32 cnt=0;
 	u32 wait_for_surveydone;
 	sint wait_status;
-#ifdef CONFIG_CONCURRENT_MODE
+#ifdef CONFIG_CONCURRENT_MODE	
 	//PADAPTER pbuddy_adapter = padapter->pbuddy_adapter;
-	//struct mlme_priv *pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
-#endif
+	//struct mlme_priv *pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);	
+#endif	
 #ifdef CONFIG_P2P
 	struct	wifidirect_info*	pwdinfo = &padapter->wdinfo;
 #endif //CONFIG_P2P
@@ -2094,11 +2094,11 @@ static int rtw_wx_get_scan(struct net_device *dev, struct iw_request_info *a,
 	RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_info_, (" Start of Query SIOCGIWSCAN .\n"));
 
 	_func_enter_;
-
+	
 	#ifdef DBG_IOCTL
 	DBG_871X("DBG_IOCTL %s:%d\n",__FUNCTION__, __LINE__);
 	#endif
-
+	
 /*
 #ifdef CONFIG_CONCURRENT_MODE
 	if(padapter->iface_type > PRIMARY_IFACE)
@@ -2107,13 +2107,13 @@ static int rtw_wx_get_scan(struct net_device *dev, struct iw_request_info *a,
 		goto exit;
 	}
 #endif
-*/
+*/	
 	if(padapter->pwrctrlpriv.brfoffbyhw && padapter->bDriverStopped)
 	{
 		ret = -EINVAL;
 		goto exit;
 	}
-
+  
 #ifdef CONFIG_P2P
 	if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 	{
@@ -2135,7 +2135,7 @@ static int rtw_wx_get_scan(struct net_device *dev, struct iw_request_info *a,
 #endif //CONFIG_P2P
 
 /*
-#ifdef CONFIG_CONCURRENT_MODE
+#ifdef CONFIG_CONCURRENT_MODE	
 	if(pmlmepriv->scanning_via_buddy_intf == _TRUE)
 	{
 		pmlmepriv->scanning_via_buddy_intf = _FALSE;//reset
@@ -2143,10 +2143,10 @@ static int rtw_wx_get_scan(struct net_device *dev, struct iw_request_info *a,
 		// change pointers to buddy interface
 		padapter = pbuddy_adapter;
 		pmlmepriv = pbuddy_mlmepriv;
-		queue = &(pbuddy_mlmepriv->scanned_queue);
-
+		queue = &(pbuddy_mlmepriv->scanned_queue);		
+		
 	}
-#endif // CONFIG_CONCURRENT_MODE
+#endif // CONFIG_CONCURRENT_MODE			
 */
 
 	wait_status = _FW_UNDER_SURVEY
@@ -2165,8 +2165,8 @@ static int rtw_wx_get_scan(struct net_device *dev, struct iw_request_info *a,
 	}
 #endif // CONFIG_DUALMAC_CONCURRENT
 
-	while(check_fwstate(pmlmepriv, wait_status) == _TRUE)
-	{
+ 	while(check_fwstate(pmlmepriv, wait_status) == _TRUE)
+	{	
 		rtw_msleep_os(30);
 		cnt++;
 		if(cnt > wait_for_surveydone )
@@ -2177,7 +2177,7 @@ static int rtw_wx_get_scan(struct net_device *dev, struct iw_request_info *a,
 
 	phead = get_list_head(queue);
 	plist = get_next(phead);
-
+       
 	while(1)
 	{
 		if (rtw_end_of_queue_search(phead,plist)== _TRUE)
@@ -2200,24 +2200,24 @@ static int rtw_wx_get_scan(struct net_device *dev, struct iw_request_info *a,
 		}
 
 		plist = get_next(plist);
-
-	}
+	
+	}        
 
 	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
 
        wrqu->data.length = ev-extra;
 	wrqu->data.flags = 0;
-
-exit:
-
-	_func_exit_;
-
+	
+exit:		
+	
+	_func_exit_;	
+	
 	#ifdef DBG_IOCTL
 	DBG_871X("DBG_IOCTL %s:%d return %d\n",__FUNCTION__, __LINE__, ret);
 	#endif
-
+	
 	return ret ;
-
+	
 }
 
 //set ssid flow
@@ -2225,7 +2225,7 @@ static int rtw_wx_get_scan(struct net_device *dev, struct iw_request_info *a,
 //s2. set_802_11_authenticaion_mode()
 //s3. set_802_11_encryption_mode()
 //s4. rtw_set_802_11_ssid()
-static int rtw_wx_set_essid(struct net_device *dev,
+static int rtw_wx_set_essid(struct net_device *dev, 
 			      struct iw_request_info *a,
 			      union iwreq_data *wrqu, char *extra)
 {
@@ -2237,18 +2237,18 @@ static int rtw_wx_set_essid(struct net_device *dev,
 	_list *phead;
 	s8 status = _TRUE;
 	struct wlan_network *pnetwork = NULL;
-	NDIS_802_11_AUTHENTICATION_MODE authmode;
-	NDIS_802_11_SSID ndis_ssid;
+	NDIS_802_11_AUTHENTICATION_MODE authmode;	
+	NDIS_802_11_SSID ndis_ssid;	
 	u8 *dst_ssid, *src_ssid;
 
 	uint ret = 0, len;
 
 	_func_enter_;
-
+	
 	#ifdef DBG_IOCTL
 	DBG_871X("DBG_IOCTL %s:%d\n",__FUNCTION__, __LINE__);
 	#endif
-
+	
 /*
 #ifdef CONFIG_CONCURRENT_MODE
 	if(padapter->iface_type > PRIMARY_IFACE)
@@ -2261,11 +2261,11 @@ static int rtw_wx_set_essid(struct net_device *dev,
 
 #ifdef CONFIG_CONCURRENT_MODE
 	if (check_buddy_fwstate(padapter, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == _TRUE)
-	{
+	{		
 		printk("set ssid, but buddy_intf is under scanning or linking\n");
-
+		
 		ret = -EINVAL;
-
+		
 		goto exit;
 	}
 #endif
@@ -2282,7 +2282,7 @@ static int rtw_wx_set_essid(struct net_device *dev,
 	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
 		 ("+rtw_wx_set_essid: fw_state=0x%08x\n", get_fwstate(pmlmepriv)));
 	if(_FAIL == rtw_pwr_wakeup(padapter))
-	{
+	{		
 		ret = -1;
 		goto exit;
 	}
@@ -2300,12 +2300,12 @@ static int rtw_wx_set_essid(struct net_device *dev,
 		ret= -E2BIG;
 		goto exit;
 	}
-
+	
 	if(check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
 		ret = -1;
 		goto exit;
-	}
-
+	}		
+	
 	authmode = padapter->securitypriv.ndisauthtype;
 	DBG_871X("=>%s\n",__FUNCTION__);
 	if (wrqu->essid.flags && wrqu->essid.length)
@@ -2314,7 +2314,7 @@ static int rtw_wx_set_essid(struct net_device *dev,
 		// We got the codes in "set_info" function of iwconfig source code.
 		//	=========================================
 		//	wrq.u.essid.length = strlen(essid) + 1;
-		//	if(we_kernel_version > 20)
+	  	//	if(we_kernel_version > 20)
 		//		wrq.u.essid.length--;
 		//	=========================================
 		//	That means, if the WIRELESS_EXT less than or equal to 20, the correct ssid len should subtract 1.
@@ -2329,9 +2329,9 @@ static int rtw_wx_set_essid(struct net_device *dev,
 
 		_rtw_memset(&ndis_ssid, 0, sizeof(NDIS_802_11_SSID));
 		ndis_ssid.SsidLength = len;
-		_rtw_memcpy(ndis_ssid.Ssid, extra, len);
+		_rtw_memcpy(ndis_ssid.Ssid, extra, len);		
 		src_ssid = ndis_ssid.Ssid;
-
+		
 		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_, ("rtw_wx_set_essid: ssid=[%s]\n", src_ssid));
 		_enter_critical_bh(&pmlmepriv->lock, &irqL);
 		_enter_critical_bh(&queue->lock, &irqL);
@@ -2339,15 +2339,15 @@ static int rtw_wx_set_essid(struct net_device *dev,
               pmlmepriv->pscanned = get_next(phead);
 
 		while (1)
-		{
+		{			
 			if (rtw_end_of_queue_search(phead, pmlmepriv->pscanned) == _TRUE)
 			{
-#if 0
+#if 0			
 				if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE)
 				{
-					rtw_set_802_11_ssid(padapter, &ndis_ssid);
+	            			rtw_set_802_11_ssid(padapter, &ndis_ssid);
 
-					goto exit;
+		    			goto exit;                    
 				}
 				else
 				{
@@ -2355,13 +2355,13 @@ static int rtw_wx_set_essid(struct net_device *dev,
 					ret = -EINVAL;
 					goto exit;
 				}
-#endif
+#endif			
 			        RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_warning_,
 					 ("rtw_wx_set_essid: scan_q is empty, set ssid to check if scanning again!\n"));
 
 				break;
 			}
-
+	
 			pnetwork = LIST_CONTAINOR(pmlmepriv->pscanned, struct wlan_network, list);
 
 			pmlmepriv->pscanned = get_next(pmlmepriv->pscanned);
@@ -2377,13 +2377,13 @@ static int rtw_wx_set_essid(struct net_device *dev,
 			{
 				RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
 					 ("rtw_wx_set_essid: find match, set infra mode\n"));
-
+				
 				if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == _TRUE)
 				{
 					if(pnetwork->network.InfrastructureMode != pmlmepriv->cur_network.network.InfrastructureMode)
 						continue;
-				}
-
+				}	
+					
 				if (rtw_set_802_11_infrastructure_mode(padapter, pnetwork->network.InfrastructureMode) == _FALSE)
 				{
 					ret = -1;
@@ -2392,7 +2392,7 @@ static int rtw_wx_set_essid(struct net_device *dev,
 					goto exit;
 				}
 
-				break;
+				break;			
 			}
 		}
 		_exit_critical_bh(&queue->lock, &irqL);
@@ -2404,23 +2404,23 @@ static int rtw_wx_set_essid(struct net_device *dev,
 		if (rtw_set_802_11_ssid(padapter, &ndis_ssid) == _FALSE) {
 			ret = -1;
 			goto exit;
-		}
-	}
-
+		}	
+	}			
+	
 exit:
 
 	DBG_871X("<=%s, ret %d\n",__FUNCTION__, ret);
-
+	
 	#ifdef DBG_IOCTL
 	DBG_871X("DBG_IOCTL %s:%d return %d\n",__FUNCTION__, __LINE__, ret);
 	#endif
-
+	
 	_func_exit_;
-
-	return ret;
+	
+	return ret;	
 }
 
-static int rtw_wx_get_essid(struct net_device *dev,
+static int rtw_wx_get_essid(struct net_device *dev, 
 			      struct iw_request_info *a,
 			      union iwreq_data *wrqu, char *extra)
 {
@@ -2439,7 +2439,7 @@ static int rtw_wx_get_essid(struct net_device *dev,
 		len = pcur_bss->Ssid.SsidLength;
 
 		wrqu->essid.length = len;
-
+			
 		_rtw_memcpy(extra, pcur_bss->Ssid.Ssid, len);
 
 		wrqu->essid.flags = 1;
@@ -2451,14 +2451,14 @@ static int rtw_wx_get_essid(struct net_device *dev,
 	}
 
 exit:
-
+	
 	_func_exit_;
-
+	
 	return ret;
-
+	
 }
 
-static int rtw_wx_set_rate(struct net_device *dev,
+static int rtw_wx_set_rate(struct net_device *dev, 
 			      struct iw_request_info *a,
 			      union iwreq_data *wrqu, char *extra)
 {
@@ -2474,7 +2474,7 @@ static int rtw_wx_set_rate(struct net_device *dev,
 
 	RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,(" rtw_wx_set_rate \n"));
 	RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_info_,("target_rate = %d, fixed = %d\n",target_rate,fixed));
-
+	
 	if(target_rate == -1){
 		ratevalue = 11;
 		goto set_rate;
@@ -2550,127 +2550,127 @@ static int rtw_wx_set_rate(struct net_device *dev,
 	return ret;
 }
 
-static int rtw_wx_get_rate(struct net_device *dev,
-			     struct iw_request_info *info,
+static int rtw_wx_get_rate(struct net_device *dev, 
+			     struct iw_request_info *info, 
 			     union iwreq_data *wrqu, char *extra)
-{
+{	
 	u16 max_rate = 0;
 
 	max_rate = rtw_get_cur_max_rate((_adapter *)rtw_netdev_priv(dev));
 
 	if(max_rate == 0)
 		return -EPERM;
-
+	
 	wrqu->bitrate.fixed = 0;	/* no auto select */
 	wrqu->bitrate.value = max_rate * 100000;
 
 	return 0;
 }
 
-static int rtw_wx_set_rts(struct net_device *dev,
-			     struct iw_request_info *info,
+static int rtw_wx_set_rts(struct net_device *dev, 
+			     struct iw_request_info *info, 
 			     union iwreq_data *wrqu, char *extra)
 {
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 
 	_func_enter_;
-
+	
 	if (wrqu->rts.disabled)
 		padapter->registrypriv.rts_thresh = 2347;
 	else {
 		if (wrqu->rts.value < 0 ||
 		    wrqu->rts.value > 2347)
 			return -EINVAL;
-
+		
 		padapter->registrypriv.rts_thresh = wrqu->rts.value;
 	}
 
 	DBG_871X("%s, rts_thresh=%d\n", __func__, padapter->registrypriv.rts_thresh);
-
+	
 	_func_exit_;
-
+	
 	return 0;
 
 }
 
-static int rtw_wx_get_rts(struct net_device *dev,
-			     struct iw_request_info *info,
+static int rtw_wx_get_rts(struct net_device *dev, 
+			     struct iw_request_info *info, 
 			     union iwreq_data *wrqu, char *extra)
 {
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
-
+	
 	_func_enter_;
 
-	DBG_871X("%s, rts_thresh=%d\n", __func__, padapter->registrypriv.rts_thresh);
-
+	DBG_871X("%s, rts_thresh=%d\n", __func__, padapter->registrypriv.rts_thresh);	
+	
 	wrqu->rts.value = padapter->registrypriv.rts_thresh;
 	wrqu->rts.fixed = 0;	/* no auto select */
 	//wrqu->rts.disabled = (wrqu->rts.value == DEFAULT_RTS_THRESHOLD);
-
+	
 	_func_exit_;
-
+	
 	return 0;
 }
 
-static int rtw_wx_set_frag(struct net_device *dev,
-			     struct iw_request_info *info,
+static int rtw_wx_set_frag(struct net_device *dev, 
+			     struct iw_request_info *info, 
 			     union iwreq_data *wrqu, char *extra)
 {
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 
 	_func_enter_;
-
+	
 	if (wrqu->frag.disabled)
 		padapter->xmitpriv.frag_len = MAX_FRAG_THRESHOLD;
 	else {
 		if (wrqu->frag.value < MIN_FRAG_THRESHOLD ||
 		    wrqu->frag.value > MAX_FRAG_THRESHOLD)
 			return -EINVAL;
-
+		
 		padapter->xmitpriv.frag_len = wrqu->frag.value & ~0x1;
 	}
 
 	DBG_871X("%s, frag_len=%d\n", __func__, padapter->xmitpriv.frag_len);
-
+	
 	_func_exit_;
-
+	
 	return 0;
-
+	
 }
 
-static int rtw_wx_get_frag(struct net_device *dev,
-			     struct iw_request_info *info,
+static int rtw_wx_get_frag(struct net_device *dev, 
+			     struct iw_request_info *info, 
 			     union iwreq_data *wrqu, char *extra)
 {
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
-
+	
 	_func_enter_;
 
 	DBG_871X("%s, frag_len=%d\n", __func__, padapter->xmitpriv.frag_len);
-
+	
 	wrqu->frag.value = padapter->xmitpriv.frag_len;
 	wrqu->frag.fixed = 0;	/* no auto select */
 	//wrqu->frag.disabled = (wrqu->frag.value == DEFAULT_FRAG_THRESHOLD);
-
+	
 	_func_exit_;
-
+	
 	return 0;
 }
 
-static int rtw_wx_get_retry(struct net_device *dev,
-			     struct iw_request_info *info,
+static int rtw_wx_get_retry(struct net_device *dev, 
+			     struct iw_request_info *info, 
 			     union iwreq_data *wrqu, char *extra)
 {
 	//_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 
-
+	
 	wrqu->retry.value = 7;
 	wrqu->retry.fixed = 0;	/* no auto select */
 	wrqu->retry.disabled = 1;
-
+	
 	return 0;
 
-}
+}	
 
 #if 0
 #define IW_ENCODE_INDEX		0x00FF	/* Token index (if needed) */
@@ -2695,13 +2695,13 @@ static int rtw_wx_get_retry(struct net_device *dev,
 */
 #endif
 
-static int rtw_wx_set_enc(struct net_device *dev,
-			    struct iw_request_info *info,
+static int rtw_wx_set_enc(struct net_device *dev, 
+			    struct iw_request_info *info, 
 			    union iwreq_data *wrqu, char *keybuf)
-{
+{	
 	u32 key, ret = 0;
 	u32 keyindex_provided;
-	NDIS_802_11_WEP	 wep;
+	NDIS_802_11_WEP	 wep;	
 	NDIS_802_11_AUTHENTICATION_MODE authmode;
 
 	struct iw_point *erq = &(wrqu->encoding);
@@ -2710,10 +2710,10 @@ static int rtw_wx_set_enc(struct net_device *dev,
 	DBG_871X("+rtw_wx_set_enc, flags=0x%x\n", erq->flags);
 
 	_rtw_memset(&wep, 0, sizeof(NDIS_802_11_WEP));
-
+	
 	key = erq->flags & IW_ENCODE_INDEX;
-
-	_func_enter_;
+	
+	_func_enter_;	
 
 	if (erq->flags & IW_ENCODE_DISABLED)
 	{
@@ -2722,9 +2722,9 @@ static int rtw_wx_set_enc(struct net_device *dev,
 		padapter->securitypriv.dot11PrivacyAlgrthm=_NO_PRIVACY_;
 		padapter->securitypriv.dot118021XGrpPrivacy=_NO_PRIVACY_;
 		padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_Open; //open system
-		authmode = Ndis802_11AuthModeOpen;
+  		authmode = Ndis802_11AuthModeOpen;
 		padapter->securitypriv.ndisauthtype=authmode;
-
+     		
 		goto exit;
 	}
 
@@ -2733,15 +2733,15 @@ static int rtw_wx_set_enc(struct net_device *dev,
 			return -EINVAL;
 		key--;
 		keyindex_provided = 1;
-	}
+	} 
 	else
 	{
 		keyindex_provided = 0;
 		key = padapter->securitypriv.dot11PrivacyKeyIndex;
 		DBG_871X("rtw_wx_set_enc, key=%d\n", key);
 	}
-
-	//set authentication mode
+	
+	//set authentication mode	
 	if(erq->flags & IW_ENCODE_OPEN)
 	{
 		DBG_871X("rtw_wx_set_enc():IW_ENCODE_OPEN\n");
@@ -2755,11 +2755,11 @@ static int rtw_wx_set_enc(struct net_device *dev,
 
 		padapter->securitypriv.dot11PrivacyAlgrthm=_NO_PRIVACY_;
 		padapter->securitypriv.dot118021XGrpPrivacy=_NO_PRIVACY_;
-		authmode = Ndis802_11AuthModeOpen;
+  		authmode = Ndis802_11AuthModeOpen;
 		padapter->securitypriv.ndisauthtype=authmode;
-	}
+	}	
 	else if(erq->flags & IW_ENCODE_RESTRICTED)
-	{
+	{		
 		DBG_871X("rtw_wx_set_enc():IW_ENCODE_RESTRICTED\n");
 		padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
 
@@ -2770,7 +2770,7 @@ static int rtw_wx_set_enc(struct net_device *dev,
 #endif
 
 		padapter->securitypriv.dot11PrivacyAlgrthm=_WEP40_;
-		padapter->securitypriv.dot118021XGrpPrivacy=_WEP40_;
+		padapter->securitypriv.dot118021XGrpPrivacy=_WEP40_;			
 		authmode = Ndis802_11AuthModeShared;
 		padapter->securitypriv.ndisauthtype=authmode;
 	}
@@ -2782,10 +2782,10 @@ static int rtw_wx_set_enc(struct net_device *dev,
 		padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_Open; //open system
 		padapter->securitypriv.dot11PrivacyAlgrthm=_NO_PRIVACY_;
 		padapter->securitypriv.dot118021XGrpPrivacy=_NO_PRIVACY_;
-		authmode = Ndis802_11AuthModeOpen;
+  		authmode = Ndis802_11AuthModeOpen;
 		padapter->securitypriv.ndisauthtype=authmode;
 	}
-
+	
 	wep.KeyIndex = key;
 	if (erq->length > 0)
 	{
@@ -2796,7 +2796,7 @@ static int rtw_wx_set_enc(struct net_device *dev,
 	else
 	{
 		wep.KeyLength = 0 ;
-
+		
 		if(keyindex_provided == 1)// set key_id only, no given KeyMaterial(erq->length==0).
 		{
 			padapter->securitypriv.dot11PrivacyKeyIndex = key;
@@ -2806,42 +2806,42 @@ static int rtw_wx_set_enc(struct net_device *dev,
 			switch(padapter->securitypriv.dot11DefKeylen[key])
 			{
 				case 5:
-					padapter->securitypriv.dot11PrivacyAlgrthm=_WEP40_;
+					padapter->securitypriv.dot11PrivacyAlgrthm=_WEP40_;					
 					break;
 				case 13:
-					padapter->securitypriv.dot11PrivacyAlgrthm=_WEP104_;
+					padapter->securitypriv.dot11PrivacyAlgrthm=_WEP104_;					
 					break;
 				default:
-					padapter->securitypriv.dot11PrivacyAlgrthm=_NO_PRIVACY_;
+					padapter->securitypriv.dot11PrivacyAlgrthm=_NO_PRIVACY_;					
 					break;
 			}
-
+				
 			goto exit;
-
+			
 		}
-
+		
 	}
 
 	wep.KeyIndex |= 0x80000000;
 
 	_rtw_memcpy(wep.KeyMaterial, keybuf, wep.KeyLength);
-
+	
 	if (rtw_set_802_11_add_wep(padapter, &wep) == _FALSE) {
 		if(rf_on == pwrpriv->rf_pwrstate )
 			ret = -EOPNOTSUPP;
 		goto exit;
-	}
+	}	
 
 exit:
-
+	
 	_func_exit_;
-
+	
 	return ret;
-
+	
 }
 
-static int rtw_wx_get_enc(struct net_device *dev,
-			    struct iw_request_info *info,
+static int rtw_wx_get_enc(struct net_device *dev, 
+			    struct iw_request_info *info, 
 			    union iwreq_data *wrqu, char *keybuf)
 {
 	uint key, ret =0;
@@ -2850,7 +2850,7 @@ static int rtw_wx_get_enc(struct net_device *dev,
 	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
 
 	_func_enter_;
-
+	
 	if(check_fwstate(pmlmepriv, _FW_LINKED) != _TRUE)
 	{
 		 if(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) != _TRUE)
@@ -2858,10 +2858,10 @@ static int rtw_wx_get_enc(struct net_device *dev,
 		erq->length = 0;
 		erq->flags |= IW_ENCODE_DISABLED;
 		return 0;
-	}
-	}
-
+	}	
+	}	
 
+	
 	key = erq->flags & IW_ENCODE_INDEX;
 
 	if (key) {
@@ -2871,15 +2871,15 @@ static int rtw_wx_get_enc(struct net_device *dev,
 	} else
 	{
 		key = padapter->securitypriv.dot11PrivacyKeyIndex;
-	}
+	}	
 
 	erq->flags = key + 1;
 
 	//if(padapter->securitypriv.ndisauthtype == Ndis802_11AuthModeOpen)
 	//{
 	//      erq->flags |= IW_ENCODE_OPEN;
-	//}
-
+	//}	  
+	
 	switch(padapter->securitypriv.ndisencryptstatus)
 	{
 		case Ndis802_11EncryptionNotSupported:
@@ -2887,28 +2887,28 @@ static int rtw_wx_get_enc(struct net_device *dev,
 
 		erq->length = 0;
 		erq->flags |= IW_ENCODE_DISABLED;
-
+	
 		break;
-
-		case Ndis802_11Encryption1Enabled:
-
-		erq->length = padapter->securitypriv.dot11DefKeylen[key];
+		
+		case Ndis802_11Encryption1Enabled:					
+		
+		erq->length = padapter->securitypriv.dot11DefKeylen[key];		
 
 		if(erq->length)
 		{
 			_rtw_memcpy(keybuf, padapter->securitypriv.dot11DefKey[key].skey, padapter->securitypriv.dot11DefKeylen[key]);
-
+		
 		erq->flags |= IW_ENCODE_ENABLED;
 
 			if(padapter->securitypriv.ndisauthtype == Ndis802_11AuthModeOpen)
 			{
-				erq->flags |= IW_ENCODE_OPEN;
+	     			erq->flags |= IW_ENCODE_OPEN;
 			}
 			else if(padapter->securitypriv.ndisauthtype == Ndis802_11AuthModeShared)
 			{
 		erq->flags |= IW_ENCODE_RESTRICTED;
-			}
-		}
+			}	
+		}	
 		else
 		{
 			erq->length = 0;
@@ -2924,63 +2924,63 @@ static int rtw_wx_get_enc(struct net_device *dev,
 		erq->flags |= (IW_ENCODE_ENABLED | IW_ENCODE_OPEN | IW_ENCODE_NOKEY);
 
 		break;
-
+	
 		default:
 		erq->length = 0;
 		erq->flags |= IW_ENCODE_DISABLED;
 
 		break;
-
+		
 	}
-
+	
 	_func_exit_;
-
+	
 	return ret;
+	
+}				     
 
-}
-
-static int rtw_wx_get_power(struct net_device *dev,
-			     struct iw_request_info *info,
+static int rtw_wx_get_power(struct net_device *dev, 
+			     struct iw_request_info *info, 
 			     union iwreq_data *wrqu, char *extra)
 {
 	//_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
-
+	
 	wrqu->power.value = 0;
 	wrqu->power.fixed = 0;	/* no auto select */
 	wrqu->power.disabled = 1;
-
+	
 	return 0;
 
 }
 
-static int rtw_wx_set_gen_ie(struct net_device *dev,
-			     struct iw_request_info *info,
+static int rtw_wx_set_gen_ie(struct net_device *dev, 
+			     struct iw_request_info *info, 
 			     union iwreq_data *wrqu, char *extra)
 {
 	int ret;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
-
+	
        ret = rtw_set_wpa_ie(padapter, extra, wrqu->data.length);
-
+	   
 	return ret;
-}
+}	
 
-static int rtw_wx_set_auth(struct net_device *dev,
-			     struct iw_request_info *info,
+static int rtw_wx_set_auth(struct net_device *dev, 
+			     struct iw_request_info *info, 
 			     union iwreq_data *wrqu, char *extra)
 {
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct iw_param *param = (struct iw_param*)&(wrqu->param);
 	int ret = 0;
-
+	
 	switch (param->flags & IW_AUTH_INDEX) {
 	case IW_AUTH_WPA_VERSION:
 		break;
 	case IW_AUTH_CIPHER_PAIRWISE:
-
+		
 		break;
 	case IW_AUTH_CIPHER_GROUP:
-
+		
 		break;
 	case IW_AUTH_KEY_MGMT:
 		/*
@@ -2992,11 +2992,11 @@ static int rtw_wx_set_auth(struct net_device *dev,
         {
 	    if ( param->value )
             {  // wpa_supplicant is enabling the tkip countermeasure.
-               padapter->securitypriv.btkip_countermeasure = _TRUE;
+               padapter->securitypriv.btkip_countermeasure = _TRUE; 
             }
             else
             {  // wpa_supplicant is disabling the tkip countermeasure.
-               padapter->securitypriv.btkip_countermeasure = _FALSE;
+               padapter->securitypriv.btkip_countermeasure = _FALSE; 
             }
 		break;
         }
@@ -3016,10 +3016,10 @@ static int rtw_wx_set_auth(struct net_device *dev,
 
 			if(padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption1Enabled)
 			{
-				break;//it means init value, or using wep, ndisencryptstatus = Ndis802_11Encryption1Enabled,
+				break;//it means init value, or using wep, ndisencryptstatus = Ndis802_11Encryption1Enabled, 
 						// then it needn't reset it;
 			}
-
+			
 			if(param->value){
 				padapter->securitypriv.ndisencryptstatus = Ndis802_11EncryptionDisabled;
 				padapter->securitypriv.dot11PrivacyAlgrthm=_NO_PRIVACY_;
@@ -3027,7 +3027,7 @@ static int rtw_wx_set_auth(struct net_device *dev,
 				padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_Open; //open system
 				padapter->securitypriv.ndisauthtype=Ndis802_11AuthModeOpen;
 			}
-
+			
 			break;
 		}
 
@@ -3047,8 +3047,8 @@ static int rtw_wx_set_auth(struct net_device *dev,
 		#endif
 
 
-		ret = wpa_set_auth_algs(dev, (u32)param->value);
-
+		ret = wpa_set_auth_algs(dev, (u32)param->value);		
+	
 		break;
 
 	case IW_AUTH_WPA_ENABLED:
@@ -3057,9 +3057,9 @@ static int rtw_wx_set_auth(struct net_device *dev,
 		//	padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_8021X; //802.1x
 		//else
 		//	padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Open;//open system
-
+		
 		//_disassociate(priv);
-
+		
 		break;
 
 	case IW_AUTH_RX_UNENCRYPTED_EAPOL:
@@ -3072,29 +3072,29 @@ static int rtw_wx_set_auth(struct net_device *dev,
 
 	default:
 		return -EOPNOTSUPP;
-
+		
 	}
-
+	
 	return ret;
-
+	
 }
 
-static int rtw_wx_set_enc_ext(struct net_device *dev,
-			     struct iw_request_info *info,
+static int rtw_wx_set_enc_ext(struct net_device *dev, 
+			     struct iw_request_info *info, 
 			     union iwreq_data *wrqu, char *extra)
 {
 	char *alg_name;
 	u32 param_len;
 	struct ieee_param *param = NULL;
 	struct iw_point *pencoding = &wrqu->encoding;
-	struct iw_encode_ext *pext = (struct iw_encode_ext *)extra;
+ 	struct iw_encode_ext *pext = (struct iw_encode_ext *)extra;
 	int ret=0;
 
 	param_len = sizeof(struct ieee_param) + pext->key_len;
 	param = (struct ieee_param *)rtw_malloc(param_len);
 	if (param == NULL)
 		return -1;
-
+	
 	_rtw_memset(param, 0, param_len);
 
 	param->cmd = IEEE_CMD_SET_ENCRYPTION;
@@ -3103,8 +3103,8 @@ static int rtw_wx_set_enc_ext(struct net_device *dev,
 
 	switch (pext->alg) {
 	case IW_ENCODE_ALG_NONE:
-		//todo: remove key
-		//remove = 1;
+		//todo: remove key 
+		//remove = 1;	
 		alg_name = "none";
 		break;
 	case IW_ENCODE_ALG_WEP:
@@ -3121,13 +3121,13 @@ static int rtw_wx_set_enc_ext(struct net_device *dev,
 		alg_name = "BIP";
 		break;
 #endif //CONFIG_IEEE80211W
-	default:
+	default:	
 		return -1;
 	}
-
+	
 	strncpy((char *)param->u.crypt.alg, alg_name, IEEE_CRYPT_ALG_NAME_LEN);
 
-
+	
 	if((pext->ext_flags & IW_ENCODE_EXT_GROUP_KEY)//?
 #ifdef CONFIG_IEEE80211W
 		|| (pext->ext_flags & IW_ENCODE_ALG_AES_CMAC)
@@ -3143,9 +3143,9 @@ static int rtw_wx_set_enc_ext(struct net_device *dev,
 	}
 
 	param->u.crypt.idx = (pencoding->flags&0x00FF) -1 ;
-
-	if (pext->ext_flags & IW_ENCODE_EXT_RX_SEQ_VALID)
-	{
+	
+	if (pext->ext_flags & IW_ENCODE_EXT_RX_SEQ_VALID) 
+	{	
 		_rtw_memcpy(param->u.crypt.seq, pext->rx_seq, 8);
 	}
 
@@ -3154,33 +3154,33 @@ static int rtw_wx_set_enc_ext(struct net_device *dev,
 		param->u.crypt.key_len = pext->key_len;
 		//_rtw_memcpy(param + 1, pext + 1, pext->key_len);
 		_rtw_memcpy(param->u.crypt.key, pext + 1, pext->key_len);
-	}
-
+	}	
 
+	
 	if (pencoding->flags & IW_ENCODE_DISABLED)
-	{
-		//todo: remove key
-		//remove = 1;
-	}
-
-	ret =  wpa_set_encryption(dev, param, param_len);
-
+	{		
+		//todo: remove key 
+		//remove = 1;		
+	}	
+	
+	ret =  wpa_set_encryption(dev, param, param_len);	
+	
 
 	if(param)
 	{
 		rtw_mfree((u8*)param, param_len);
 	}
-
-
-	return ret;
+		
+	
+	return ret;		
 
 }
 
 
-static int rtw_wx_get_nick(struct net_device *dev,
-			     struct iw_request_info *info,
+static int rtw_wx_get_nick(struct net_device *dev, 
+			     struct iw_request_info *info, 
 			     union iwreq_data *wrqu, char *extra)
-{
+{	
 	//_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	 //struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	 //struct security_priv *psecuritypriv = &padapter->securitypriv;
@@ -3194,19 +3194,19 @@ static int rtw_wx_get_nick(struct net_device *dev,
 
 	//rtw_signal_process(pid, SIGUSR1); //for test
 
-	//dump debug info here
+	//dump debug info here	
 /*
 	u32 dot11AuthAlgrthm;		// 802.11 auth, could be open, shared, and 8021x
 	u32 dot11PrivacyAlgrthm;	// This specify the privacy for shared auth. algorithm.
-	u32 dot118021XGrpPrivacy;	// This specify the privacy algthm. used for Grp key
+	u32 dot118021XGrpPrivacy;	// This specify the privacy algthm. used for Grp key 
 	u32 ndisauthtype;
 	u32 ndisencryptstatus;
 */
 
-	//DBG_871X("auth_alg=0x%x, enc_alg=0x%x, auth_type=0x%x, enc_type=0x%x\n",
+	//DBG_871X("auth_alg=0x%x, enc_alg=0x%x, auth_type=0x%x, enc_type=0x%x\n", 
 	//		psecuritypriv->dot11AuthAlgrthm, psecuritypriv->dot11PrivacyAlgrthm,
 	//		psecuritypriv->ndisauthtype, psecuritypriv->ndisencryptstatus);
-
+	
 	//DBG_871X("enc_alg=0x%x\n", psecuritypriv->dot11PrivacyAlgrthm);
 	//DBG_871X("auth_type=0x%x\n", psecuritypriv->ndisauthtype);
 	//DBG_871X("enc_type=0x%x\n", psecuritypriv->ndisencryptstatus);
@@ -3217,7 +3217,7 @@ static int rtw_wx_get_nick(struct net_device *dev,
 	DBG_871X("dbg(0x280)=0x%x\n", rtw_read32(padapter, 0x280));
 	DBG_871X("dbg(0x284)=0x%x\n", rtw_read32(padapter, 0x284));
 	DBG_871X("dbg(0x288)=0x%x\n", rtw_read32(padapter, 0x288));
-
+	
 	DBG_871X("dbg(0x664)=0x%x\n", rtw_read32(padapter, 0x664));
 
 
@@ -3227,18 +3227,18 @@ static int rtw_wx_get_nick(struct net_device *dev,
 	DBG_871X("dbg(0x438)=0x%x\n", rtw_read32(padapter, 0x438));
 
 	DBG_871X("dbg(0x440)=0x%x\n", rtw_read32(padapter, 0x440));
-
+	
 	DBG_871X("dbg(0x458)=0x%x\n", rtw_read32(padapter, 0x458));
-
+	
 	DBG_871X("dbg(0x484)=0x%x\n", rtw_read32(padapter, 0x484));
 	DBG_871X("dbg(0x488)=0x%x\n", rtw_read32(padapter, 0x488));
-
+	
 	DBG_871X("dbg(0x444)=0x%x\n", rtw_read32(padapter, 0x444));
 	DBG_871X("dbg(0x448)=0x%x\n", rtw_read32(padapter, 0x448));
 	DBG_871X("dbg(0x44c)=0x%x\n", rtw_read32(padapter, 0x44c));
 	DBG_871X("dbg(0x450)=0x%x\n", rtw_read32(padapter, 0x450));
 #endif
-
+	
 	return 0;
 
 }
@@ -3381,13 +3381,13 @@ static int rtw_wx_priv_null(struct net_device *dev, struct iw_request_info *a,
 static int dummy(struct net_device *dev, struct iw_request_info *a,
 		 union iwreq_data *wrqu, char *b)
 {
-	//_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	//_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
 	//struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 
 	//DBG_871X("cmd_code=%x, fwstate=0x%x\n", a->cmd, get_fwstate(pmlmepriv));
-
+	
 	return -1;
-
+	
 }
 
 static int rtw_wx_set_channel_plan(struct net_device *dev,
@@ -3408,7 +3408,7 @@ static int rtw_wx_set_channel_plan(struct net_device *dev,
 
 	if( _SUCCESS == rtw_set_chplan_cmd(padapter, channel_plan_req, 1) ) {
 		DBG_871X("%s set channel_plan = 0x%02X\n", __func__, pmlmepriv->ChannelPlan);
-	} else
+	} else 
 		return -EPERM;
 
 	return 0;
@@ -3480,8 +3480,8 @@ struct	iw_point
 
 #ifdef CONFIG_DRVEXT_MODULE
 	u8 res;
-	struct drvext_handler *phandler;
-	struct drvext_oidparam *poidparam;
+	struct drvext_handler *phandler;	
+	struct drvext_oidparam *poidparam;		
 	int ret;
 	u16 len;
 	u8 *pparmbuf, bset;
@@ -3492,8 +3492,8 @@ struct	iw_point
 		ret = -EINVAL;
 		goto _rtw_drvext_hdl_exit;
 	}
-
-
+	
+	
 	bset = (u8)(p->flags&0xFFFF);
 	len = p->length;
 	pparmbuf = (u8*)rtw_malloc(len);
@@ -3501,32 +3501,32 @@ struct	iw_point
 		ret = -ENOMEM;
 		goto _rtw_drvext_hdl_exit;
 	}
-
+	
 	if(bset)//set info
 	{
 		if (copy_from_user(pparmbuf, p->pointer,len)) {
 			rtw_mfree(pparmbuf, len);
 			ret = -EFAULT;
 			goto _rtw_drvext_hdl_exit;
-		}
+		}		
 	}
 	else//query info
 	{
-
+	
 	}
 
-
+	
 	//
-	poidparam = (struct drvext_oidparam *)pparmbuf;
-
+	poidparam = (struct drvext_oidparam *)pparmbuf;	
+	
 	RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_info_,("drvext set oid subcode [%d], len[%d], InformationBufferLength[%d]\r\n",
-						 poidparam->subcode, poidparam->len, len));
+        					 poidparam->subcode, poidparam->len, len));
 
 
-	//check subcode
+	//check subcode	
 	if ( poidparam->subcode >= MAX_DRVEXT_HANDLERS)
 	{
-		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("no matching drvext handlers\r\n"));
+		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("no matching drvext handlers\r\n"));		
 		ret = -EINVAL;
 		goto _rtw_drvext_hdl_exit;
 	}
@@ -3534,7 +3534,7 @@ struct	iw_point
 
 	if ( poidparam->subcode >= MAX_DRVEXT_OID_SUBCODES)
 	{
-		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("no matching drvext subcodes\r\n"));
+		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("no matching drvext subcodes\r\n"));		
 		ret = -EINVAL;
 		goto _rtw_drvext_hdl_exit;
 	}
@@ -3544,9 +3544,9 @@ struct	iw_point
 
 	if (poidparam->len != phandler->parmsize)
 	{
-		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("no matching drvext param size %d vs %d\r\n",
-						poidparam->len , phandler->parmsize));
-		ret = -EINVAL;
+		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("no matching drvext param size %d vs %d\r\n",			
+						poidparam->len , phandler->parmsize));		
+		ret = -EINVAL;		
 		goto _rtw_drvext_hdl_exit;
 	}
 
@@ -3556,21 +3556,21 @@ struct	iw_point
 	if(res==0)
 	{
 		ret = 0;
-
+			
 		if (bset == 0x00) {//query info
 			//_rtw_memcpy(p->pointer, pparmbuf, len);
 			if (copy_to_user(p->pointer, pparmbuf, len))
 				ret = -EFAULT;
-		}
-	}
+		}		
+	}		
 	else
 		ret = -EFAULT;
 
-
-_rtw_drvext_hdl_exit:
-
-	return ret;
-
+	
+_rtw_drvext_hdl_exit:	
+	
+	return ret;	
+	
 #endif
 
 	return 0;
@@ -3608,7 +3608,7 @@ static void rtw_dbg_mode_hdl(_adapter *padapter, u32 id, u8 *pdata, u32 len)
 				default:
 					break;
 			}
-
+		
 			break;
 		case GEN_MP_IOCTL_SUBCODE(WRITE_REG):
 			RegRWStruct = (pRW_Reg)pdata;
@@ -3623,40 +3623,40 @@ static void rtw_dbg_mode_hdl(_adapter *padapter, u32 id, u8 *pdata, u32 len)
 				case 4:
 					rtw_write32(padapter, RegRWStruct->offset, (u32)RegRWStruct->value);
 					break;
-				default:
+				default:					
 				break;
 			}
-
+				
 			break;
 		case GEN_MP_IOCTL_SUBCODE(READ_RF_REG):
 
 			prfreg = (struct rf_reg_param *)pdata;
 
-			path = (u8)prfreg->path;
-			offset = (u8)prfreg->offset;
+			path = (u8)prfreg->path;		
+			offset = (u8)prfreg->offset;	
 
 			value = rtw_hal_read_rfreg(padapter, path, offset, 0xffffffff);
 
 			prfreg->value = value;
 
-			break;
+			break;			
 		case GEN_MP_IOCTL_SUBCODE(WRITE_RF_REG):
 
 			prfreg = (struct rf_reg_param *)pdata;
 
 			path = (u8)prfreg->path;
-			offset = (u8)prfreg->offset;
+			offset = (u8)prfreg->offset;	
 			value = prfreg->value;
 
 			rtw_hal_write_rfreg(padapter, path, offset, 0xffffffff, value);
-
-			break;
+			
+			break;			
                 case GEN_MP_IOCTL_SUBCODE(TRIGGER_GPIO):
 			DBG_871X("==> trigger gpio 0\n");
 			rtw_hal_set_hwreg(padapter, HW_VAR_TRIGGER_GPIO_0, 0);
-			break;
+			break;	
 #ifdef CONFIG_BT_COEXIST
-		case GEN_MP_IOCTL_SUBCODE(SET_DM_BT):
+		case GEN_MP_IOCTL_SUBCODE(SET_DM_BT):			
 			DBG_871X("==> set dm_bt_coexist:%x\n",*(u8 *)pdata);
 			rtw_hal_set_hwreg(padapter, HW_VAR_BT_SET_COEXIST, pdata);
 			break;
@@ -3666,15 +3666,15 @@ static void rtw_dbg_mode_hdl(_adapter *padapter, u32 id, u8 *pdata, u32 len)
 			break;
 #endif
 #ifdef DBG_CONFIG_ERROR_DETECT
-		case GEN_MP_IOCTL_SUBCODE(GET_WIFI_STATUS):
+		case GEN_MP_IOCTL_SUBCODE(GET_WIFI_STATUS):	
 			*pdata = rtw_hal_sreset_get_wifi_status(padapter);
 			break;
 #endif
-
+	
 		default:
 			break;
 	}
-
+	
 }
 
 static int rtw_mp_ioctl_hdl(struct net_device *dev, struct iw_request_info *info,
@@ -3727,7 +3727,7 @@ static int rtw_mp_ioctl_hdl(struct net_device *dev, struct iw_request_info *info
 
 	//DBG_871X("%s: %d\n", __func__, poidparam->subcode);
 
-#ifdef CONFIG_MP_INCLUDED
+#ifdef CONFIG_MP_INCLUDED 
 	phandler = mp_ioctl_hdl + poidparam->subcode;
 
 	if ((phandler->paramsize != 0) && (poidparam->len < phandler->paramsize))
@@ -3765,7 +3765,7 @@ static int rtw_mp_ioctl_hdl(struct net_device *dev, struct iw_request_info *info
 		//todo:check status, BytesNeeded, etc.
 	}
 	else {
-		DBG_871X("rtw_mp_ioctl_hdl(): err!, subcode=%d, oid=%d, handler=%p\n",
+		DBG_871X("rtw_mp_ioctl_hdl(): err!, subcode=%d, oid=%d, handler=%p\n", 
 			poidparam->subcode, phandler->oid, phandler->handler);
 		ret = -EFAULT;
 		goto _rtw_mp_ioctl_hdl_exit;
@@ -3773,7 +3773,7 @@ static int rtw_mp_ioctl_hdl(struct net_device *dev, struct iw_request_info *info
 #else
 
 	rtw_dbg_mode_hdl(padapter, poidparam->subcode, poidparam->data, poidparam->len);
-
+	
 #endif
 
 	if (bset == 0x00) {//query info
@@ -3808,29 +3808,29 @@ static int rtw_get_ap_info(struct net_device *dev,
 	u8 bssid[ETH_ALEN];
 	char data[32];
 	struct wlan_network *pnetwork = NULL;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
-	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);	
 	_queue *queue = &(pmlmepriv->scanned_queue);
-	struct iw_point *pdata = &wrqu->data;
+	struct iw_point *pdata = &wrqu->data;	
 
 	DBG_871X("+rtw_get_aplist_info\n");
 
 	if((padapter->bDriverStopped) || (pdata==NULL))
-	{
+	{                
 		ret= -EINVAL;
 		goto exit;
-	}
-
-	while((check_fwstate(pmlmepriv, (_FW_UNDER_SURVEY|_FW_UNDER_LINKING))) == _TRUE)
-	{
+	}		
+  
+ 	while((check_fwstate(pmlmepriv, (_FW_UNDER_SURVEY|_FW_UNDER_LINKING))) == _TRUE)
+	{	
 		rtw_msleep_os(30);
 		cnt++;
 		if(cnt > 100)
 			break;
 	}
+	
 
-
-	//pdata->length = 0;//?
+	//pdata->length = 0;//?	
 	pdata->flags = 0;
 	if(pdata->length>=32)
 	{
@@ -3839,18 +3839,18 @@ static int rtw_get_ap_info(struct net_device *dev,
 			ret= -EINVAL;
 			goto exit;
 		}
-	}
+	}	
 	else
 	{
 		ret= -EINVAL;
 		goto exit;
-	}
+	}	
 
 	_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
-
+	
 	phead = get_list_head(queue);
 	plist = get_next(phead);
-
+       
 	while(1)
 	{
 		if (rtw_end_of_queue_search(phead,plist)== _TRUE)
@@ -3859,20 +3859,20 @@ static int rtw_get_ap_info(struct net_device *dev,
 
 		pnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);
 
-		//if(hwaddr_aton_i(pdata->pointer, bssid))
-		if(hwaddr_aton_i(data, bssid))
-		{
+		//if(hwaddr_aton_i(pdata->pointer, bssid)) 
+		if(hwaddr_aton_i(data, bssid)) 
+		{			
 			DBG_871X("Invalid BSSID '%s'.\n", (u8*)data);
 			_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
 			return -EINVAL;
-		}
-
-
+		}		
+		
+	
 		if(_rtw_memcmp(bssid, pnetwork->network.MacAddress, ETH_ALEN) == _TRUE)//BSSID match, then check if supporting wpa/wpa2
 		{
 			DBG_871X("BSSID:" MAC_FMT "\n", MAC_ARG(bssid));
-
-			pbuf = rtw_get_wpa_ie(&pnetwork->network.IEs[12], &wpa_ielen, pnetwork->network.IELength-12);
+			
+			pbuf = rtw_get_wpa_ie(&pnetwork->network.IEs[12], &wpa_ielen, pnetwork->network.IELength-12);				
 			if(pbuf && (wpa_ielen>0))
 			{
 				pdata->flags = 1;
@@ -3885,12 +3885,12 @@ static int rtw_get_ap_info(struct net_device *dev,
 				pdata->flags = 2;
 				break;
 			}
-
+			
 		}
 
-		plist = get_next(plist);
-
-	}
+		plist = get_next(plist);		
+	
+	}        
 
 	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
 
@@ -3901,30 +3901,30 @@ static int rtw_get_ap_info(struct net_device *dev,
 			ret= -EINVAL;
 			goto exit;
 		}
-	}
-
+	}	
+	
 exit:
-
+	
 	return ret;
-
+		
 }
 
 static int rtw_set_pid(struct net_device *dev,
                                struct iw_request_info *info,
                                union iwreq_data *wrqu, char *extra)
 {
-
-	int ret = 0;
-	_adapter *padapter = rtw_netdev_priv(dev);
+	
+	int ret = 0;	
+	_adapter *padapter = rtw_netdev_priv(dev);	
 	int *pdata = (int *)wrqu;
 	int selector;
 
 	if((padapter->bDriverStopped) || (pdata==NULL))
-	{
+	{                
 		ret= -EINVAL;
 		goto exit;
-	}
-
+	}		
+  
 	selector = *pdata;
 	if(selector < 3 && selector >=0) {
 		padapter->pid[selector] = *(pdata+1);
@@ -3937,18 +3937,18 @@ static int rtw_set_pid(struct net_device *dev,
 		DBG_871X("%s selector %d error\n", __FUNCTION__, selector);
 
 exit:
-
+	
 	return ret;
-
+		
 }
 
 static int rtw_wps_start(struct net_device *dev,
                                struct iw_request_info *info,
                                union iwreq_data *wrqu, char *extra)
 {
-
-	int ret = 0;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	
+	int ret = 0;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
 	struct iw_point *pdata = &wrqu->data;
 	u32   u32wps_start = 0;
         unsigned int uintRet = 0;
@@ -3956,10 +3956,10 @@ static int rtw_wps_start(struct net_device *dev,
         uintRet = copy_from_user( ( void* ) &u32wps_start, pdata->pointer, 4 );
 
 	if((padapter->bDriverStopped) || (pdata==NULL))
-	{
+	{                
 		ret= -EINVAL;
 		goto exit;
-	}
+	}		
 
 	if ( u32wps_start == 0 )
 	{
@@ -3984,11 +3984,11 @@ static int rtw_wps_start(struct net_device *dev,
 #ifdef CONFIG_INTEL_WIDI
 	process_intel_widi_wps_status(padapter, u32wps_start);
 #endif //CONFIG_INTEL_WIDI
-
+	
 exit:
-
+	
 	return ret;
-
+		
 }
 
 #ifdef CONFIG_P2P
@@ -3996,10 +3996,10 @@ static int rtw_wext_p2p_enable(struct net_device *dev,
                                struct iw_request_info *info,
                                union iwreq_data *wrqu, char *extra)
 {
-
-	int ret = 0;
+	
+	int ret = 0;	
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
-	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);	
 	struct iw_point *pdata = &wrqu->data;
 	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
@@ -4022,8 +4022,8 @@ static int rtw_wext_p2p_enable(struct net_device *dev,
 	}
 
 	//set channel/bandwidth
-	if(init_role != P2P_ROLE_DISABLE)
-	{
+	if(init_role != P2P_ROLE_DISABLE) 
+	{	
 		u8 channel, ch_offset;
 		u16 bwmode;
 
@@ -4042,7 +4042,7 @@ static int rtw_wext_p2p_enable(struct net_device *dev,
 			//struct wifidirect_info	*pbuddy_wdinfo = &pbuddy_adapter->wdinfo;
 			struct mlme_priv		*pbuddy_mlmepriv = &pbuddy_adapter->mlmepriv;
 			struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
-
+			
 			_set_timer( &pwdinfo->ap_p2p_switch_timer, pwdinfo->ext_listen_interval );
 			if ( check_fwstate( pbuddy_mlmepriv, _FW_LINKED ) )
 			{
@@ -4062,10 +4062,10 @@ static int rtw_wext_p2p_enable(struct net_device *dev,
 		else
 		{
 			pwdinfo->operating_channel = pmlmeext->cur_channel;
-
+		
 			channel = pwdinfo->operating_channel;
 			ch_offset = pmlmeext->cur_ch_offset;
-			bwmode = pmlmeext->cur_bwmode;
+			bwmode = pmlmeext->cur_bwmode;						
 		}
 
 		set_channel_bwmode(padapter, channel, ch_offset, bwmode);
@@ -4073,26 +4073,26 @@ static int rtw_wext_p2p_enable(struct net_device *dev,
 
 exit:
 	return ret;
-
+		
 }
 
 static int rtw_p2p_set_go_nego_ssid(struct net_device *dev,
                                struct iw_request_info *info,
                                union iwreq_data *wrqu, char *extra)
 {
-
-	int ret = 0;
+	
+	int ret = 0;	
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
-	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);	
 	struct iw_point *pdata = &wrqu->data;
 	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
 
 	DBG_871X( "[%s] ssid = %s, len = %d\n", __FUNCTION__, extra, (u32)strlen( extra ) );
 	_rtw_memcpy( pwdinfo->nego_ssid, extra, strlen( extra ) );
 	pwdinfo->nego_ssidlen = strlen( extra );
-
+	
 	return ret;
-
+		
 }
 
 
@@ -4108,7 +4108,7 @@ static int rtw_p2p_set_intent(struct net_device *dev,
 	extra[ wrqu->data.length ] = 0x00;
 
 	intent = rtw_atoi( extra );
-
+	
 	if ( intent <= 15 )
 	{
 		pwdinfo->intent= intent;
@@ -4117,7 +4117,7 @@ static int rtw_p2p_set_intent(struct net_device *dev,
 	{
 		ret = -1;
 	}
-
+	
 	DBG_871X( "[%s] intent = %d\n", __FUNCTION__, intent);
 
 	return ret;
@@ -4128,8 +4128,8 @@ static int rtw_p2p_set_listen_ch(struct net_device *dev,
                                struct iw_request_info *info,
                                union iwreq_data *wrqu, char *extra)
 {
-
-	int ret = 0;
+	
+	int ret = 0;	
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
 	u8	listen_ch = pwdinfo->listen_channel;	//	Listen channel number
@@ -4146,11 +4146,11 @@ static int rtw_p2p_set_listen_ch(struct net_device *dev,
 	{
 		ret = -1;
 	}
-
+	
 	DBG_871X( "[%s] listen_ch = %d\n", __FUNCTION__, pwdinfo->listen_channel );
-
+	
 	return ret;
-
+		
 }
 
 static int rtw_p2p_set_op_ch(struct net_device *dev,
@@ -4160,7 +4160,7 @@ static int rtw_p2p_set_op_ch(struct net_device *dev,
 //	Commented by Albert 20110524
 //	This function is used to set the operating channel if the driver will become the group owner
 
-	int ret = 0;
+	int ret = 0;	
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
 	u8	op_ch = pwdinfo->operating_channel;	//	Operating channel number
@@ -4176,9 +4176,9 @@ static int rtw_p2p_set_op_ch(struct net_device *dev,
 	{
 		ret = -1;
 	}
-
+	
 	DBG_871X( "[%s] op_ch = %d\n", __FUNCTION__, pwdinfo->operating_channel );
-
+	
 	return ret;
 
 }
@@ -4188,8 +4188,8 @@ static int rtw_p2p_profilefound(struct net_device *dev,
                                struct iw_request_info *info,
                                union iwreq_data *wrqu, char *extra)
 {
-
-	int ret = 0;
+	
+	int ret = 0;	
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
 
@@ -4205,7 +4205,7 @@ static int rtw_p2p_profilefound(struct net_device *dev,
 
 	DBG_871X( "[%s] In value = %s, len = %d \n", __FUNCTION__, extra, wrqu->data.length -1);
 
-
+	
 	//	The upper application should pass the SSID to driver by using this rtw_p2p_profilefound function.
 	if(!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 	{
@@ -4224,7 +4224,7 @@ static int rtw_p2p_profilefound(struct net_device *dev,
 		else
 		{
 				int jj, kk;
-
+				
 				//	Add this profile information into pwdinfo->profileinfo
 				//	Ex:  1XX:XX:XX:XX:XX:XXYYSSID
 				for( jj = 0, kk = 1; jj < ETH_ALEN; jj++, kk += 3 )
@@ -4237,18 +4237,18 @@ static int rtw_p2p_profilefound(struct net_device *dev,
 				pwdinfo->profileindex++;
 			}
 		}
-	}
-
+	}	
+	
 	return ret;
-
+		
 }
 
 static int rtw_p2p_setDN(struct net_device *dev,
                                struct iw_request_info *info,
                                union iwreq_data *wrqu, char *extra)
 {
-
-	int ret = 0;
+	
+	int ret = 0;	
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
 
@@ -4259,7 +4259,7 @@ static int rtw_p2p_setDN(struct net_device *dev,
 	_rtw_memcpy( pwdinfo->device_name, extra, wrqu->data.length - 1 );
 	pwdinfo->device_name_len = wrqu->data.length - 1;
 	return ret;
-
+		
 }
 
 
@@ -4267,9 +4267,9 @@ static int rtw_p2p_get_status(struct net_device *dev,
                                struct iw_request_info *info,
                                union iwreq_data *wrqu, char *extra)
 {
-
-	int ret = 0;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	
+	int ret = 0;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
 	struct iw_point *pdata = &wrqu->data;
 	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo );
 
@@ -4280,7 +4280,7 @@ static int rtw_p2p_get_status(struct net_device *dev,
 				pwdinfo->p2p_peer_interface_addr[ 0 ], pwdinfo->p2p_peer_interface_addr[ 1 ], pwdinfo->p2p_peer_interface_addr[ 2 ],
 				pwdinfo->p2p_peer_interface_addr[ 3 ], pwdinfo->p2p_peer_interface_addr[ 4 ], pwdinfo->p2p_peer_interface_addr[ 5 ]);
 	}
-
+ 
 	//	Commented by Albert 2010/10/12
 	//	Because of the output size limitation, I had removed the "Role" information.
 	//	About the "Role" information, we will use the new private IOCTL to get the "Role" information.
@@ -4288,11 +4288,11 @@ static int rtw_p2p_get_status(struct net_device *dev,
 	wrqu->data.length = strlen( extra );
 
 	return ret;
-
+		
 }
 
 //	Commented by Albert 20110520
-//	This function will return the config method description
+//	This function will return the config method description 
 //	This config method description will show us which config method the remote P2P device is intented to use
 //	by sending the provisioning discovery request frame.
 
@@ -4300,8 +4300,8 @@ static int rtw_p2p_get_req_cm(struct net_device *dev,
                                struct iw_request_info *info,
                                union iwreq_data *wrqu, char *extra)
 {
-
-	int ret = 0;
+	
+	int ret = 0;	
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct iw_point *pdata = &wrqu->data;
 	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo );
@@ -4309,7 +4309,7 @@ static int rtw_p2p_get_req_cm(struct net_device *dev,
 	sprintf( extra, "\n\nCM=%s\n", pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req );
 	wrqu->data.length = strlen( extra );
 	return ret;
-
+		
 }
 
 
@@ -4317,13 +4317,13 @@ static int rtw_p2p_get_role(struct net_device *dev,
                                struct iw_request_info *info,
                                union iwreq_data *wrqu, char *extra)
 {
-
-	int ret = 0;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	
+	int ret = 0;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
 	struct iw_point *pdata = &wrqu->data;
 	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo );
 
-
+	
 	DBG_871X( "[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n", __FUNCTION__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
 			pwdinfo->p2p_peer_interface_addr[ 0 ], pwdinfo->p2p_peer_interface_addr[ 1 ], pwdinfo->p2p_peer_interface_addr[ 2 ],
 			pwdinfo->p2p_peer_interface_addr[ 3 ], pwdinfo->p2p_peer_interface_addr[ 4 ], pwdinfo->p2p_peer_interface_addr[ 5 ]);
@@ -4331,7 +4331,7 @@ static int rtw_p2p_get_role(struct net_device *dev,
 	sprintf( extra, "\n\nRole=%.2d\n", rtw_p2p_role(pwdinfo) );
 	wrqu->data.length = strlen( extra );
 	return ret;
-
+		
 }
 
 
@@ -4339,9 +4339,9 @@ static int rtw_p2p_get_peer_ifaddr(struct net_device *dev,
                                struct iw_request_info *info,
                                union iwreq_data *wrqu, char *extra)
 {
-
-	int ret = 0;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	
+	int ret = 0;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
 	struct iw_point *pdata = &wrqu->data;
 	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo );
 
@@ -4355,7 +4355,7 @@ static int rtw_p2p_get_peer_ifaddr(struct net_device *dev,
 			pwdinfo->p2p_peer_interface_addr[ 3 ], pwdinfo->p2p_peer_interface_addr[ 4 ], pwdinfo->p2p_peer_interface_addr[ 5 ]);
 	wrqu->data.length = strlen( extra );
 	return ret;
-
+		
 }
 
 static int rtw_p2p_get_peer_devaddr(struct net_device *dev,
@@ -4363,23 +4363,23 @@ static int rtw_p2p_get_peer_devaddr(struct net_device *dev,
                                union iwreq_data *wrqu, char *extra)
 
 {
-
-	int ret = 0;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	
+	int ret = 0;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
 	struct iw_point *pdata = &wrqu->data;
 	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo );
 
 	DBG_871X( "[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n", __FUNCTION__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
-			pwdinfo->rx_prov_disc_info.peerDevAddr[ 0 ], pwdinfo->rx_prov_disc_info.peerDevAddr[ 1 ],
+			pwdinfo->rx_prov_disc_info.peerDevAddr[ 0 ], pwdinfo->rx_prov_disc_info.peerDevAddr[ 1 ], 
 			pwdinfo->rx_prov_disc_info.peerDevAddr[ 2 ], pwdinfo->rx_prov_disc_info.peerDevAddr[ 3 ],
 			pwdinfo->rx_prov_disc_info.peerDevAddr[ 4 ], pwdinfo->rx_prov_disc_info.peerDevAddr[ 5 ]);
 	sprintf( extra, "\n%.2X%.2X%.2X%.2X%.2X%.2X",
-			pwdinfo->rx_prov_disc_info.peerDevAddr[ 0 ], pwdinfo->rx_prov_disc_info.peerDevAddr[ 1 ],
+			pwdinfo->rx_prov_disc_info.peerDevAddr[ 0 ], pwdinfo->rx_prov_disc_info.peerDevAddr[ 1 ], 
 			pwdinfo->rx_prov_disc_info.peerDevAddr[ 2 ], pwdinfo->rx_prov_disc_info.peerDevAddr[ 3 ],
 			pwdinfo->rx_prov_disc_info.peerDevAddr[ 4 ], pwdinfo->rx_prov_disc_info.peerDevAddr[ 5 ]);
-	wrqu->data.length = strlen( extra );
+	wrqu->data.length = strlen( extra );	
 	return ret;
-
+		
 }
 
 static int rtw_p2p_get_peer_devaddr_by_invitation(struct net_device *dev,
@@ -4387,23 +4387,23 @@ static int rtw_p2p_get_peer_devaddr_by_invitation(struct net_device *dev,
                                union iwreq_data *wrqu, char *extra)
 
 {
-
-	int ret = 0;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	
+	int ret = 0;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
 	struct iw_point *pdata = &wrqu->data;
 	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo );
 
 	DBG_871X( "[%s] Role = %d, Status = %d, peer addr = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n", __FUNCTION__, rtw_p2p_role(pwdinfo), rtw_p2p_state(pwdinfo),
-			pwdinfo->p2p_peer_device_addr[ 0 ], pwdinfo->p2p_peer_device_addr[ 1 ],
+			pwdinfo->p2p_peer_device_addr[ 0 ], pwdinfo->p2p_peer_device_addr[ 1 ], 
 			pwdinfo->p2p_peer_device_addr[ 2 ], pwdinfo->p2p_peer_device_addr[ 3 ],
 			pwdinfo->p2p_peer_device_addr[ 4 ], pwdinfo->p2p_peer_device_addr[ 5 ]);
 	sprintf( extra, "\nMAC %.2X:%.2X:%.2X:%.2X:%.2X:%.2X",
-			pwdinfo->p2p_peer_device_addr[ 0 ], pwdinfo->p2p_peer_device_addr[ 1 ],
+			pwdinfo->p2p_peer_device_addr[ 0 ], pwdinfo->p2p_peer_device_addr[ 1 ], 
 			pwdinfo->p2p_peer_device_addr[ 2 ], pwdinfo->p2p_peer_device_addr[ 3 ],
 			pwdinfo->p2p_peer_device_addr[ 4 ], pwdinfo->p2p_peer_device_addr[ 5 ]);
-	wrqu->data.length = strlen( extra );
+	wrqu->data.length = strlen( extra );	
 	return ret;
-
+		
 }
 
 static int rtw_p2p_get_groupid(struct net_device *dev,
@@ -4411,20 +4411,20 @@ static int rtw_p2p_get_groupid(struct net_device *dev,
                                union iwreq_data *wrqu, char *extra)
 
 {
-
-	int ret = 0;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	
+	int ret = 0;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
 	struct iw_point *pdata = &wrqu->data;
 	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo );
 
 	sprintf( extra, "\n%.2X:%.2X:%.2X:%.2X:%.2X:%.2X %s",
-			pwdinfo->groupid_info.go_device_addr[ 0 ], pwdinfo->groupid_info.go_device_addr[ 1 ],
+			pwdinfo->groupid_info.go_device_addr[ 0 ], pwdinfo->groupid_info.go_device_addr[ 1 ], 
 			pwdinfo->groupid_info.go_device_addr[ 2 ], pwdinfo->groupid_info.go_device_addr[ 3 ],
 			pwdinfo->groupid_info.go_device_addr[ 4 ], pwdinfo->groupid_info.go_device_addr[ 5 ],
 			pwdinfo->groupid_info.ssid);
-	wrqu->data.length = strlen( extra );
+	wrqu->data.length = strlen( extra );	
 	return ret;
-
+		
 }
 
 static int rtw_p2p_get_op_ch(struct net_device *dev,
@@ -4432,19 +4432,19 @@ static int rtw_p2p_get_op_ch(struct net_device *dev,
                                union iwreq_data *wrqu, char *extra)
 
 {
-
-	int ret = 0;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	
+	int ret = 0;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
 	struct iw_point *pdata = &wrqu->data;
 	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo );
 
-
+	
 	DBG_871X( "[%s] Op_ch = %02x\n", __FUNCTION__, pwdinfo->operating_channel);
-
+	
 	sprintf( extra, "\n\nOp_ch=%.2d\n", pwdinfo->operating_channel );
 	wrqu->data.length = strlen( extra );
 	return ret;
-
+		
 }
 
 inline static void macstr2num(u8 *dst, u8 *src)
@@ -4459,8 +4459,8 @@ inline static void macstr2num(u8 *dst, u8 *src)
 static int rtw_p2p_get_wps_configmethod(struct net_device *dev,
 										struct iw_request_info *info,
 										union iwreq_data *wrqu, char *extra, char *subcmd)
-{
-
+{ 
+	
 	int ret = 0;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	u8 peerMAC[ETH_ALEN] = { 0x00 };
@@ -4528,8 +4528,8 @@ static int rtw_p2p_get_wps_configmethod(struct net_device *dev,
 	wrqu->data.length = strlen(attr_content_str);
 	_rtw_memcpy(extra, attr_content_str, wrqu->data.length);
 
-	return ret;
-
+	return ret; 
+		
 }
 
 #ifdef CONFIG_WFD
@@ -4537,9 +4537,9 @@ static int rtw_p2p_get_peer_wfd_port(struct net_device *dev,
                                struct iw_request_info *info,
                                union iwreq_data *wrqu, char *extra)
 {
-
-	int ret = 0;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	
+	int ret = 0;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
 	struct iw_point *pdata = &wrqu->data;
 	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo );
 
@@ -4547,19 +4547,19 @@ static int rtw_p2p_get_peer_wfd_port(struct net_device *dev,
 
 	sprintf( extra, "\n\nPort=%d\n", pwdinfo->wfd_info->peer_rtsp_ctrlport );
 	DBG_871X( "[%s] remote port = %d\n", __FUNCTION__, pwdinfo->wfd_info->peer_rtsp_ctrlport );
-
+	
 	wrqu->data.length = strlen( extra );
 	return ret;
-
+		
 }
 
 static int rtw_p2p_get_peer_wfd_preferred_connection(struct net_device *dev,
                                struct iw_request_info *info,
                                union iwreq_data *wrqu, char *extra)
 {
-
-	int ret = 0;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	
+	int ret = 0;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
 	struct iw_point *pdata = &wrqu->data;
 	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo );
 
@@ -4569,16 +4569,16 @@ static int rtw_p2p_get_peer_wfd_preferred_connection(struct net_device *dev,
 	wrqu->data.length = strlen( extra );
 	pwdinfo->wfd_info->wfd_pc = _FALSE;	//	Reset the WFD preferred connection to P2P
 	return ret;
-
+		
 }
 
 static int rtw_p2p_get_peer_wfd_session_available(struct net_device *dev,
                                struct iw_request_info *info,
                                union iwreq_data *wrqu, char *extra)
 {
-
-	int ret = 0;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	
+	int ret = 0;	
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
 	struct iw_point *pdata = &wrqu->data;
 	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo );
 
@@ -4588,7 +4588,7 @@ static int rtw_p2p_get_peer_wfd_session_available(struct net_device *dev,
 	wrqu->data.length = strlen( extra );
 	pwdinfo->wfd_info->peer_session_avail = _TRUE;	//	Reset the WFD session available
 	return ret;
-
+		
 }
 
 #endif // CONFIG_WFD
@@ -4598,7 +4598,7 @@ static int rtw_p2p_get_go_device_address(struct net_device *dev,
 										 union iwreq_data *wrqu, char *extra, char *subcmd)
 {
 
-	int ret = 0;
+	int ret = 0;	
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	u8 peerMAC[ETH_ALEN] = { 0x00 };
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
@@ -4681,15 +4681,15 @@ static int rtw_p2p_get_go_device_address(struct net_device *dev,
 	wrqu->data.length = strlen(go_devadd_str);
 	_rtw_memcpy(extra, go_devadd_str, wrqu->data.length);
 
-	return ret;
-
+	return ret; 
+		
 }
 
 static int rtw_p2p_get_device_type(struct net_device *dev,
 								   struct iw_request_info *info,
 								   union iwreq_data *wrqu, char *extra, char *subcmd)
-{
-
+{ 
+	
 	int ret = 0;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	u8 peerMAC[ETH_ALEN] = { 0x00 };
@@ -4759,15 +4759,15 @@ static int rtw_p2p_get_device_type(struct net_device *dev,
 	wrqu->data.length = strlen(dev_type_str);
 	_rtw_memcpy(extra, dev_type_str, wrqu->data.length);
 
-	return ret;
-
+	return ret; 
+		
 }
 
 static int rtw_p2p_get_device_name(struct net_device *dev,
 								   struct iw_request_info *info,
 								   union iwreq_data *wrqu, char *extra, char *subcmd)
-{
-
+{ 
+	
 	int ret = 0;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	u8 peerMAC[ETH_ALEN] = { 0x00 };
@@ -4833,8 +4833,8 @@ static int rtw_p2p_get_device_name(struct net_device *dev,
 	wrqu->data.length = strlen(dev_name_str);
 	_rtw_memcpy(extra, dev_name_str, wrqu->data.length);
 
-	return ret;
-
+	return ret; 
+		
 }
 
 static int rtw_p2p_get_invitation_procedure(struct net_device *dev,
@@ -4842,7 +4842,7 @@ static int rtw_p2p_get_invitation_procedure(struct net_device *dev,
 											union iwreq_data *wrqu, char *extra, char *subcmd)
 {
 
-	int ret = 0;
+	int ret = 0;	
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	u8 peerMAC[ETH_ALEN] = { 0x00 };
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
@@ -4922,17 +4922,17 @@ static int rtw_p2p_get_invitation_procedure(struct net_device *dev,
 	wrqu->data.length = strlen(inv_proc_str);
 	_rtw_memcpy(extra, inv_proc_str, wrqu->data.length);
 
-	return ret;
-
+	return ret; 
+		
 }
 
 static int rtw_p2p_connect(struct net_device *dev,
                                struct iw_request_info *info,
                                union iwreq_data *wrqu, char *extra)
 {
-
-	int ret = 0;
-	_adapter 				*padapter = (_adapter *)rtw_netdev_priv(dev);
+	
+	int ret = 0;	
+	_adapter 				*padapter = (_adapter *)rtw_netdev_priv(dev);	
 	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo );
 	u8					peerMAC[ ETH_ALEN ] = { 0x00 };
 	int 					jj,kk;
@@ -4946,9 +4946,9 @@ static int rtw_p2p_connect(struct net_device *dev,
 #ifdef CONFIG_CONCURRENT_MODE
 	_adapter				*pbuddy_adapter = padapter->pbuddy_adapter;
 	struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
-#endif // CONFIG_CONCURRENT_MODE
-
-
+#endif // CONFIG_CONCURRENT_MODE	
+	
+	
 	//	Commented by Albert 20110304
 	//	The input data contains two informations.
 	//	1. First information is the MAC address which wants to formate with
@@ -4963,12 +4963,12 @@ static int rtw_p2p_connect(struct net_device *dev,
 		DBG_871X( "[%s] WiFi Direct is disable!\n", __FUNCTION__ );
 		return ret;
 	}
-
+	
 	if ( pwdinfo->ui_got_wps_info == P2P_NO_WPSINFO )
 	{
 		return -1;
 	}
-
+	
 	for( jj = 0, kk = 0; jj < ETH_ALEN; jj++, kk += 3 )
 	{
 		peerMAC[ jj ] = key_2char2num( extra[kk], extra[kk+ 1] );
@@ -4978,7 +4978,7 @@ static int rtw_p2p_connect(struct net_device *dev,
 
 	phead = get_list_head(queue);
 	plist = get_next(phead);
-
+       
 	while(1)
 	{
 		if (rtw_end_of_queue_search(phead,plist)== _TRUE)
@@ -4992,8 +4992,8 @@ static int rtw_p2p_connect(struct net_device *dev,
               }
 
 		plist = get_next(plist);
-
-	}
+	
+	}        
 
 	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
 
@@ -5008,7 +5008,7 @@ static int rtw_p2p_connect(struct net_device *dev,
 
 		_rtw_memset( &pwdinfo->nego_req_info, 0x00, sizeof( struct tx_nego_req_info ) );
 		_rtw_memset( &pwdinfo->groupid_info, 0x00, sizeof( struct group_id_info ) );
-
+		
 		pwdinfo->nego_req_info.peer_channel_num[ 0 ] = uintPeerChannel;
 		_rtw_memcpy( pwdinfo->nego_req_info.peerDevAddr, pnetwork->network.MacAddress, ETH_ALEN );
 		pwdinfo->nego_req_info.benable = _TRUE;
@@ -5022,20 +5022,20 @@ static int rtw_p2p_connect(struct net_device *dev,
 
 		rtw_p2p_set_pre_state(pwdinfo, rtw_p2p_state(pwdinfo));
 		rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_ING);
-
+		
 #ifdef CONFIG_CONCURRENT_MODE
 		if ( check_buddy_fwstate(padapter, _FW_LINKED ) )
 		{
 			//	Have to enter the power saving with the AP
 			set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
-
+			
 			issue_nulldata(pbuddy_adapter, NULL, 1, 3, 500);
 		}
 #endif // CONFIG_CONCURRENT_MODE
 
 		DBG_871X( "[%s] Start PreTx Procedure!\n", __FUNCTION__ );
 		_set_timer( &pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT );
-
+		
 #ifdef CONFIG_CONCURRENT_MODE
 		if ( check_buddy_fwstate(padapter, _FW_LINKED ) )
 		{
@@ -5047,7 +5047,7 @@ static int rtw_p2p_connect(struct net_device *dev,
 		}
 #else
 		_set_timer( &pwdinfo->restore_p2p_state_timer, P2P_GO_NEGO_TIMEOUT );
-#endif // CONFIG_CONCURRENT_MODE
+#endif // CONFIG_CONCURRENT_MODE		
 
 	}
 	else
@@ -5055,7 +5055,7 @@ static int rtw_p2p_connect(struct net_device *dev,
 		DBG_871X( "[%s] Not Found in Scanning Queue~\n", __FUNCTION__ );
 		ret = -1;
 	}
-exit:
+exit:	
 	return ret;
 }
 
@@ -5063,9 +5063,9 @@ static int rtw_p2p_invite_req(struct net_device *dev,
                                struct iw_request_info *info,
                                union iwreq_data *wrqu, char *extra)
 {
-
-	int ret = 0;
-	_adapter 					*padapter = (_adapter *)rtw_netdev_priv(dev);
+	
+	int ret = 0;	
+	_adapter 					*padapter = (_adapter *)rtw_netdev_priv(dev);	
 	struct iw_point 			*pdata = &wrqu->data;
 	struct wifidirect_info		*pwdinfo = &( padapter->wdinfo );
 	int 						jj,kk;
@@ -5089,10 +5089,10 @@ static int rtw_p2p_invite_req(struct net_device *dev,
 #ifdef CONFIG_WFD
 	struct wifi_display_info*	pwfd_info = pwdinfo->wfd_info;
 #endif // CONFIG_WFD
-
+	
 	//	Commented by Albert 20120321
 	//	The input data contains two informations.
-	//	1. First information is the P2P device address which you want to send to.
+	//	1. First information is the P2P device address which you want to send to.	
 	//	2. Second information is the group id which combines with GO's mac address, space and GO's ssid.
 	//	Command line sample: iwpriv wlan0 p2p_set invite="00:11:22:33:44:55 00:E0:4C:00:00:05 DIRECT-xy"
 	//	Format: 00:11:22:33:44:55 00:E0:4C:00:00:05 DIRECT-xy
@@ -5121,7 +5121,7 @@ static int rtw_p2p_invite_req(struct net_device *dev,
 		_rtw_memset( pinvite_req_info->peer_macaddr, 0x00, ETH_ALEN );
 		pinvite_req_info->token = 3;
 	}
-
+	
 	for( jj = 0, kk = 0; jj < ETH_ALEN; jj++, kk += 3 )
 	{
 		pinvite_req_info->peer_macaddr[ jj ] = key_2char2num( extra[kk], extra[kk+ 1] );
@@ -5131,7 +5131,7 @@ static int rtw_p2p_invite_req(struct net_device *dev,
 
 	phead = get_list_head(queue);
 	plist = get_next(phead);
-
+       
 	while(1)
 	{
 		if (rtw_end_of_queue_search(phead,plist)== _TRUE)
@@ -5164,13 +5164,13 @@ static int rtw_p2p_invite_req(struct net_device *dev,
 				{
 					uintPeerChannel = pnetwork->network.Configuration.DSConfig;
 					break;
-				}
+				}					
 			}
 
 		}
 
 		plist = get_next(plist);
-
+	
 	}
 
 	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
@@ -5180,7 +5180,7 @@ static int rtw_p2p_invite_req(struct net_device *dev,
 	{
 		u8	wfd_ie[ 128 ] = { 0x00 };
 		uint	wfd_ielen = 0;
-
+		
 		if ( rtw_get_wfd_ie( &pnetwork->network.IEs[12], pnetwork->network.IELength - 12,  wfd_ie, &wfd_ielen ) )
 		{
 			u8	wfd_devinfo[ 6 ] = { 0x00 };
@@ -5190,7 +5190,7 @@ static int rtw_p2p_invite_req(struct net_device *dev,
 			if ( rtw_get_wfd_attr_content( wfd_ie, wfd_ielen, WFD_ATTR_DEVICE_INFO, wfd_devinfo, &wfd_devlen ) )
 			{
 				u16	wfd_devinfo_field = 0;
-
+				
 				//	Commented by Albert 20120319
 				//	The first two bytes are the WFD device information field of WFD device information subelement.
 				//	In big endian format.
@@ -5205,7 +5205,7 @@ static int rtw_p2p_invite_req(struct net_device *dev,
 				}
 			}
 		}
-
+		
 		if ( _FALSE == pwfd_info->peer_session_avail )
 		{
 			DBG_871X( "[%s] WFD Session not avaiable!\n", __FUNCTION__ );
@@ -5243,7 +5243,7 @@ static int rtw_p2p_invite_req(struct net_device *dev,
 		{
 			//	Have to enter the power saving with the AP
 			set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
-
+			
 			issue_nulldata(pbuddy_adapter, NULL, 1, 3, 500);
 		}
 		else
@@ -5255,7 +5255,7 @@ static int rtw_p2p_invite_req(struct net_device *dev,
 #endif
 
 		_set_timer( &pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT );
-
+		
 #ifdef CONFIG_CONCURRENT_MODE
 		if ( check_fwstate( pbuddy_mlmepriv, _FW_LINKED ) )
 		{
@@ -5267,27 +5267,27 @@ static int rtw_p2p_invite_req(struct net_device *dev,
 		}
 #else
 		_set_timer( &pwdinfo->restore_p2p_state_timer, P2P_INVITE_TIMEOUT );
-#endif // CONFIG_CONCURRENT_MODE
-
+#endif // CONFIG_CONCURRENT_MODE		
 
+		
 	}
 	else
 	{
 		DBG_871X( "[%s] NOT Found in the Scanning Queue!\n", __FUNCTION__ );
 	}
 exit:
-
+	
 	return ret;
-
+		
 }
 
 static int rtw_p2p_set_persistent(struct net_device *dev,
                                struct iw_request_info *info,
                                union iwreq_data *wrqu, char *extra)
 {
-
-	int ret = 0;
-	_adapter 					*padapter = (_adapter *)rtw_netdev_priv(dev);
+	
+	int ret = 0;	
+	_adapter 					*padapter = (_adapter *)rtw_netdev_priv(dev);	
 	struct iw_point 			*pdata = &wrqu->data;
 	struct wifidirect_info		*pwdinfo = &( padapter->wdinfo );
 	int 						jj,kk;
@@ -5311,12 +5311,12 @@ static int rtw_p2p_set_persistent(struct net_device *dev,
 #ifdef CONFIG_WFD
 	struct wifi_display_info*	pwfd_info = pwdinfo->wfd_info;
 #endif // CONFIG_WFD
-
+	
 	//	Commented by Albert 20120328
 	//	The input data is 0 or 1
 	//	0: disable persistent group functionality
 	//	1: enable persistent group founctionality
-
+	
 	DBG_871X( "[%s] data = %s\n", __FUNCTION__, extra );
 
 	if(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
@@ -5340,11 +5340,11 @@ static int rtw_p2p_set_persistent(struct net_device *dev,
 		}
 	}
 	printk( "[%s] persistent_supported = %d\n", __FUNCTION__, pwdinfo->persistent_supported );
-
+	
 exit:
-
+	
 	return ret;
-
+		
 }
 
 static int hexstr2bin(const char *hex, u8 *buf, size_t len)
@@ -5409,7 +5409,7 @@ static int rtw_p2p_set_wps_uuid(struct net_device *dev,
 
 	DBG_871X("[%s] data = %s\n", __FUNCTION__, extra);
 
-	if ((36 == strlen(extra)) && (uuid_str2bin(extra, pwdinfo->uuid) == 0))
+	if ((36 == strlen(extra)) && (uuid_str2bin(extra, pwdinfo->uuid) == 0)) 
 	{
 		pwdinfo->external_uuid = 1;
 	} else {
@@ -5425,9 +5425,9 @@ static int rtw_p2p_set_pc(struct net_device *dev,
                                struct iw_request_info *info,
                                union iwreq_data *wrqu, char *extra)
 {
-
-	int ret = 0;
-	_adapter 				*padapter = (_adapter *)rtw_netdev_priv(dev);
+	
+	int ret = 0;	
+	_adapter 				*padapter = (_adapter *)rtw_netdev_priv(dev);	
 	struct iw_point 		*pdata = &wrqu->data;
 	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo );
 	u8					peerMAC[ ETH_ALEN ] = { 0x00 };
@@ -5445,9 +5445,9 @@ static int rtw_p2p_set_pc(struct net_device *dev,
 #ifdef CONFIG_CONCURRENT_MODE
 	_adapter				*pbuddy_adapter = padapter->pbuddy_adapter;
 	struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
-#endif // CONFIG_CONCURRENT_MODE
+#endif // CONFIG_CONCURRENT_MODE	
 	struct wifi_display_info*	pwfd_info = pwdinfo->wfd_info;
-
+	
 	//	Commented by Albert 20120512
 	//	1. Input information is the MAC address which wants to know the Preferred Connection bit (PC bit)
 	//	Format: 00:E0:4C:00:00:05
@@ -5459,7 +5459,7 @@ static int rtw_p2p_set_pc(struct net_device *dev,
 		DBG_871X( "[%s] WiFi Direct is disable!\n", __FUNCTION__ );
 		return ret;
 	}
-
+	
 	for( jj = 0, kk = 0; jj < ETH_ALEN; jj++, kk += 3 )
 	{
 		peerMAC[ jj ] = key_2char2num( extra[kk], extra[kk+ 1] );
@@ -5469,7 +5469,7 @@ static int rtw_p2p_set_pc(struct net_device *dev,
 
 	phead = get_list_head(queue);
 	plist = get_next(phead);
-
+       
 	while(1)
 	{
 		if (rtw_end_of_queue_search(phead,plist)== _TRUE)
@@ -5504,13 +5504,13 @@ static int rtw_p2p_set_pc(struct net_device *dev,
 				{
 					uintPeerChannel = pnetwork->network.Configuration.DSConfig;
 					break;
-				}
+				}					
 			}
 
 		}
 
 		plist = get_next(plist);
-
+	
 	}
 
 	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
@@ -5520,7 +5520,7 @@ static int rtw_p2p_set_pc(struct net_device *dev,
 	{
 		u8	wfd_ie[ 128 ] = { 0x00 };
 		uint	wfd_ielen = 0;
-
+		
 		if ( rtw_get_wfd_ie( &pnetwork->network.IEs[12], pnetwork->network.IELength - 12,  wfd_ie, &wfd_ielen ) )
 		{
 			u8	wfd_devinfo[ 6 ] = { 0x00 };
@@ -5530,7 +5530,7 @@ static int rtw_p2p_set_pc(struct net_device *dev,
 			if ( rtw_get_wfd_attr_content( wfd_ie, wfd_ielen, WFD_ATTR_DEVICE_INFO, wfd_devinfo, &wfd_devlen ) )
 			{
 				u16	wfd_devinfo_field = 0;
-
+				
 				//	Commented by Albert 20120319
 				//	The first two bytes are the WFD device information field of WFD device information subelement.
 				//	In big endian format.
@@ -5545,25 +5545,25 @@ static int rtw_p2p_set_pc(struct net_device *dev,
 				}
 			}
 		}
-	}
+	}	
 	else
 	{
 		DBG_871X( "[%s] NOT Found in the Scanning Queue!\n", __FUNCTION__ );
 	}
 
 exit:
-
+	
 	return ret;
-
+		
 }
 
 static int rtw_p2p_set_wfd_device_type(struct net_device *dev,
                                struct iw_request_info *info,
                                union iwreq_data *wrqu, char *extra)
 {
-
-	int ret = 0;
-	_adapter 					*padapter = (_adapter *)rtw_netdev_priv(dev);
+	
+	int ret = 0;	
+	_adapter 					*padapter = (_adapter *)rtw_netdev_priv(dev);	
 	struct iw_point 			*pdata = &wrqu->data;
 	struct wifidirect_info		*pwdinfo = &( padapter->wdinfo );
 	struct wifi_display_info		*pwfd_info = pwdinfo->wfd_info;
@@ -5572,7 +5572,7 @@ static int rtw_p2p_set_wfd_device_type(struct net_device *dev,
 	//	The input data is 0 or 1
 	//	0: specify to Miracast source device
 	//	1 or others: specify to Miracast sink device (display device)
-
+	
 	DBG_871X( "[%s] data = %s\n", __FUNCTION__, extra );
 
 	if ( extra[ 0 ] == '0' )	//	Set to Miracast source device.
@@ -5583,24 +5583,24 @@ static int rtw_p2p_set_wfd_device_type(struct net_device *dev,
 	{
 		pwfd_info->wfd_device_type = WFD_DEVINFO_PSINK;
 	}
-
+	
 exit:
 
 	return ret;
-
+		
 }
 
 static int rtw_p2p_set_scan_result_type(struct net_device *dev,
                                struct iw_request_info *info,
                                union iwreq_data *wrqu, char *extra)
 {
-
-	int ret = 0;
-	_adapter 					*padapter = (_adapter *)rtw_netdev_priv(dev);
+	
+	int ret = 0;	
+	_adapter 					*padapter = (_adapter *)rtw_netdev_priv(dev);	
 	struct iw_point 			*pdata = &wrqu->data;
 	struct wifidirect_info		*pwdinfo = &( padapter->wdinfo );
 	struct wifi_display_info		*pwfd_info = pwdinfo->wfd_info;
-
+	
 	//	Commented by Albert 20120328
 	//	The input data is 0 , 1 , 2
 	//	0: when the P2P is enabled, the scan result will return all the found P2P device.
@@ -5608,7 +5608,7 @@ static int rtw_p2p_set_scan_result_type(struct net_device *dev,
 	//	2: when the P2P is enabled, the scan result will show up the found Miracast devices base on...
 	//	It will show up all the Miracast source device if this device is sink.
 	//	It will show up all the Miracast sink device if this device is source.
-
+	
 	DBG_871X( "[%s] data = %s\n", __FUNCTION__, extra );
 
 	if ( extra[ 0 ] == '0' )
@@ -5627,11 +5627,11 @@ static int rtw_p2p_set_scan_result_type(struct net_device *dev,
 	{
 		pwfd_info->scan_result_type = SCAN_RESULT_P2P_ONLY;
 	}
-
+	
 exit:
-
+	
 	return ret;
-
+		
 }
 
 static int rtw_p2p_set_wfd_enable(struct net_device *dev,
@@ -5641,7 +5641,7 @@ static int rtw_p2p_set_wfd_enable(struct net_device *dev,
 //	Commented by Kurt 20121206
 //	This function is used to set wfd enabled
 
-	int ret = 0;
+	int ret = 0;	
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
 
@@ -5651,9 +5651,9 @@ static int rtw_p2p_set_wfd_enable(struct net_device *dev,
 		pwdinfo->wfd_info->wfd_enable = _TRUE;
 
 	DBG_871X( "[%s] wfd_enable = %d\n", __FUNCTION__, pwdinfo->wfd_info->wfd_enable );
-
+	
 	return ret;
-
+		
 }
 
 static int rtw_p2p_set_driver_iface(struct net_device *dev,
@@ -5662,7 +5662,7 @@ static int rtw_p2p_set_driver_iface(struct net_device *dev,
 {
 //	Commented by Kurt 20121206
 //	This function is used to set driver iface is WEXT or CFG80211
-	int ret = 0;
+	int ret = 0;	
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
 
@@ -5676,9 +5676,9 @@ static int rtw_p2p_set_driver_iface(struct net_device *dev,
 		pwdinfo->driver_interface = DRIVER_CFG80211;
 		DBG_871X( "[%s] driver_interface = CFG80211\n", __FUNCTION__);
 	}
-
+	
 	return ret;
-
+		
 }
 
 //	To set the WFD session available to enable or disable
@@ -5686,13 +5686,13 @@ static int rtw_p2p_set_sa(struct net_device *dev,
                                struct iw_request_info *info,
                                union iwreq_data *wrqu, char *extra)
 {
-
-	int ret = 0;
-	_adapter 					*padapter = (_adapter *)rtw_netdev_priv(dev);
+	
+	int ret = 0;	
+	_adapter 					*padapter = (_adapter *)rtw_netdev_priv(dev);	
 	struct iw_point 			*pdata = &wrqu->data;
 	struct wifidirect_info		*pwdinfo = &( padapter->wdinfo );
 	struct wifi_display_info		*pwfd_info = pwdinfo->wfd_info;
-
+	
 	DBG_871X( "[%s] data = %s\n", __FUNCTION__, extra );
 
 	if( 0 )
@@ -5716,20 +5716,20 @@ static int rtw_p2p_set_sa(struct net_device *dev,
 		}
 	}
 	printk( "[%s] session available = %d\n", __FUNCTION__, pwdinfo->session_available );
-
+	
 exit:
-
+	
 	return ret;
-
+		
 }
 #endif //CONFIG_WFD
 
 static int rtw_p2p_prov_disc(struct net_device *dev,
                                struct iw_request_info *info,
                                union iwreq_data *wrqu, char *extra)
-{
-	int ret = 0;
-	_adapter 				*padapter = (_adapter *)rtw_netdev_priv(dev);
+{	
+	int ret = 0;	
+	_adapter 				*padapter = (_adapter *)rtw_netdev_priv(dev);	
 	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo );
 	u8					peerMAC[ ETH_ALEN ] = { 0x00 };
 	int 					jj,kk;
@@ -5747,12 +5747,12 @@ static int rtw_p2p_prov_disc(struct net_device *dev,
 #ifdef CONFIG_CONCURRENT_MODE
 	_adapter				*pbuddy_adapter = padapter->pbuddy_adapter;
 	struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
-#endif // CONFIG_CONCURRENT_MODE
-
+#endif // CONFIG_CONCURRENT_MODE	
+	
 #ifdef CONFIG_WFD
 	struct wifi_display_info*	pwfd_info = pwdinfo->wfd_info;
 #endif // CONFIG_WFD
-
+	
 	//	Commented by Albert 20110301
 	//	The input data contains two informations.
 	//	1. First information is the MAC address which wants to issue the provisioning discovery request frame.
@@ -5781,12 +5781,12 @@ static int rtw_p2p_prov_disc(struct net_device *dev,
 		//	Reset the content of struct tx_provdisc_req_info excluded the wps_config_method_request.
 		_rtw_memset( pwdinfo->tx_prov_disc_info.peerDevAddr, 0x00, ETH_ALEN );
 		_rtw_memset( pwdinfo->tx_prov_disc_info.peerIFAddr, 0x00, ETH_ALEN );
-		_rtw_memset( &pwdinfo->tx_prov_disc_info.ssid, 0x00, sizeof( NDIS_802_11_SSID ) );
+		_rtw_memset( &pwdinfo->tx_prov_disc_info.ssid, 0x00, sizeof( NDIS_802_11_SSID ) );		
 		pwdinfo->tx_prov_disc_info.peer_channel_num[ 0 ] = 0;
 		pwdinfo->tx_prov_disc_info.peer_channel_num[ 1 ] = 0;
 		pwdinfo->tx_prov_disc_info.benable = _FALSE;
 	}
-
+	
 	for( jj = 0, kk = 0; jj < ETH_ALEN; jj++, kk += 3 )
 	{
 		peerMAC[ jj ] = key_2char2num( extra[kk], extra[kk+ 1] );
@@ -5819,7 +5819,7 @@ static int rtw_p2p_prov_disc(struct net_device *dev,
 
 	phead = get_list_head(queue);
 	plist = get_next(phead);
-
+       
 	while(1)
 	{
 		if (rtw_end_of_queue_search(phead,plist)== _TRUE)
@@ -5862,7 +5862,7 @@ static int rtw_p2p_prov_disc(struct net_device *dev,
 					{
 						uintPeerChannel = pnetwork->network.Configuration.DSConfig;
 						break;
-					}
+					}					
 				}
 
 				//Get the next P2P IE
@@ -5871,9 +5871,9 @@ static int rtw_p2p_prov_disc(struct net_device *dev,
 		}
 
 #ifdef CONFIG_INTEL_WIDI
-			// Some Intel WiDi source may not provide P2P IE,
+			// Some Intel WiDi source may not provide P2P IE, 
 			// so we could only compare mac addr by 802.11 Source Address
-			if( pmlmepriv->widi_state == INTEL_WIDI_STATE_WFD_CONNECTION
+			if( pmlmepriv->widi_state == INTEL_WIDI_STATE_WFD_CONNECTION 
 				&& uintPeerChannel == 0 )
 			{
 				if ( _rtw_memcmp( pnetwork->network.MacAddress, peerMAC, ETH_ALEN ) )
@@ -5885,7 +5885,7 @@ static int rtw_p2p_prov_disc(struct net_device *dev,
 #endif //CONFIG_INTEL_WIDI
 
 		plist = get_next(plist);
-
+	
 	}
 
 	_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);
@@ -5896,7 +5896,7 @@ static int rtw_p2p_prov_disc(struct net_device *dev,
 	{
 		u8	wfd_ie[ 128 ] = { 0x00 };
 		uint	wfd_ielen = 0;
-
+		
 		if ( rtw_get_wfd_ie( &pnetwork->network.IEs[12], pnetwork->network.IELength - 12,  wfd_ie, &wfd_ielen ) )
 		{
 			u8	wfd_devinfo[ 6 ] = { 0x00 };
@@ -5906,7 +5906,7 @@ static int rtw_p2p_prov_disc(struct net_device *dev,
 			if ( rtw_get_wfd_attr_content( wfd_ie, wfd_ielen, WFD_ATTR_DEVICE_INFO, wfd_devinfo, &wfd_devlen ) )
 			{
 				u16	wfd_devinfo_field = 0;
-
+				
 				//	Commented by Albert 20120319
 				//	The first two bytes are the WFD device information field of WFD device information subelement.
 				//	In big endian format.
@@ -5921,13 +5921,13 @@ static int rtw_p2p_prov_disc(struct net_device *dev,
 				}
 			}
 		}
-
+		
 		if ( _FALSE == pwfd_info->peer_session_avail )
 		{
 			DBG_871X( "[%s] WFD Session not avaiable!\n", __FUNCTION__ );
 			goto exit;
 		}
-	}
+	}	
 #endif // CONFIG_WFD
 
 		DBG_871X( "[%s] peer channel: %d!\n", __FUNCTION__, uintPeerChannel );
@@ -5959,7 +5959,7 @@ static int rtw_p2p_prov_disc(struct net_device *dev,
 		{
 			//	Have to enter the power saving with the AP
 			set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
-
+			
 			issue_nulldata(pbuddy_adapter, NULL, 1, 3, 500);
 		}
 		else
@@ -5971,7 +5971,7 @@ static int rtw_p2p_prov_disc(struct net_device *dev,
 #endif
 
 		_set_timer( &pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT );
-
+		
 #ifdef CONFIG_CONCURRENT_MODE
 		if ( check_buddy_fwstate(padapter, _FW_LINKED ) )
 		{
@@ -5983,9 +5983,9 @@ static int rtw_p2p_prov_disc(struct net_device *dev,
 		}
 #else
 		_set_timer( &pwdinfo->restore_p2p_state_timer, P2P_PROVISION_TIMEOUT );
-#endif // CONFIG_CONCURRENT_MODE
-
+#endif // CONFIG_CONCURRENT_MODE		
 
+		
 	}
 	else
 	{
@@ -5993,16 +5993,16 @@ static int rtw_p2p_prov_disc(struct net_device *dev,
 #ifdef CONFIG_INTEL_WIDI
 		rtw_p2p_set_state(pwdinfo, P2P_STATE_FIND_PHASE_SEARCH);
 		rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_NONE);
-		rtw_free_network_queue(padapter, _TRUE);
-		_enter_critical_bh(&pmlmepriv->lock, &irqL);
+		rtw_free_network_queue(padapter, _TRUE);		
+		_enter_critical_bh(&pmlmepriv->lock, &irqL);				
 		rtw_sitesurvey_cmd(padapter, NULL, 0, NULL, 0);
 		_exit_critical_bh(&pmlmepriv->lock, &irqL);
 #endif //CONFIG_INTEL_WIDI
 	}
 exit:
-
+	
 	return ret;
-
+		
 }
 
 //	Added by Albert 20110328
@@ -6013,11 +6013,11 @@ static int rtw_p2p_got_wpsinfo(struct net_device *dev,
                                struct iw_request_info *info,
                                union iwreq_data *wrqu, char *extra)
 {
-
-	int ret = 0;
-	_adapter 				*padapter = (_adapter *)rtw_netdev_priv(dev);
+	
+	int ret = 0;	
+	_adapter 				*padapter = (_adapter *)rtw_netdev_priv(dev);	
 	struct wifidirect_info	*pwdinfo = &( padapter->wdinfo );
-
+	
 
 	DBG_871X( "[%s] data = %s\n", __FUNCTION__, extra );
 	//	Added by Albert 20110328
@@ -6025,7 +6025,7 @@ static int rtw_p2p_got_wpsinfo(struct net_device *dev,
 	//	if the input data is P2P_GOT_WPSINFO_PEER_DISPLAY_PIN -> the utility just input the PIN code got from the peer P2P device.
 	//	if the input data is P2P_GOT_WPSINFO_SELF_DISPLAY_PIN -> the utility just got the PIN code from itself.
 	//	if the input data is P2P_GOT_WPSINFO_PBC -> the utility just determine to use the PBC
-
+	
 	if ( *extra == '0' )
 	{
 		pwdinfo->ui_got_wps_info = P2P_NO_WPSINFO;
@@ -6046,9 +6046,9 @@ static int rtw_p2p_got_wpsinfo(struct net_device *dev,
 	{
 		pwdinfo->ui_got_wps_info = P2P_NO_WPSINFO;
 	}
-
+	
 	return ret;
-
+		
 }
 
 #endif //CONFIG_P2P
@@ -6057,12 +6057,12 @@ static int rtw_p2p_set(struct net_device *dev,
                                struct iw_request_info *info,
                                union iwreq_data *wrqu, char *extra)
 {
-
+	
 	int ret = 0;
 #ifdef CONFIG_P2P
 
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
-	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);	
 	struct iw_point *pdata = &wrqu->data;
 	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
@@ -6115,7 +6115,7 @@ static int rtw_p2p_set(struct net_device *dev,
 	{
 		//	Commented by Albert 2011/05/24
 		//	The wrqu->data.length will include the null character
-		//	So, we will decrease (10 + 1)
+		//	So, we will decrease (10 + 1)	
 		wrqu->data.length -= 11;
 		rtw_p2p_set_listen_ch( dev, info, wrqu, &extra[10] );
 	}
@@ -6123,7 +6123,7 @@ static int rtw_p2p_set(struct net_device *dev,
 	{
 		//	Commented by Albert 2011/05/24
 		//	The wrqu->data.length will include the null character
-		//	So, we will decrease (6 + 1)
+		//	So, we will decrease (6 + 1)	
 		wrqu->data.length -= 7;
 		rtw_p2p_set_op_ch( dev, info, wrqu, &extra[6] );
 	}
@@ -6180,20 +6180,20 @@ static int rtw_p2p_set(struct net_device *dev,
 #endif //CONFIG_P2P
 
 	return ret;
-
+		
 }
 
 static int rtw_p2p_get(struct net_device *dev,
                                struct iw_request_info *info,
                                union iwreq_data *wrqu, char *extra)
 {
-
-	int ret = 0;
-
+	
+	int ret = 0;	
+	
 #ifdef CONFIG_P2P
 
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
-	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);	
 	struct iw_point *pdata = &wrqu->data;
 	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
@@ -6202,7 +6202,7 @@ static int rtw_p2p_get(struct net_device *dev,
 	{
 		DBG_871X( "[%s] extra = %s\n", __FUNCTION__, (char*) wrqu->data.pointer );
 	}
-
+	
 	if ( _rtw_memcmp( wrqu->data.pointer, "status", 6 ) )
 	{
 		rtw_p2p_get_status( dev, info, wrqu, extra );
@@ -6250,12 +6250,12 @@ static int rtw_p2p_get(struct net_device *dev,
 	{
 		rtw_p2p_get_peer_wfd_preferred_connection( dev, info, wrqu, extra );
 	}
-#endif // CONFIG_WFD
-
+#endif // CONFIG_WFD	
+	
 #endif //CONFIG_P2P
 
 	return ret;
-
+		
 }
 
 static int rtw_p2p_get2(struct net_device *dev,
@@ -6322,14 +6322,14 @@ static int rtw_rereg_nd_name(struct net_device *dev,
                                struct iw_request_info *info,
                                union iwreq_data *wrqu, char *extra)
 {
-	int ret = 0;
+	int ret = 0;	
 	_adapter *padapter = rtw_netdev_priv(dev);
 	struct rereg_nd_name_data *rereg_priv = &padapter->rereg_nd_name_priv;
 	char new_ifname[IFNAMSIZ];
 
 	if(rereg_priv->old_ifname[0] == 0) {
 		char *reg_ifname;
-#ifdef CONFIG_CONCURRENT_MODE
+#ifdef CONFIG_CONCURRENT_MODE 
 		if (padapter->isprimary)
 			reg_ifname = padapter->registrypriv.ifname;
 		else
@@ -6365,19 +6365,19 @@ static int rtw_rereg_nd_name(struct net_device *dev,
 
 	strncpy(rereg_priv->old_ifname, new_ifname, IFNAMSIZ);
 	rereg_priv->old_ifname[IFNAMSIZ-1] = 0;
-
+	
 	if(_rtw_memcmp(new_ifname, "disable%d", 9) == _TRUE) {
 
 		DBG_871X("%s disable\n", __FUNCTION__);
 		// free network queue for Android's timming issue
 		rtw_free_network_queue(padapter, _TRUE);
-
+		
 		// close led
 		rtw_led_control(padapter, LED_CTL_POWER_OFF);
 		rereg_priv->old_bRegUseLed = padapter->ledpriv.bRegUseLed;
 		padapter->ledpriv.bRegUseLed= _FALSE;
 		rtw_hal_sw_led_deinit(padapter);
-
+		
 		// the interface is being "disabled", we can do deeper IPS
 		rereg_priv->old_ips_mode = rtw_get_ips_mode_req(&padapter->pwrctrlpriv);
 		rtw_ips_mode_req(&padapter->pwrctrlpriv, IPS_NORMAL);
@@ -6390,48 +6390,48 @@ static int rtw_rereg_nd_name(struct net_device *dev,
 #if 0
 void mac_reg_dump(_adapter *padapter)
 {
-	int i,j=1;
+	int i,j=1;		
 	DBG_871X("\n======= MAC REG =======\n");
 	for(i=0x0;i<0x300;i+=4)
-	{
+	{	
 		if(j%4==1)	DBG_871X("0x%02x",i);
-		DBG_871X(" 0x%08x ",rtw_read32(padapter,i));
-		if((j++)%4 == 0)	DBG_871X("\n");
+		DBG_871X(" 0x%08x ",rtw_read32(padapter,i));		
+		if((j++)%4 == 0)	DBG_871X("\n");	
 	}
 	for(i=0x400;i<0x800;i+=4)
-	{
+	{	
 		if(j%4==1)	DBG_871X("0x%02x",i);
-		DBG_871X(" 0x%08x ",rtw_read32(padapter,i));
-		if((j++)%4 == 0)	DBG_871X("\n");
-	}
+		DBG_871X(" 0x%08x ",rtw_read32(padapter,i));		
+		if((j++)%4 == 0)	DBG_871X("\n");	
+	}									
 }
 void bb_reg_dump(_adapter *padapter)
 {
-	int i,j=1;
+	int i,j=1;		
 	DBG_871X("\n======= BB REG =======\n");
 	for(i=0x800;i<0x1000;i+=4)
 	{
 		if(j%4==1) DBG_871X("0x%02x",i);
-
-		DBG_871X(" 0x%08x ",rtw_read32(padapter,i));
-		if((j++)%4 == 0)	DBG_871X("\n");
-	}
+				
+		DBG_871X(" 0x%08x ",rtw_read32(padapter,i));		
+		if((j++)%4 == 0)	DBG_871X("\n");	
+	}		
 }
 void rf_reg_dump(_adapter *padapter)
-{
+{	
 	int i,j=1,path;
-	u32 value;
+	u32 value;			
 	DBG_871X("\n======= RF REG =======\n");
 	for(path=0;path<2;path++)
 	{
 		DBG_871X("\nRF_Path(%x)\n",path);
 		for(i=0;i<0x100;i++)
-		{
+		{								
 			value = PHY_QueryRFReg(padapter, (RF90_RADIO_PATH_E)path,i, bMaskDWord);
 			if(j%4==1)	DBG_871X("0x%02x ",i);
 			DBG_871X(" 0x%08x ",value);
-			if((j++)%4==0)	DBG_871X("\n");
-		}
+			if((j++)%4==0)	DBG_871X("\n");	
+		}	
 	}
 }
 
@@ -6439,57 +6439,57 @@ void rf_reg_dump(_adapter *padapter)
 
 void mac_reg_dump(_adapter *padapter)
 {
-	int i,j=1;
+	int i,j=1;		
 	DBG_871X("\n======= MAC REG =======\n");
 	for(i=0x0;i<0x300;i+=4)
-	{
+	{	
 		if(j%4==1)	DBG_871X("0x%02x",i);
-		DBG_871X(" 0x%08x ",rtw_read32(padapter,i));
-		if((j++)%4 == 0)	DBG_871X("\n");
+		DBG_871X(" 0x%08x ",rtw_read32(padapter,i));		
+		if((j++)%4 == 0)	DBG_871X("\n");	
 	}
 	for(i=0x400;i<0x800;i+=4)
-	{
+	{	
 		if(j%4==1)	DBG_871X("0x%02x",i);
-		DBG_871X(" 0x%08x ",rtw_read32(padapter,i));
-		if((j++)%4 == 0)	DBG_871X("\n");
-	}
+		DBG_871X(" 0x%08x ",rtw_read32(padapter,i));		
+		if((j++)%4 == 0)	DBG_871X("\n");	
+	}									
 }
 void bb_reg_dump(_adapter *padapter)
 {
-	int i,j=1;
+	int i,j=1;		
 	DBG_871X("\n======= BB REG =======\n");
 	for(i=0x800;i<0x1000;i+=4)
 	{
 		if(j%4==1) DBG_871X("0x%02x",i);
-
-		DBG_871X(" 0x%08x ",rtw_read32(padapter,i));
-		if((j++)%4 == 0)	DBG_871X("\n");
-	}
+				
+		DBG_871X(" 0x%08x ",rtw_read32(padapter,i));		
+		if((j++)%4 == 0)	DBG_871X("\n");	
+	}		
 }
 void rf_reg_dump(_adapter *padapter)
-{
+{	
 	int i,j=1,path;
-	u32 value;
+	u32 value;	
 	u8 rf_type,path_nums = 0;
 	rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
-
+		
 	DBG_871X("\n======= RF REG =======\n");
-	if((RF_1T2R == rf_type) ||(RF_1T1R ==rf_type ))
+	if((RF_1T2R == rf_type) ||(RF_1T1R ==rf_type ))	
 		path_nums = 1;
-	else
+	else	
 		path_nums = 2;
-
+		
 	for(path=0;path<path_nums;path++)
 	{
 		DBG_871X("\nRF_Path(%x)\n",path);
 		for(i=0;i<0x100;i++)
-		{
+		{								
 			//value = PHY_QueryRFReg(padapter, (RF90_RADIO_PATH_E)path,i, bMaskDWord);
 			value =rtw_hal_read_rfreg(padapter, path, i, 0xffffffff);
 			if(j%4==1)	DBG_871X("0x%02x ",i);
 			DBG_871X(" 0x%08x ",value);
-			if((j++)%4==0)	DBG_871X("\n");
-		}
+			if((j++)%4==0)	DBG_871X("\n");	
+		}	
 	}
 }
 
@@ -6502,13 +6502,13 @@ void rf_reg_dump(_adapter *padapter)
 static int rtw_dbg_port(struct net_device *dev,
                                struct iw_request_info *info,
                                union iwreq_data *wrqu, char *extra)
-{
+{	
 	_irqL irqL;
 	int ret = 0;
 	u8 major_cmd, minor_cmd;
 	u16 arg;
 	u32 extra_arg, *pdata, val32;
-	struct sta_info *psta;
+	struct sta_info *psta;						
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
@@ -6516,9 +6516,9 @@ static int rtw_dbg_port(struct net_device *dev,
 	struct security_priv *psecuritypriv = &padapter->securitypriv;
 	struct wlan_network *cur_network = &(pmlmepriv->cur_network);
 	struct sta_priv *pstapriv = &padapter->stapriv;
+	
 
-
-	pdata = (u32*)&wrqu->data;
+	pdata = (u32*)&wrqu->data;	
 
 	val32 = *pdata;
 	arg = (u16)(val32&0x0000ffff);
@@ -6526,7 +6526,7 @@ static int rtw_dbg_port(struct net_device *dev,
 	minor_cmd = (u8)((val32>>16)&0x00ff);
 
 	extra_arg = *(pdata+1);
-
+	
 	switch(major_cmd)
 	{
 		case 0x70://read_reg
@@ -6541,7 +6541,7 @@ static int rtw_dbg_port(struct net_device *dev,
 				case 4:
 					DBG_871X("rtw_read32(0x%x)=0x%08x\n", arg, rtw_read32(padapter, arg));
 					break;
-			}
+			}			
 			break;
 		case 0x71://write_reg
 			switch(minor_cmd)
@@ -6558,7 +6558,7 @@ static int rtw_dbg_port(struct net_device *dev,
 					rtw_write32(padapter, arg, extra_arg);
 					DBG_871X("rtw_write32(0x%x)=0x%08x\n", arg, rtw_read32(padapter, arg));
 					break;
-			}
+			}			
 			break;
 		case 0x72://read_bb
 			DBG_871X("read_bbreg(0x%x)=0x%x\n", arg, rtw_hal_read_bbreg(padapter, arg, 0xffffffff));
@@ -6568,22 +6568,23 @@ static int rtw_dbg_port(struct net_device *dev,
 			DBG_871X("write_bbreg(0x%x)=0x%x\n", arg, rtw_hal_read_bbreg(padapter, arg, 0xffffffff));
 			break;
 		case 0x74://read_rf
-			DBG_871X("read RF_reg path(0x%02x),offset(0x%x),value(0x%08x)\n",minor_cmd,arg,rtw_hal_read_rfreg(padapter, minor_cmd, arg, 0xffffffff));
+			DBG_871X("read RF_reg path(0x%02x),offset(0x%x),value(0x%08x)\n",minor_cmd,arg,rtw_hal_read_rfreg(padapter, minor_cmd, arg, 0xffffffff));	
 			break;
 		case 0x75://write_rf
 			rtw_hal_write_rfreg(padapter, minor_cmd, arg, 0xffffffff, extra_arg);
 			DBG_871X("write RF_reg path(0x%02x),offset(0x%x),value(0x%08x)\n",minor_cmd,arg, rtw_hal_read_rfreg(padapter, minor_cmd, arg, 0xffffffff));
-			break;
+			break;	
 
 		case 0x76:
 			switch(minor_cmd)
 			{
-				case 0x00: //normal mode,
+				case 0x00: //normal mode, 
 					padapter->recvpriv.is_signal_dbg = 0;
 					break;
 				case 0x01: //dbg mode
 					padapter->recvpriv.is_signal_dbg = 1;
 					extra_arg = extra_arg>100?100:extra_arg;
+					extra_arg = extra_arg<0?0:extra_arg;
 					padapter->recvpriv.signal_strength_dbg=extra_arg;
 					break;
 			}
@@ -6599,10 +6600,10 @@ static int rtw_dbg_port(struct net_device *dev,
 						struct xmit_frame	*xmit_frame;
 
 						if((xmit_frame=rtw_IOL_accquire_xmit_frame(padapter)) == NULL) {
-							ret = -ENOMEM;
+							ret = -ENOMEM;	
 							break;
 						}
-
+						
 						rtw_IOL_append_LLT_cmd(xmit_frame, page_boundary);
 
 
@@ -6617,12 +6618,12 @@ static int rtw_dbg_port(struct net_device *dev,
 					u32 blink_num = 50;
 					u32 blink_delay_ms = 200;
 					int i;
-
+					
 					{
 						struct xmit_frame	*xmit_frame;
 
 						if((xmit_frame=rtw_IOL_accquire_xmit_frame(padapter)) == NULL) {
-							ret = -ENOMEM;
+							ret = -ENOMEM;	
 							break;
 						}
 
@@ -6637,7 +6638,7 @@ static int rtw_dbg_port(struct net_device *dev,
 					}
 				}
 					break;
-
+					
 				case 0x06: //continuous wirte byte test
 				{
 					u16 reg = arg;
@@ -6645,12 +6646,12 @@ static int rtw_dbg_port(struct net_device *dev,
 					u32 write_num = extra_arg;
 					int i;
 					u8 final;
-
+					
 					{
 						struct xmit_frame	*xmit_frame;
 
 						if((xmit_frame=rtw_IOL_accquire_xmit_frame(padapter)) == NULL) {
-							ret = -ENOMEM;
+							ret = -ENOMEM;	
 							break;
 						}
 
@@ -6668,13 +6669,13 @@ static int rtw_dbg_port(struct net_device *dev,
 					}
 				}
 					break;
-
+					
 				case 0x07: //continuous wirte word test
 				{
 					u16 reg = arg;
 					u16 start_value = 200;
 					u32 write_num = extra_arg;
-
+				
 					int i;
 					u16 final;
 
@@ -6682,7 +6683,7 @@ static int rtw_dbg_port(struct net_device *dev,
 						struct xmit_frame	*xmit_frame;
 
 						if((xmit_frame=rtw_IOL_accquire_xmit_frame(padapter)) == NULL) {
-							ret = -ENOMEM;
+							ret = -ENOMEM;	
 							break;
 						}
 
@@ -6700,13 +6701,13 @@ static int rtw_dbg_port(struct net_device *dev,
 					}
 				}
 					break;
-
+					
 				case 0x08: //continuous wirte dword test
 				{
 					u16 reg = arg;
 					u32 start_value = 0x110000c7;
 					u32 write_num = extra_arg;
-
+				
 					int i;
 					u32 final;
 
@@ -6714,7 +6715,7 @@ static int rtw_dbg_port(struct net_device *dev,
 						struct xmit_frame	*xmit_frame;
 
 						if((xmit_frame=rtw_IOL_accquire_xmit_frame(padapter)) == NULL) {
-							ret = -ENOMEM;
+							ret = -ENOMEM;	
 							break;
 						}
 
@@ -6723,7 +6724,7 @@ static int rtw_dbg_port(struct net_device *dev,
 						}
 						if(_SUCCESS !=rtw_IOL_exec_cmds_sync(padapter, xmit_frame, 5000))
 							ret = -EPERM;
-
+							
 					}
 
 					if(start_value+write_num-1 == (final=rtw_read32(padapter, reg)) ) {
@@ -6748,7 +6749,7 @@ static int rtw_dbg_port(struct net_device *dev,
 					DBG_871X("fwstate=0x%x\n", get_fwstate(pmlmepriv));
 					break;
 				case 0x01:
-					DBG_871X("auth_alg=0x%x, enc_alg=0x%x, auth_type=0x%x, enc_type=0x%x\n",
+					DBG_871X("auth_alg=0x%x, enc_alg=0x%x, auth_type=0x%x, enc_type=0x%x\n", 
 						psecuritypriv->dot11AuthAlgrthm, psecuritypriv->dot11PrivacyAlgrthm,
 						psecuritypriv->ndisauthtype, psecuritypriv->ndisencryptstatus);
 					break;
@@ -6770,31 +6771,31 @@ static int rtw_dbg_port(struct net_device *dev,
 					{
 						int i;
 						struct recv_reorder_ctrl *preorder_ctrl;
-
+					
 						DBG_871X("SSID=%s\n", cur_network->network.Ssid.Ssid);
 						DBG_871X("sta's macaddr:" MAC_FMT "\n", MAC_ARG(psta->hwaddr));
 						DBG_871X("cur_channel=%d, cur_bwmode=%d, cur_ch_offset=%d\n", pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
 						DBG_871X("rtsen=%d, cts2slef=%d\n", psta->rtsen, psta->cts2self);
-						DBG_871X("qos_en=%d, ht_en=%d, init_rate=%d\n", psta->qos_option, psta->htpriv.ht_option, psta->init_rate);
-						DBG_871X("state=0x%x, aid=%d, macid=%d, raid=%d\n", psta->state, psta->aid, psta->mac_id, psta->raid);
-						DBG_871X("bwmode=%d, ch_offset=%d, sgi=%d\n", psta->htpriv.bwmode, psta->htpriv.ch_offset, psta->htpriv.sgi);
-						DBG_871X("ampdu_enable = %d\n", psta->htpriv.ampdu_enable);
+						DBG_871X("qos_en=%d, ht_en=%d, init_rate=%d\n", psta->qos_option, psta->htpriv.ht_option, psta->init_rate);	
+						DBG_871X("state=0x%x, aid=%d, macid=%d, raid=%d\n", psta->state, psta->aid, psta->mac_id, psta->raid);	
+						DBG_871X("bwmode=%d, ch_offset=%d, sgi=%d\n", psta->htpriv.bwmode, psta->htpriv.ch_offset, psta->htpriv.sgi);						
+						DBG_871X("ampdu_enable = %d\n", psta->htpriv.ampdu_enable);	
 						DBG_871X("agg_enable_bitmap=%x, candidate_tid_bitmap=%x\n", psta->htpriv.agg_enable_bitmap, psta->htpriv.candidate_tid_bitmap);
-
+						
 						for(i=0;i<16;i++)
-						{
+						{							
 							preorder_ctrl = &psta->recvreorder_ctrl[i];
 							if(preorder_ctrl->enable)
 							{
 								DBG_871X("tid=%d, indicate_seq=%d\n", i, preorder_ctrl->indicate_seq);
 							}
-						}
-
+						}	
+							
 					}
 					else
-					{
+					{							
 						DBG_871X("can't get sta's macaddr, cur_network's macaddr:" MAC_FMT "\n", MAC_ARG(cur_network->network.MacAddress));
-					}
+					}					
 					break;
 				case 0x06:
 					{
@@ -6807,14 +6808,14 @@ static int rtw_dbg_port(struct net_device *dev,
 					}
 					break;
 				case 0x07:
-					DBG_871X("bSurpriseRemoved=%d, bDriverStopped=%d\n",
+					DBG_871X("bSurpriseRemoved=%d, bDriverStopped=%d\n", 
 						padapter->bSurpriseRemoved, padapter->bDriverStopped);
 					break;
                                 case 0x08:
 					{
 						struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
 						struct recv_priv  *precvpriv = &padapter->recvpriv;
-
+						
 						DBG_871X("free_xmitbuf_cnt=%d, free_xmitframe_cnt=%d"
 							", free_xmit_extbuf_cnt=%d, free_xframe_ext_cnt=%d"
 							", free_recvframe_cnt=%d\n",
@@ -6825,23 +6826,23 @@ static int rtw_dbg_port(struct net_device *dev,
 						DBG_871X("rx_urb_pending_cn=%d\n", precvpriv->rx_pending_cnt);
 						#endif
 					}
-					break;
+					break;	
 				case 0x09:
 					{
 						int i, j;
 						_list	*plist, *phead;
 						struct recv_reorder_ctrl *preorder_ctrl;
-
+						
 #ifdef CONFIG_AP_MODE
 						DBG_871X("sta_dz_bitmap=0x%x, tim_bitmap=0x%x\n", pstapriv->sta_dz_bitmap, pstapriv->tim_bitmap);
-#endif
+#endif						
 						_enter_critical_bh(&pstapriv->sta_hash_lock, &irqL);
 
 						for(i=0; i< NUM_STA; i++)
 						{
 							phead = &(pstapriv->sta_hash[i]);
 							plist = get_next(phead);
-
+		
 							while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
 							{
 								psta = LIST_CONTAINOR(plist, struct sta_info, hash_list);
@@ -6852,10 +6853,10 @@ static int rtw_dbg_port(struct net_device *dev,
 								{
 									DBG_871X("sta's macaddr:" MAC_FMT "\n", MAC_ARG(psta->hwaddr));
 									DBG_871X("rtsen=%d, cts2slef=%d\n", psta->rtsen, psta->cts2self);
-									DBG_871X("qos_en=%d, ht_en=%d, init_rate=%d\n", psta->qos_option, psta->htpriv.ht_option, psta->init_rate);
-									DBG_871X("state=0x%x, aid=%d, macid=%d, raid=%d\n", psta->state, psta->aid, psta->mac_id, psta->raid);
-									DBG_871X("bwmode=%d, ch_offset=%d, sgi=%d\n", psta->htpriv.bwmode, psta->htpriv.ch_offset, psta->htpriv.sgi);
-									DBG_871X("ampdu_enable = %d\n", psta->htpriv.ampdu_enable);
+									DBG_871X("qos_en=%d, ht_en=%d, init_rate=%d\n", psta->qos_option, psta->htpriv.ht_option, psta->init_rate);	
+									DBG_871X("state=0x%x, aid=%d, macid=%d, raid=%d\n", psta->state, psta->aid, psta->mac_id, psta->raid);	
+									DBG_871X("bwmode=%d, ch_offset=%d, sgi=%d\n", psta->htpriv.bwmode, psta->htpriv.ch_offset, psta->htpriv.sgi);						
+									DBG_871X("ampdu_enable = %d\n", psta->htpriv.ampdu_enable);									
 									DBG_871X("agg_enable_bitmap=%x, candidate_tid_bitmap=%x\n", psta->htpriv.agg_enable_bitmap, psta->htpriv.candidate_tid_bitmap);
 #ifdef CONFIG_AP_MODE
 									DBG_871X("capability=0x%x\n", psta->capability);
@@ -6866,23 +6867,23 @@ static int rtw_dbg_port(struct net_device *dev,
 									DBG_871X("qos_info=0x%x\n", psta->qos_info);
 #endif
 									DBG_871X("dot118021XPrivacy=0x%x\n", psta->dot118021XPrivacy);
-
-
-
+									
+									
+						
 									for(j=0;j<16;j++)
-									{
+									{							
 										preorder_ctrl = &psta->recvreorder_ctrl[j];
 										if(preorder_ctrl->enable)
 										{
 											DBG_871X("tid=%d, indicate_seq=%d\n", j, preorder_ctrl->indicate_seq);
 										}
-									}
-
-								}
-
+									}		
+									
+								}							
+			
 							}
 						}
-
+	
 						_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);
 
 					}
@@ -6890,12 +6891,12 @@ static int rtw_dbg_port(struct net_device *dev,
 
                                 case 0x0c://dump rx packet
 					{
-						DBG_871X("dump rx packet (%d)\n",extra_arg);
-						//pHalData->bDumpRxPkt =extra_arg;
+						DBG_871X("dump rx packet (%d)\n",extra_arg);						
+						//pHalData->bDumpRxPkt =extra_arg;						
 						rtw_hal_set_def_var(padapter, HAL_DEF_DBG_DUMP_RXPKT, &(extra_arg));
 					}
 					break;
-#if 0
+#if 0				
 					case 0x0d://dump cam
 					{
 						//u8 entry = (u8) extra_arg;
@@ -6903,29 +6904,29 @@ static int rtw_dbg_port(struct net_device *dev,
 						//dump cam
 						for(entry=0;entry<32;entry++)
 							read_cam(padapter,entry);
-					}
+					}				
 					break;
 #endif
 		#ifdef DBG_CONFIG_ERROR_DETECT
 				case 0x0f:
 						{
-							if(extra_arg == 0){
+							if(extra_arg == 0){	
 								DBG_871X("###### silent reset test.......#####\n");
 								rtw_hal_sreset_reset(padapter);
 							} else {
 								sreset_set_trigger_point(padapter, extra_arg);
 							}
-
+							
 						}
 				break;
 				case 0x15:
 					{
-						struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+						struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;	
 						DBG_871X("==>silent resete cnts:%d\n",pwrpriv->ips_enter_cnts);
 					}
-					break;
-
-		#endif
+					break;	
+					
+		#endif	
 
 				case 0x10:// driver version display
 					DBG_871X("rtw driver version=%s\n", DRIVERVERSION);
@@ -6933,7 +6934,7 @@ static int rtw_dbg_port(struct net_device *dev,
 				case 0x11:
 					{
 						DBG_871X("turn %s Rx RSSI display function\n",(extra_arg==1)?"on":"off");
-						padapter->bRxRSSIDisplay = extra_arg ;
+						padapter->bRxRSSIDisplay = extra_arg ;						
 					}
 					break;
 				case 0x12: //set rx_stbc
@@ -6948,28 +6949,28 @@ static int rtw_dbg_port(struct net_device *dev,
 					}
 					else
 						DBG_871X("get rx_stbc=%d\n",pregpriv->rx_stbc);
-
+					
 				}
 				break;
 				case 0x13: //set ampdu_enable
 				{
 					struct registry_priv	*pregpriv = &padapter->registrypriv;
 					// 0: disable, 0x1:enable (but wifi_spec should be 0), 0x2: force enable (don't care wifi_spec)
-					if( pregpriv && extra_arg < 3 )
+					if( pregpriv && extra_arg >= 0 && extra_arg < 3 )
 					{
 						pregpriv->ampdu_enable= extra_arg;
 						DBG_871X("set ampdu_enable=%d\n",pregpriv->ampdu_enable);
 					}
 					else
 						DBG_871X("get ampdu_enable=%d\n",pregpriv->ampdu_enable);
-
+					
 				}
 				break;
 				case 0x14: //get wifi_spec
 				{
 					struct registry_priv	*pregpriv = &padapter->registrypriv;
 					DBG_871X("get wifi_spec=%d\n",pregpriv->wifi_spec);
-
+					
 				}
 				break;
 				case 0x22:
@@ -6990,11 +6991,11 @@ static int rtw_dbg_port(struct net_device *dev,
 						DBG_871X("turn %s the bShowGetP2PState Variable\n",(extra_arg==1)?"on":"off");
 						padapter->bShowGetP2PState = extra_arg;
 #endif // CONFIG_P2P
-						break;
+						break;						
 					}
 #if 1
 				case 0xdd://registers dump , 0 for mac reg,1 for bb reg, 2 for rf reg
-					{
+					{						
 						if(extra_arg==0){
 							mac_reg_dump(padapter);
 						}
@@ -7004,16 +7005,16 @@ static int rtw_dbg_port(struct net_device *dev,
 						else if(extra_arg==2){
 							rf_reg_dump(padapter);
 						}
-
+																				
 					}
-					break;
+					break;		
 #endif
 				case 0xee://turn on/off dynamic funcs
 					{
 						u8 dm_flag;
 
 						if(0xf==extra_arg){
-							rtw_hal_get_def_var(padapter, HAL_DEF_DBG_DM_FUNC,&dm_flag);
+							rtw_hal_get_def_var(padapter, HAL_DEF_DBG_DM_FUNC,&dm_flag);							
 							DBG_871X(" === DMFlag(0x%02x) === \n",dm_flag);
 							DBG_871X("extra_arg = 0  - disable all dynamic func \n");
 							DBG_871X("extra_arg = 1  - disable DIG- BIT(0)\n");
@@ -7021,16 +7022,16 @@ static int rtw_dbg_port(struct net_device *dev,
 							DBG_871X("extra_arg = 3  - disable tx power tracking - BIT(2)\n");
 							DBG_871X("extra_arg = 4  - disable BT coexistence - BIT(3)\n");
 							DBG_871X("extra_arg = 5  - disable antenna diversity - BIT(4)\n");
-							DBG_871X("extra_arg = 6  - enable all dynamic func \n");
+							DBG_871X("extra_arg = 6  - enable all dynamic func \n");							
 						}
 						else{
 							/*	extra_arg = 0  - disable all dynamic func
 								extra_arg = 1  - disable DIG
 								extra_arg = 2  - disable tx power tracking
 								extra_arg = 3  - turn on all dynamic func
-							*/
+							*/			
 							rtw_hal_set_def_var(padapter, HAL_DEF_DBG_DM_FUNC, &(extra_arg));
-							rtw_hal_get_def_var(padapter, HAL_DEF_DBG_DM_FUNC,&dm_flag);
+							rtw_hal_get_def_var(padapter, HAL_DEF_DBG_DM_FUNC,&dm_flag);							
 							DBG_871X(" === DMFlag(0x%02x) === \n",dm_flag);
 						}
 					}
@@ -7053,35 +7054,35 @@ static int rtw_dbg_port(struct net_device *dev,
 						DBG_871X("dbg(0x280)=0x%x\n", rtw_read32(padapter, 0x280));
 						DBG_871X("dbg(0x284)=0x%x\n", rtw_read32(padapter, 0x284));
 						DBG_871X("dbg(0x288)=0x%x\n", rtw_read32(padapter, 0x288));
-
+	
 						DBG_871X("dbg(0x664)=0x%x\n", rtw_read32(padapter, 0x664));
 
 
 						DBG_871X("\n");
-
+		
 						DBG_871X("dbg(0x430)=0x%x\n", rtw_read32(padapter, 0x430));
 						DBG_871X("dbg(0x438)=0x%x\n", rtw_read32(padapter, 0x438));
 
 						DBG_871X("dbg(0x440)=0x%x\n", rtw_read32(padapter, 0x440));
-
+	
 						DBG_871X("dbg(0x458)=0x%x\n", rtw_read32(padapter, 0x458));
-
+	
 						DBG_871X("dbg(0x484)=0x%x\n", rtw_read32(padapter, 0x484));
 						DBG_871X("dbg(0x488)=0x%x\n", rtw_read32(padapter, 0x488));
-
+	
 						DBG_871X("dbg(0x444)=0x%x\n", rtw_read32(padapter, 0x444));
 						DBG_871X("dbg(0x448)=0x%x\n", rtw_read32(padapter, 0x448));
 						DBG_871X("dbg(0x44c)=0x%x\n", rtw_read32(padapter, 0x44c));
 						DBG_871X("dbg(0x450)=0x%x\n", rtw_read32(padapter, 0x450));
 					}
 					break;
-			}
+			}			
 			break;
 		default:
 			DBG_871X("error dbg cmd!\n");
-			break;
+			break;	
 	}
-
+	
 
 	return ret;
 
@@ -7092,14 +7093,14 @@ static int wpa_set_param(struct net_device *dev, u8 name, u32 value)
 	uint ret=0;
 	u32 flags;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
-
+	
 	switch (name){
 	case IEEE_PARAM_WPA_ENABLED:
 
 		padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_8021X; //802.1x
-
+		
 		//ret = ieee80211_wpa_enable(ieee, value);
-
+		
 		switch((value)&0xff)
 		{
 			case 1 : //WPA
@@ -7111,16 +7112,16 @@ static int wpa_set_param(struct net_device *dev, u8 name, u32 value)
 			padapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption3Enabled;
 				break;
 		}
-
+		
 		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_info_,("wpa_set_param:padapter->securitypriv.ndisauthtype=%d\n", padapter->securitypriv.ndisauthtype));
-
+		
 		break;
 
 	case IEEE_PARAM_TKIP_COUNTERMEASURES:
 		//ieee->tkip_countermeasures=value;
 		break;
 
-	case IEEE_PARAM_DROP_UNENCRYPTED:
+	case IEEE_PARAM_DROP_UNENCRYPTED: 
 	{
 		/* HACK:
 		 *
@@ -7133,13 +7134,13 @@ static int wpa_set_param(struct net_device *dev, u8 name, u32 value)
 		 * can use this to determine if the CAP_PRIVACY_ON bit should
 		 * be set.
 		 */
-
-#if 0
+		 
+#if 0	 
 		struct ieee80211_security sec = {
 			.flags = SEC_ENABLED,
 			.enabled = value,
 		};
-		ieee->drop_unencrypted = value;
+ 		ieee->drop_unencrypted = value;
 		/* We only change SEC_LEVEL for open mode. Others
 		 * are set by ipw_wpa_set_encryption.
 		 */
@@ -7153,30 +7154,30 @@ static int wpa_set_param(struct net_device *dev, u8 name, u32 value)
 		}
 		if (ieee->set_security)
 			ieee->set_security(ieee->dev, &sec);
-#endif
+#endif		
 		break;
 
 	}
-	case IEEE_PARAM_PRIVACY_INVOKED:
-
+	case IEEE_PARAM_PRIVACY_INVOKED:	
+		
 		//ieee->privacy_invoked=value;
-
+		
 		break;
 
 	case IEEE_PARAM_AUTH_ALGS:
-
+		
 		ret = wpa_set_auth_algs(dev, value);
-
+		
 		break;
 
 	case IEEE_PARAM_IEEE_802_1X:
-
-		//ieee->ieee802_1x=value;
-
+		
+		//ieee->ieee802_1x=value;		
+		
 		break;
-
+		
 	case IEEE_PARAM_WPAX_SELECT:
-
+		
 		// added for WPA2 mixed mode
 		//DBG_871X(KERN_WARNING "------------------------>wpax value = %x\n", value);
 		/*
@@ -7185,26 +7186,26 @@ static int wpa_set_param(struct net_device *dev, u8 name, u32 value)
 		ieee->wpax_type_notify = value;
 		spin_unlock_irqrestore(&ieee->wpax_suitlist_lock,flags);
 		*/
-
+		
 		break;
 
-	default:
-
+	default:		
 
 
+		
 		ret = -EOPNOTSUPP;
 
-
+		
 		break;
-
+	
 	}
 
 	return ret;
-
+	
 }
 
 static int wpa_mlme(struct net_device *dev, u32 command, u32 reason)
-{
+{	
 	int ret = 0;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 
@@ -7213,15 +7214,15 @@ static int wpa_mlme(struct net_device *dev, u32 command, u32 reason)
 		case IEEE_MLME_STA_DEAUTH:
 
 			if(!rtw_set_802_11_disassociate(padapter))
-				ret = -1;
-
+				ret = -1;		
+			
 			break;
 
 		case IEEE_MLME_STA_DISASSOC:
-
+		
 			if(!rtw_set_802_11_disassociate(padapter))
-				ret = -1;
-
+				ret = -1;		
+	
 			break;
 
 		default:
@@ -7230,7 +7231,7 @@ static int wpa_mlme(struct net_device *dev, u32 command, u32 reason)
 	}
 
 	return ret;
-
+	
 }
 
 static int wpa_supplicant_ioctl(struct net_device *dev, struct iw_point *p)
@@ -7238,20 +7239,20 @@ static int wpa_supplicant_ioctl(struct net_device *dev, struct iw_point *p)
 	struct ieee_param *param;
 	uint ret=0;
 
-	//down(&ieee->wx_sem);
+	//down(&ieee->wx_sem);	
 
 	if (p->length < sizeof(struct ieee_param) || !p->pointer){
 		ret = -EINVAL;
 		goto out;
 	}
-
+	
 	param = (struct ieee_param *)rtw_malloc(p->length);
 	if (param == NULL)
 	{
 		ret = -ENOMEM;
 		goto out;
 	}
-
+	
 	if (copy_from_user(param, p->pointer, p->length))
 	{
 		rtw_mfree((u8*)param, p->length);
@@ -7282,20 +7283,20 @@ static int wpa_supplicant_ioctl(struct net_device *dev, struct iw_point *p)
 		DBG_871X("Unknown WPA supplicant request: %d\n", param->cmd);
 		ret = -EOPNOTSUPP;
 		break;
-
+		
 	}
 
 	if (ret == 0 && copy_to_user(p->pointer, param, p->length))
 		ret = -EFAULT;
 
 	rtw_mfree((u8 *)param, p->length);
-
+	
 out:
-
+	
 	//up(&ieee->wx_sem);
-
+	
 	return ret;
-
+	
 }
 
 #ifdef CONFIG_AP_MODE
@@ -7303,7 +7304,7 @@ static u8 set_pairwise_key(_adapter *padapter, struct sta_info *psta)
 {
 	struct cmd_obj*			ph2c;
 	struct set_stakey_parm	*psetstakey_para;
-	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;
+	struct cmd_priv 			*pcmdpriv=&padapter->cmdpriv;	
 	u8	res=_SUCCESS;
 
 	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
@@ -7324,17 +7325,17 @@ static u8 set_pairwise_key(_adapter *padapter, struct sta_info *psta)
 
 	psetstakey_para->algorithm = (u8)psta->dot118021XPrivacy;
 
-	_rtw_memcpy(psetstakey_para->addr, psta->hwaddr, ETH_ALEN);
-
+	_rtw_memcpy(psetstakey_para->addr, psta->hwaddr, ETH_ALEN);	
+	
 	_rtw_memcpy(psetstakey_para->key, &psta->dot118021x_UncstKey, 16);
 
-
-	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+	
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);	
 
 exit:
 
 	return res;
-
+	
 }
 
 static int set_group_key(_adapter *padapter, u8 *key, u8 alg, int keyid)
@@ -7342,11 +7343,11 @@ static int set_group_key(_adapter *padapter, u8 *key, u8 alg, int keyid)
 	u8 keylen;
 	struct cmd_obj* pcmd;
 	struct setkey_parm *psetkeyparm;
-	struct cmd_priv	*pcmdpriv=&(padapter->cmdpriv);
+	struct cmd_priv	*pcmdpriv=&(padapter->cmdpriv);	
 	int res=_SUCCESS;
 
 	DBG_871X("%s\n", __FUNCTION__);
-
+	
 	pcmd = (struct cmd_obj*)rtw_zmalloc(sizeof(struct	cmd_obj));
 	if(pcmd==NULL){
 		res= _FAIL;
@@ -7360,7 +7361,7 @@ static int set_group_key(_adapter *padapter, u8 *key, u8 alg, int keyid)
 	}
 
 	_rtw_memset(psetkeyparm, 0, sizeof(struct setkey_parm));
-
+		
 	psetkeyparm->keyid=(u8)keyid;
 	if (is_wep_enc(alg))
 		padapter->securitypriv.key_mask |= BIT(psetkeyparm->keyid);
@@ -7371,25 +7372,25 @@ static int set_group_key(_adapter *padapter, u8 *key, u8 alg, int keyid)
 
 	switch(alg)
 	{
-		case _WEP40_:
+		case _WEP40_:					
 			keylen = 5;
 			break;
 		case _WEP104_:
-			keylen = 13;
+			keylen = 13;			
 			break;
 		case _TKIP_:
-		case _TKIP_WTMIC_:
+		case _TKIP_WTMIC_:		
 		case _AES_:
-			keylen = 16;
+			keylen = 16;		
 		default:
-			keylen = 16;
+			keylen = 16;		
 	}
 
 	_rtw_memcpy(&(psetkeyparm->key[0]), key, keylen);
-
+	
 	pcmd->cmdcode = _SetKey_CMD_;
-	pcmd->parmbuf = (u8 *)psetkeyparm;
-	pcmd->cmdsz =  (sizeof(struct setkey_parm));
+	pcmd->parmbuf = (u8 *)psetkeyparm;   
+	pcmd->cmdsz =  (sizeof(struct setkey_parm));  
 	pcmd->rsp = NULL;
 	pcmd->rspsz = 0;
 
@@ -7401,24 +7402,24 @@ static int set_group_key(_adapter *padapter, u8 *key, u8 alg, int keyid)
 exit:
 
 	return res;
-
+	
 
 }
 
 static int set_wep_key(_adapter *padapter, u8 *key, u8 keylen, int keyid)
-{
+{	
 	u8 alg;
 
 	switch(keylen)
 	{
 		case 5:
-			alg =_WEP40_;
+			alg =_WEP40_;			
 			break;
 		case 13:
-			alg =_WEP104_;
+			alg =_WEP104_;			
 			break;
 		default:
-			alg =_NO_PRIVACY_;
+			alg =_NO_PRIVACY_;			
 	}
 
 	return set_group_key(padapter, key, alg, keyid);
@@ -7431,7 +7432,7 @@ static int rtw_set_encryption(struct net_device *dev, struct ieee_param *param,
 	int ret = 0;
 	u32 wep_key_idx, wep_key_len,wep_total_len;
 	NDIS_802_11_WEP	 *pwep = NULL;
-	struct sta_info *psta = NULL, *pbcmc_sta = NULL;
+	struct sta_info *psta = NULL, *pbcmc_sta = NULL;	
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct mlme_priv 	*pmlmepriv = &padapter->mlmepriv;
 	struct security_priv* psecuritypriv=&(padapter->securitypriv);
@@ -7452,23 +7453,23 @@ static int rtw_set_encryption(struct net_device *dev, struct ieee_param *param,
 
 	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
 	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
-	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff)
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) 
 	{
 		if (param->u.crypt.idx >= WEP_KEYS)
 		{
 			ret = -EINVAL;
 			goto exit;
-		}
+		}	
 	}
-	else
-	{
+	else 
+	{		
 		psta = rtw_get_stainfo(pstapriv, param->sta_addr);
 		if(!psta)
 		{
 			//ret = -EINVAL;
 			DBG_871X("rtw_set_encryption(), sta has already been removed or never been added\n");
 			goto exit;
-		}
+		}			
 	}
 
 	if (strcmp(param->u.crypt.alg, "none") == 0 && (psta==NULL))
@@ -7476,18 +7477,18 @@ static int rtw_set_encryption(struct net_device *dev, struct ieee_param *param,
 		//todo:clear default encryption keys
 
 		DBG_871X("clear default encryption keys, keyid=%d\n", param->u.crypt.idx);
-
+		
 		goto exit;
 	}
 
 
 	if (strcmp(param->u.crypt.alg, "WEP") == 0 && (psta==NULL))
-	{
+	{		
 		DBG_871X("r871x_set_encryption, crypt.alg = WEP\n");
-
+		
 		wep_key_idx = param->u.crypt.idx;
 		wep_key_len = param->u.crypt.key_len;
-
+					
 		DBG_871X("r871x_set_encryption, wep_key_idx=%d, len=%d\n", wep_key_idx, wep_key_len);
 
 		if((wep_key_idx >= WEP_KEYS) || (wep_key_len<=0))
@@ -7495,25 +7496,25 @@ static int rtw_set_encryption(struct net_device *dev, struct ieee_param *param,
 			ret = -EINVAL;
 			goto exit;
 		}
+			
 
-
-		if (wep_key_len > 0)
-		{
-			wep_key_len = wep_key_len <= 5 ? 5 : 13;
+		if (wep_key_len > 0) 
+		{			
+		 	wep_key_len = wep_key_len <= 5 ? 5 : 13;
 			wep_total_len = wep_key_len + FIELD_OFFSET(NDIS_802_11_WEP, KeyMaterial);
-			pwep =(NDIS_802_11_WEP *)rtw_malloc(wep_total_len);
+		 	pwep =(NDIS_802_11_WEP *)rtw_malloc(wep_total_len);
 			if(pwep == NULL){
 				DBG_871X(" r871x_set_encryption: pwep allocate fail !!!\n");
 				goto exit;
 			}
-
-			_rtw_memset(pwep, 0, wep_total_len);
-
-			pwep->KeyLength = wep_key_len;
+			
+		 	_rtw_memset(pwep, 0, wep_total_len);
+		
+		 	pwep->KeyLength = wep_key_len;
 			pwep->Length = wep_total_len;
-
+			
 		}
-
+		
 		pwep->KeyIndex = wep_key_idx;
 
 		_rtw_memcpy(pwep->KeyMaterial,  param->u.crypt.key, pwep->KeyLength);
@@ -7525,44 +7526,44 @@ static int rtw_set_encryption(struct net_device *dev, struct ieee_param *param,
 			psecuritypriv->ndisencryptstatus = Ndis802_11Encryption1Enabled;
 			psecuritypriv->dot11PrivacyAlgrthm=_WEP40_;
 			psecuritypriv->dot118021XGrpPrivacy=_WEP40_;
-
+			
 			if(pwep->KeyLength==13)
 			{
 				psecuritypriv->dot11PrivacyAlgrthm=_WEP104_;
 				psecuritypriv->dot118021XGrpPrivacy=_WEP104_;
 			}
 
-
+		
 			psecuritypriv->dot11PrivacyKeyIndex = wep_key_idx;
-
+			
 			_rtw_memcpy(&(psecuritypriv->dot11DefKey[wep_key_idx].skey[0]), pwep->KeyMaterial, pwep->KeyLength);
 
 			psecuritypriv->dot11DefKeylen[wep_key_idx]=pwep->KeyLength;
 
-			set_wep_key(padapter, pwep->KeyMaterial, pwep->KeyLength, wep_key_idx);
-
+			set_wep_key(padapter, pwep->KeyMaterial, pwep->KeyLength, wep_key_idx);		
 
+			
 		}
 		else
 		{
 			DBG_871X("wep, set_tx=0\n");
-
-			//don't update "psecuritypriv->dot11PrivacyAlgrthm" and
+			
+			//don't update "psecuritypriv->dot11PrivacyAlgrthm" and 
 			//"psecuritypriv->dot11PrivacyKeyIndex=keyid", but can rtw_set_key to cam
-
+					
 		      _rtw_memcpy(&(psecuritypriv->dot11DefKey[wep_key_idx].skey[0]), pwep->KeyMaterial, pwep->KeyLength);
 
-			psecuritypriv->dot11DefKeylen[wep_key_idx] = pwep->KeyLength;
+			psecuritypriv->dot11DefKeylen[wep_key_idx] = pwep->KeyLength;			
 
 			set_wep_key(padapter, pwep->KeyMaterial, pwep->KeyLength, wep_key_idx);
-
+			
 		}
 
 		goto exit;
-
+		
 	}
 
-
+	
 	if(!psta && check_fwstate(pmlmepriv, WIFI_AP_STATE)) // //group key
 	{
 		if(param->u.crypt.set_tx ==1)
@@ -7570,36 +7571,36 @@ static int rtw_set_encryption(struct net_device *dev, struct ieee_param *param,
 			if(strcmp(param->u.crypt.alg, "WEP") == 0)
 			{
 				DBG_871X("%s, set group_key, WEP\n", __FUNCTION__);
-
+				
 				_rtw_memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
-
+					
 				psecuritypriv->dot118021XGrpPrivacy = _WEP40_;
 				if(param->u.crypt.key_len==13)
-				{
+				{						
 						psecuritypriv->dot118021XGrpPrivacy = _WEP104_;
 				}
-
+				
 			}
 			else if(strcmp(param->u.crypt.alg, "TKIP") == 0)
-			{
+			{						
 				DBG_871X("%s, set group_key, TKIP\n", __FUNCTION__);
-
+				
 				psecuritypriv->dot118021XGrpPrivacy = _TKIP_;
 
 				_rtw_memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
-
+				
 				//DEBUG_ERR("set key length :param->u.crypt.key_len=%d\n", param->u.crypt.key_len);
 				//set mic key
 				_rtw_memcpy(psecuritypriv->dot118021XGrptxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[16]), 8);
 				_rtw_memcpy(psecuritypriv->dot118021XGrprxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[24]), 8);
 
 				psecuritypriv->busetkipkey = _TRUE;
-
+											
 			}
 			else if(strcmp(param->u.crypt.alg, "CCMP") == 0)
 			{
 				DBG_871X("%s, set group_key, CCMP\n", __FUNCTION__);
-
+			
 				psecuritypriv->dot118021XGrpPrivacy = _AES_;
 
 				_rtw_memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
@@ -7607,7 +7608,7 @@ static int rtw_set_encryption(struct net_device *dev, struct ieee_param *param,
 			else
 			{
 				DBG_871X("%s, set group_key, none\n", __FUNCTION__);
-
+				
 				psecuritypriv->dot118021XGrpPrivacy = _NO_PRIVACY_;
 			}
 
@@ -7616,98 +7617,98 @@ static int rtw_set_encryption(struct net_device *dev, struct ieee_param *param,
 			psecuritypriv->binstallGrpkey = _TRUE;
 
 			psecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;//!!!
-
+								
 			set_group_key(padapter, param->u.crypt.key, psecuritypriv->dot118021XGrpPrivacy, param->u.crypt.idx);
-
+			
 			pbcmc_sta=rtw_get_bcmc_stainfo(padapter);
 			if(pbcmc_sta)
 			{
 				pbcmc_sta->ieee8021x_blocked = _FALSE;
-				pbcmc_sta->dot118021XPrivacy= psecuritypriv->dot118021XGrpPrivacy;//rx will use bmc_sta's dot118021XPrivacy
-			}
-
+				pbcmc_sta->dot118021XPrivacy= psecuritypriv->dot118021XGrpPrivacy;//rx will use bmc_sta's dot118021XPrivacy			
+			}	
+						
 		}
 
 		goto exit;
-
-	}
+		
+	}	
 
 	if(psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X && psta) // psk/802_1x
 	{
 		if(check_fwstate(pmlmepriv, WIFI_AP_STATE))
 		{
 			if(param->u.crypt.set_tx ==1)
-			{
+			{ 
 				_rtw_memcpy(psta->dot118021x_UncstKey.skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
-
+				
 				if(strcmp(param->u.crypt.alg, "WEP") == 0)
 				{
 					DBG_871X("%s, set pairwise key, WEP\n", __FUNCTION__);
-
+					
 					psta->dot118021XPrivacy = _WEP40_;
 					if(param->u.crypt.key_len==13)
-					{
+					{						
 						psta->dot118021XPrivacy = _WEP104_;
 					}
 				}
 				else if(strcmp(param->u.crypt.alg, "TKIP") == 0)
-				{
+				{						
 					DBG_871X("%s, set pairwise key, TKIP\n", __FUNCTION__);
-
+					
 					psta->dot118021XPrivacy = _TKIP_;
-
+				
 					//DEBUG_ERR("set key length :param->u.crypt.key_len=%d\n", param->u.crypt.key_len);
 					//set mic key
 					_rtw_memcpy(psta->dot11tkiptxmickey.skey, &(param->u.crypt.key[16]), 8);
 					_rtw_memcpy(psta->dot11tkiprxmickey.skey, &(param->u.crypt.key[24]), 8);
 
 					psecuritypriv->busetkipkey = _TRUE;
-
+											
 				}
 				else if(strcmp(param->u.crypt.alg, "CCMP") == 0)
 				{
 
 					DBG_871X("%s, set pairwise key, CCMP\n", __FUNCTION__);
-
+					
 					psta->dot118021XPrivacy = _AES_;
 				}
 				else
 				{
 					DBG_871X("%s, set pairwise key, none\n", __FUNCTION__);
-
+					
 					psta->dot118021XPrivacy = _NO_PRIVACY_;
 				}
-
+						
 				set_pairwise_key(padapter, psta);
-
+					
 				psta->ieee8021x_blocked = _FALSE;
-
-			}
+					
+			}			
 			else//group key???
-			{
+			{ 
 				if(strcmp(param->u.crypt.alg, "WEP") == 0)
 				{
 					_rtw_memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
-
+					
 					psecuritypriv->dot118021XGrpPrivacy = _WEP40_;
 					if(param->u.crypt.key_len==13)
-					{
+					{						
 						psecuritypriv->dot118021XGrpPrivacy = _WEP104_;
 					}
 				}
 				else if(strcmp(param->u.crypt.alg, "TKIP") == 0)
-				{
+				{						
 					psecuritypriv->dot118021XGrpPrivacy = _TKIP_;
 
 					_rtw_memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
-
+				
 					//DEBUG_ERR("set key length :param->u.crypt.key_len=%d\n", param->u.crypt.key_len);
 					//set mic key
 					_rtw_memcpy(psecuritypriv->dot118021XGrptxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[16]), 8);
 					_rtw_memcpy(psecuritypriv->dot118021XGrprxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[24]), 8);
 
 					psecuritypriv->busetkipkey = _TRUE;
-
+											
 				}
 				else if(strcmp(param->u.crypt.alg, "CCMP") == 0)
 				{
@@ -7722,39 +7723,39 @@ static int rtw_set_encryption(struct net_device *dev, struct ieee_param *param,
 
 				psecuritypriv->dot118021XGrpKeyid = param->u.crypt.idx;
 
-				psecuritypriv->binstallGrpkey = _TRUE;
-
+				psecuritypriv->binstallGrpkey = _TRUE;	
+								
 				psecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;//!!!
-
+								
 				set_group_key(padapter, param->u.crypt.key, psecuritypriv->dot118021XGrpPrivacy, param->u.crypt.idx);
-
+			
 				pbcmc_sta=rtw_get_bcmc_stainfo(padapter);
 				if(pbcmc_sta)
 				{
 					pbcmc_sta->ieee8021x_blocked = _FALSE;
-					pbcmc_sta->dot118021XPrivacy= psecuritypriv->dot118021XGrpPrivacy;//rx will use bmc_sta's dot118021XPrivacy
-				}
+					pbcmc_sta->dot118021XPrivacy= psecuritypriv->dot118021XGrpPrivacy;//rx will use bmc_sta's dot118021XPrivacy			
+				}					
 
 			}
-
+			
 		}
-
+				
 	}
 
 exit:
 
 	if(pwep)
 	{
-		rtw_mfree((u8 *)pwep,wep_total_len);
-	}
-
+		rtw_mfree((u8 *)pwep,wep_total_len);		
+	}	
+	
 	return ret;
-
+	
 }
 
 static int rtw_set_beacon(struct net_device *dev, struct ieee_param *param, int len)
 {
-	int ret=0;
+	int ret=0;	
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	struct sta_priv *pstapriv = &padapter->stapriv;
@@ -7776,26 +7777,26 @@ static int rtw_set_beacon(struct net_device *dev, struct ieee_param *param, int
 		ret = 0;
 	else
 		ret = -EINVAL;
-
+	
 
 	return ret;
-
+	
 }
 
 static int rtw_hostapd_sta_flush(struct net_device *dev)
 {
 	//_irqL irqL;
 	//_list	*phead, *plist;
-	int ret=0;
+	int ret=0;	
 	//struct sta_info *psta = NULL;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
 	//struct sta_priv *pstapriv = &padapter->stapriv;
 
 	DBG_871X("%s\n", __FUNCTION__);
 
 	flush_all_cam_entry(padapter);	//clear CAM
 
-	ret = rtw_sta_flush(padapter);
+	ret = rtw_sta_flush(padapter);	
 
 	return ret;
 
@@ -7804,24 +7805,24 @@ static int rtw_hostapd_sta_flush(struct net_device *dev)
 static int rtw_add_sta(struct net_device *dev, struct ieee_param *param)
 {
 	_irqL irqL;
-	int ret=0;
+	int ret=0;	
 	struct sta_info *psta = NULL;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	struct sta_priv *pstapriv = &padapter->stapriv;
 
 	DBG_871X("rtw_add_sta(aid=%d)=" MAC_FMT "\n", param->u.add_sta.aid, MAC_ARG(param->sta_addr));
-
-	if(check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != _TRUE)
+	
+	if(check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != _TRUE)	
 	{
-		return -EINVAL;
+		return -EINVAL;		
 	}
 
 	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
 	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
-	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff)
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) 
 	{
-		return -EINVAL;
+		return -EINVAL;	
 	}
 
 /*
@@ -7829,37 +7830,37 @@ static int rtw_add_sta(struct net_device *dev, struct ieee_param *param)
 	if(psta)
 	{
 		DBG_871X("rtw_add_sta(), free has been added psta=%p\n", psta);
-		_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
-		rtw_free_stainfo(padapter,  psta);
+		_enter_critical_bh(&(pstapriv->sta_hash_lock), &irqL);		
+		rtw_free_stainfo(padapter,  psta);		
 		_exit_critical_bh(&(pstapriv->sta_hash_lock), &irqL);
 
 		psta = NULL;
-	}
+	}	
 */
 	//psta = rtw_alloc_stainfo(pstapriv, param->sta_addr);
 	psta = rtw_get_stainfo(pstapriv, param->sta_addr);
 	if(psta)
 	{
-		int flags = param->u.add_sta.flags;
-
+		int flags = param->u.add_sta.flags;			
+		
 		//DBG_871X("rtw_add_sta(), init sta's variables, psta=%p\n", psta);
-
+		
 		psta->aid = param->u.add_sta.aid;//aid=1~2007
 
 		_rtw_memcpy(psta->bssrateset, param->u.add_sta.tx_supp_rates, 16);
-
-
+		
+		
 		//check wmm cap.
 		if(WLAN_STA_WME&flags)
 			psta->qos_option = 1;
 		else
 			psta->qos_option = 0;
 
-		if(pmlmepriv->qospriv.qos_option == 0)
+		if(pmlmepriv->qospriv.qos_option == 0)	
 			psta->qos_option = 0;
 
-
-#ifdef CONFIG_80211N_HT
+		
+#ifdef CONFIG_80211N_HT		
 		//chec 802.11n ht cap.
 		if(WLAN_STA_HT&flags)
 		{
@@ -7867,89 +7868,89 @@ static int rtw_add_sta(struct net_device *dev, struct ieee_param *param)
 			psta->qos_option = 1;
 			_rtw_memcpy((void*)&psta->htpriv.ht_cap, (void*)&param->u.add_sta.ht_cap, sizeof(struct rtw_ieee80211_ht_cap));
 		}
-		else
+		else		
 		{
 			psta->htpriv.ht_option = _FALSE;
 		}
-
-		if(pmlmepriv->htpriv.ht_option == _FALSE)
+		
+		if(pmlmepriv->htpriv.ht_option == _FALSE)	
 			psta->htpriv.ht_option = _FALSE;
-#endif
+#endif		
 
 
 		update_sta_info_apmode(padapter, psta);
-
-
+		
+		
 	}
 	else
 	{
 		ret = -ENOMEM;
-	}
-
+	}	
+	
 	return ret;
-
+	
 }
 
 static int rtw_del_sta(struct net_device *dev, struct ieee_param *param)
 {
 	_irqL irqL;
-	int ret=0;
+	int ret=0;	
 	struct sta_info *psta = NULL;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	struct sta_priv *pstapriv = &padapter->stapriv;
 
 	DBG_871X("rtw_del_sta=" MAC_FMT "\n", MAC_ARG(param->sta_addr));
-
-	if(check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != _TRUE)
+		
+	if(check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != _TRUE)		
 	{
-		return -EINVAL;
+		return -EINVAL;		
 	}
 
 	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
 	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
-	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff)
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) 
 	{
-		return -EINVAL;
+		return -EINVAL;	
 	}
 
 	psta = rtw_get_stainfo(pstapriv, param->sta_addr);
 	if(psta)
 	{
 		u8 updated=_FALSE;
-
+	
 		//DBG_871X("free psta=%p, aid=%d\n", psta, psta->aid);
 
 		_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 		if(rtw_is_list_empty(&psta->asoc_list)==_FALSE)
-		{
+		{			
 			rtw_list_delete(&psta->asoc_list);
 			pstapriv->asoc_list_cnt--;
 			updated = ap_free_sta(padapter, psta, _TRUE, WLAN_REASON_DEAUTH_LEAVING);
 
 		}
 		_exit_critical_bh(&pstapriv->asoc_list_lock, &irqL);
-
+		
 		associated_clients_update(padapter, updated);
-
+	
 		psta = NULL;
-
+		
 	}
 	else
 	{
 		DBG_871X("rtw_del_sta(), sta has already been removed or never been added\n");
-
+		
 		//ret = -1;
 	}
-
-
+	
+	
 	return ret;
-
+	
 }
 
 static int rtw_ioctl_get_sta_data(struct net_device *dev, struct ieee_param *param, int len)
 {
-	int ret=0;
+	int ret=0;	
 	struct sta_info *psta = NULL;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
@@ -7959,16 +7960,16 @@ static int rtw_ioctl_get_sta_data(struct net_device *dev, struct ieee_param *par
 
 	DBG_871X("rtw_ioctl_get_sta_info, sta_addr: " MAC_FMT "\n", MAC_ARG(param_ex->sta_addr));
 
-	if(check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != _TRUE)
+	if(check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != _TRUE)		
 	{
-		return -EINVAL;
+		return -EINVAL;		
 	}
 
 	if (param_ex->sta_addr[0] == 0xff && param_ex->sta_addr[1] == 0xff &&
 	    param_ex->sta_addr[2] == 0xff && param_ex->sta_addr[3] == 0xff &&
-	    param_ex->sta_addr[4] == 0xff && param_ex->sta_addr[5] == 0xff)
+	    param_ex->sta_addr[4] == 0xff && param_ex->sta_addr[5] == 0xff) 
 	{
-		return -EINVAL;
+		return -EINVAL;	
 	}
 
 	psta = rtw_get_stainfo(pstapriv, param_ex->sta_addr);
@@ -7980,7 +7981,7 @@ static int rtw_ioctl_get_sta_data(struct net_device *dev, struct ieee_param *par
 			u16 capability;
 			int flags;
 			u32 sta_set;
-			u8 tx_supp_rates[16];
+			u8 tx_supp_rates[16];	
 			u32 tx_supp_rates_len;
 			struct rtw_ieee80211_ht_cap ht_cap;
 			u64	rx_pkts;
@@ -7989,7 +7990,7 @@ static int rtw_ioctl_get_sta_data(struct net_device *dev, struct ieee_param *par
 			u64	tx_pkts;
 			u64	tx_bytes;
 			u64	tx_drops;
-		} get_sta;
+		} get_sta;		
 #endif
 		psta_data->aid = (u16)psta->aid;
 		psta_data->capability = psta->capability;
@@ -8023,7 +8024,7 @@ static int rtw_ioctl_get_sta_data(struct net_device *dev, struct ieee_param *par
 		psta_data->tx_pkts = psta->sta_stats.tx_pkts;
 		psta_data->tx_bytes = psta->sta_stats.tx_bytes;
 		psta_data->tx_drops = psta->sta_stats.tx_drops;
-
+		
 
 	}
 	else
@@ -8037,7 +8038,7 @@ static int rtw_ioctl_get_sta_data(struct net_device *dev, struct ieee_param *par
 
 static int rtw_get_sta_wpaie(struct net_device *dev, struct ieee_param *param)
 {
-	int ret=0;
+	int ret=0;	
 	struct sta_info *psta = NULL;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
@@ -8045,16 +8046,16 @@ static int rtw_get_sta_wpaie(struct net_device *dev, struct ieee_param *param)
 
 	DBG_871X("rtw_get_sta_wpaie, sta_addr: " MAC_FMT "\n", MAC_ARG(param->sta_addr));
 
-	if(check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != _TRUE)
+	if(check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != _TRUE)		
 	{
-		return -EINVAL;
+		return -EINVAL;		
 	}
 
 	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
 	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
-	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff)
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) 
 	{
-		return -EINVAL;
+		return -EINVAL;	
 	}
 
 	psta = rtw_get_stainfo(pstapriv, param->sta_addr);
@@ -8066,9 +8067,9 @@ static int rtw_get_sta_wpaie(struct net_device *dev, struct ieee_param *param)
 			int copy_len;
 
 			wpa_ie_len = psta->wpa_ie[1];
-
+			
 			copy_len = ((wpa_ie_len+2) > sizeof(psta->wpa_ie)) ? (sizeof(psta->wpa_ie)):(wpa_ie_len+2);
-
+				
 			param->u.wpa_ie.len = copy_len;
 
 			_rtw_memcpy(param->u.wpa_ie.reserved, psta->wpa_ie, copy_len);
@@ -8077,7 +8078,7 @@ static int rtw_get_sta_wpaie(struct net_device *dev, struct ieee_param *param)
 		{
 			//ret = -1;
 			DBG_871X("sta's wpa_ie is NONE\n");
-		}
+		}		
 	}
 	else
 	{
@@ -8092,7 +8093,7 @@ static int rtw_set_wps_beacon(struct net_device *dev, struct ieee_param *param,
 {
 	int ret=0;
 	unsigned char wps_oui[4]={0x0,0x50,0xf2,0x04};
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
@@ -8109,8 +8110,8 @@ static int rtw_set_wps_beacon(struct net_device *dev, struct ieee_param *param,
 	if(pmlmepriv->wps_beacon_ie)
 	{
 		rtw_mfree(pmlmepriv->wps_beacon_ie, pmlmepriv->wps_beacon_ie_len);
-		pmlmepriv->wps_beacon_ie = NULL;
-	}
+		pmlmepriv->wps_beacon_ie = NULL;			
+	}	
 
 	if(ie_len>0)
 	{
@@ -8124,20 +8125,20 @@ static int rtw_set_wps_beacon(struct net_device *dev, struct ieee_param *param,
 		_rtw_memcpy(pmlmepriv->wps_beacon_ie, param->u.bcn_ie.buf, ie_len);
 
 		update_beacon(padapter, _VENDOR_SPECIFIC_IE_, wps_oui, _TRUE);
-
+		
 		pmlmeext->bstart_bss = _TRUE;
-
+		
 	}
-
-
-	return ret;
+	
+	
+	return ret;		
 
 }
 
 static int rtw_set_wps_probe_resp(struct net_device *dev, struct ieee_param *param, int len)
 {
 	int ret=0;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	int ie_len;
 
@@ -8152,8 +8153,8 @@ static int rtw_set_wps_probe_resp(struct net_device *dev, struct ieee_param *par
 	if(pmlmepriv->wps_probe_resp_ie)
 	{
 		rtw_mfree(pmlmepriv->wps_probe_resp_ie, pmlmepriv->wps_probe_resp_ie_len);
-		pmlmepriv->wps_probe_resp_ie = NULL;
-	}
+		pmlmepriv->wps_probe_resp_ie = NULL;			
+	}	
 
 	if(ie_len>0)
 	{
@@ -8163,10 +8164,10 @@ static int rtw_set_wps_probe_resp(struct net_device *dev, struct ieee_param *par
 			DBG_871X("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
 			return -EINVAL;
 		}
-		_rtw_memcpy(pmlmepriv->wps_probe_resp_ie, param->u.bcn_ie.buf, ie_len);
+		_rtw_memcpy(pmlmepriv->wps_probe_resp_ie, param->u.bcn_ie.buf, ie_len);		
 	}
-
-
+	
+	
 	return ret;
 
 }
@@ -8174,7 +8175,7 @@ static int rtw_set_wps_probe_resp(struct net_device *dev, struct ieee_param *par
 static int rtw_set_wps_assoc_resp(struct net_device *dev, struct ieee_param *param, int len)
 {
 	int ret=0;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	int ie_len;
 
@@ -8189,8 +8190,8 @@ static int rtw_set_wps_assoc_resp(struct net_device *dev, struct ieee_param *par
 	if(pmlmepriv->wps_assoc_resp_ie)
 	{
 		rtw_mfree(pmlmepriv->wps_assoc_resp_ie, pmlmepriv->wps_assoc_resp_ie_len);
-		pmlmepriv->wps_assoc_resp_ie = NULL;
-	}
+		pmlmepriv->wps_assoc_resp_ie = NULL;			
+	}	
 
 	if(ie_len>0)
 	{
@@ -8200,11 +8201,11 @@ static int rtw_set_wps_assoc_resp(struct net_device *dev, struct ieee_param *par
 			DBG_871X("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
 			return -EINVAL;
 		}
-
-		_rtw_memcpy(pmlmepriv->wps_assoc_resp_ie, param->u.bcn_ie.buf, ie_len);
+		
+		_rtw_memcpy(pmlmepriv->wps_assoc_resp_ie, param->u.bcn_ie.buf, ie_len);		
 	}
-
-
+	
+	
 	return ret;
 
 }
@@ -8266,57 +8267,57 @@ static int rtw_set_hidden_ssid(struct net_device *dev, struct ieee_param *param,
 static int rtw_ioctl_acl_remove_sta(struct net_device *dev, struct ieee_param *param, int len)
 {
 	int ret=0;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
-	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);	
 
 	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
 		return -EINVAL;
 
 	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
 	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
-	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff)
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) 
 	{
-		return -EINVAL;
+		return -EINVAL;	
 	}
 
-	ret = rtw_acl_remove_sta(padapter, param->sta_addr);
+	ret = rtw_acl_remove_sta(padapter, param->sta_addr);	
 
-	return ret;
+	return ret;		
 
 }
 
 static int rtw_ioctl_acl_add_sta(struct net_device *dev, struct ieee_param *param, int len)
 {
 	int ret=0;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-
+	
 	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
 		return -EINVAL;
 
 	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
 	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
-	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff)
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) 
 	{
-		return -EINVAL;
+		return -EINVAL;	
 	}
 
-	ret = rtw_acl_add_sta(padapter, param->sta_addr);
+	ret = rtw_acl_add_sta(padapter, param->sta_addr);	
 
-	return ret;
+	return ret;		
 
 }
 
 static int rtw_ioctl_set_macaddr_acl(struct net_device *dev, struct ieee_param *param, int len)
 {
 	int ret=0;
-	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-
+	
 	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) != _TRUE)
-		return -EINVAL;
-
-	rtw_set_macaddr_acl(padapter, param->u.mlme.command);
+		return -EINVAL;	
+	
+	rtw_set_macaddr_acl(padapter, param->u.mlme.command);	
 
 	return ret;
 }
@@ -8345,14 +8346,14 @@ static int rtw_hostapd_ioctl(struct net_device *dev, struct iw_point *p)
 		ret = -EINVAL;
 		goto out;
 	}
-
+	
 	param = (struct ieee_param *)rtw_malloc(p->length);
 	if (param == NULL)
 	{
 		ret = -ENOMEM;
 		goto out;
 	}
-
+	
 	if (copy_from_user(param, p->pointer, p->length))
 	{
 		rtw_mfree((u8*)param, p->length);
@@ -8362,18 +8363,18 @@ static int rtw_hostapd_ioctl(struct net_device *dev, struct iw_point *p)
 
 	//DBG_871X("%s, cmd=%d\n", __FUNCTION__, param->cmd);
 
-	switch (param->cmd)
-	{
+	switch (param->cmd) 
+	{	
 		case RTL871X_HOSTAPD_FLUSH:
 
 			ret = rtw_hostapd_sta_flush(dev);
 
 			break;
-
-		case RTL871X_HOSTAPD_ADD_STA:
-
-			ret = rtw_add_sta(dev, param);
-
+	
+		case RTL871X_HOSTAPD_ADD_STA:	
+			
+			ret = rtw_add_sta(dev, param);					
+			
 			break;
 
 		case RTL871X_HOSTAPD_REMOVE_STA:
@@ -8381,25 +8382,25 @@ static int rtw_hostapd_ioctl(struct net_device *dev, struct iw_point *p)
 			ret = rtw_del_sta(dev, param);
 
 			break;
-
+	
 		case RTL871X_HOSTAPD_SET_BEACON:
 
 			ret = rtw_set_beacon(dev, param, p->length);
 
 			break;
-
+			
 		case RTL871X_SET_ENCRYPTION:
 
 			ret = rtw_set_encryption(dev, param, p->length);
-
+			
 			break;
-
+			
 		case RTL871X_HOSTAPD_GET_WPAIE_STA:
 
 			ret = rtw_get_sta_wpaie(dev, param);
-
+	
 			break;
-
+			
 		case RTL871X_HOSTAPD_SET_WPS_BEACON:
 
 			ret = rtw_set_wps_beacon(dev, param, p->length);
@@ -8409,14 +8410,14 @@ static int rtw_hostapd_ioctl(struct net_device *dev, struct iw_point *p)
 		case RTL871X_HOSTAPD_SET_WPS_PROBE_RESP:
 
 			ret = rtw_set_wps_probe_resp(dev, param, p->length);
-
-			break;
-
+			
+	 		break;
+			
 		case RTL871X_HOSTAPD_SET_WPS_ASSOC_RESP:
 
 			ret = rtw_set_wps_assoc_resp(dev, param, p->length);
-
-			break;
+			
+	 		break;
 
 		case RTL871X_HOSTAPD_SET_HIDDEN_SSID:
 
@@ -8429,7 +8430,7 @@ static int rtw_hostapd_ioctl(struct net_device *dev, struct iw_point *p)
 			ret = rtw_ioctl_get_sta_data(dev, param, p->length);
 
 			break;
-
+			
 		case RTL871X_HOSTAPD_SET_MACADDR_ACL:
 
 			ret = rtw_ioctl_set_macaddr_acl(dev, param, p->length);
@@ -8447,12 +8448,12 @@ static int rtw_hostapd_ioctl(struct net_device *dev, struct iw_point *p)
 			ret = rtw_ioctl_acl_remove_sta(dev, param, p->length);
 
 			break;
-
+			
 		default:
 			DBG_871X("Unknown hostapd request: %d\n", param->cmd);
 			ret = -EOPNOTSUPP;
 			break;
-
+		
 	}
 
 	if (ret == 0 && copy_to_user(p->pointer, param, p->length))
@@ -8460,11 +8461,11 @@ static int rtw_hostapd_ioctl(struct net_device *dev, struct iw_point *p)
 
 
 	rtw_mfree((u8 *)param, p->length);
-
+	
 out:
-
+		
 	return ret;
-
+	
 }
 #endif
 
@@ -8504,25 +8505,25 @@ static int rtw_wx_set_priv(struct net_device *dev,
 	//	 ("rtw_wx_set_priv: %s req=%s\n",
 	//	  dev->name, ext));
 
-	#ifdef CONFIG_DEBUG_RTW_WX_SET_PRIV
+	#ifdef CONFIG_DEBUG_RTW_WX_SET_PRIV	
 	if (!(ext_dbg = rtw_vmalloc(len)))
 	{
 		rtw_vmfree(ext, len);
 		return -ENOMEM;
-	}
-
+	}	
+	
 	_rtw_memcpy(ext_dbg, ext, len);
 	#endif
 
 	//added for wps2.0 @20110524
 	if(dwrq->flags == 0x8766 && len > 8)
 	{
-		u32 cp_sz;
+		u32 cp_sz;		
 		struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 		u8 *probereq_wpsie = ext;
 		int probereq_wpsie_len = len;
-		u8 wps_oui[4]={0x0,0x50,0xf2,0x04};
-
+		u8 wps_oui[4]={0x0,0x50,0xf2,0x04};		
+	
 		if((_VENDOR_SPECIFIC_IE_ == probereq_wpsie[0]) &&
 			(_rtw_memcmp(&probereq_wpsie[2], wps_oui, 4) ==_TRUE))
 		{
@@ -8530,32 +8531,32 @@ static int rtw_wx_set_priv(struct net_device *dev,
 
 			//_rtw_memcpy(pmlmepriv->probereq_wpsie, probereq_wpsie, cp_sz);
 			//pmlmepriv->probereq_wpsie_len = cp_sz;
-
+					
 			printk("probe_req_wps_ielen=%d\n", cp_sz);
-
+						
 			if(pmlmepriv->wps_probe_req_ie)
 			{
 				u32 free_len = pmlmepriv->wps_probe_req_ie_len;
 				pmlmepriv->wps_probe_req_ie_len = 0;
 				rtw_mfree(pmlmepriv->wps_probe_req_ie, free_len);
-				pmlmepriv->wps_probe_req_ie = NULL;
-			}
+				pmlmepriv->wps_probe_req_ie = NULL;			
+			}	
 
 			pmlmepriv->wps_probe_req_ie = rtw_malloc(cp_sz);
 			if ( pmlmepriv->wps_probe_req_ie == NULL) {
 				printk("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
 				ret =  -EINVAL;
 				goto FREE_EXT;
-
+			
 			}
-
+			
 			_rtw_memcpy(pmlmepriv->wps_probe_req_ie, probereq_wpsie, cp_sz);
-			pmlmepriv->wps_probe_req_ie_len = cp_sz;
-
-		}
-
+			pmlmepriv->wps_probe_req_ie_len = cp_sz;					
+			
+		}	
+		
 		goto FREE_EXT;
-
+		
 	}
 
 	if(	len >= WEXT_CSCAN_HEADER_SIZE
@@ -8564,7 +8565,7 @@ static int rtw_wx_set_priv(struct net_device *dev,
 		ret = rtw_wx_set_scan(dev, info, awrq, ext);
 		goto FREE_EXT;
 	}
-
+	
 #ifdef CONFIG_ANDROID
 	//DBG_871X("rtw_wx_set_priv: %s req=%s\n", dev->name, ext);
 
@@ -8579,7 +8580,7 @@ static int rtw_wx_set_priv(struct net_device *dev,
 			break;
 		case ANDROID_WIFI_CMD_RSSI :
 			{
-				struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+				struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);	
 				struct	wlan_network	*pcur_network = &pmlmepriv->cur_network;
 
 				if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) {
@@ -8626,7 +8627,7 @@ static int rtw_wx_set_priv(struct net_device *dev,
 			#endif
 
 			sprintf(ext, "OK");
-
+		
 	}
 
 	if (copy_to_user(dwrq->pointer, ext, min(dwrq->length, (u16)(strlen(ext)+1)) ) )
@@ -8646,11 +8647,11 @@ static int rtw_wx_set_priv(struct net_device *dev,
 	rtw_vmfree(ext_dbg, len);
 	#endif
 
-	//DBG_871X("rtw_wx_set_priv: (SIOCSIWPRIV) %s ret=%d\n",
+	//DBG_871X("rtw_wx_set_priv: (SIOCSIWPRIV) %s ret=%d\n", 
 	//		dev->name, ret);
 
 	return ret;
-
+	
 }
 
 static int rtw_mp_efuse_get(struct net_device *dev,
@@ -8659,45 +8660,45 @@ static int rtw_mp_efuse_get(struct net_device *dev,
 {
 	struct iw_point *wrqu = (struct iw_point *)wdata;
 	PADAPTER padapter = rtw_netdev_priv(dev);
-	struct mp_priv *pmp_priv;
-
+	struct mp_priv *pmp_priv;	
+	
 	int i,j =0;
 	u8 data[EFUSE_MAP_SIZE];
 	u8 rawdata[EFUSE_MAX_SIZE];
 	u16 mapLen=0;
 	char *pch, *ptmp, *token, *tmp[3]={0x00,0x00,0x00};
 	u16 addr = 0, cnts = 0, max_available_size = 0,raw_cursize = 0 ,raw_maxsize = 0;
-
+	
 	_rtw_memset(data, '\0', sizeof(data));
 	_rtw_memset(rawdata, '\0', sizeof(rawdata));
-
+	
 	if (copy_from_user(extra, wrqu->pointer, wrqu->length))
 		return -EFAULT;
 
 	pch = extra;
 	DBG_871X("%s: in=%s\n", __func__, extra);
-
+	
 	i=0;
 	//mac 16 "00e04c871200" rmap,00,2
 	while ( (token = strsep (&pch,",") )!=NULL )
 	{
 			if(i>2) break;
-			tmp[i] = token;
+			tmp[i] = token; 	  
 			i++;
 	}
-
+	
 	if ( strcmp(tmp[0],"realmap") == 0 ) {
-
+		
 		DBG_871X("strcmp OK =	%s \n" ,tmp[0]);
 
 		mapLen = EFUSE_MAP_SIZE;
-
+		 
 		if (rtw_efuse_map_read(padapter, 0, mapLen, data) == _SUCCESS){
-			DBG_871X("\t  rtw_efuse_map_read \n");
+			DBG_871X("\t  rtw_efuse_map_read \n"); 
 		}else {
 			DBG_871X("\t  rtw_efuse_map_read : Fail \n");
 			return -EFAULT;
-		}
+		} 
 		_rtw_memset(extra, '\0', sizeof(extra));
 		DBG_871X("\tOFFSET\tVALUE(hex)\n");
 		sprintf(extra, "%s \n", extra);
@@ -8706,7 +8707,7 @@ static int rtw_mp_efuse_get(struct net_device *dev,
 			DBG_871X("\t0x%02x\t", i);
 			sprintf(extra, "%s \t0x%02x\t", extra,i);
 			for (j = 0; j < 8; j++)
-			{
+			{	  
 				DBG_871X("%02X ", data[i+j]);
 				sprintf(extra, "%s %02X", extra, data[i+j]);
 			}
@@ -8717,11 +8718,11 @@ static int rtw_mp_efuse_get(struct net_device *dev,
 				sprintf(extra, "%s %02X", extra, data[i+j]);
 			}
 			DBG_871X("\n");
-			sprintf(extra,"%s\n",extra);
+			sprintf(extra,"%s\n",extra);	
 		}
 		DBG_871X("\n");
 		wrqu->length = strlen(extra);
-
+	
 		return 0;
 	}
 	else if ( strcmp(tmp[0],"rmap") == 0 ) {
@@ -8742,16 +8743,16 @@ static int rtw_mp_efuse_get(struct net_device *dev,
 			DBG_871X("(addr + cnts parameter error \n");
 			return -EFAULT;
 		}
-
-		if (rtw_efuse_map_read(padapter, addr, cnts, data) == _FAIL)
+				
+		if (rtw_efuse_map_read(padapter, addr, cnts, data) == _FAIL) 
 		{
-			DBG_871X("rtw_efuse_access error \n");
+			DBG_871X("rtw_efuse_access error \n"); 		
 		}
 		else{
 			DBG_871X("rtw_efuse_access ok \n");
-		}
+		}	
 
-		_rtw_memset(extra, '\0', sizeof(extra));
+		_rtw_memset(extra, '\0', sizeof(extra));	 
 		for ( i = 0; i < cnts; i ++) {
 			DBG_871X("0x%02x", data[i]);
 			sprintf(extra, "%s 0x%02X", extra, data[i]);
@@ -8763,7 +8764,7 @@ static int rtw_mp_efuse_get(struct net_device *dev,
 
 		DBG_871X("extra = %s ", extra);
 
-		return 0;
+		return 0;	
 	}
 	else if ( strcmp(tmp[0],"realraw") == 0 ) {
 		addr=0;
@@ -8775,19 +8776,19 @@ static int rtw_mp_efuse_get(struct net_device *dev,
 			return -EFAULT;
 		} else
 		{
-			DBG_871X("\t  rtw_efuse_access raw ok \n");
+			DBG_871X("\t  rtw_efuse_access raw ok \n");	
 		}
-
+				
 		_rtw_memset(extra, '\0', sizeof(extra));
 		for ( i=0; i<mapLen; i++ ) {
 			DBG_871X(" %02x", rawdata[i]);
 			sprintf(extra, "%s %02x", extra, rawdata[i] );
 
-			if ((i & 0xF) == 0xF){
+			if ((i & 0xF) == 0xF){ 
 				DBG_871X("\n\t");
 				sprintf(extra, "%s\n\t", extra);
 			}
-			else if ((i & 0x7) == 0x7){
+			else if ((i & 0x7) == 0x7){ 
 				DBG_871X("\t");
 				sprintf(extra, "%s\t", extra);
 			}
@@ -8812,12 +8813,12 @@ static int rtw_mp_efuse_get(struct net_device *dev,
 		}
 		if (rtw_efuse_map_read(padapter, addr, cnts, data) == _FAIL)
 		{
-			DBG_871X("rtw_efuse_access error \n");
+			DBG_871X("rtw_efuse_access error \n"); 		
 		}
 		else{
 			DBG_871X("rtw_efuse_access ok \n");
-		}
-		_rtw_memset(extra, '\0', sizeof(extra));
+		}	
+		_rtw_memset(extra, '\0', sizeof(extra));		 
 		for ( i = 0; i < cnts; i ++) {
 			DBG_871X("0x%02x", data[i]);
 			sprintf(extra, "%s 0x%02X", extra, data[i+j]);
@@ -8841,14 +8842,14 @@ static int rtw_mp_efuse_get(struct net_device *dev,
 			DBG_871X("(addr + cnts parameter error \n");
 			return -EFAULT;
 		}
-		if (rtw_efuse_map_read(padapter, addr, cnts, data) == _FAIL)
+		if (rtw_efuse_map_read(padapter, addr, cnts, data) == _FAIL) 
 		{
-			DBG_871X("rtw_efuse_access error \n");
+			DBG_871X("rtw_efuse_access error \n"); 		
 		}
 		else{
 			DBG_871X("rtw_efuse_access ok \n");
-		}
-		_rtw_memset(extra, '\0', sizeof(extra));
+		}	
+		_rtw_memset(extra, '\0', sizeof(extra));		 
 		for ( i = 0; i < cnts; i ++) {
 			DBG_871X("0x%02x", data[i]);
 			sprintf(extra, "%s 0x%02X", extra, data[i+j]);
@@ -8871,7 +8872,7 @@ static int rtw_mp_efuse_get(struct net_device *dev,
 		  wrqu->length = strlen(extra);
 		  return 0;
 	}
-
+	
 	return 0;
 }
 
@@ -8881,7 +8882,7 @@ static int rtw_mp_efuse_set(struct net_device *dev,
 {
 	struct iw_point *wrqu = (struct iw_point *)wdata;
 	PADAPTER padapter = rtw_netdev_priv(dev);
-
+	
 	u8 buffer[40];
 	u32 i,jj,kk;
 	u8 setdata[EFUSE_MAP_SIZE];
@@ -8890,10 +8891,10 @@ static int rtw_mp_efuse_set(struct net_device *dev,
 
 	u16 addr = 0, max_available_size = 0;
 	u32  cnts = 0;
-
+	
 	pch = extra;
 	DBG_871X("%s: in=%s\n", __func__, extra);
-
+	
 	i=0;
 	while ( (token = strsep (&pch,",") )!=NULL )
 	{
@@ -8906,64 +8907,64 @@ static int rtw_mp_efuse_set(struct net_device *dev,
 	// wmap,addr,00e04c871200
 	if ( strcmp(tmp[0],"wmap") == 0 ) {
 		 if ( tmp[1]==NULL || tmp[2]==NULL ) return 	-EINVAL;
-			if ( ! strlen( tmp[2] )/2 > 1 ) return -EFAULT;
-
+			if ( ! strlen( tmp[2] )/2 > 1 ) return -EFAULT; 			
+				  
 			addr = simple_strtoul( tmp[1], &ptmp, 16 );
 			addr = addr & 0xFF;
 			DBG_871X("addr = %x \n" ,addr);
-
-			cnts = strlen( tmp[2] )/2;
+					
+			cnts = strlen( tmp[2] )/2;	
 			if ( cnts == 0) return -EFAULT;
-
+					
 			DBG_871X("cnts = %d \n" ,cnts);
 			DBG_871X("target data = %s \n" ,tmp[2]);
-
+					
 			for( jj = 0, kk = 0; jj < cnts; jj++, kk += 2 )
 			{
 				setdata[jj] = key_2char2num( tmp[2][kk], tmp[2][kk+ 1] );
 			}
-
+	
 			EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (PVOID)&max_available_size, _FALSE);
-
+			
 			if ((addr + cnts) > max_available_size) {
 						DBG_871X("parameter error \n");
 						return -EFAULT;
-			}
-			if (rtw_efuse_map_write(padapter, addr, cnts, setdata) == _FAIL) {
+			}	
+			if (rtw_efuse_map_write(padapter, addr, cnts, setdata) == _FAIL) {			
 					DBG_871X("rtw_efuse_map_write error \n");
 					return -EFAULT;
 			} else
 			   DBG_871X("rtw_efuse_map_write ok \n");
-
+		
 		return 0;
 	}
 	else if ( strcmp(tmp[0],"wraw") == 0 ) {
 			 if ( tmp[1]==NULL || tmp[2]==NULL ) return 	-EINVAL;
-			 if ( ! strlen( tmp[2] )/2 > 1 ) return -EFAULT;
+			 if ( ! strlen( tmp[2] )/2 > 1 ) return -EFAULT;			 
 			addr = simple_strtoul( tmp[1], &ptmp, 16 );
 			addr = addr & 0xFF;
 			DBG_871X("addr = %x \n" ,addr);
-
+				
 			cnts=strlen( tmp[2] )/2;
 			if ( cnts == 0) return -EFAULT;
 
-			DBG_871X(" cnts = %d \n" ,cnts );
+			DBG_871X(" cnts = %d \n" ,cnts );		
 			DBG_871X("target data = %s \n" ,tmp[2] );
-
+			
 			for( jj = 0, kk = 0; jj < cnts; jj++, kk += 2 )
 			{
 					setrawdata[jj] = key_2char2num( tmp[2][kk], tmp[2][kk+ 1] );
 			}
-
+					
 			if ( rtw_efuse_access( padapter, _TRUE, addr, cnts, setrawdata ) == _FAIL ){
 					DBG_871X("\t  rtw_efuse_map_read : Fail \n");
 						return -EFAULT;
 			} else
-			  DBG_871X("\t  rtw_efuse_access raw ok \n");
-
+			  DBG_871X("\t  rtw_efuse_access raw ok \n");	
+			
 					return 0;
 		}
-	else if ( strcmp(tmp[0],"mac") == 0 ) {
+	else if ( strcmp(tmp[0],"mac") == 0 ) { 
 			 if ( tmp[1]==NULL || tmp[2]==NULL ) return 	-EINVAL;
 			//mac,00e04c871200
 			#ifdef CONFIG_RTL8192C
@@ -8978,29 +8979,29 @@ static int rtw_mp_efuse_set(struct net_device *dev,
 						DBG_871X("error data for mac addr = %s \n" ,tmp[1]);
 						return -EFAULT;
 				}
-
+				
 				DBG_871X("target data = %s \n" ,tmp[1]);
-
+				
 				for( jj = 0, kk = 0; jj < cnts; jj++, kk += 2 )
 				{
 					setdata[jj] = key_2char2num(tmp[1][kk], tmp[1][kk+ 1]);
 				}
-
+				
 				EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (PVOID)&max_available_size, _FALSE);
-
+		
 				if ((addr + cnts) > max_available_size) {
 						DBG_871X("parameter error \n");
 						return -EFAULT;
-					}
+					}	
 				if ( rtw_efuse_map_write(padapter, addr, cnts, setdata) == _FAIL ) {
 					DBG_871X("rtw_efuse_map_write error \n");
 					return -EFAULT;
 				} else
 					DBG_871X("rtw_efuse_map_write ok \n");
-
+				
 			return 0;
 		}
-		else if ( strcmp(tmp[0],"vidpid") == 0 ) {
+		else if ( strcmp(tmp[0],"vidpid") == 0 ) { 
 			 if ( tmp[1]==NULL || tmp[2]==NULL ) return 	-EINVAL;
 				// pidvid,da0b7881
 				#ifdef CONFIG_RTL8192C
@@ -9009,36 +9010,36 @@ static int rtw_mp_efuse_set(struct net_device *dev,
 				#ifdef CONFIG_RTL8192D
 					addr = 0x0c;
 				#endif
-
+				
 				cnts=strlen( tmp[1] )/2;
 				if ( cnts == 0) return -EFAULT;
 				DBG_871X("target data = %s \n" ,tmp[1]);
-
+				
 				for( jj = 0, kk = 0; jj < cnts; jj++, kk += 2 )
 				{
 					setdata[jj] = key_2char2num(tmp[1][kk], tmp[1][kk+ 1]);
 				}
 
 				EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (PVOID)&max_available_size, _FALSE);
-
+				
 				if ((addr + cnts) > max_available_size) {
 						DBG_871X("parameter error \n");
 						return -EFAULT;
-					}
-
+					}	
+				
 				if ( rtw_efuse_map_write(padapter, addr, cnts, setdata) == _FAIL ) {
 					DBG_871X("rtw_efuse_map_write error \n");
 					return -EFAULT;
 				} else
 					DBG_871X("rtw_efuse_map_write ok \n");
-
+			
 				return 0;
 		}
 		else{
 				 DBG_871X("Command not found\n");
 			   return 0;
 		}
-
+		
 	  return 0;
 }
 
@@ -9157,7 +9158,7 @@ static int rtw_mp_read_reg(struct net_device *dev,
 
 	pch = pnext + 1;
 	if ((pch - input) >= wrqu->length) return -EINVAL;
-
+	
 	addr = simple_strtoul(pch, &ptmp, 16);
 	if (addr > 0x3FFF) return -EINVAL;
 
@@ -9182,13 +9183,13 @@ static int rtw_mp_read_reg(struct net_device *dev,
 						   j++;
 					  }
 					  if ( data[i] != '\0' )
-						 tmp[j] = data[i];
-
-						 j++;
+					 	 tmp[j] = data[i];
+					 	
+					  	 j++;
 				}
-				pch = tmp;
+				pch = tmp;		
 				DBG_871X("pch=%s",pch);
-
+				
 				while( *pch != '\0' )
 				{
 					pnext = strpbrk(pch, " ");
@@ -9220,9 +9221,9 @@ static int rtw_mp_read_reg(struct net_device *dev,
 					  tmp[j] = data[i];
 					  j++;
 				}
-				pch = tmp;
+				pch = tmp;		
 				DBG_871X("pch=%s",pch);
-
+				
 				while( *pch != '\0' )
 				{
 					pnext = strpbrk(pch, " ");
@@ -9239,12 +9240,12 @@ static int rtw_mp_read_reg(struct net_device *dev,
 				}
 			wrqu->length = strlen(extra);
 			break;
-
+			
 		default:
 			wrqu->length = 0;
 			ret = -EINVAL;
 			break;
-
+			
 	}
 
 	return ret;
@@ -9259,7 +9260,7 @@ static int rtw_mp_read_reg(struct net_device *dev,
  static int rtw_mp_write_rf(struct net_device *dev,
 			struct iw_request_info *info,
 			struct iw_point *wrqu, char *extra)
-{
+{			
 /*static int rtw_mp_write_rf(struct net_device *dev,
 			struct iw_request_info *info,
 			union iwreq_data *wrqu, char *extra)
@@ -9280,7 +9281,7 @@ static int rtw_mp_read_reg(struct net_device *dev,
 	write_rfreg(padapter, path, addr, data);
 
 	sprintf(extra, "write_rf completed \n");
-
+	
 	return 0;
 }
 
@@ -9316,7 +9317,7 @@ static int rtw_mp_read_rf(struct net_device *dev,
 	if (addr > 0xFF) return -EINVAL;
 
 	_rtw_memset(extra, 0, wrqu->length);
-
+	
 	//*data = read_rfreg(padapter, path, addr);
 	sprintf(data, "%08x", read_rfreg(padapter, path, addr));
 				//add read data format blank
@@ -9330,9 +9331,9 @@ static int rtw_mp_read_rf(struct net_device *dev,
 					  tmp[j] = data[i];
 					  j++;
 				}
-				pch = tmp;
+				pch = tmp;		
 				DBG_871X("pch=%s",pch);
-
+				
 				while( *pch != '\0' )
 				{
 					pnext = strpbrk(pch, " ");
@@ -9399,18 +9400,18 @@ static int rtw_mp_rate(struct net_device *dev,
 
 	if (copy_from_user(input, wrqu->pointer, wrqu->length))
 			return -EFAULT;
-
+			
 	rate = rtw_atoi(input);
 	sprintf( extra, "Set data rate to %d" , rate );
-
+		
 	if(rate <= 0x7f)
-		rate = wifirate2_ratetbl_inx( (u8)rate);
-	else
+		rate = wifirate2_ratetbl_inx( (u8)rate);	
+	else 
 		rate =(rate-0x80+MPT_RATE_MCS0);
 
 	//DBG_871X("%s: rate=%d\n", __func__, rate);
-
-	if (rate >= MPT_RATE_LAST )
+	
+	if (rate >= MPT_RATE_LAST )	
 	return -EINVAL;
 
 	padapter->mppriv.rateidx = rate;
@@ -9431,7 +9432,7 @@ static int rtw_mp_channel(struct net_device *dev,
 
 	if (copy_from_user(input, wrqu->pointer, wrqu->length))
 			return -EFAULT;
-
+	
 	channel = rtw_atoi(input);
 	//DBG_871X("%s: channel=%d\n", __func__, channel);
 	sprintf( extra, "Change channel %d to channel %d", padapter->mppriv.channel , channel );
@@ -9452,19 +9453,19 @@ static int rtw_mp_bandwidth(struct net_device *dev,
 	PADAPTER padapter = rtw_netdev_priv(dev);
 	//if (copy_from_user(buffer, (void*)wrqu->data.pointer, wrqu->data.length))
     //            return -EFAULT;
-
+                
 	//DBG_871X("%s:iwpriv in=%s\n", __func__, extra);
-
+	
 	sscanf(extra, "40M=%d,shortGI=%d", &bandwidth, &sg);
-
+	
 	if (bandwidth != HT_CHANNEL_WIDTH_40)
 		bandwidth = HT_CHANNEL_WIDTH_20;
 
 	//DBG_871X("%s: bw=%d sg=%d \n", __func__, bandwidth , sg);
-
+	
 	padapter->mppriv.bandwidth = (u8)bandwidth;
 	padapter->mppriv.preamble = sg;
-
+	
 	SetBandwidth(padapter);
 
 	return 0;
@@ -9488,9 +9489,9 @@ static int rtw_mp_txpower(struct net_device *dev,
 	sprintf( extra, "Set power level path_A:%d path_B:%d", idx_a , idx_b );
 	padapter->mppriv.txpoweridx = (u8)idx_a;
 	padapter->mppriv.txpoweridx_b = (u8)idx_b;
-
+	
 	Hal_SetAntennaPathPower(padapter);
-
+	
 	wrqu->length = strlen(extra) + 1;
 	return 0;
 }
@@ -9506,11 +9507,11 @@ static int rtw_mp_ant_tx(struct net_device *dev,
 
 	if (copy_from_user(input, wrqu->pointer, wrqu->length))
 			return -EFAULT;
-
-	//DBG_871X("%s: input=%s\n", __func__, input);
-
+			
+	//DBG_871X("%s: input=%s\n", __func__, input);	
+	
 	sprintf( extra, "switch Tx antenna to %s", input );
-
+	
 	for (i=0; i < strlen(input); i++)
 	{
 		switch(input[i])
@@ -9524,10 +9525,10 @@ static int rtw_mp_ant_tx(struct net_device *dev,
 			}
 	}
 	//antenna |= BIT(extra[i]-'a');
-	//DBG_871X("%s: antenna=0x%x\n", __func__, antenna);
+	//DBG_871X("%s: antenna=0x%x\n", __func__, antenna);		
 	padapter->mppriv.antenna_tx = antenna;
 	//DBG_871X("%s:mppriv.antenna_rx=%d\n", __func__, padapter->mppriv.antenna_tx);
-
+	
 	Hal_SetAntenna(padapter);
 
 	wrqu->length = strlen(extra) + 1;
@@ -9547,11 +9548,11 @@ static int rtw_mp_ant_rx(struct net_device *dev,
 			return -EFAULT;
 	//DBG_871X("%s: input=%s\n", __func__, input);
 	_rtw_memset(extra, 0, wrqu->length);
-
+	
 	sprintf( extra, "switch Rx antenna to %s", input );
-
+	
 	for (i=0; i < strlen(input); i++) {
-
+	
 	switch( input[i] )
 			{
 				case 'a' :
@@ -9562,13 +9563,13 @@ static int rtw_mp_ant_rx(struct net_device *dev,
 								break;
 			}
 	}
-
-	//DBG_871X("%s: antenna=0x%x\n", __func__, antenna);
+	
+	//DBG_871X("%s: antenna=0x%x\n", __func__, antenna);		
 	padapter->mppriv.antenna_rx = antenna;
 	//DBG_871X("%s:mppriv.antenna_rx=%d\n", __func__, padapter->mppriv.antenna_rx);
 	Hal_SetAntenna(padapter);
 	wrqu->length = strlen(extra);
-
+	
 	return 0;
 }
 
@@ -9589,7 +9590,7 @@ static int rtw_mp_ctx(struct net_device *dev,
 
 	if (copy_from_user(extra, wrqu->pointer, wrqu->length))
 			return -EFAULT;
-
+			
 	DBG_871X("%s: in=%s\n", __func__, extra);
 
 	countPkTx = strncmp(extra, "count=", 5); // strncmp TRUE is 0
@@ -9600,10 +9601,10 @@ static int rtw_mp_ctx(struct net_device *dev,
 	pkTx = strncmp(extra, "background,pkt", 20);
 	stop = strncmp(extra, "stop", 5);
 	sscanf(extra, "count=%d,pkt", &count);
-
+	
 	//DBG_871X("%s: count=%d countPkTx=%d cotuTx=%d CarrSprTx=%d scTx=%d sgleTx=%d pkTx=%d stop=%d\n", __func__, count, countPkTx, cotuTx, CarrSprTx, pkTx, sgleTx, scTx, stop);
 	_rtw_memset(extra, '\0', sizeof(extra));
-
+	
 	if (stop == 0) {
 		bStartTest = 0; // To set Stop
 		pmp_priv->tx.stop = 1;
@@ -9632,7 +9633,7 @@ static int rtw_mp_ctx(struct net_device *dev,
 	switch (pmp_priv->mode)
 	{
 		case MP_PACKET_TX:
-
+		
 			//DBG_871X("%s:pkTx %d\n", __func__,bStartTest);
 			if (bStartTest == 0)
 			{
@@ -9651,7 +9652,7 @@ static int rtw_mp_ctx(struct net_device *dev,
 				pattrib->pktlen = 1460;
 				_rtw_memset(pattrib->dst, 0xFF, ETH_ALEN);
 				SetPacketTx(padapter);
-			}
+			} 
 			else {
 				//DBG_871X("%s: pkTx not stop\n", __func__);
 				return -EFAULT;
@@ -9663,8 +9664,8 @@ static int rtw_mp_ctx(struct net_device *dev,
 			//DBG_871X("%s: sgleTx %d \n", __func__, bStartTest);
 			if (bStartTest != 0){
 				sprintf( extra, "Start continuous DA=ffffffffffff len=1500 \n infinite=yes.");
-
-			 }
+            		
+           		 }
 			Hal_SetSingleToneTx(padapter, (u8)bStartTest);
 			break;
 
@@ -9672,14 +9673,14 @@ static int rtw_mp_ctx(struct net_device *dev,
 			DBG_871X("%s: cotuTx %d\n", __func__, bStartTest);
 			if (bStartTest != 0){
 				sprintf( extra, "Start continuous DA=ffffffffffff len=1500 \n infinite=yes.");
-			 }
+           		 }
 			 Hal_SetContinuousTx(padapter, (u8)bStartTest);
 			break;
 
 		case MP_CARRIER_SUPPRISSION_TX:
 			//DBG_871X("%s: CarrSprTx %d\n", __func__, bStartTest);
 			if (bStartTest != 0){
-				if( pmp_priv->rateidx <= MPT_RATE_11M )
+				if( pmp_priv->rateidx <= MPT_RATE_11M ) 
 				{
 					sprintf( extra, "Start continuous DA=ffffffffffff len=1500 \n infinite=yes.");
 				}else
@@ -9748,7 +9749,7 @@ static int rtw_mp_arx(struct net_device *dev,
 														padapter->mppriv.rx_crcerrpktcount);
 		wrqu->length = strlen(extra) + 1;
 	}
-
+	
 
 	return 0;
 }
@@ -9790,11 +9791,11 @@ static int rtw_mp_pwrtrk(struct net_device *dev,
 			return -EFAULT;
 
 	_rtw_memset(extra, 0, wrqu->length);
-
+		
 	enable = 1;
 	if (wrqu->length > 1) { // not empty string
 		if (strncmp(input, "stop", 4) == 0)
-		{
+		{	
 			enable = 0;
 			sprintf(extra, "mp tx power tracking stop");
 		}
@@ -9809,7 +9810,7 @@ static int rtw_mp_pwrtrk(struct net_device *dev,
 
 	ret = Hal_SetPowerTracking(padapter, enable);
 	if (ret == _FAIL) return -EPERM;
-
+	
 	wrqu->length = strlen(extra);
 
 	return 0;
@@ -9824,11 +9825,11 @@ static int rtw_mp_psd(struct net_device *dev,
 
 	if (copy_from_user(input, wrqu->pointer, wrqu->length))
 		return -EFAULT;
-
+	
 	strcpy(extra,input);
 
 	wrqu->length = mp_query_psd(padapter, extra);
-
+	
 	return 0;
 }
 
@@ -9846,34 +9847,34 @@ static int rtw_mp_thermal(struct net_device *dev,
 	#endif
 	u16 cnt=1;
 	u16 max_available_size=0;
-	PADAPTER padapter = rtw_netdev_priv(dev);
+	PADAPTER padapter = rtw_netdev_priv(dev);	
 
 	if (copy_from_user(extra, wrqu->pointer, wrqu->length))
 		return -EFAULT;
 
-	//DBG_871X("print extra %s \n",extra);
-
+	//DBG_871X("print extra %s \n",extra); 
+	 
 	 bwrite = strncmp(extra, "write", 6); // strncmp TRUE is 0
-
+	 
 	 Hal_GetThermalMeter(padapter, &val);
-
-	 if( bwrite == 0 )
+	 
+	 if( bwrite == 0 )	
 	 {
 		 //DBG_871X("to write val:%d",val);
 			EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (PVOID)&max_available_size, _FALSE);
 			if( 2 > max_available_size )
-			{
+			{			
 				DBG_871X("no available efuse!\n");
 				return -EFAULT;
-			}
+			}	
 			if ( rtw_efuse_map_write(padapter, addr, cnt, &val) == _FAIL )
 			{
-				DBG_871X("rtw_efuse_map_write error \n");
+				DBG_871X("rtw_efuse_map_write error \n");			
 				return -EFAULT;
-			}
+			} 
 			else
 			{
-				 sprintf(extra, " efuse write ok :%d", val);
+				 sprintf(extra, " efuse write ok :%d", val);	
 			}
 	  }
 	  else
@@ -9881,7 +9882,7 @@ static int rtw_mp_thermal(struct net_device *dev,
 			 sprintf(extra, "%d", val);
 	  }
 	wrqu->length = strlen(extra);
-
+	
 	return 0;
 }
 
@@ -9892,9 +9893,9 @@ static int rtw_mp_reset_stats(struct net_device *dev,
 	struct mp_priv *pmp_priv;
 	struct pkt_attrib *pattrib;
 	PADAPTER padapter = rtw_netdev_priv(dev);
-
+	
 	pmp_priv = &padapter->mppriv;
-
+	
 	pmp_priv->tx.sended = 0;
 	padapter->mppriv.rx_pktcount = 0;
 	padapter->mppriv.rx_crcerrpktcount = 0;
@@ -9912,52 +9913,52 @@ static int rtw_mp_dump(struct net_device *dev,
 	u8 rf_type,path_nums = 0;
 	u32 i,j=1,path;
 	PADAPTER padapter = rtw_netdev_priv(dev);
-
+	
 	pmp_priv = &padapter->mppriv;
 
-
+	
 	//if (copy_from_user(extra, wrqu->data.pointer, wrqu->data.length))
 	//	return -EFAULT;
-
+	
 	if ( strncmp(extra, "all", 4)==0 )
 	{
 			DBG_871X("\n======= MAC REG =======\n");
 			for ( i=0x0;i<0x300;i+=4 )
-			{
+			{	
 				if(j%4==1)	DBG_871X("0x%02x",i);
-				DBG_871X(" 0x%08x ",rtw_read32(padapter,i));
-				if((j++)%4 == 0)	DBG_871X("\n");
+				DBG_871X(" 0x%08x ",rtw_read32(padapter,i));		
+				if((j++)%4 == 0)	DBG_871X("\n");	
 			}
 			for( i=0x400;i<0x800;i+=4 )
-			{
+			{	
 				if(j%4==1)	DBG_871X("0x%02x",i);
-				DBG_871X(" 0x%08x ",rtw_read32(padapter,i));
-				if((j++)%4 == 0)	DBG_871X("\n");
+				DBG_871X(" 0x%08x ",rtw_read32(padapter,i));		
+				if((j++)%4 == 0)	DBG_871X("\n");	
 			}
-
+			
 			i,j=1;
 			rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
-
+				
 			DBG_871X("\n======= RF REG =======\n");
-			if(( RF_1T2R == rf_type ) ||( RF_1T1R ==rf_type ))
+			if(( RF_1T2R == rf_type ) ||( RF_1T1R ==rf_type ))	
 				path_nums = 1;
-			else
+			else	
 				path_nums = 2;
-
+				
 			for(path=0;path<path_nums;path++)
 			{
 #ifdef CONFIG_RTL8192D
 			  for (i = 0; i < 0x50; i++)
 #else
-			 for (i = 0; i < 0x34; i++)
+	   		 for (i = 0; i < 0x34; i++)
 #endif
-				{
+				{								
 					//value = PHY_QueryRFReg(padapter, (RF90_RADIO_PATH_E)path,i, bMaskDWord);
 					value =rtw_hal_read_rfreg(padapter, path, i, 0xffffffff);
 					if(j%4==1)	DBG_871X("0x%02x ",i);
 					DBG_871X(" 0x%08x ",value);
-					if((j++)%4==0)	DBG_871X("\n");
-				}
+					if((j++)%4==0)	DBG_871X("\n");	
+				}	
 			}
 	}
 	return 0;
@@ -9971,12 +9972,12 @@ static int rtw_mp_phypara(struct net_device *dev,
 	PADAPTER padapter = rtw_netdev_priv(dev);
 	char 	input[wrqu->length];
 	u32		valxcap;
-
+	
 	if (copy_from_user(input, wrqu->pointer, wrqu->length))
 			return -EFAULT;
-
+	
 	DBG_871X("%s:iwpriv in=%s\n", __func__, input);
-
+	
 	sscanf(input, "xcap=%d", &valxcap);
 
 	if (!IS_HARDWARE_TYPE_8192D(padapter))
@@ -9987,7 +9988,7 @@ static int rtw_mp_phypara(struct net_device *dev,
 
 	sprintf( extra, "Set xcap=%d",valxcap );
 	wrqu->length = strlen(extra) + 1;
-
+	
 return 0;
 
 }
@@ -10031,40 +10032,40 @@ static int rtw_mp_set(struct net_device *dev,
 	case WRITE_REG :
 			rtw_mp_write_reg (dev,info,wrqu,extra);
 			 break;
-
+			 
 	case WRITE_RF:
 			rtw_mp_write_rf (dev,info,wrqu,extra);
-			 break;
-
+			 break; 
+			 
 	case MP_START:
 			DBG_871X("set case mp_start \n");
 			rtw_mp_start (dev,info,wrqu,extra);
-			 break;
-
+			 break; 
+			 
 	case MP_STOP:
 			DBG_871X("set case mp_stop \n");
 			rtw_mp_stop (dev,info,wrqu,extra);
-			 break;
-
+			 break; 
+			 
 	case MP_BANDWIDTH:
 			DBG_871X("set case mp_bandwidth \n");
 			rtw_mp_bandwidth (dev,info,wrqu,extra);
 			break;
-
+			
 	case MP_RESET_STATS:
 			DBG_871X("set case MP_RESET_STATS \n");
 			rtw_mp_reset_stats	(dev,info,wrqu,extra);
 			break;
-
+			
 	case EFUSE_SET:
 			DBG_871X("efuse set \n");
 			rtw_mp_efuse_set (dev,info,wdata,extra);
-			break;
-
+			break;	
+		 		
 	}
 
-
-	return 0;
+	  
+	return 0;		
 }
 
 
@@ -10087,89 +10088,89 @@ static int rtw_mp_get(struct net_device *dev,
 		wrqu->length = 0;
 		return -EIO;
 	}
-
+	
 	switch(subcmd)
 	{
 	case MP_PHYPARA:
 			DBG_871X("mp_get  MP_PHYPARA \n");
-			rtw_mp_phypara(dev,info,wrqu,extra);
+			rtw_mp_phypara(dev,info,wrqu,extra);	
 			break;
 
 	case MP_CHANNEL:
 			DBG_871X("set case mp_channel \n");
 			rtw_mp_channel (dev,info,wrqu,extra);
 			break;
-
+			
 	case READ_REG:
 			DBG_871X("mp_get  READ_REG \n");
 			rtw_mp_read_reg (dev,info,wrqu,extra);
-			 break;
+			 break; 
 	case READ_RF:
 			DBG_871X("mp_get  READ_RF \n");
 			rtw_mp_read_rf (dev,info,wrqu,extra);
-			break;
-
+			break; 
+			
 	case MP_RATE:
 			DBG_871X("set case mp_rate \n");
 			rtw_mp_rate (dev,info,wrqu,extra);
 			break;
-
+			
 	case MP_TXPOWER:
 			DBG_871X("set case MP_TXPOWER \n");
 			rtw_mp_txpower (dev,info,wrqu,extra);
 			break;
-
+			
 	case MP_ANT_TX:
 			DBG_871X("set case MP_ANT_TX \n");
 			rtw_mp_ant_tx (dev,info,wrqu,extra);
 			break;
-
+			
 	case MP_ANT_RX:
 			DBG_871X("set case MP_ANT_RX \n");
 			rtw_mp_ant_rx (dev,info,wrqu,extra);
 			break;
-
+			
 	case MP_QUERY:
 			DBG_871X("mp_get mp_query MP_QUERY \n");
 			rtw_mp_trx_query(dev,info,wrqu,extra);
 			break;
-
+					
 	case MP_CTX:
 			DBG_871X("set case MP_CTX \n");
 			rtw_mp_ctx (dev,info,wrqu,extra);
 			break;
-
+			
 	case MP_ARX:
 			DBG_871X("set case MP_ARX \n");
 			rtw_mp_arx (dev,info,wrqu,extra);
 			break;
-
+			
 	case EFUSE_GET:
 			DBG_871X("efuse get EFUSE_GET \n");
 			rtw_mp_efuse_get(dev,info,wdata,extra);
-		 break;
-
+		 break; 
+		 
 	case MP_DUMP:
 			DBG_871X("set case MP_DUMP \n");
 			rtw_mp_dump (dev,info,wrqu,extra);
-		 break;
+		 break; 
 	case MP_PSD:
 			DBG_871X("set case MP_PSD \n");
 			rtw_mp_psd (dev,info,wrqu,extra);
 		 break;
-
+		 
 	case MP_THER:
 			DBG_871X("set case MP_THER \n");
 			rtw_mp_thermal (dev,info,wrqu,extra);
 		break;
-
+		
 	case MP_PWRTRK:
 			DBG_871X("set case MP_PWRTRK \n");
 			rtw_mp_pwrtrk (dev,info,wrqu,extra);
-			break;
+			break;			 
 	}
 
-return 0;
+return 0;	
 }
 
 #endif //#if defined(CONFIG_MP_INCLUDED) && defined(CONFIG_MP_IWPRIV_SUPPORT)
@@ -10198,7 +10199,7 @@ static int rtw_wfd_tdls_enable(struct net_device *dev,
 
 #endif //CONFIG_WFD
 #endif //CONFIG_TDLS
-
+	
 	return ret;
 }
 
@@ -10224,7 +10225,7 @@ static int rtw_tdls_weaksec(struct net_device *dev,
 		padapter->wdinfo.wfd_tdls_weaksec = 1;
 	}
 #endif
-
+	
 	return ret;
 }
 
@@ -10263,7 +10264,7 @@ static int rtw_tdls_enable(struct net_device *dev,
 		{
 			phead = &(pstapriv->sta_hash[index]);
 			plist = get_next(phead);
-
+			
 			while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
 			{
 				psta = LIST_CONTAINOR(plist, struct sta_info ,hash_list);
@@ -10294,7 +10295,7 @@ static int rtw_tdls_enable(struct net_device *dev,
 		ptdlsinfo->enable = 1;
 	}
 #endif //CONFIG_TDLS
-
+	
 	return ret;
 }
 
@@ -10340,7 +10341,7 @@ static int rtw_tdls_setup(struct net_device *dev,
 		issue_tdls_setup_req(padapter, mac_addr);
 	}
 #endif
-
+	
 	return ret;
 }
 
@@ -10364,7 +10365,7 @@ static int rtw_tdls_teardown(struct net_device *dev,
 	}
 
 	ptdls_sta = rtw_get_stainfo( &(padapter->stapriv), mac_addr);
-
+	
 	if(ptdls_sta != NULL)
 	{
 		ptdls_sta->stat_code = _RSON_TDLS_TEAR_UN_RSN_;
@@ -10372,7 +10373,7 @@ static int rtw_tdls_teardown(struct net_device *dev,
 	}
 
 #endif //CONFIG_TDLS
-
+	
 	return ret;
 }
 
@@ -10383,7 +10384,7 @@ static int rtw_tdls_discovery(struct net_device *dev,
 	int ret = 0;
 
 #ifdef CONFIG_TDLS
-
+	
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
@@ -10404,7 +10405,7 @@ static int rtw_tdls_ch_switch(struct net_device *dev,
 	int ret = 0;
 
 #ifdef CONFIG_TDLS
-
+	
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct tdls_info	*ptdlsinfo = &padapter->tdlsinfo;
 	u8 i, j, mac_addr[ETH_ALEN];
@@ -10427,7 +10428,7 @@ static int rtw_tdls_ch_switch(struct net_device *dev,
 
 		return ret;
 }
-
+	
 static int rtw_tdls_pson(struct net_device *dev,
 				struct iw_request_info *info,
 				union iwreq_data *wrqu, char *extra)
@@ -10435,7 +10436,7 @@ static int rtw_tdls_pson(struct net_device *dev,
 	int ret = 0;
 
 #ifdef CONFIG_TDLS
-
+	
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
@@ -10451,12 +10452,12 @@ static int rtw_tdls_pson(struct net_device *dev,
 	ptdls_sta = rtw_get_stainfo(&padapter->stapriv, mac_addr);
 
 	issue_nulldata_to_TDLS_peer_STA(padapter, ptdls_sta, 1);
-
+	
 #endif //CONFIG_TDLS
 
 		return ret;
 }
-
+	
 static int rtw_tdls_psoff(struct net_device *dev,
 				struct iw_request_info *info,
 				union iwreq_data *wrqu, char *extra)
@@ -10464,13 +10465,13 @@ static int rtw_tdls_psoff(struct net_device *dev,
 	int ret = 0;
 
 #ifdef CONFIG_TDLS
-
+	
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	u8 i, j, mac_addr[ETH_ALEN];
 	struct sta_info *ptdls_sta = NULL;
-
+	
 	printk( "[%s] %s %d\n", __FUNCTION__, extra, wrqu->data.length -1  );
 
 	for( i=0, j=0 ; i < ETH_ALEN; i++, j+=3 ){
@@ -10480,7 +10481,7 @@ static int rtw_tdls_psoff(struct net_device *dev,
 	ptdls_sta = rtw_get_stainfo(&padapter->stapriv, mac_addr);
 
 	issue_nulldata_to_TDLS_peer_STA(padapter, ptdls_sta, 0);
-
+	
 #endif //CONFIG_TDLS
 
 	return ret;
@@ -10494,12 +10495,12 @@ static int rtw_tdls_setip(struct net_device *dev,
 
 #ifdef CONFIG_TDLS
 #ifdef CONFIG_WFD
-
+	
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
 	struct wifi_display_info *pwfd_info = ptdlsinfo->wfd_info;
 	u8 i=0, j=0, k=0, tag=0, ip[3] = { 0xff }, *ptr = extra;
-
+	
 	printk( "[%s] %s %d\n", __FUNCTION__, extra, wrqu->data.length - 1  );
 
 
@@ -10514,7 +10515,7 @@ static int rtw_tdls_setip(struct net_device *dev,
 				if( j == 2 )
 					pwfd_info->ip_address[i]=convert_ip_addr( '0', *(extra+(j-2)+tag), *(extra+(j-1)+tag));
 				if( j == 3 )
-					pwfd_info->ip_address[i]=convert_ip_addr( *(extra+(j-3)+tag), *(extra+(j-2)+tag), *(extra+(j-1)+tag));
+					pwfd_info->ip_address[i]=convert_ip_addr( *(extra+(j-3)+tag), *(extra+(j-2)+tag), *(extra+(j-1)+tag));	
 
 				tag += j + 1;
 				break;
@@ -10523,12 +10524,12 @@ static int rtw_tdls_setip(struct net_device *dev,
 		i++;
 	}
 
-	printk( "[%s] Set IP = %u.%u.%u.%u \n", __FUNCTION__,
+	printk( "[%s] Set IP = %u.%u.%u.%u \n", __FUNCTION__, 
 		ptdlsinfo->wfd_info->ip_address[0], ptdlsinfo->wfd_info->ip_address[1],
 		ptdlsinfo->wfd_info->ip_address[2], ptdlsinfo->wfd_info->ip_address[3]
 	);
 
-#endif //CONFIG_WFD
+#endif //CONFIG_WFD	
 #endif //CONFIG_TDLS
 
 	return ret;
@@ -10542,26 +10543,26 @@ static int rtw_tdls_getip(struct net_device *dev,
 
 #ifdef CONFIG_TDLS
 #ifdef CONFIG_WFD
-
+	
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
 	struct wifi_display_info *pwfd_info = ptdlsinfo->wfd_info;
-
+	
 	printk( "[%s]\n", __FUNCTION__);
 
-	sprintf( extra, "\n\n%u.%u.%u.%u\n",
-		pwfd_info->peer_ip_address[0], pwfd_info->peer_ip_address[1],
+	sprintf( extra, "\n\n%u.%u.%u.%u\n", 
+		pwfd_info->peer_ip_address[0], pwfd_info->peer_ip_address[1], 
 		pwfd_info->peer_ip_address[2], pwfd_info->peer_ip_address[3]
 		);
 
 	printk( "[%s] IP=%u.%u.%u.%u\n", __FUNCTION__,
-		pwfd_info->peer_ip_address[0], pwfd_info->peer_ip_address[1],
+		pwfd_info->peer_ip_address[0], pwfd_info->peer_ip_address[1], 
 		pwfd_info->peer_ip_address[2], pwfd_info->peer_ip_address[3]
 		);
-
+	
 	wrqu->data.length = strlen( extra );
 
-#endif //CONFIG_WFD
+#endif //CONFIG_WFD	
 #endif //CONFIG_TDLS
 
 	return ret;
@@ -10571,8 +10572,8 @@ static int rtw_tdls_getport(struct net_device *dev,
                                struct iw_request_info *info,
                                union iwreq_data *wrqu, char *extra)
 {
-
-	int ret = 0;
+	
+	int ret = 0;	
 
 #ifdef CONFIG_TDLS
 #ifdef CONFIG_WFD
@@ -10585,14 +10586,14 @@ static int rtw_tdls_getport(struct net_device *dev,
 
 	sprintf( extra, "\n\n%d\n", pwfd_info->peer_rtsp_ctrlport );
 	printk( "[%s] remote port = %d\n", __FUNCTION__, pwfd_info->peer_rtsp_ctrlport );
-
+	
 	wrqu->data.length = strlen( extra );
 
 #endif //CONFIG_WFD
 #endif //CONFIG_TDLS
 
 	return ret;
-
+		
 }
 
 //WFDTDLS, for sigma test
@@ -10600,8 +10601,8 @@ static int rtw_tdls_dis_result(struct net_device *dev,
                                struct iw_request_info *info,
                                union iwreq_data *wrqu, char *extra)
 {
-
-	int ret = 0;
+	
+	int ret = 0;	
 
 #ifdef CONFIG_TDLS
 #ifdef CONFIG_WFD
@@ -10617,14 +10618,14 @@ static int rtw_tdls_dis_result(struct net_device *dev,
 		sprintf( extra, "\n\nDis=1\n" );
 		ptdlsinfo->dev_discovered = 0;
 	}
-
+	
 	wrqu->data.length = strlen( extra );
 
 #endif //CONFIG_WFD
 #endif //CONFIG_TDLS
 
 	return ret;
-
+		
 }
 
 //WFDTDLS, for sigma test
@@ -10632,8 +10633,8 @@ static int rtw_wfd_tdls_status(struct net_device *dev,
                                struct iw_request_info *info,
                                union iwreq_data *wrqu, char *extra)
 {
-
-	int ret = 0;
+	
+	int ret = 0;	
 
 #ifdef CONFIG_TDLS
 #ifdef CONFIG_WFD
@@ -10652,14 +10653,14 @@ static int rtw_wfd_tdls_status(struct net_device *dev,
 	{
 		sprintf( extra, "\n\nStatus=0\n" );
 	}
-
+	
 	wrqu->data.length = strlen( extra );
 
 #endif //CONFIG_WFD
 #endif //CONFIG_TDLS
 
 	return ret;
-
+		
 }
 
 static int rtw_tdls_ch_switch_off(struct net_device *dev,
@@ -10669,11 +10670,11 @@ static int rtw_tdls_ch_switch_off(struct net_device *dev,
 	int ret = 0;
 
 #ifdef CONFIG_TDLS
-
+	
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
 	u8 i, j, mac_addr[ETH_ALEN];
 	struct sta_info *ptdls_sta = NULL;
-
+	
 	printk( "[%s] %s %d\n", __FUNCTION__, extra, wrqu->data.length -1  );
 
 	for( i=0, j=0 ; i < ETH_ALEN; i++, j+=3 ){
@@ -10690,7 +10691,7 @@ static int rtw_tdls_ch_switch_off(struct net_device *dev,
 		DBG_871X("issue tdls ch switch req back to base channel\n");
 	}
 */
-
+	
 #endif //CONFIG_TDLS
 
 	return ret;
@@ -10756,7 +10757,7 @@ static int rtw_tdls(struct net_device *dev,
 	{
 		wrqu->data.length -= 6;
 		rtw_tdls_ch_switch_off( dev, info, wrqu, &extra[6] );
-	}
+	}	
 	else if (_rtw_memcmp( extra, "pson=", 5 ) )
 	{
 		wrqu->data.length -= 5;
@@ -10780,7 +10781,7 @@ static int rtw_tdls(struct net_device *dev,
 #endif //CONFIG_WFD
 
 #endif //CONFIG_TDLS
-
+	
 	return ret;
 }
 
@@ -10831,7 +10832,7 @@ static int rtw_pm_set(struct net_device *dev,
 
 	if ( _rtw_memcmp( extra, "lps=", 4 ) )
 	{
-		sscanf(extra+4, "%u", &mode);
+		sscanf(extra+4, "%u", &mode);	
 		ret = rtw_pm_set_lps(padapter,mode);
 	}
 	else if ( _rtw_memcmp( extra, "ips=", 4 ) )
@@ -10883,7 +10884,7 @@ static int rtw_wowlan_ctrl(struct net_device *dev,
 		ret = -EFAULT;
 		goto _rtw_wowlan_ctrl_exit_free;
 	}
-	poidparam = (struct wowlan_ioctl_param *)pparmbuf;
+	poidparam = (struct wowlan_ioctl_param *)pparmbuf;	
 
 	if(padapter->pwrctrlpriv.bSupportRemoteWakeup==_FALSE){
 		ret = -EPERM;
@@ -10891,21 +10892,21 @@ static int rtw_wowlan_ctrl(struct net_device *dev,
 		goto _rtw_wowlan_ctrl_exit_free;
 	}
 	rtw_hal_set_hwreg(padapter,HW_VAR_WOWLAN,(u8 *)poidparam);
-
+	
 	DBG_871X("rtw_wowlan_ctrl: subcode [%d], len[%d], buffer_len[%d]\r\n",
-		  poidparam->subcode, poidparam->len, len);
-
+        	  poidparam->subcode, poidparam->len, len);
+	
 	if (copy_to_user(p->pointer, pparmbuf, len)) {
 		ret = -EFAULT;
 	}
-
-
+	
+	
 _rtw_wowlan_ctrl_exit_free:
 	//DBG_871X("-rtw_wowlan_ctrl( subcode = %d)\n", poidparam->subcode);
 	rtw_mfree(pparmbuf, len);
 _rtw_wowlan_ctrl_exit:
-
-
+	
+	
 	return ret;
 }
 #endif //CONFIG_WOWLAN
@@ -10991,10 +10992,10 @@ static s32 initpseudoadhoc(PADAPTER padapter)
 	_irqL irqL;
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	_queue *queue = &pmlmepriv->scanned_queue;
-
+	
 	networkType = Ndis802_11IBSS;
 	_enter_critical_bh(&pmlmepriv->lock, &irqL);
-	_enter_critical_bh(&queue->lock, &irqL);
+	_enter_critical_bh(&queue->lock, &irqL);	
 	err = rtw_set_802_11_infrastructure_mode(padapter, networkType);
 	_exit_critical_bh(&queue->lock, &irqL);
 	_exit_critical_bh(&pmlmepriv->lock, &irqL);
@@ -11256,16 +11257,16 @@ thread_return lbk_thread(thread_context context)
 			pktsize = (pktsize % 1535) + 1; // 1~1535
 		} else
 			pktsize = ploopback->size;
-
+		
 		pxmitframe = createloopbackpkt(padapter, pktsize);
 		if (pxmitframe == NULL) {
 			sprintf(ploopback->msg, "loopback FAIL! 3. create Packet FAIL!");
 			break;
 		}
-
+		
 		ploopback->txsize = TXDESC_SIZE + pxmitframe->attrib.last_txcmdsz;
 		_rtw_memcpy(ploopback->txbuf, pxmitframe->buf_addr, ploopback->txsize);
-
+		
 		ff_hwaddr = get_txfifo_hwaddr(pxmitframe);
 		rtw_write_port(padapter, ff_hwaddr, ploopback->txsize, ploopback->txbuf);
 		cnt++;
@@ -11364,7 +11365,7 @@ static void loopbackTest(PADAPTER padapter, u32 cnt, u32 size, u8* pmsg)
 		freeLoopback(padapter);
 		return;
 	}
-
+	
 	// create pseudo ad-hoc connection
 	err = initpseudoadhoc(padapter);
 	if (err == _FAIL) {
@@ -11523,18 +11524,18 @@ int rtw_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 
 	switch (cmd)
 	{
-	    case RTL_IOCTL_WPA_SUPPLICANT:
+	    case RTL_IOCTL_WPA_SUPPLICANT:	
 			ret = wpa_supplicant_ioctl(dev, &wrq->u.data);
 			break;
 #ifdef CONFIG_AP_MODE
 		case RTL_IOCTL_HOSTAPD:
-			ret = rtw_hostapd_ioctl(dev, &wrq->u.data);
+			ret = rtw_hostapd_ioctl(dev, &wrq->u.data);			
 			break;
-#ifdef CONFIG_NO_WIRELESS_HANDLERS
+#ifdef CONFIG_NO_WIRELESS_HANDLERS			
 		case SIOCSIWMODE:
 			ret = rtw_wx_set_mode(dev, NULL, &wrq->u, NULL);
 			break;
-#endif
+#endif			
 #endif
 		case (SIOCDEVPRIVATE+1):
 			ret = rtw_android_priv_cmd(dev, rq, cmd);
@@ -11543,7 +11544,7 @@ int rtw_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 			ret = -EOPNOTSUPP;
 			break;
 	}
-
+	
 	return ret;
 }
 
@@ -11605,15 +11606,15 @@ int rtw_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 	NULL,					/* SIOCGIWENCODEEXT */
 	rtw_wx_set_pmkid,		/* SIOCSIWPMKSA */
 	NULL,					/*---hole---*/
-};
+}; 
 
 #if defined(CONFIG_MP_INCLUDED) && defined(CONFIG_MP_IWPRIV_SUPPORT)
 
 static const struct iw_priv_args rtw_private_args[] =
-{
-	{ SIOCIWFIRSTPRIV + 0x00, IW_PRIV_TYPE_CHAR | 1024, 0 , ""},  //set
+{	
+	{ SIOCIWFIRSTPRIV + 0x00, IW_PRIV_TYPE_CHAR | 1024, 0 , ""},  //set 
 	{ SIOCIWFIRSTPRIV + 0x01, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK , ""},//get
-/* --- sub-ioctls definitions --- */
+/* --- sub-ioctls definitions --- */   
 		{ MP_START , IW_PRIV_TYPE_CHAR | 1024, 0, "mp_start" }, //set
 		{ MP_PHYPARA, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_phypara" },//get
 		{ MP_STOP , IW_PRIV_TYPE_CHAR | 1024, 0, "mp_stop" }, //set
@@ -11629,7 +11630,7 @@ int rtw_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 		{ MP_NULL, IW_PRIV_TYPE_CHAR | 128, 0,"NULL"},//set
 		{ READ_RF , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "read_rf" },
 		{ MP_NULL, IW_PRIV_TYPE_CHAR | 128, 0,"NULL"},//set
-		{ MP_PSD , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_psd"},
+		{ MP_PSD , IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_psd"}, 
 		{ MP_NULL, IW_PRIV_TYPE_CHAR | 128, 0,"NULL"},//set
 		{ MP_DUMP, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_dump" },
 		{ MP_NULL, IW_PRIV_TYPE_CHAR | 128, 0,"NULL"},//set
@@ -11652,14 +11653,14 @@ int rtw_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 		{ EFUSE_GET, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "efuse_get" },
 		{ MP_NULL , IW_PRIV_TYPE_CHAR | 1024, 0, "NULL"},
 		{ MP_PWRTRK, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "mp_pwrtrk" },
-		{ MP_IOCTL, IW_PRIV_TYPE_CHAR | 1024, 0, "mp_ioctl"}, // mp_ioctl
-
-
+		{ MP_IOCTL, IW_PRIV_TYPE_CHAR | 1024, 0, "mp_ioctl"}, // mp_ioctl	
+		
+	
 	{ SIOCIWFIRSTPRIV + 0x02, IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK , "test"},//set
 };
 
 
-static iw_handler rtw_private_handler[] =
+static iw_handler rtw_private_handler[] = 
 {
 	rtw_mp_set,
 	rtw_mp_get,
@@ -11695,7 +11696,7 @@ int rtw_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 		SIOCIWFIRSTPRIV + 0x6,
 		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "wps_start"
 	},
-//for PLATFORM_MT53XX
+//for PLATFORM_MT53XX	
 	{
 		SIOCIWFIRSTPRIV + 0x7,
 		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "get_sensitivity"
@@ -11709,7 +11710,7 @@ int rtw_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "wps_assoc_req_ie"
 	},
 
-//for RTK_DMP_PLATFORM
+//for RTK_DMP_PLATFORM	
 	{
 		SIOCIWFIRSTPRIV + 0xA,
 		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "channel_plan"
@@ -11718,7 +11719,7 @@ int rtw_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 	{
 		SIOCIWFIRSTPRIV + 0xB,
 		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2, 0, "dbg"
-	},
+	},	
 	{
 		SIOCIWFIRSTPRIV + 0xC,
 		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 3, 0, "rfw"
@@ -11746,7 +11747,7 @@ int rtw_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 	{
 		SIOCIWFIRSTPRIV + 0x13,
 		IW_PRIV_TYPE_CHAR | 64, IW_PRIV_TYPE_CHAR | 64 , "p2p_get2"
-	},
+	},	
 	{
 		SIOCIWFIRSTPRIV + 0x14,
 		IW_PRIV_TYPE_CHAR  | 64, 0, "tdls"
@@ -11754,7 +11755,7 @@ int rtw_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 	{
 		SIOCIWFIRSTPRIV + 0x15,
 		IW_PRIV_TYPE_CHAR | P2P_PRIVATE_IOCTL_SET_LEN, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | P2P_PRIVATE_IOCTL_SET_LEN , "tdls_get"
-	},
+	},	
 	{
 		SIOCIWFIRSTPRIV + 0x16,
 		IW_PRIV_TYPE_CHAR | 64, 0, "pm_set"
@@ -11780,7 +11781,7 @@ int rtw_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 #endif // CONFIG_INTEL_WIDI
 };
 
-static iw_handler rtw_private_handler[] =
+static iw_handler rtw_private_handler[] = 
 {
 	rtw_wx_write32,					//0x00
 	rtw_wx_read32,					//0x01
@@ -11838,7 +11839,7 @@ int rtw_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 
 #endif // #if defined(CONFIG_MP_INCLUDED) && defined(CONFIG_MP_IWPRIV_SUPPORT)
 
-#if WIRELESS_EXT >= 17
+#if WIRELESS_EXT >= 17	
 static struct iw_statistics *rtw_get_wireless_stats(struct net_device *dev)
 {
        _adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
@@ -11856,13 +11857,13 @@ static struct iw_statistics *rtw_get_wireless_stats(struct net_device *dev)
 	}
 	else{
 		#ifdef CONFIG_SIGNAL_DISPLAY_DBM
-		tmp_level = translate_percentage_to_dbm(padapter->recvpriv.signal_strength);
+		tmp_level = translate_percentage_to_dbm(padapter->recvpriv.signal_strength); 
 		#else
 		tmp_level = padapter->recvpriv.signal_strength;
 		#endif
-
+		
 		tmp_qual = padapter->recvpriv.signal_qual;
-		tmp_noise =padapter->recvpriv.noise;
+		tmp_noise =padapter->recvpriv.noise;		
 		//DBG_871X("level:%d, qual:%d, noise:%d, rssi (%d)\n", tmp_level, tmp_qual, tmp_noise,padapter->recvpriv.rssi);
 
 		piwstats->qual.level = tmp_level;
@@ -11898,10 +11899,11 @@ struct iw_handler_def rtw_handlers_def =
 	.private = rtw_private_handler,
 	.private_args = (struct iw_priv_args *)rtw_private_args,
 	.num_private = sizeof(rtw_private_handler) / sizeof(iw_handler),
-	.num_private_args = sizeof(rtw_private_args) / sizeof(struct iw_priv_args),
+ 	.num_private_args = sizeof(rtw_private_args) / sizeof(struct iw_priv_args),
 #endif
 #if WIRELESS_EXT >= 17
 	.get_wireless_stats = rtw_get_wireless_stats,
 #endif
 };
 #endif
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/mlme_linux.c b/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/mlme_linux.c
old mode 100644
new mode 100755
index d518395..0ec8d05
--- a/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/mlme_linux.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/mlme_linux.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -77,33 +77,64 @@ void sitesurvey_ctrl_handler(void *FunctionContext)
 }
 */
 
-void rtw_join_timeout_handler (void *FunctionContext)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+void rtw_join_timeout_handler(void *FunctionContext)
+#else
+void rtw_join_timeout_handler(struct timer_list *t)
+#endif
 {
-	_adapter *adapter = (_adapter *)FunctionContext;
-	_rtw_join_timeout_handler(adapter);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+        _adapter *adapter = (_adapter *)FunctionContext;
+#else
+        _adapter *adapter = from_timer(adapter, t, mlmepriv.assoc_timer);
+#endif
+
+        _rtw_join_timeout_handler(adapter);
 }
 
 
-void _rtw_scan_timeout_handler (void *FunctionContext)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+void _rtw_scan_timeout_handler(void *FunctionContext)
+#else
+void _rtw_scan_timeout_handler(struct timer_list *t)
+#endif
 {
-	_adapter *adapter = (_adapter *)FunctionContext;
-	rtw_scan_timeout_handler(adapter);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+        _adapter *adapter = (_adapter *)FunctionContext;
+#else
+        _adapter *adapter = from_timer(adapter, t, mlmepriv.scan_to_timer);
+#endif
+        rtw_scan_timeout_handler(adapter);
 }
 
-
-void _dynamic_check_timer_handlder (void *FunctionContext)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+static void _dynamic_check_timer_handlder(void *FunctionContext)
+#else
+static void _dynamic_check_timer_handlder(struct timer_list *t)
+#endif
 {
-	_adapter *adapter = (_adapter *)FunctionContext;
-
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+        _adapter *adapter = (_adapter *)FunctionContext;
+#else
+        _adapter *adapter = from_timer(adapter, t, mlmepriv.dynamic_chk_timer);
+#endif
 	rtw_dynamic_check_timer_handlder(adapter);
 
 	_set_timer(&adapter->mlmepriv.dynamic_chk_timer, 2000);
 }
 
 #ifdef CONFIG_SET_SCAN_DENY_TIMER
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
 void _rtw_set_scan_deny_timer_hdl(void *FunctionContext)
+#else
+void _rtw_set_scan_deny_timer_hdl(struct timer_list *t)
+#endif
 {
-	_adapter *adapter = (_adapter *)FunctionContext;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+        _adapter *adapter = (_adapter *)FunctionContext;
+#else
+        _adapter *adapter = from_timer(adapter, t, mlmepriv.set_scan_deny_timer);
+#endif
 	rtw_set_scan_deny_timer_hdl(adapter);
 }
 #endif
@@ -113,15 +144,21 @@ void rtw_init_mlme_timer(_adapter *padapter)
 {
 	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
 	_init_timer(&(pmlmepriv->assoc_timer), padapter->pnetdev, rtw_join_timeout_handler, padapter);
-	//_init_timer(&(pmlmepriv->sitesurveyctrl.sitesurvey_ctrl_timer), padapter->pnetdev, sitesurvey_ctrl_handler, padapter);
 	_init_timer(&(pmlmepriv->scan_to_timer), padapter->pnetdev, _rtw_scan_timeout_handler, padapter);
-
 	_init_timer(&(pmlmepriv->dynamic_chk_timer), padapter->pnetdev, _dynamic_check_timer_handlder, padapter);
-
 	#ifdef CONFIG_SET_SCAN_DENY_TIMER
 	_init_timer(&(pmlmepriv->set_scan_deny_timer), padapter->pnetdev, _rtw_set_scan_deny_timer_hdl, padapter);
 	#endif
+#else
+        timer_setup(&pmlmepriv->assoc_timer, rtw_join_timeout_handler, 0);
+        timer_setup(&pmlmepriv->scan_to_timer, _rtw_scan_timeout_handler, 0);
+        timer_setup(&pmlmepriv->dynamic_chk_timer, _dynamic_check_timer_handlder, 0);
+        #ifdef CONFIG_SET_SCAN_DENY_TIMER
+        timer_setup(&pmlmepriv->set_scan_deny_timer, _rtw_set_scan_deny_timer_hdl, 0);
+        #endif
+#endif
 
 #ifdef RTK_DMP_PLATFORM
 	_init_workitem(&(pmlmepriv->Linkup_workitem), Linkup_workitem_callback, padapter);
@@ -136,7 +173,7 @@ void rtw_init_mlme_timer(_adapter *padapter)
 void rtw_os_indicate_connect(_adapter *adapter)
 {
 
-_func_enter_;
+_func_enter_;	
 
 #ifdef CONFIG_IOCTL_CFG80211
 	rtw_cfg80211_indicate_connect(adapter);
@@ -152,7 +189,7 @@ void rtw_os_indicate_connect(_adapter *adapter)
 	_set_workitem(&adapter->mlmepriv.Linkup_workitem);
 #endif
 
-_func_exit_;
+_func_exit_;	
 
 }
 
@@ -174,11 +211,11 @@ void rtw_reset_securitypriv( _adapter *adapter )
 	// add for CONFIG_IEEE80211W, none 11w also can use
 	_irqL irqL;
 	struct mlme_ext_priv	*pmlmeext = &adapter->mlmeextpriv;
-
+	
 	_enter_critical_bh(&adapter->security_key_mutex, &irqL);
-
+	
 	if(adapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X)//802.1x
-	{
+	{		 
 		// Added by Albert 2009/02/18
 		// We have to backup the PMK information for WiFi PMK Caching test item.
 		//
@@ -190,7 +227,7 @@ void rtw_reset_securitypriv( _adapter *adapter )
 		_rtw_memcpy( &backupPMKIDList[ 0 ], &adapter->securitypriv.PMKIDList[ 0 ], sizeof( RT_PMKID_LIST ) * NUM_PMKID_CACHE );
 		backupPMKIDIndex = adapter->securitypriv.PMKIDIndex;
 		backupTKIPCountermeasure = adapter->securitypriv.btkip_countermeasure;
-		backupTKIPcountermeasure_time = adapter->securitypriv.btkip_countermeasure_time;
+		backupTKIPcountermeasure_time = adapter->securitypriv.btkip_countermeasure_time;		
 #ifdef CONFIG_IEEE80211W
 		//reset RX BIP packet number
 		pmlmeext->mgnt_80211w_IPN_rx = 0;
@@ -203,13 +240,13 @@ void rtw_reset_securitypriv( _adapter *adapter )
 		_rtw_memcpy( &adapter->securitypriv.PMKIDList[ 0 ], &backupPMKIDList[ 0 ], sizeof( RT_PMKID_LIST ) * NUM_PMKID_CACHE );
 		adapter->securitypriv.PMKIDIndex = backupPMKIDIndex;
 		adapter->securitypriv.btkip_countermeasure = backupTKIPCountermeasure;
-		adapter->securitypriv.btkip_countermeasure_time = backupTKIPcountermeasure_time;
+		adapter->securitypriv.btkip_countermeasure_time = backupTKIPcountermeasure_time;		
 
 		adapter->securitypriv.ndisauthtype = Ndis802_11AuthModeOpen;
 		adapter->securitypriv.ndisencryptstatus = Ndis802_11WEPDisabled;
 
 	}
-	else //reset values in securitypriv
+	else //reset values in securitypriv 
 	{
 		//if(adapter->mlmepriv.fw_state & WIFI_STATION_STATE)
 		//{
@@ -233,16 +270,16 @@ void rtw_reset_securitypriv( _adapter *adapter )
 void rtw_os_indicate_disconnect( _adapter *adapter )
 {
    //RT_PMKID_LIST   backupPMKIDList[ NUM_PMKID_CACHE ];
-
+  
 _func_enter_;
 
 	netif_carrier_off(adapter->pnetdev); // Do it first for tx broadcast pkt after disconnection issue!
 
 #ifdef CONFIG_IOCTL_CFG80211
-	rtw_cfg80211_indicate_disconnect(adapter);
+	rtw_cfg80211_indicate_disconnect(adapter); 	
 #endif //CONFIG_IOCTL_CFG80211
 
-	rtw_indicate_wx_disassoc_event(adapter);
+	rtw_indicate_wx_disassoc_event(adapter);	
 
 #ifdef RTK_DMP_PLATFORM
 	_set_workitem(&adapter->mlmepriv.Linkdown_workitem);
@@ -268,57 +305,79 @@ void rtw_report_sec_ie(_adapter *adapter,u8 authmode,u8 *sec_ie)
 	if(authmode==_WPA_IE_ID_)
 	{
 		RT_TRACE(_module_mlme_osdep_c_,_drv_info_,("rtw_report_sec_ie, authmode=%d\n", authmode));
-
+		
 		buff = rtw_malloc(IW_CUSTOM_MAX);
-
+		
 		_rtw_memset(buff,0,IW_CUSTOM_MAX);
-
+		
 		p=buff;
-
+		
 		p+=sprintf(p,"ASSOCINFO(ReqIEs=");
 
 		len = sec_ie[1]+2;
 		len =  (len < IW_CUSTOM_MAX) ? len:IW_CUSTOM_MAX;
-
+			
 		for(i=0;i<len;i++){
 			p+=sprintf(p,"%02x",sec_ie[i]);
 		}
 
 		p+=sprintf(p,")");
-
+		
 		_rtw_memset(&wrqu,0,sizeof(wrqu));
-
+		
 		wrqu.data.length=p-buff;
-
+		
 		wrqu.data.length = (wrqu.data.length<IW_CUSTOM_MAX) ? wrqu.data.length:IW_CUSTOM_MAX;
-
+		
 		wireless_send_event(adapter->pnetdev,IWEVCUSTOM,&wrqu,buff);
 
 		if(buff)
 		    rtw_mfree(buff, IW_CUSTOM_MAX);
-
+		
 	}
 
 _func_exit_;
 
 }
 
-void _survey_timer_hdl (void *FunctionContext)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+static void _survey_timer_hdl(void *FunctionContext)
+#else
+static void _survey_timer_hdl(struct timer_list *t)
+#endif
 {
-	_adapter *padapter = (_adapter *)FunctionContext;
-
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+        _adapter *padapter = (_adapter *)FunctionContext;
+#else
+        _adapter *padapter = from_timer(padapter, t, mlmeextpriv.survey_timer);
+#endif
 	survey_timer_hdl(padapter);
 }
 
-void _link_timer_hdl (void *FunctionContext)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+static void _link_timer_hdl (void *FunctionContext)
+#else
+static void _link_timer_hdl(struct timer_list *t)
+#endif
 {
-	_adapter *padapter = (_adapter *)FunctionContext;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+        _adapter *padapter = (_adapter *)FunctionContext;
+#else
+        _adapter *padapter = from_timer(padapter, t, mlmeextpriv.link_timer);
+#endif
 	link_timer_hdl(padapter);
 }
-
-void _addba_timer_hdl(void *FunctionContext)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+static void _addba_timer_hdl(void *FunctionContext)
+#else
+static void _addba_timer_hdl(struct timer_list *t)
+#endif
 {
-	struct sta_info *psta = (struct sta_info *)FunctionContext;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+        struct sta_info *psta = (struct sta_info *)FunctionContext;
+#else
+        struct sta_info *psta = from_timer(psta, t, addba_retry_timer);
+#endif
 	addba_timer_hdl(psta);
 }
 
@@ -332,8 +391,11 @@ void _sa_query_timer_hdl (void *FunctionContext)
 
 void init_addba_retry_timer(_adapter *padapter, struct sta_info *psta)
 {
-
-	_init_timer(&psta->addba_retry_timer, padapter->pnetdev, _addba_timer_hdl, psta);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+        _init_timer(&psta->addba_retry_timer, padapter->pnetdev, _addba_timer_hdl, psta);
+#else
+        timer_setup(&psta->addba_retry_timer, _addba_timer_hdl, 0);
+#endif
 }
 
 /*
@@ -354,8 +416,13 @@ void init_mlme_ext_timer(_adapter *padapter)
 {
 	struct	mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
 
-	_init_timer(&pmlmeext->survey_timer, padapter->pnetdev, _survey_timer_hdl, padapter);
-	_init_timer(&pmlmeext->link_timer, padapter->pnetdev, _link_timer_hdl, padapter);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+        _init_timer(&pmlmeext->survey_timer, padapter->pnetdev, _survey_timer_hdl, padapter);
+        _init_timer(&pmlmeext->link_timer, padapter->pnetdev, _link_timer_hdl, padapter);
+#else
+        timer_setup(&pmlmeext->survey_timer, _survey_timer_hdl, 0);
+        timer_setup(&pmlmeext->link_timer, _link_timer_hdl, 0);
+#endif
 #ifdef CONFIG_IEEE80211W
 	_init_timer(&pmlmeext->sa_query_timer, padapter->pnetdev, _sa_query_timer_hdl, padapter);
 #endif //CONFIG_IEEE80211W
@@ -380,14 +447,14 @@ void rtw_indicate_sta_assoc_event(_adapter *padapter, struct sta_info *psta)
 
 	if(pstapriv->sta_aid[psta->aid - 1] != psta)
 		return;
-
-
-	wrqu.addr.sa_family = ARPHRD_ETHER;
-
+	
+	
+	wrqu.addr.sa_family = ARPHRD_ETHER;	
+	
 	_rtw_memcpy(wrqu.addr.sa_data, psta->hwaddr, ETH_ALEN);
 
 	DBG_871X("+rtw_indicate_sta_assoc_event\n");
-
+	
 	wireless_send_event(padapter->pnetdev, IWEVREGISTERED, &wrqu, NULL);
 
 }
@@ -405,16 +472,16 @@ void rtw_indicate_sta_disassoc_event(_adapter *padapter, struct sta_info *psta)
 
 	if(pstapriv->sta_aid[psta->aid - 1] != psta)
 		return;
-
-
-	wrqu.addr.sa_family = ARPHRD_ETHER;
-
+	
+	
+	wrqu.addr.sa_family = ARPHRD_ETHER;	
+	
 	_rtw_memcpy(wrqu.addr.sa_data, psta->hwaddr, ETH_ALEN);
 
 	DBG_871X("+rtw_indicate_sta_disassoc_event\n");
-
+	
 	wireless_send_event(padapter->pnetdev, IWEVEXPIRED, &wrqu, NULL);
-
+	
 }
 
 
@@ -438,18 +505,18 @@ static int mgnt_netdev_open(struct net_device *pnetdev)
 
 
 	init_usb_anchor(&phostapdpriv->anchored);
-
-	if(!rtw_netif_queue_stopped(pnetdev))
-		rtw_netif_start_queue(pnetdev);
+	
+ 	if(!rtw_netif_queue_stopped(pnetdev))
+      		rtw_netif_start_queue(pnetdev);
 	else
 		rtw_netif_wake_queue(pnetdev);
 
 
 	netif_carrier_on(pnetdev);
-
-	//rtw_write16(phostapdpriv->padapter, 0x0116, 0x0100);//only excluding beacon
-
-	return 0;
+		
+	//rtw_write16(phostapdpriv->padapter, 0x0116, 0x0100);//only excluding beacon 
+		
+	return 0;	
 }
 static int mgnt_netdev_close(struct net_device *pnetdev)
 {
@@ -463,10 +530,10 @@ static int mgnt_netdev_close(struct net_device *pnetdev)
 
 	if (!rtw_netif_queue_stopped(pnetdev))
 		rtw_netif_stop_queue(pnetdev);
-
+	
 	//rtw_write16(phostapdpriv->padapter, 0x0116, 0x3f3f);
-
-	return 0;
+	
+	return 0;	
 }
 
 #if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,29))
@@ -485,8 +552,8 @@ int hostapd_mode_init(_adapter *padapter)
 	unsigned char mac[ETH_ALEN];
 	struct hostapd_priv *phostapdpriv;
 	struct net_device *pnetdev;
-
-	pnetdev = rtw_alloc_etherdev(sizeof(struct hostapd_priv));
+	
+	pnetdev = rtw_alloc_etherdev(sizeof(struct hostapd_priv));	
 	if (!pnetdev)
 	   return -ENOMEM;
 
@@ -494,49 +561,49 @@ int hostapd_mode_init(_adapter *padapter)
        ether_setup(pnetdev);
 
 	//pnetdev->type = ARPHRD_IEEE80211;
-
+	
 	phostapdpriv = rtw_netdev_priv(pnetdev);
 	phostapdpriv->pmgnt_netdev = pnetdev;
 	phostapdpriv->padapter= padapter;
 	padapter->phostapdpriv = phostapdpriv;
-
+	
 	//pnetdev->init = NULL;
-
+	
 #if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,29))
 
 	DBG_871X("register rtl871x_mgnt_netdev_ops to netdev_ops\n");
 
 	pnetdev->netdev_ops = &rtl871x_mgnt_netdev_ops;
-
+	
 #else
 
 	pnetdev->open = mgnt_netdev_open;
 
-	pnetdev->stop = mgnt_netdev_close;
-
+	pnetdev->stop = mgnt_netdev_close;	
+	
 	pnetdev->hard_start_xmit = mgnt_xmit_entry;
-
+	
 	//pnetdev->set_mac_address = r871x_net_set_mac_address;
-
+	
 	//pnetdev->get_stats = r871x_net_get_stats;
 
 	//pnetdev->do_ioctl = r871x_mp_ioctl;
-
+	
 #endif
 
-	pnetdev->watchdog_timeo = HZ; /* 1 second timeout */
+	pnetdev->watchdog_timeo = HZ; /* 1 second timeout */	
 
 	//pnetdev->wireless_handlers = NULL;
 
 #ifdef CONFIG_TCP_CSUM_OFFLOAD_TX
 	pnetdev->features |= NETIF_F_IP_CSUM;
-#endif
-
-
+#endif	
 
+	
+	
 	if(dev_alloc_name(pnetdev,"mgnt.wlan%d") < 0)
 	{
-		DBG_871X("hostapd_mode_init(): dev_alloc_name, fail! \n");
+		DBG_871X("hostapd_mode_init(): dev_alloc_name, fail! \n");		
 	}
 
 
@@ -549,9 +616,9 @@ int hostapd_mode_init(_adapter *padapter)
 	mac[3]=0x87;
 	mac[4]=0x11;
 	mac[5]=0x12;
-
+				
 	_rtw_memcpy(pnetdev->dev_addr, mac, ETH_ALEN);
-
+	
 
 	netif_carrier_off(pnetdev);
 
@@ -560,15 +627,15 @@ int hostapd_mode_init(_adapter *padapter)
 	if (register_netdev(pnetdev) != 0)
 	{
 		DBG_871X("hostapd_mode_init(): register_netdev fail!\n");
-
+		
 		if(pnetdev)
-		{
+      		{	 
 			rtw_free_netdev(pnetdev);
-		}
+      		}
 	}
-
+	
 	return 0;
-
+	
 }
 
 void hostapd_mode_unload(_adapter *padapter)
@@ -578,8 +645,9 @@ void hostapd_mode_unload(_adapter *padapter)
 
 	unregister_netdev(pnetdev);
 	rtw_free_netdev(pnetdev);
-
+	
 }
 
 #endif
 #endif
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/os_intfs.c b/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/os_intfs.c
old mode 100644
new mode 100755
index 596eda7..87901aa
--- a/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/os_intfs.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/os_intfs.c
@@ -279,6 +279,7 @@
 
 void rtw_proc_init_one(struct net_device *dev)
 {
+#if(LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0))
 	struct proc_dir_entry *dir_dev = NULL;
 	struct proc_dir_entry *entry=NULL;
 	_adapter	*padapter = rtw_netdev_priv(dev);
@@ -647,6 +648,9 @@ void rtw_proc_init_one(struct net_device *dev)
 	entry->write_proc = proc_set_dm_adaptivity;
 #endif /* CONFIG_DM_ADAPTIVITY */
 
+#else /* kernel version < 3.10 */
+		DBG_871X(KERN_ERR "Unable to create /proc entry in this kernel version\n");
+#endif
 }
 
 void rtw_proc_remove_one(struct net_device *dev)
@@ -787,8 +791,8 @@ uint loadparam( _adapter *padapter,  _nic_hdl	pnetdev)
 	registry_par->radio_enable = (u8)rtw_radio_enable;
 	registry_par->long_retry_lmt = (u8)rtw_long_retry_lmt;
 	registry_par->short_retry_lmt = (u8)rtw_short_retry_lmt;
-	registry_par->busy_thresh = (u16)rtw_busy_thresh;
-	//registry_par->qos_enable = (u8)rtw_qos_enable;
+  	registry_par->busy_thresh = (u16)rtw_busy_thresh;
+  	//registry_par->qos_enable = (u8)rtw_qos_enable;
 	registry_par->ack_policy = (u8)rtw_ack_policy;
 	registry_par->mp_mode = (u8)rtw_mp_mode;
 	registry_par->software_encrypt = (u8)rtw_software_encrypt;
@@ -945,14 +949,13 @@ unsigned int rtw_classify8021d(struct sk_buff *skb)
 	return dscp >> 5;
 }
 
-static u16 rtw_select_queue(struct net_device *dev, struct sk_buff *skb
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 13, 0)
-				, void *accel_priv
-#endif
 #if (LINUX_VERSION_CODE>=KERNEL_VERSION(3,14,0))
-			    , select_queue_fallback_t fallback
+static u16 rtw_select_queue(struct net_device *dev, struct sk_buff *skb,
+			    void *accel_priv,
+			    select_queue_fallback_t fallback)
+#else
+static u16 rtw_select_queue(struct net_device *dev, struct sk_buff *skb)
 #endif
-)
 {
 	_adapter	*padapter = rtw_netdev_priv(dev);
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
@@ -1120,7 +1123,7 @@ struct net_device *rtw_init_netdev(_adapter *old_padapter)
 #endif
 
 	//step 2.
-	loadparam(padapter, pnetdev);
+   	loadparam(padapter, pnetdev);
 
 	return pnetdev;
 
@@ -1671,7 +1674,7 @@ int _netdev_vir_if_open(struct net_device *pnetdev)
 		int i;
 
 		padapter->bDriverStopped = _FALSE;
-		padapter->bSurpriseRemoved = _FALSE;
+	 	padapter->bSurpriseRemoved = _FALSE;
 		padapter->bCardDisableWOHSM = _FALSE;
 
 		_rtw_memcpy(padapter->HalData, primary_padapter->HalData, padapter->hal_data_sz);
@@ -1692,6 +1695,9 @@ int _netdev_vir_if_open(struct net_device *pnetdev)
 
 		padapter->bup = _TRUE;
 		padapter->hw_init_completed = _TRUE;
+
+		rtw_start_mbssid_cam(padapter);//start mbssid_cam after bup = _TRUE & hw_init_completed = _TRUE
+
 	}
 
 	padapter->net_closed = _FALSE;
@@ -2031,7 +2037,7 @@ int _netdev_if2_open(struct net_device *pnetdev)
 		int i;
 
 		padapter->bDriverStopped = _FALSE;
-		padapter->bSurpriseRemoved = _FALSE;
+	 	padapter->bSurpriseRemoved = _FALSE;
 		padapter->bCardDisableWOHSM = _FALSE;
 
 		_rtw_memcpy(padapter->HalData, primary_padapter->HalData, padapter->hal_data_sz);
@@ -2589,7 +2595,7 @@ int  ips_netdrv_open(_adapter *padapter)
 	}
 
 	rtw_set_pwr_state_check_timer(&padapter->pwrctrlpriv);
-	_set_timer(&padapter->mlmepriv.dynamic_chk_timer,5000);
+  	_set_timer(&padapter->mlmepriv.dynamic_chk_timer,5000);
 
 	 return _SUCCESS;
 
@@ -2612,7 +2618,7 @@ int rtw_ips_pwr_up(_adapter *padapter)
 
 	rtw_led_control(padapter, LED_CTL_NO_LINK);
 
-	DBG_871X("<===  rtw_ips_pwr_up.............. in %dms\n", rtw_get_passing_time_ms(start_time));
+ 	DBG_871X("<===  rtw_ips_pwr_up.............. in %dms\n", rtw_get_passing_time_ms(start_time));
 	return result;
 
 }
@@ -2753,4 +2759,6 @@ void rtw_ndev_destructor(struct net_device *ndev)
 	if (ndev->ieee80211_ptr)
 		rtw_mfree((u8 *)ndev->ieee80211_ptr, sizeof(struct wireless_dev));
 #endif
+	free_netdev(ndev);
 }
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/pci_intf.c b/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/pci_intf.c
old mode 100644
new mode 100755
index 15f5d9b..5bf576f
--- a/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/pci_intf.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/pci_intf.c
@@ -1994,3 +1994,4 @@ static void __exit rtw_drv_halt(void)
 
 module_init(rtw_drv_entry);
 module_exit(rtw_drv_halt);
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/pci_ops_linux.c b/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/pci_ops_linux.c
old mode 100644
new mode 100755
index 5eed11a..7d671df
--- a/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/pci_ops_linux.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/pci_ops_linux.c
@@ -19,3 +19,6 @@
 #define _PCI_OPS_LINUX_C_
 
 #include <drv_types.h>
+
+
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/recv_linux.c b/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/recv_linux.c
old mode 100644
new mode 100755
index c02046d..f265ddc
--- a/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/recv_linux.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/recv_linux.c
@@ -45,7 +45,7 @@ int rtw_os_recv_resource_init(struct recv_priv *precvpriv, _adapter *padapter)
 int rtw_os_recv_resource_alloc(_adapter *padapter, union recv_frame *precvframe)
 {
 	int	res=_SUCCESS;
-
+	
 	precvframe->u.hdr.pkt_newalloc = precvframe->u.hdr.pkt = NULL;
 
 	return res;
@@ -92,7 +92,7 @@ int rtw_os_recvbuf_resource_alloc(_adapter *padapter, struct recv_buf *precvbuf)
 	if(precvbuf->pallocated_buf == NULL)
 		return _FAIL;
 	#endif //CONFIG_USE_USB_BUFFER_ALLOC_RX
-
+	
 #endif //CONFIG_USB_HCI
 
 	return res;
@@ -136,12 +136,12 @@ int rtw_os_recvbuf_resource_free(_adapter *padapter, struct recv_buf *precvbuf)
 void rtw_handle_tkip_mic_err(_adapter *padapter,u8 bgroup)
 {
 #ifdef CONFIG_IOCTL_CFG80211
-	enum nl80211_key_type key_type = 0;
+	enum nl80211_key_type key_type;
 #endif
 	union iwreq_data wrqu;
 	struct iw_michaelmicfailure    ev;
 	struct mlme_priv*              pmlmepriv  = &padapter->mlmepriv;
-	struct security_priv	*psecuritypriv = &padapter->securitypriv;
+	struct security_priv	*psecuritypriv = &padapter->securitypriv;	
 	u32 cur_time = 0;
 
 	if( psecuritypriv->last_mic_err_time == 0 )
@@ -271,7 +271,7 @@ int rtw_recv_indicatepkt(_adapter *padapter, union recv_frame *precv_frame)
 		goto _recv_indicatepkt_drop;
 	}
 
-	RT_TRACE(_module_recv_osdep_c_,_drv_info_,("rtw_recv_indicatepkt():skb != NULL !!!\n"));
+	RT_TRACE(_module_recv_osdep_c_,_drv_info_,("rtw_recv_indicatepkt():skb != NULL !!!\n"));		
 	RT_TRACE(_module_recv_osdep_c_,_drv_info_,("rtw_recv_indicatepkt():precv_frame->u.hdr.rx_head=%p  precv_frame->hdr.rx_data=%p\n", precv_frame->u.hdr.rx_head, precv_frame->u.hdr.rx_data));
 	RT_TRACE(_module_recv_osdep_c_,_drv_info_,("precv_frame->hdr.rx_tail=%p precv_frame->u.hdr.rx_end=%p precv_frame->hdr.len=%d \n", precv_frame->u.hdr.rx_tail, precv_frame->u.hdr.rx_end, precv_frame->u.hdr.len));
 
@@ -285,9 +285,9 @@ int rtw_recv_indicatepkt(_adapter *padapter, union recv_frame *precv_frame)
 
 	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == _TRUE)
 	{
-		_pkt *pskb2=NULL;
-		struct sta_info *psta = NULL;
-		struct sta_priv *pstapriv = &padapter->stapriv;
+	 	_pkt *pskb2=NULL;
+	 	struct sta_info *psta = NULL;
+	 	struct sta_priv *pstapriv = &padapter->stapriv;
 		struct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;
 		int bmcast = IS_MCAST(pattrib->dst);
 
@@ -307,18 +307,18 @@ int rtw_recv_indicatepkt(_adapter *padapter, union recv_frame *precv_frame)
 
 			if(psta)
 			{
-				struct net_device *pnetdev= (struct net_device*)padapter->pnetdev;
+				struct net_device *pnetdev= (struct net_device*)padapter->pnetdev;			
 
 				//DBG_871X("directly forwarding to the rtw_xmit_entry\n");
 
 				//skb->ip_summed = CHECKSUM_NONE;
-				skb->dev = pnetdev;
+				skb->dev = pnetdev;			
 #if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
 				skb_set_queue_mapping(skb, rtw_recv_select_queue(skb));
 #endif //LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35)
-
+			
 				_rtw_xmit_entry(skb, pnetdev);
-
+			
 				if(bmcast)
 					skb = pskb2;
 				else
@@ -332,7 +332,7 @@ int rtw_recv_indicatepkt(_adapter *padapter, union recv_frame *precv_frame)
 			//DBG_871X("to APSelf\n");
 		}
 	}
-
+	
 
 #ifdef CONFIG_BR_EXT
 
@@ -344,19 +344,19 @@ int rtw_recv_indicatepkt(_adapter *padapter, union recv_frame *precv_frame)
 	rcu_read_unlock();
 #endif  // (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
 
-	if( br_port	&& (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) == _TRUE) )
+	if( br_port	&& (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) == _TRUE) )	 	
 	{
 		int nat25_handle_frame(_adapter *priv, struct sk_buff *skb);
 		if (nat25_handle_frame(padapter, skb) == -1) {
 			//priv->ext_stats.rx_data_drops++;
 			//DEBUG_ERR("RX DROP: nat25_handle_frame fail!\n");
 			//return FAIL;
-#if 1
+#if 1			
 			// bypass this frame to upper layer!!
 #else
 			goto _recv_indicatepkt_drop;
 #endif
-		}
+		}	
 	}
 
 #endif	// CONFIG_BR_EXT
@@ -431,17 +431,31 @@ void rtw_os_read_port(_adapter *padapter, struct recv_buf *precvbuf)
 #endif
 
 }
-void _rtw_reordering_ctrl_timeout_handler (void *FunctionContext);
-void _rtw_reordering_ctrl_timeout_handler (void *FunctionContext)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+void _rtw_reordering_ctrl_timeout_handler(void *FunctionContext);
+void _rtw_reordering_ctrl_timeout_handler(void *FunctionContext)
+#else
+void _rtw_reordering_ctrl_timeout_handler(struct timer_list *t);
+void _rtw_reordering_ctrl_timeout_handler(struct timer_list *t)
+#endif
 {
-	struct recv_reorder_ctrl *preorder_ctrl = (struct recv_reorder_ctrl *)FunctionContext;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+        struct recv_reorder_ctrl *preorder_ctrl = (struct recv_reorder_ctrl *)FunctionContext;
+#else
+        struct recv_reorder_ctrl *preorder_ctrl = from_timer(preorder_ctrl, t, reordering_ctrl_timer);
+#endif
 	rtw_reordering_ctrl_timeout_handler(preorder_ctrl);
 }
 
 void rtw_init_recv_timer(struct recv_reorder_ctrl *preorder_ctrl)
 {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
 	_adapter *padapter = preorder_ctrl->padapter;
 
 	_init_timer(&(preorder_ctrl->reordering_ctrl_timer), padapter->pnetdev, _rtw_reordering_ctrl_timeout_handler, preorder_ctrl);
-
+#else
+	timer_setup(&preorder_ctrl->reordering_ctrl_timer, _rtw_reordering_ctrl_timeout_handler, 0);
+#endif
 }
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/rtw_android.c b/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/rtw_android.c
old mode 100644
new mode 100755
index bbd22ef..d6ac16c
--- a/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/rtw_android.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/rtw_android.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -74,7 +74,7 @@
 	"WFD-DISABLE",
 	"WFD-SET-TCPPORT",
 	"WFD-SET-MAXTPUT",
-	"WFD-SET-DEVTYPE",
+	"WFD-SET-DEVTYPE",	
 };
 
 #ifdef PNO_SUPPORT
@@ -96,7 +96,13 @@
 #endif /* PNO_SUPPORT */
 
 typedef struct android_wifi_priv_cmd {
+
+#ifdef CONFIG_COMPAT
+	compat_uptr_t buf;
+#else
 	char *buf;
+#endif
+
 	int used_len;
 	int total_len;
 } android_wifi_priv_cmd;
@@ -226,19 +232,19 @@ int rtw_android_cmdstr_to_num(char *cmdstr)
 	for(cmd_num=0 ; cmd_num<ANDROID_WIFI_CMD_MAX; cmd_num++)
 		if(0 == strncasecmp(cmdstr , android_wifi_cmd_str[cmd_num], strlen(android_wifi_cmd_str[cmd_num])) )
 			break;
-
+		
 	return cmd_num;
 }
 
 int rtw_android_get_rssi(struct net_device *net, char *command, int total_len)
 {
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(net);
-	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);	
 	struct	wlan_network	*pcur_network = &pmlmepriv->cur_network;
 	int bytes_written = 0;
 
-	if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) {
-		bytes_written += snprintf(&command[bytes_written], total_len, "%s rssi %d",
+	if(check_fwstate(pmlmepriv, _FW_LINKED) == _TRUE) {	
+		bytes_written += snprintf(&command[bytes_written], total_len, "%s rssi %d", 
 			pcur_network->network.Ssid.Ssid, padapter->recvpriv.rssi);
 	}
 
@@ -248,7 +254,7 @@ int rtw_android_get_rssi(struct net_device *net, char *command, int total_len)
 int rtw_android_get_link_speed(struct net_device *net, char *command, int total_len)
 {
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(net);
-	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);	
 	struct	wlan_network	*pcur_network = &pmlmepriv->cur_network;
 	int bytes_written = 0;
 	u16 link_speed = 0;
@@ -263,7 +269,7 @@ int rtw_android_get_macaddr(struct net_device *net, char *command, int total_len
 {
 	_adapter *adapter = (_adapter *)rtw_netdev_priv(net);
 	int bytes_written = 0;
-
+	
 	bytes_written = snprintf(command, total_len, "Macaddr = "MAC_FMT, MAC_ARG(net->dev_addr));
 	return bytes_written;
 }
@@ -273,7 +279,7 @@ int rtw_android_set_country(struct net_device *net, char *command, int total_len
 	_adapter *adapter = (_adapter *)rtw_netdev_priv(net);
 	char *country_code = command + strlen(android_wifi_cmd_str[ANDROID_WIFI_CMD_COUNTRY]) + 1;
 	int ret = _FAIL;
-
+	
 	ret = rtw_set_country(adapter, country_code);
 
 	return (ret==_SUCCESS)?0:-1;
@@ -285,7 +291,7 @@ int rtw_android_get_p2p_dev_addr(struct net_device *net, char *command, int tota
 
 	//We use the same address as our HW MAC address
 	_rtw_memcpy(command, net->dev_addr, ETH_ALEN);
-
+	
 	bytes_written = ETH_ALEN;
 	return bytes_written;
 }
@@ -298,7 +304,7 @@ int rtw_android_set_block(struct net_device *net, char *command, int total_len)
 	#ifdef CONFIG_IOCTL_CFG80211
 	wdev_to_priv(adapter->rtw_wdev)->block = (*block_value=='0')?_FALSE:_TRUE;
 	#endif
-
+	
 	return 0;
 }
 
@@ -369,7 +375,7 @@ int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 	}
 
 	if (!access_ok(VERIFY_READ, priv_cmd.buf, priv_cmd.total_len)){
-		DBG_871X("%s: failed to access memory\n", __FUNCTION__);
+	 	DBG_871X("%s: failed to access memory\n", __FUNCTION__);
 		ret = -EFAULT;
 		goto exit;
 	 }
@@ -382,7 +388,7 @@ int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 		, __FUNCTION__, command, ifr->ifr_name);
 
 	cmd_num = rtw_android_cmdstr_to_num(command);
-
+	
 	switch(cmd_num) {
 	case ANDROID_WIFI_CMD_START:
 		//bytes_written = wl_android_wifi_on(net);
@@ -403,19 +409,19 @@ int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 	case ANDROID_WIFI_CMD_STOP:
 		//bytes_written = wl_android_wifi_off(net);
 		break;
-
+		
 	case ANDROID_WIFI_CMD_SCAN_ACTIVE:
 		//rtw_set_scan_mode((_adapter *)rtw_netdev_priv(net), SCAN_ACTIVE);
 #ifdef CONFIG_PLATFORM_MSTAR
 #ifdef CONFIG_IOCTL_CFG80211
-		(wdev_to_priv(net->ieee80211_ptr))->bandroid_scan = _TRUE;
+		(wdev_to_priv(net->ieee80211_ptr))->bandroid_scan = _TRUE;	
 #endif //CONFIG_IOCTL_CFG80211
 #endif //CONFIG_PLATFORM_MSTAR
 		break;
 	case ANDROID_WIFI_CMD_SCAN_PASSIVE:
 		//rtw_set_scan_mode((_adapter *)rtw_netdev_priv(net), SCAN_PASSIVE);
 		break;
-
+		
 	case ANDROID_WIFI_CMD_RSSI:
 		bytes_written = rtw_android_get_rssi(net, command, priv_cmd.total_len);
 		break;
@@ -426,11 +432,11 @@ int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 	case ANDROID_WIFI_CMD_MACADDR:
 		bytes_written = rtw_android_get_macaddr(net, command, priv_cmd.total_len);
 		break;
-
+		
 	case ANDROID_WIFI_CMD_BLOCK:
 		bytes_written = rtw_android_set_block(net, command, priv_cmd.total_len);
 		break;
-
+		
 	case ANDROID_WIFI_CMD_RXFILTER_START:
 		//bytes_written = net_os_set_packet_filter(net, 1);
 		break;
@@ -445,7 +451,7 @@ int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 		//int filter_num = *(command + strlen(CMD_RXFILTER_REMOVE) + 1) - '0';
 		//bytes_written = net_os_rxfilter_add_remove(net, FALSE, filter_num);
 		break;
-
+		
 	case ANDROID_WIFI_CMD_BTCOEXSCAN_START:
 		/* TBD: BTCOEXSCAN-START */
 		break;
@@ -464,11 +470,11 @@ int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 #endif
 		#endif
 		break;
-
+		
 	case ANDROID_WIFI_CMD_SETSUSPENDOPT:
 		//bytes_written = wl_android_set_suspendopt(net, command, priv_cmd.total_len);
 		break;
-
+		
 	case ANDROID_WIFI_CMD_SETBAND:
 		bytes_written = rtw_android_setband(net, command, priv_cmd.total_len);
 		break;
@@ -476,11 +482,11 @@ int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 	case ANDROID_WIFI_CMD_GETBAND:
 		bytes_written = rtw_android_getband(net, command, priv_cmd.total_len);
 		break;
-
+		
 	case ANDROID_WIFI_CMD_COUNTRY:
 		bytes_written = rtw_android_set_country(net, command, priv_cmd.total_len);
 		break;
-
+		
 #ifdef PNO_SUPPORT
 	case ANDROID_WIFI_CMD_PNOSSIDCLR_SET:
 		//bytes_written = dhd_dev_pno_reset(net);
@@ -508,7 +514,7 @@ int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 		//int skip = strlen(CMD_P2P_SET_PS) + 1;
 		//bytes_written = wl_cfg80211_set_p2p_ps(net, command + skip, priv_cmd.total_len - skip);
 		break;
-
+		
 #ifdef CONFIG_IOCTL_CFG80211
 	case ANDROID_WIFI_CMD_SET_AP_WPS_P2P_IE:
 	{
@@ -524,10 +530,10 @@ int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 		//	Commented by Albert 2012/07/24
 		//	We can enable the WFD function by using the following command:
 		//	wpa_cli driver wfd-enable
-
+		
 		struct wifi_display_info		*pwfd_info;
 		_adapter*	padapter = ( _adapter * ) rtw_netdev_priv(net);
-
+	
 		pwfd_info = &padapter->wfd_info;
 		if( padapter->wdinfo.driver_interface == DRIVER_CFG80211 )
 			pwfd_info->wfd_enable = _TRUE;
@@ -539,10 +545,10 @@ int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 		//	Commented by Albert 2012/07/24
 		//	We can disable the WFD function by using the following command:
 		//	wpa_cli driver wfd-disable
-
+				
 		struct wifi_display_info		*pwfd_info;
 		_adapter*	padapter = ( _adapter * ) rtw_netdev_priv(net);
-
+	
 		pwfd_info = &padapter->wfd_info;
 		if( padapter->wdinfo.driver_interface == DRIVER_CFG80211 )
 			pwfd_info->wfd_enable = _FALSE;
@@ -553,10 +559,10 @@ int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 		//	Commented by Albert 2012/07/24
 		//	We can set the tcp port number by using the following command:
 		//	wpa_cli driver wfd-set-tcpport = 554
-
+		
 		struct wifi_display_info		*pwfd_info;
 		_adapter*	padapter = ( _adapter * ) rtw_netdev_priv(net);
-
+	
 		pwfd_info = &padapter->wfd_info;
 		if( padapter->wdinfo.driver_interface == DRIVER_CFG80211 )
 			pwfd_info->rtsp_ctrlport = ( u16 ) get_int_from_command( priv_cmd.buf );
@@ -564,18 +570,18 @@ int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
 	}
 	case ANDROID_WIFI_CMD_WFD_SET_MAX_TPUT:
 	{
-
-
+		
+		
 		break;
 	}
 	case ANDROID_WIFI_CMD_WFD_SET_DEVTYPE:
 	{
 		//	Commented by Albert 2012/08/28
 		//	Specify the WFD device type ( WFD source/primary sink )
-
+		
 		struct wifi_display_info		*pwfd_info;
 		_adapter*	padapter = ( _adapter * ) rtw_netdev_priv(net);
-
+	
 		pwfd_info = &padapter->wfd_info;
 		if( padapter->wdinfo.driver_interface == DRIVER_CFG80211 )
 		{
@@ -830,3 +836,4 @@ static void wifi_del_dev(void)
 	platform_driver_unregister(&wifi_device_legacy);
 }
 #endif /* defined(RTW_ENABLE_WIFI_CONTROL_FUNC) */
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/usb_intf.c b/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/usb_intf.c
old mode 100644
new mode 100755
index be72304..47f9513
--- a/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/usb_intf.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/usb_intf.c
@@ -96,6 +96,7 @@
 	{USB_DEVICE(0x2019, 0xED17)},/* PCI - Edimax */ \
 	{USB_DEVICE(0x0DF6, 0x0052)},/* Sitecom - Edimax */ \
 	{USB_DEVICE(0x7392, 0x7811)},/* Edimax - Edimax */ \
+	{USB_DEVICE(0x07B8, 0x8188)},/* Abocom - Abocom */ \
 	{USB_DEVICE(0x07B8, 0x8189)},/* Abocom - Abocom */ \
 	{USB_DEVICE(0x0EB0, 0x9071)},/* NO Brand - Etop */ \
 	{USB_DEVICE(0x06F8, 0xE033)},/* Hercules - Edimax */ \
@@ -120,7 +121,6 @@
 	{USB_DEVICE(0x0B05, 0x17BA)}, /* ASUS - Edimax */ \
 	{USB_DEVICE(0x0BDA, 0x1E1E)}, /* Intel - - */ \
 	{USB_DEVICE(0x04BB, 0x094c)}, /* I-O DATA - Edimax */ \
-	{USB_DEVICE(0X0BDA, 0x8176)}, /* TP-Link TL-WN723N */ \
 	/****** 8188CTV ********/ \
 	{USB_DEVICE(0xCDAB, 0x8011)}, /* - - compare */ \
 	{USB_DEVICE(0x0BDA, 0x0A8A)}, /* Sony - Foxconn */ \
@@ -142,7 +142,7 @@
 	{USB_DEVICE(0x2001, 0x3307)},/* D-Link - Cameo */ \
 	{USB_DEVICE(0x2001, 0x330A)},/* D-Link - Alpha */ \
 	{USB_DEVICE(0x2001, 0x3309)},/* D-Link - Alpha */ \
-	{USB_DEVICE(0x2001, 0x330D)},/* D-Link - DWA 131 */ \
+	{USB_DEVICE(0x2001, 0x330D)},/* D-Link DWA-131 (H/W Ver. B1) */ \
 	{USB_DEVICE(0x0586, 0x341F)},/* Zyxel - Abocom */ \
 	{USB_DEVICE(0x7392, 0x7822)},/* Edimax - Edimax */ \
 	{USB_DEVICE(0x2019, 0xAB2B)},/* Planex - Abocom */ \
@@ -151,6 +151,7 @@
 	{USB_DEVICE(0x4855, 0x0091)},/*  - Feixun */ \
 	{USB_DEVICE(0x050D, 0x2102)},/* Belkin - Sercomm */ \
 	{USB_DEVICE(0x050D, 0x2103)},/* Belkin - Edimax */ \
+	{USB_DEVICE(0x050D, 0x21F2)},/* Belkin - Edimax */ \
 	{USB_DEVICE(0x20F4, 0x624D)},/* TRENDnet */ \
 	{USB_DEVICE(0x0DF6, 0x0061)},/* Sitecom - Edimax */ \
 	{USB_DEVICE(0x0B05, 0x17AB)},/* ASUS - Edimax */ \
@@ -262,7 +263,7 @@ struct rtw_usb_drv rtl8192c_usb_drv = {
 	.usbdrv.suspend =  rtw_suspend,
 	.usbdrv.resume = rtw_resume,
 	#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 22))
-	.usbdrv.reset_resume   = rtw_resume,
+  	.usbdrv.reset_resume   = rtw_resume,
 	#endif
 	#ifdef CONFIG_AUTOSUSPEND
 	.usbdrv.supports_autosuspend = 1,
@@ -292,7 +293,7 @@ struct rtw_usb_drv rtl8192d_usb_drv = {
 	.usbdrv.suspend =  rtw_suspend,
 	.usbdrv.resume = rtw_resume,
 	#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 22))
-	.usbdrv.reset_resume   = rtw_resume,
+  	.usbdrv.reset_resume   = rtw_resume,
 	#endif
 	#ifdef CONFIG_AUTOSUSPEND
 	.usbdrv.supports_autosuspend = 1,
@@ -324,7 +325,7 @@ static inline int RT_usb_endpoint_xfer_int(const struct usb_endpoint_descriptor
 
 static inline int RT_usb_endpoint_xfer_bulk(const struct usb_endpoint_descriptor *epd)
 {
-	return ((epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_BULK);
+ 	return ((epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_BULK);
 }
 
 static inline int RT_usb_endpoint_is_bulk_in(const struct usb_endpoint_descriptor *epd)
@@ -824,7 +825,7 @@ int rtw_hw_resume(_adapter *padapter)
 		netif_carrier_on(pnetdev);
 
 		if(!rtw_netif_queue_stopped(pnetdev))
-			rtw_netif_start_queue(pnetdev);
+      			rtw_netif_start_queue(pnetdev);
 		else
 			rtw_netif_wake_queue(pnetdev);
 
@@ -970,7 +971,7 @@ static int rtw_resume(struct usb_interface *pusb_intf)
 	 int ret = 0;
 
 	if(pwrpriv->bInternalAutoSuspend ){
-		ret = rtw_resume_process(padapter);
+ 		ret = rtw_resume_process(padapter);
 	} else {
 #ifdef CONFIG_RESUME_IN_WORKQUEUE
 		rtw_resume_in_workqueue(pwrpriv);
@@ -995,7 +996,7 @@ static int rtw_resume(struct usb_interface *pusb_intf)
 int rtw_resume_process(_adapter *padapter)
 {
 	struct net_device *pnetdev;
-	struct pwrctrl_priv *pwrpriv=NULL;
+	struct pwrctrl_priv *pwrpriv;
 	int ret = -1;
 	u32 start_time = rtw_get_current_time();
 	_func_enter_;
@@ -1058,8 +1059,7 @@ int rtw_resume_process(_adapter *padapter)
 	rtw_unlock_suspend();
 	#endif //CONFIG_RESUME_IN_WORKQUEUE
 
-	if (pwrpriv)
-		pwrpriv->bInSuspend = _FALSE;
+	pwrpriv->bInSuspend = _FALSE;
 	DBG_871X("<===  %s return %d.............. in %dms\n", __FUNCTION__
 		, ret, rtw_get_passing_time_ms(start_time));
 
@@ -1658,3 +1658,4 @@ _adapter  *rtw_usb_get_sw_pointer(void)
 }
 EXPORT_SYMBOL(rtw_usb_get_sw_pointer);
 #endif	//CONFIG_INTEL_PROXIM
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/usb_ops_linux.c b/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/usb_ops_linux.c
old mode 100644
new mode 100755
index acb58ef..f54cfb4
--- a/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/usb_ops_linux.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/usb_ops_linux.c
@@ -55,7 +55,7 @@ static int _usbctrl_vendorreq_async_write(struct usb_device *udev, u8 request,
 		pipe = usb_sndctrlpipe(udev, 0);//write_out
 		reqtype =  REALTEK_USB_VENQT_WRITE;
 	}
-
+	
 	buf = (struct rtl819x_async_write_data *)rtw_zmalloc(sizeof(*buf));
 	if (!buf) {
 		rc = -ENOMEM;
@@ -153,7 +153,7 @@ int usb_async_write32(struct intf_hdl *pintfhdl, u32 addr, u32 val)
 	data = val;
 	ret = usb_write_async(udev, addr, &data, 4);
 	_func_exit_;
-
+	
 	return ret;
 }
 #endif /* CONFIG_USB_SUPPORT_ASYNC_VDN_REQ */
@@ -163,17 +163,17 @@ unsigned int ffaddr2pipehdl(struct dvobj_priv *pdvobj, u32 addr)
 	unsigned int pipe=0;
 	int ep_num=0;
 	_adapter *padapter = pdvobj->if1;
-	struct usb_device *pusbd = pdvobj->pusbdev;
+	struct usb_device *pusbd = pdvobj->pusbdev;	
 	HAL_DATA_TYPE *pHalData = GET_HAL_DATA(padapter);
 
-	if (addr == RECV_BULK_IN_ADDR) {
+	if (addr == RECV_BULK_IN_ADDR) {	
 		pipe=usb_rcvbulkpipe(pusbd, pHalData->RtBulkInPipe);
-
-	} else if (addr == RECV_INT_IN_ADDR) {
+		
+	} else if (addr == RECV_INT_IN_ADDR) {	
 		pipe=usb_rcvbulkpipe(pusbd, pHalData->RtIntInPipe);
-
+		
 	} else if (addr < HW_QUEUE_ENTRY) {
-		ep_num = pHalData->Queue2EPNum[addr];
+		ep_num = pHalData->Queue2EPNum[addr];	
 		pipe = usb_sndbulkpipe(pusbd, ep_num);
 	}
 
@@ -188,102 +188,102 @@ struct zero_bulkout_context{
 };
 
 static void usb_bulkout_zero_complete(struct urb *purb, struct pt_regs *regs)
-{
+{	
 	struct zero_bulkout_context *pcontext = (struct zero_bulkout_context *)purb->context;
 
 	//DBG_8192C("+usb_bulkout_zero_complete\n");
-
+	
 	if(pcontext)
 	{
 		if(pcontext->pbuf)
-		{
-			rtw_mfree(pcontext->pbuf, sizeof(int));
-		}
+		{			
+			rtw_mfree(pcontext->pbuf, sizeof(int));	
+		}	
 
 		if(pcontext->purb && (pcontext->purb==purb))
 		{
 			usb_free_urb(pcontext->purb);
 		}
 
-
-		rtw_mfree((u8*)pcontext, sizeof(struct zero_bulkout_context));
-	}
-
+	
+		rtw_mfree((u8*)pcontext, sizeof(struct zero_bulkout_context));	
+	}	
+	
 
 }
 
 static u32 usb_bulkout_zero(struct intf_hdl *pintfhdl, u32 addr)
-{
+{	
 	int pipe, status, len;
 	u32 ret;
 	unsigned char *pbuf;
 	struct zero_bulkout_context *pcontext;
-	PURB	purb = NULL;
+	PURB	purb = NULL;	
 	_adapter *padapter = (_adapter *)pintfhdl->padapter;
-	struct dvobj_priv *pdvobj = adapter_to_dvobj(padapter);
+	struct dvobj_priv *pdvobj = adapter_to_dvobj(padapter);	
 	struct usb_device *pusbd = pdvobj->pusbdev;
 
 	//DBG_871X("%s\n", __func__);
-
-
+	
+		
 	if((padapter->bDriverStopped) || (padapter->bSurpriseRemoved) ||(padapter->pwrctrlpriv.pnp_bstop_trx))
-	{
+	{		
 		return _FAIL;
 	}
-
+	
 
 	pcontext = (struct zero_bulkout_context *)rtw_zmalloc(sizeof(struct zero_bulkout_context));
 
-	pbuf = (unsigned char *)rtw_zmalloc(sizeof(int));
-	purb = usb_alloc_urb(0, GFP_ATOMIC);
-
+	pbuf = (unsigned char *)rtw_zmalloc(sizeof(int));	
+    	purb = usb_alloc_urb(0, GFP_ATOMIC);
+      	
 	len = 0;
 	pcontext->pbuf = pbuf;
 	pcontext->purb = purb;
 	pcontext->pirp = NULL;
 	pcontext->padapter = padapter;
 
-
+	
 	//translate DMA FIFO addr to pipehandle
-	//pipe = ffaddr2pipehdl(pdvobj, addr);
+	//pipe = ffaddr2pipehdl(pdvobj, addr);	
 
-	usb_fill_bulk_urb(purb, pusbd, pipe,
-				pbuf,
-				len,
-				usb_bulkout_zero_complete,
-				pcontext);//context is pcontext
+	usb_fill_bulk_urb(purb, pusbd, pipe, 
+       				pbuf,
+              			len,
+              			usb_bulkout_zero_complete,
+              			pcontext);//context is pcontext
 
 	status = usb_submit_urb(purb, GFP_ATOMIC);
 
 	if (!status)
-	{
+	{		
 		ret= _SUCCESS;
 	}
 	else
 	{
 		ret= _FAIL;
 	}
-
-
+	
+	
 	return _SUCCESS;
 
 }
 
 void usb_read_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
 {
-
+	
 }
 
 void usb_write_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
 {
-
+	
 }
 
 
 void usb_read_port_cancel(struct intf_hdl *pintfhdl)
 {
-	int i;
-	struct recv_buf *precvbuf;
+	int i;	
+	struct recv_buf *precvbuf;	
 	_adapter	*padapter = pintfhdl->padapter;
 	precvbuf = (struct recv_buf *)padapter->recvpriv.precv_buf;
 
@@ -292,12 +292,12 @@ void usb_read_port_cancel(struct intf_hdl *pintfhdl)
 	padapter->bReadPortCancel = _TRUE;
 
 	for (i=0; i < NR_RECVBUFF ; i++) {
-
-		precvbuf->reuse = _TRUE;
+		
+		precvbuf->reuse = _TRUE;	
 		if (precvbuf->purb)	 {
 			//DBG_8192C("usb_read_port_cancel : usb_kill_urb \n");
 			usb_kill_urb(precvbuf->purb);
-		}
+		}		
 		precvbuf++;
 	}
 
@@ -314,43 +314,43 @@ static void usb_write_port_complete(struct urb *purb, struct pt_regs *regs)
 	//struct xmit_frame *pxmitframe = (struct xmit_frame *)pxmitbuf->priv_data;
 	//_adapter			*padapter = pxmitframe->padapter;
 	_adapter	*padapter = pxmitbuf->padapter;
-       struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
+       struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;		
 	//struct pkt_attrib *pattrib = &pxmitframe->attrib;
-
+	   
 _func_enter_;
 
 	switch(pxmitbuf->flags)
 	{
 		case VO_QUEUE_INX:
-			pxmitpriv->voq_cnt--;
+			pxmitpriv->voq_cnt--;			
 			break;
 		case VI_QUEUE_INX:
-			pxmitpriv->viq_cnt--;
+			pxmitpriv->viq_cnt--;		
 			break;
 		case BE_QUEUE_INX:
-			pxmitpriv->beq_cnt--;
+			pxmitpriv->beq_cnt--;			
 			break;
 		case BK_QUEUE_INX:
-			pxmitpriv->bkq_cnt--;
+			pxmitpriv->bkq_cnt--;			
 			break;
 		case HIGH_QUEUE_INX:
-#ifdef CONFIG_AP_MODE
+#ifdef CONFIG_AP_MODE			
 			rtw_chk_hi_queue_cmd(padapter);
 #endif
 			break;
-		default:
+		default:			
 			break;
 	}
-
+		
 
 /*
 	_enter_critical(&pxmitpriv->lock, &irqL);
 
 	pxmitpriv->txirp_cnt--;
-
-	switch(pattrib->priority)
+	
+	switch(pattrib->priority) 
 	{
-		case 1:
+		case 1:				
 		case 2:
 			pxmitpriv->bkq_cnt--;
 			//DBG_8192C("pxmitpriv->bkq_cnt=%d\n", pxmitpriv->bkq_cnt);
@@ -366,43 +366,43 @@ static void usb_write_port_complete(struct urb *purb, struct pt_regs *regs)
 			//DBG_8192C("pxmitpriv->voq_cnt=%d\n", pxmitpriv->voq_cnt);
 			break;
 		case 0:
-		case 3:
+		case 3:			
 		default:
 			pxmitpriv->beq_cnt--;
 			//DBG_8192C("pxmitpriv->beq_cnt=%d\n", pxmitpriv->beq_cnt);
 			break;
-
-	}
-
+			
+	}	
+	
 	_exit_critical(&pxmitpriv->lock, &irqL);
-
-
+	
+	
 	if(pxmitpriv->txirp_cnt==0)
 	{
-		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete: txirp_cnt== 0, set allrxreturnevt!\n"));
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete: txirp_cnt== 0, set allrxreturnevt!\n"));		
 		_rtw_up_sema(&(pxmitpriv->tx_retevt));
 	}
 */
         //rtw_free_xmitframe(pxmitpriv, pxmitframe);
-
+	
 	if(padapter->bSurpriseRemoved || padapter->bDriverStopped ||padapter->bWritePortCancel)
 	{
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete:bDriverStopped(%d) OR bSurpriseRemoved(%d)", padapter->bDriverStopped, padapter->bSurpriseRemoved));
-		DBG_8192C("%s(): TX Warning! bDriverStopped(%d) OR bSurpriseRemoved(%d) bWritePortCancel(%d) pxmitbuf->ext_tag(%x) \n",
-		__FUNCTION__,padapter->bDriverStopped, padapter->bSurpriseRemoved,padapter->bReadPortCancel,pxmitbuf->ext_tag);
+		DBG_8192C("%s(): TX Warning! bDriverStopped(%d) OR bSurpriseRemoved(%d) bWritePortCancel(%d) pxmitbuf->ext_tag(%x) \n", 
+		__FUNCTION__,padapter->bDriverStopped, padapter->bSurpriseRemoved,padapter->bReadPortCancel,pxmitbuf->ext_tag);	
 
 		goto check_completion;
 	}
 
 
 	if (purb->status==0) {
-
+	
 	} else {
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete : purb->status(%d) != 0 \n", purb->status));
 		DBG_871X("###=> urb_write_port_complete status(%d)\n",purb->status);
 		if((purb->status==-EPIPE)||(purb->status==-EPROTO))
 		{
-			//usb_clear_halt(pusbdev, purb->pipe);
+			//usb_clear_halt(pusbdev, purb->pipe);	
 			//msleep(10);
 			sreset_set_wifi_error_status(padapter, USB_WRITE_PORT_FAIL);
 		} else if (purb->status == -EINPROGRESS) {
@@ -412,7 +412,7 @@ static void usb_write_port_complete(struct urb *purb, struct pt_regs *regs)
 		} else if (purb->status == -ENOENT) {
 			DBG_871X("%s: -ENOENT\n", __func__);
 			goto check_completion;
-
+			
 		} else if (purb->status == -ECONNRESET) {
 			DBG_871X("%s: -ECONNRESET\n", __func__);
 			goto check_completion;
@@ -425,7 +425,7 @@ static void usb_write_port_complete(struct urb *purb, struct pt_regs *regs)
 			goto check_completion;
 		}
 		else
-		{
+		{					
 			padapter->bSurpriseRemoved=_TRUE;
 			DBG_8192C("bSurpriseRemoved=TRUE\n");
 			//rtl8192cu_trigger_gpio_0(padapter);
@@ -436,9 +436,9 @@ static void usb_write_port_complete(struct urb *purb, struct pt_regs *regs)
 	}
 
 	#ifdef DBG_CONFIG_ERROR_DETECT
-	{
+	{	
 		HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
-		pHalData->srestpriv.last_tx_complete_time = rtw_get_current_time();
+		pHalData->srestpriv.last_tx_complete_time = rtw_get_current_time();		
 	}
 	#endif
 
@@ -450,34 +450,34 @@ static void usb_write_port_complete(struct urb *purb, struct pt_regs *regs)
 
 	rtw_free_xmitbuf(pxmitpriv, pxmitbuf);
 
-	//if(rtw_txframes_pending(padapter))
+	//if(rtw_txframes_pending(padapter))	
 	{
 		tasklet_hi_schedule(&pxmitpriv->xmit_tasklet);
 	}
-
-_func_exit_;
+	
+_func_exit_;	
 
 }
 
 u32 usb_write_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
-{
+{    
 	_irqL irqL;
 	unsigned int pipe;
 	int status;
 	u32 ret = _FAIL, bwritezero = _FALSE;
 	PURB	purb = NULL;
 	_adapter *padapter = (_adapter *)pintfhdl->padapter;
-	struct dvobj_priv	*pdvobj = adapter_to_dvobj(padapter);
+	struct dvobj_priv	*pdvobj = adapter_to_dvobj(padapter);	
 	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
 	struct xmit_buf *pxmitbuf = (struct xmit_buf *)wmem;
 	struct xmit_frame *pxmitframe = (struct xmit_frame *)pxmitbuf->priv_data;
 	struct usb_device *pusbd = pdvobj->pusbdev;
 	struct pkt_attrib *pattrib = &pxmitframe->attrib;
-
-_func_enter_;
-
+	
+_func_enter_;	
+	
 	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("+usb_write_port\n"));
-
+	
 	if ((padapter->bDriverStopped) || (padapter->bSurpriseRemoved) ||(padapter->pwrctrlpriv.pnp_bstop_trx)) {
 		#ifdef DBG_TX
 		DBG_871X(" DBG_TX %s:%d bDriverStopped%d, bSurpriseRemoved:%d, pnp_bstop_trx:%d\n",__FUNCTION__, __LINE__
@@ -487,7 +487,7 @@ u32 usb_write_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
 		rtw_sctx_done_err(&pxmitbuf->sctx, RTW_SCTX_DONE_TX_DENY);
 		goto exit;
 	}
-
+	
 	_enter_critical(&pxmitpriv->lock, &irqL);
 
 	switch(addr)
@@ -515,9 +515,9 @@ u32 usb_write_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
 			pxmitbuf->flags = MGT_QUEUE_INX;
 			break;
 	}
-
+		
 	_exit_critical(&pxmitpriv->lock, &irqL);
-
+		
 	purb	= pxmitbuf->pxmit_urb[0];
 
 #if 0
@@ -526,23 +526,23 @@ u32 usb_write_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
 		if(cnt> 0 && cnt%512 == 0)
 		{
 			//DBG_8192C("ishighspeed, cnt=%d\n", cnt);
-			bwritezero = _TRUE;
-		}
+			bwritezero = _TRUE;			
+		}	
 	}
 	else
 	{
 		if(cnt > 0 && cnt%64 == 0)
 		{
 			//DBG_8192C("cnt=%d\n", cnt);
-			bwritezero = _TRUE;
-		}
+			bwritezero = _TRUE;			
+		}	
 	}
 #endif
 
 	//translate DMA FIFO addr to pipehandle
-	pipe = ffaddr2pipehdl(pdvobj, addr);
+	pipe = ffaddr2pipehdl(pdvobj, addr);	
 
-#ifdef CONFIG_REDUCE_USB_TX_INT
+#ifdef CONFIG_REDUCE_USB_TX_INT	
 	if ( (pxmitpriv->free_xmitbuf_cnt%NR_XMITBUFF == 0)
 		|| (pxmitbuf->ext_tag == _TRUE) )
 	{
@@ -554,38 +554,38 @@ u32 usb_write_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
 #endif
 
 
-	usb_fill_bulk_urb(purb, pusbd, pipe,
-				pxmitframe->buf_addr, //= pxmitbuf->pbuf
-				cnt,
-				usb_write_port_complete,
-				pxmitbuf);//context is pxmitbuf
-
+	usb_fill_bulk_urb(purb, pusbd, pipe, 
+       				pxmitframe->buf_addr, //= pxmitbuf->pbuf
+              			cnt,
+              			usb_write_port_complete,
+              			pxmitbuf);//context is pxmitbuf
+              			
 #ifdef CONFIG_USE_USB_BUFFER_ALLOC_TX
 	purb->transfer_dma = pxmitbuf->dma_transfer_addr;
 	purb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
 	purb->transfer_flags |= URB_ZERO_PACKET;
 #endif	// CONFIG_USE_USB_BUFFER_ALLOC_TX
-
+              			
 #if 0
 	if (bwritezero)
         {
-            purb->transfer_flags |= URB_ZERO_PACKET;
-        }
+            purb->transfer_flags |= URB_ZERO_PACKET;           
+        }			
 #endif
 
 	status = usb_submit_urb(purb, GFP_ATOMIC);
 	if (!status) {
-		#ifdef DBG_CONFIG_ERROR_DETECT
-		{
+		#ifdef DBG_CONFIG_ERROR_DETECT	
+		{	
 			HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
-			pHalData->srestpriv.last_tx_time = rtw_get_current_time();
+			pHalData->srestpriv.last_tx_time = rtw_get_current_time();		
 		}
 		#endif
 	} else {
 		rtw_sctx_done_err(&pxmitbuf->sctx, RTW_SCTX_DONE_WRITE_PORT_ERR);
 		DBG_871X("usb_write_port, status=%d\n", status);
 		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port(): usb_submit_urb, status=%x\n", status));
-
+		
 		switch (status) {
 		case -ENODEV:
 			padapter->bDriverStopped=_TRUE;
@@ -600,7 +600,7 @@ u32 usb_write_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
 
 //   Commented by Albert 2009/10/13
 //   We add the URB_ZERO_PACKET flag to urb so that the host will send the zero packet automatically.
-/*
+/*	
 	if(bwritezero == _TRUE)
 	{
 		usb_bulkout_zero(pintfhdl, addr);
@@ -624,9 +624,9 @@ void usb_write_port_cancel(struct intf_hdl *pintfhdl)
 	struct xmit_buf *pxmitbuf = (struct xmit_buf *)padapter->xmitpriv.pxmitbuf;
 
 	DBG_871X("%s \n", __func__);
-
-	padapter->bWritePortCancel = _TRUE;
-
+	
+	padapter->bWritePortCancel = _TRUE;	
+	
 	for (i=0; i<NR_XMITBUFF; i++) {
 		for (j=0; j<8; j++) {
 			if (pxmitbuf->pxmit_urb[j]) {
@@ -635,9 +635,9 @@ void usb_write_port_cancel(struct intf_hdl *pintfhdl)
 		}
 		pxmitbuf++;
 	}
-
+	
 	pxmitbuf = (struct xmit_buf*)padapter->xmitpriv.pxmit_extbuf;
-	for (i = 0; i < NR_XMIT_EXTBUFF; i++) {
+	for (i = 0; i < NR_XMIT_EXTBUFF; i++) {	
 		for (j=0; j<8; j++) {
 			if(pxmitbuf->pxmit_urb[j]) {
 				usb_kill_urb(pxmitbuf->pxmit_urb[j]);
@@ -646,3 +646,4 @@ void usb_write_port_cancel(struct intf_hdl *pintfhdl)
 		pxmitbuf++;
 	}
 }
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/xmit_linux.c b/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/xmit_linux.c
old mode 100644
new mode 100755
index 13dc446..9105e29
--- a/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/xmit_linux.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/os_dep/linux/xmit_linux.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -47,28 +47,28 @@ void _rtw_open_pktfile (_pkt *pktptr, struct pkt_file *pfile)
 	pfile->pkt_len = pfile->buf_len = pktptr->len;
 
 	pfile->cur_buffer = pfile->buf_start ;
-
+	
 _func_exit_;
 }
 
 uint _rtw_pktfile_read (struct pkt_file *pfile, u8 *rmem, uint rlen)
-{
+{	
 	uint	len = 0;
-
+	
 _func_enter_;
 
        len =  rtw_remainder_len(pfile);
-	len = (rlen > len)? len: rlen;
+      	len = (rlen > len)? len: rlen;
 
        if(rmem)
 	  skb_copy_bits(pfile->pkt, pfile->buf_len-pfile->pkt_len, rmem, len);
 
        pfile->cur_addr += len;
        pfile->pkt_len -= len;
+	   
+_func_exit_;	       		
 
-_func_exit_;
-
-	return len;
+	return len;	
 }
 
 sint rtw_endofpktfile(struct pkt_file *pfile)
@@ -91,10 +91,10 @@ void rtw_set_tx_chksum_offload(_pkt *pkt, struct pkt_attrib *pattrib)
 #ifdef CONFIG_TCP_CSUM_OFFLOAD_TX
 	struct sk_buff *skb = (struct sk_buff *)pkt;
 	pattrib->hw_tcp_csum = 0;
-
+	
 	if (skb->ip_summed == CHECKSUM_PARTIAL) {
 		if (skb_shinfo(skb)->nr_frags == 0)
-		{
+		{	
                         const struct iphdr *ip = ip_hdr(skb);
                         if (ip->protocol == IPPROTO_TCP) {
                                 // TCP checksum offload by HW
@@ -103,7 +103,7 @@ void rtw_set_tx_chksum_offload(_pkt *pkt, struct pkt_attrib *pattrib)
                                 //skb_checksum_help(skb);
                         } else if (ip->protocol == IPPROTO_UDP) {
                                 //DBG_871X("CHECKSUM_PARTIAL UDP\n");
-#if 1
+#if 1                       
                                 skb_checksum_help(skb);
 #else
                                 // Set UDP checksum = 0 to skip checksum check
@@ -117,11 +117,11 @@ void rtw_set_tx_chksum_offload(_pkt *pkt, struct pkt_attrib *pattrib)
 		}
 		else { // IP fragmentation case
 			DBG_871X("%s-%d nr_frags != 0, using skb_checksum_help(skb);!!\n", __FUNCTION__, __LINE__);
-			skb_checksum_help(skb);
-		}
+                	skb_checksum_help(skb);
+		}		
 	}
-#endif
-
+#endif	
+	
 }
 
 int rtw_os_xmit_resource_alloc(_adapter *padapter, struct xmit_buf *pxmitbuf,u32 alloc_sz)
@@ -137,7 +137,7 @@ int rtw_os_xmit_resource_alloc(_adapter *padapter, struct xmit_buf *pxmitbuf,u32
 	if(pxmitbuf->pallocated_buf == NULL)
 		return _FAIL;
 #else // CONFIG_USE_USB_BUFFER_ALLOC_TX
-
+	
 	pxmitbuf->pallocated_buf = rtw_zmalloc(alloc_sz);
 	if (pxmitbuf->pallocated_buf == NULL)
 	{
@@ -150,15 +150,15 @@ int rtw_os_xmit_resource_alloc(_adapter *padapter, struct xmit_buf *pxmitbuf,u32
 #endif // CONFIG_USE_USB_BUFFER_ALLOC_TX
 
 	for(i=0; i<8; i++)
-	{
-		pxmitbuf->pxmit_urb[i] = usb_alloc_urb(0, GFP_KERNEL);
-		if(pxmitbuf->pxmit_urb[i] == NULL)
-		{
-			DBG_871X("pxmitbuf->pxmit_urb[i]==NULL");
-			return _FAIL;
-		}
-
-	}
+      	{
+      		pxmitbuf->pxmit_urb[i] = usb_alloc_urb(0, GFP_KERNEL);
+             	if(pxmitbuf->pxmit_urb[i] == NULL) 
+             	{
+             		DBG_871X("pxmitbuf->pxmit_urb[i]==NULL");
+	        	return _FAIL;	 
+             	}      		  	
+	
+      	}
 #endif
 #if defined(CONFIG_PCI_HCI) || defined(CONFIG_SDIO_HCI)
 	pxmitbuf->pallocated_buf = rtw_zmalloc(alloc_sz);
@@ -170,7 +170,7 @@ int rtw_os_xmit_resource_alloc(_adapter *padapter, struct xmit_buf *pxmitbuf,u32
 	pxmitbuf->pbuf = (u8 *)N_BYTE_ALIGMENT((SIZE_PTR)(pxmitbuf->pallocated_buf), XMITBUF_ALIGN_SZ);
 #endif
 
-	return _SUCCESS;
+	return _SUCCESS;	
 }
 
 void rtw_os_xmit_resource_free(_adapter *padapter, struct xmit_buf *pxmitbuf,u32 free_sz)
@@ -239,7 +239,7 @@ void rtw_os_xmit_schedule(_adapter *padapter)
 #ifdef CONFIG_SDIO_HCI
 	if(!padapter)
 		return;
-
+	
 	if (rtw_txframes_pending(padapter))
 		_rtw_up_sema(&padapter->xmitpriv.xmit_sema);
 #else
@@ -253,7 +253,7 @@ void rtw_os_xmit_schedule(_adapter *padapter)
 
 	_enter_critical_bh(&pxmitpriv->lock, &irqL);
 
-	if(rtw_txframes_pending(padapter))
+	if(rtw_txframes_pending(padapter))	
 	{
 		tasklet_hi_schedule(&pxmitpriv->xmit_tasklet);
 	}
@@ -284,7 +284,7 @@ int rtw_mlcst2unicst(_adapter *padapter, struct sk_buff *skb)
 	_enter_critical_bh(&pstapriv->asoc_list_lock, &irqL);
 	phead = &pstapriv->asoc_list;
 	plist = get_next(phead);
-
+	
 	//free sta asoc_queue
 	while ((rtw_end_of_queue_search(phead, plist)) == _FALSE) {
 		int stainfo_offset;
@@ -301,7 +301,7 @@ int rtw_mlcst2unicst(_adapter *padapter, struct sk_buff *skb)
 	for (i = 0; i < chk_alive_num; i++) {
 		psta = rtw_get_stainfo_by_offset(pstapriv, chk_alive_list[i]);
 
-		/* avoid come from STA1 and send back STA1 */
+		/* avoid come from STA1 and send back STA1 */ 
 		if (_rtw_memcmp(psta->hwaddr, &skb->data[6], 6) == _TRUE
 			|| _rtw_memcmp(psta->hwaddr, null_addr, 6) == _TRUE
 			|| _rtw_memcmp(psta->hwaddr, bc_addr, 6) == _TRUE
@@ -340,7 +340,7 @@ int _rtw_xmit_entry(_pkt *pkt, _nic_hdl pnetdev)
 #ifdef CONFIG_TX_MCAST2UNI
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 	extern int rtw_mc2u_disable;
-#endif	// CONFIG_TX_MCAST2UNI
+#endif	// CONFIG_TX_MCAST2UNI	
 	s32 res = 0;
 #if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
 	u16 queue;
@@ -385,8 +385,8 @@ int _rtw_xmit_entry(_pkt *pkt, _nic_hdl pnetdev)
 			//DBG_871X("Stop M2U(%d, %d)! ", pxmitpriv->free_xmitframe_cnt, pxmitpriv->free_xmitbuf_cnt);
 			//DBG_871X("!m2u );
 		}
-	}
-#endif	// CONFIG_TX_MCAST2UNI
+	}	
+#endif	// CONFIG_TX_MCAST2UNI	
 
 	res = rtw_xmit(padapter, &pkt);
 	if (res < 0) {
@@ -418,3 +418,4 @@ int rtw_xmit_entry(_pkt *pkt, _nic_hdl pnetdev)
 		rtw_mstat_update(MSTAT_TYPE_SKB, MSTAT_ALLOC_SUCCESS, pkt->truesize);
 	return _rtw_xmit_entry(pkt, pnetdev);
 }
+
diff --git a/drivers/net/wireless/realtek/rtl8192cu/os_dep/osdep_service.c b/drivers/net/wireless/realtek/rtl8192cu/os_dep/osdep_service.c
old mode 100644
new mode 100755
index 4b113e9..e73a068
--- a/drivers/net/wireless/realtek/rtl8192cu/os_dep/osdep_service.c
+++ b/drivers/net/wireless/realtek/rtl8192cu/os_dep/osdep_service.c
@@ -1,7 +1,7 @@
 /******************************************************************************
  *
  * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
+ *                                        
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
  * published by the Free Software Foundation.
@@ -80,31 +80,31 @@ u32 rtw_atoi(u8* s)
 	{
 	  if(s[i] >= '0' && s[i] <= '9')
 		 num = num * 10 + s[i] -'0';
-	  else if(s[0] == '-' && i==0)
+	  else if(s[0] == '-' && i==0) 
 		 flag =1;
-	  else
+	  else 
 		  break;
 	 }
 
 	if(flag == 1)
 	   num = num * -1;
 
-	 return(num);
+	 return(num); 
 
 }
 
 inline u8* _rtw_vmalloc(u32 sz)
 {
 	u8 	*pbuf;
-#ifdef PLATFORM_LINUX
+#ifdef PLATFORM_LINUX	
 	pbuf = vmalloc(sz);
-#endif
+#endif	
 #ifdef PLATFORM_FREEBSD
-	pbuf = malloc(sz,M_DEVBUF,M_NOWAIT);
-#endif
-
+	pbuf = malloc(sz,M_DEVBUF,M_NOWAIT);	
+#endif	
+	
 #ifdef PLATFORM_WINDOWS
-	NdisAllocateMemoryWithTag(&pbuf,sz, RT_TAG);
+	NdisAllocateMemoryWithTag(&pbuf,sz, RT_TAG);	
 #endif
 
 #ifdef DBG_MEMORY_LEAK
@@ -116,7 +116,7 @@ inline u8* _rtw_vmalloc(u32 sz)
 #endif
 #endif /* DBG_MEMORY_LEAK */
 
-	return pbuf;
+	return pbuf;	
 }
 
 inline u8* _rtw_zvmalloc(u32 sz)
@@ -126,27 +126,27 @@ inline u8* _rtw_zvmalloc(u32 sz)
 	pbuf = _rtw_vmalloc(sz);
 	if (pbuf != NULL)
 		memset(pbuf, 0, sz);
-#endif
+#endif	
 #ifdef PLATFORM_FREEBSD
-	pbuf = malloc(sz,M_DEVBUF,M_ZERO|M_NOWAIT);
-#endif
+	pbuf = malloc(sz,M_DEVBUF,M_ZERO|M_NOWAIT);	
+#endif	
 #ifdef PLATFORM_WINDOWS
 	NdisAllocateMemoryWithTag(&pbuf,sz, RT_TAG);
 	if (pbuf != NULL)
 		NdisFillMemory(pbuf, sz, 0);
 #endif
 
-	return pbuf;
+	return pbuf;	
 }
 
 inline void _rtw_vmfree(u8 *pbuf, u32 sz)
 {
 #ifdef	PLATFORM_LINUX
 	vfree(pbuf);
-#endif
+#endif	
 #ifdef PLATFORM_FREEBSD
-	free(pbuf,M_DEVBUF);
-#endif
+	free(pbuf,M_DEVBUF);	
+#endif	
 #ifdef PLATFORM_WINDOWS
 	NdisFreeMemory(pbuf,sz, 0);
 #endif
@@ -169,13 +169,13 @@ u8* _rtw_malloc(u32 sz)
 	if(sz > 0x4000)
 		pbuf = (u8 *)dvr_malloc(sz);
 	else
-#endif
-		pbuf = kmalloc(sz,in_interrupt() ? GFP_ATOMIC : GFP_KERNEL);
+#endif		
+		pbuf = kmalloc(sz,in_interrupt() ? GFP_ATOMIC : GFP_KERNEL); 		
 
-#endif
+#endif	
 #ifdef PLATFORM_FREEBSD
-	pbuf = malloc(sz,M_DEVBUF,M_NOWAIT);
-#endif
+	pbuf = malloc(sz,M_DEVBUF,M_NOWAIT);	
+#endif		
 #ifdef PLATFORM_WINDOWS
 
 	NdisAllocateMemoryWithTag(&pbuf,sz, RT_TAG);
@@ -191,8 +191,8 @@ u8* _rtw_malloc(u32 sz)
 #endif
 #endif /* DBG_MEMORY_LEAK */
 
-	return pbuf;
-
+	return pbuf;	
+	
 }
 
 
@@ -207,15 +207,15 @@ u8* _rtw_zmalloc(u32 sz)
 
 #ifdef PLATFORM_LINUX
 		memset(pbuf, 0, sz);
-#endif
-
+#endif	
+	
 #ifdef PLATFORM_WINDOWS
 		NdisFillMemory(pbuf, sz, 0);
 #endif
 
 	}
 
-	return pbuf;
+	return pbuf;	
 #endif // PLATFORM_FREEBSD
 }
 
@@ -230,23 +230,23 @@ void	_rtw_mfree(u8 *pbuf, u32 sz)
 #endif
 		kfree(pbuf);
 
-#endif
+#endif	
 #ifdef PLATFORM_FREEBSD
-	free(pbuf,M_DEVBUF);
-#endif
+	free(pbuf,M_DEVBUF);	
+#endif		
 #ifdef PLATFORM_WINDOWS
 
 	NdisFreeMemory(pbuf,sz, 0);
 
 #endif
-
+	
 #ifdef DBG_MEMORY_LEAK
 #ifdef PLATFORM_LINUX
 	atomic_dec(&_malloc_cnt);
 	atomic_sub(sz, &_malloc_size);
 #endif
 #endif /* DBG_MEMORY_LEAK */
-
+	
 }
 
 #ifdef PLATFORM_FREEBSD
@@ -254,8 +254,8 @@ void	_rtw_mfree(u8 *pbuf, u32 sz)
 struct sk_buff * dev_alloc_skb(unsigned int size)
 {
 	struct sk_buff *skb=NULL;
-	u8 *data=NULL;
-
+    	u8 *data=NULL;
+	
 	//skb = (struct sk_buff *)_rtw_zmalloc(sizeof(struct sk_buff)); // for skb->len, etc.
 	skb = (struct sk_buff *)_rtw_malloc(sizeof(struct sk_buff));
 	if(!skb)
@@ -277,7 +277,7 @@ struct sk_buff * dev_alloc_skb(unsigned int size)
 	_rtw_mfree((u8 *)skb, sizeof(struct sk_buff));
 	skb = NULL;
 goto out;
-
+	
 }
 
 void dev_kfree_skb_any(struct sk_buff *skb)
@@ -364,7 +364,7 @@ inline void *_rtw_usb_buffer_alloc(struct usb_device *dev, size_t size, dma_addr
 	return usb_buffer_alloc(dev, size, (in_interrupt() ? GFP_ATOMIC : GFP_KERNEL), dma);
 #endif
 #endif /* PLATFORM_LINUX */
-
+	
 #ifdef PLATFORM_FREEBSD
 	return (malloc(size, M_USBDEV, M_NOWAIT | M_ZERO));
 #endif /* PLATFORM_FREEBSD */
@@ -373,7 +373,7 @@ inline void _rtw_usb_buffer_free(struct usb_device *dev, size_t size, void *addr
 {
 #ifdef PLATFORM_LINUX
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
-	usb_free_coherent(dev, size, addr, dma);
+	usb_free_coherent(dev, size, addr, dma); 
 #else
 	usb_buffer_free(dev, size, addr, dma);
 #endif
@@ -389,7 +389,7 @@ inline void _rtw_usb_buffer_free(struct usb_device *dev, size_t size, void *addr
 
 struct rtw_mem_stat {
 	ATOMIC_T alloc; // the memory bytes we allocate currently
-	ATOMIC_T peak; // the peak memory bytes we allocate
+	ATOMIC_T peak; // the peak memory bytes we allocate 
 	ATOMIC_T alloc_cnt; // the alloc count for alloc currently
 	ATOMIC_T alloc_err_cnt; // the error times we fail to allocate memory
 };
@@ -419,7 +419,7 @@ int _rtw_mstat_dump(char *buf, int len)
 	int i;
 	int value_t[4][mstat_tf_idx(MSTAT_TYPE_MAX)];
 	int value_f[4][mstat_ff_idx(MSTAT_FUNC_MAX)];
-
+	
 	int vir_alloc, vir_peak, vir_alloc_err, phy_alloc, phy_peak, phy_alloc_err;
 	int tx_alloc, tx_peak, tx_alloc_err, rx_alloc, rx_peak, rx_alloc_err;
 
@@ -527,7 +527,7 @@ inline u8* dbg_rtw_vmalloc(u32 sz, const enum mstat_f flags, const char *func, c
 {
 	u8  *p;
 	//DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d)\n", func,  line, __FUNCTION__, (sz));
-
+	
 	p=_rtw_vmalloc((sz));
 
 	rtw_mstat_update(
@@ -535,16 +535,16 @@ inline u8* dbg_rtw_vmalloc(u32 sz, const enum mstat_f flags, const char *func, c
 		, p ? MSTAT_ALLOC_SUCCESS : MSTAT_ALLOC_FAIL
 		, sz
 	);
-
+	
 	return p;
 }
 
 inline u8* dbg_rtw_zvmalloc(u32 sz, const enum mstat_f flags, const char *func, const int line)
 {
 	u8 *p;
-	//DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d)\n", func, line, __FUNCTION__, (sz));
-
-	p=_rtw_zvmalloc((sz));
+	//DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d)\n", func, line, __FUNCTION__, (sz)); 
+	
+	p=_rtw_zvmalloc((sz)); 
 
 	rtw_mstat_update(
 		flags
@@ -558,8 +558,8 @@ inline u8* dbg_rtw_zvmalloc(u32 sz, const enum mstat_f flags, const char *func,
 inline void dbg_rtw_vmfree(u8 *pbuf, u32 sz, const enum mstat_f flags, const char *func, const int line)
 {
 	//DBG_871X("DBG_MEM_ALLOC %s:%d %s(%p,%d)\n",  func, line, __FUNCTION__, (pbuf), (sz));
-
-	_rtw_vmfree((pbuf), (sz));
+	
+	_rtw_vmfree((pbuf), (sz)); 
 
 	rtw_mstat_update(
 		flags
@@ -568,18 +568,18 @@ inline void dbg_rtw_vmfree(u8 *pbuf, u32 sz, const enum mstat_f flags, const cha
 	);
 }
 
-inline u8* dbg_rtw_malloc(u32 sz, const enum mstat_f flags, const char *func, const int line)
+inline u8* dbg_rtw_malloc(u32 sz, const enum mstat_f flags, const char *func, const int line) 
 {
 	u8 *p;
 
-	//if(sz>=153 && sz<=306)
+	//if(sz>=153 && sz<=306) 
 	//	DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d)\n", func, line, __FUNCTION__, (sz));
 
-	//if((sz)>4096)
-	//	DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d)\n", func, line, __FUNCTION__, (sz));
+	//if((sz)>4096) 
+	//	DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d)\n", func, line, __FUNCTION__, (sz)); 
 
 	p=_rtw_malloc((sz));
-
+	
 	rtw_mstat_update(
 		flags
 		, p ? MSTAT_ALLOC_SUCCESS : MSTAT_ALLOC_FAIL
@@ -593,7 +593,7 @@ inline u8* dbg_rtw_zmalloc(u32 sz, const enum mstat_f flags, const char *func, c
 {
 	u8 *p;
 
-	//if(sz>=153 && sz<=306)
+	//if(sz>=153 && sz<=306) 
 	//	DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d)\n", func, line, __FUNCTION__, (sz));
 
 	//if((sz)>4096)
@@ -612,12 +612,12 @@ inline u8* dbg_rtw_zmalloc(u32 sz, const enum mstat_f flags, const char *func, c
 
 inline void dbg_rtw_mfree(u8 *pbuf, u32 sz, const enum mstat_f flags, const char *func, const int line)
 {
-	//if(sz>=153 && sz<=306)
+	//if(sz>=153 && sz<=306) 
 	//	DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d)\n", func, line, __FUNCTION__, (sz));
 
 	//if((sz)>4096)
 	//	DBG_871X("DBG_MEM_ALLOC %s:%d %s(%p,%d)\n", func, line, __FUNCTION__, (pbuf), (sz));
-
+	
 	_rtw_mfree((pbuf), (sz));
 
 	rtw_mstat_update(
@@ -657,7 +657,7 @@ inline void dbg_rtw_skb_free(struct sk_buff *skb, const enum mstat_f flags, cons
 	//	DBG_871X("DBG_MEM_ALLOC %s:%d %s, truesize=%u\n", func, line, __FUNCTION__, truesize);
 
 	_rtw_skb_free(skb);
-
+	
 	rtw_mstat_update(
 		flags
 		, MSTAT_FREE
@@ -670,7 +670,7 @@ inline struct sk_buff *dbg_rtw_skb_copy(const struct sk_buff *skb, const enum ms
 	struct sk_buff *skb_cp;
 	unsigned int truesize = skb->truesize;
 	unsigned int cp_truesize = 0;
-
+	
 	skb_cp = _rtw_skb_copy(skb);
 	if(skb_cp)
 		cp_truesize = skb_cp->truesize;
@@ -718,7 +718,7 @@ inline int dbg_rtw_netif_rx(_nic_hdl ndev, struct sk_buff *skb, const enum mstat
 	//	DBG_871X("DBG_MEM_ALLOC %s:%d %s, truesize=%u\n", func, line, __FUNCTION__, truesize);
 
 	ret = _rtw_netif_rx(ndev, skb);
-
+	
 	rtw_mstat_update(
 		flags
 		, MSTAT_FREE
@@ -741,9 +741,9 @@ inline void *dbg_rtw_usb_buffer_alloc(struct usb_device *dev, size_t size, dma_a
 {
 	void *p;
 	//DBG_871X("DBG_MEM_ALLOC %s:%d %s(%d)\n", func, line, __FUNCTION__, size);
-
+	
 	p = _rtw_usb_buffer_alloc(dev, size, dma);
-
+	
 	rtw_mstat_update(
 		flags
 		, p ? MSTAT_ALLOC_SUCCESS : MSTAT_ALLOC_FAIL
@@ -790,14 +790,14 @@ void rtw_mfree2d(void *pbuf, int h, int w, int size)
 	rtw_mfree((u8 *)pbuf, h*sizeof(void*) + w*h*size);
 }
 
-void _rtw_memcpy(void* dst, const void* src, u32 sz)
+void _rtw_memcpy(void* dst, void* src, u32 sz)
 {
 
 #if defined (PLATFORM_LINUX)|| defined (PLATFORM_FREEBSD)
 
 	memcpy(dst, src, sz);
 
-#endif
+#endif	
 
 #ifdef PLATFORM_WINDOWS
 
@@ -807,7 +807,7 @@ void _rtw_memcpy(void* dst, const void* src, u32 sz)
 
 }
 
-int	_rtw_memcmp(const void *dst, const void *src, u32 sz)
+int	_rtw_memcmp(void *dst, void *src, u32 sz)
 {
 
 #if defined (PLATFORM_LINUX)|| defined (PLATFORM_FREEBSD)
@@ -822,16 +822,16 @@ int	_rtw_memcmp(const void *dst, const void *src, u32 sz)
 
 #ifdef PLATFORM_WINDOWS
 //under Windows, the return value of NdisEqualMemory for two same mem. chunk is 1
-
+	
 	if (NdisEqualMemory (dst, src, sz))
 		return _TRUE;
 	else
 		return _FALSE;
 
-#endif
-
-
-
+#endif	
+	
+	
+	
 }
 
 void _rtw_memset(void *pbuf, int c, u32 sz)
@@ -887,7 +887,7 @@ void _rtw_init_listhead(_list *list)
 
 
 /*
-For the following list_xxx operations,
+For the following list_xxx operations, 
 caller must guarantee the atomic context.
 Otherwise, there will be racing condition.
 */
@@ -921,7 +921,7 @@ u32	rtw_is_list_empty(_list *phead)
 
 #endif
 
-
+	
 }
 
 void rtw_list_insert_head(_list *plist, _list *phead)
@@ -943,22 +943,22 @@ void rtw_list_insert_head(_list *plist, _list *phead)
 void rtw_list_insert_tail(_list *plist, _list *phead)
 {
 
-#ifdef PLATFORM_LINUX
-
+#ifdef PLATFORM_LINUX	
+	
 	list_add_tail(plist, phead);
-
+	
 #endif
 #ifdef PLATFORM_FREEBSD
-
+	
 	__list_add(plist, phead->prev, phead);
-
-#endif
+	
+#endif	
 #ifdef PLATFORM_WINDOWS
 
   InsertTailList(phead, plist);
 
-#endif
-
+#endif		
+	
 }
 
 
@@ -985,7 +985,7 @@ void _rtw_init_sema(_sema	*sema, int init_val)
 	KeInitializeSemaphore(sema, init_val,  SEMA_UPBND); // count=0;
 
 #endif
-
+	
 #ifdef PLATFORM_OS_CE
 	if(*sema == NULL)
 		*sema = CreateSemaphore(NULL, init_val, SEMA_UPBND, NULL);
@@ -1011,7 +1011,7 @@ void _rtw_up_sema(_sema	*sema)
 
 	up(sema);
 
-#endif
+#endif	
 #ifdef PLATFORM_FREEBSD
 	sema_post(sema);
 #endif
@@ -1030,13 +1030,13 @@ u32 _rtw_down_sema(_sema *sema)
 {
 
 #ifdef PLATFORM_LINUX
-
+	
 	if (down_interruptible(sema))
 		return _FAIL;
 	else
 		return _SUCCESS;
 
-#endif
+#endif    	
 #ifdef PLATFORM_FREEBSD
 	sema_wait(sema);
 	return  _SUCCESS;
@@ -1051,7 +1051,7 @@ u32 _rtw_down_sema(_sema *sema)
 
 #ifdef PLATFORM_OS_CE
 	if(WAIT_OBJECT_0 == WaitForSingleObject(*sema, INFINITE ))
-		return _SUCCESS;
+		return _SUCCESS; 
 	else
 		return _FAIL;
 #endif
@@ -1091,7 +1091,7 @@ void	_rtw_mutex_free(_mutex *pmutex)
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
 	mutex_destroy(pmutex);
-#else
+#else	
 #endif
 
 #ifdef PLATFORM_FREEBSD
@@ -1116,7 +1116,7 @@ void	_rtw_spinlock_init(_lock *plock)
 
 	spin_lock_init(plock);
 
-#endif
+#endif	
 #ifdef PLATFORM_FREEBSD
 		mtx_init(plock, "", NULL, MTX_DEF|MTX_RECURSE);
 #endif
@@ -1125,7 +1125,7 @@ void	_rtw_spinlock_init(_lock *plock)
 	NdisAllocateSpinLock(plock);
 
 #endif
-
+	
 }
 
 void	_rtw_spinlock_free(_lock *plock)
@@ -1133,13 +1133,13 @@ void	_rtw_spinlock_free(_lock *plock)
 #ifdef PLATFORM_FREEBSD
 	 mtx_destroy(plock);
 #endif
-
+	
 #ifdef PLATFORM_WINDOWS
 
 	NdisFreeSpinLock(plock);
 
 #endif
-
+	
 }
 #ifdef PLATFORM_FREEBSD
 extern PADAPTER prtw_lock;
@@ -1159,7 +1159,7 @@ void rtw_mtx_unlock(_lock *plock){
 	else{
 		printf("%s prtw_lock==NULL",__FUNCTION__);
 	}
-
+	
 }
 #endif //PLATFORM_FREEBSD
 
@@ -1180,7 +1180,7 @@ void	_rtw_spinlock(_lock	*plock)
 	NdisAcquireSpinLock(plock);
 
 #endif
-
+	
 }
 
 void	_rtw_spinunlock(_lock *plock)
@@ -1193,7 +1193,7 @@ void	_rtw_spinunlock(_lock *plock)
 #endif
 #ifdef PLATFORM_FREEBSD
 	mtx_unlock(plock);
-#endif
+#endif	
 #ifdef PLATFORM_WINDOWS
 
 	NdisReleaseSpinLock(plock);
@@ -1212,13 +1212,13 @@ void	_rtw_spinlock_ex(_lock	*plock)
 #endif
 #ifdef PLATFORM_FREEBSD
 	mtx_lock(plock);
-#endif
+#endif	
 #ifdef PLATFORM_WINDOWS
 
 	NdisDprAcquireSpinLock(plock);
 
 #endif
-
+	
 }
 
 void	_rtw_spinunlock_ex(_lock *plock)
@@ -1231,7 +1231,7 @@ void	_rtw_spinunlock_ex(_lock *plock)
 #endif
 #ifdef PLATFORM_FREEBSD
 	mtx_unlock(plock);
-#endif
+#endif	
 #ifdef PLATFORM_WINDOWS
 
 	NdisDprReleaseSpinLock(plock);
@@ -1267,10 +1267,10 @@ u32 rtw_end_of_queue_search(_list *head, _list *plist)
 
 u32	rtw_get_current_time(void)
 {
-
+	
 #ifdef PLATFORM_LINUX
 	return jiffies;
-#endif
+#endif	
 #ifdef PLATFORM_FREEBSD
 	struct timeval tvp;
 	getmicrotime(&tvp);
@@ -1279,7 +1279,7 @@ u32	rtw_get_current_time(void)
 #ifdef PLATFORM_WINDOWS
 	LARGE_INTEGER	SystemTime;
 	NdisGetCurrentSystemTime(&SystemTime);
-	return (u32)(SystemTime.LowPart);// count of 100-nanosecond intervals
+	return (u32)(SystemTime.LowPart);// count of 100-nanosecond intervals 
 #endif
 }
 
@@ -1287,12 +1287,12 @@ inline u32 rtw_systime_to_ms(u32 systime)
 {
 #ifdef PLATFORM_LINUX
 	return systime * 1000 / HZ;
-#endif
+#endif	
 #ifdef PLATFORM_FREEBSD
 	return systime * 1000;
-#endif
+#endif	
 #ifdef PLATFORM_WINDOWS
-	return systime / 10000 ;
+	return systime / 10000 ; 
 #endif
 }
 
@@ -1300,12 +1300,12 @@ inline u32 rtw_ms_to_systime(u32 ms)
 {
 #ifdef PLATFORM_LINUX
 	return ms * HZ / 1000;
-#endif
+#endif	
 #ifdef PLATFORM_FREEBSD
 	return ms /1000;
-#endif
+#endif	
 #ifdef PLATFORM_WINDOWS
-	return ms * 10000 ;
+	return ms * 10000 ; 
 #endif
 }
 
@@ -1317,7 +1317,7 @@ inline s32 rtw_get_passing_time_ms(u32 start)
 #endif
 #ifdef PLATFORM_FREEBSD
 	return rtw_systime_to_ms(rtw_get_current_time());
-#endif
+#endif	
 #ifdef PLATFORM_WINDOWS
 	LARGE_INTEGER	SystemTime;
 	NdisGetCurrentSystemTime(&SystemTime);
@@ -1332,20 +1332,20 @@ inline s32 rtw_get_time_interval_ms(u32 start, u32 end)
 #endif
 #ifdef PLATFORM_FREEBSD
 	return rtw_systime_to_ms(rtw_get_current_time());
-#endif
+#endif	
 #ifdef PLATFORM_WINDOWS
 	return rtw_systime_to_ms(end-start);
 #endif
 }
+	
 
-
-void rtw_sleep_schedulable(int ms)
+void rtw_sleep_schedulable(int ms)	
 {
 
 #ifdef PLATFORM_LINUX
 
     u32 delta;
-
+    
     delta = (ms * HZ)/1000;//(ms)
     if (delta == 0) {
         delta = 1;// 1 ms
@@ -1356,12 +1356,12 @@ void rtw_sleep_schedulable(int ms)
     }
     return;
 
-#endif
+#endif	
 #ifdef PLATFORM_FREEBSD
 	DELAY(ms*1000);
 	return ;
-#endif
-
+#endif	
+	
 #ifdef PLATFORM_WINDOWS
 
 	NdisMSleep(ms*1000); //(us)*1000=(ms)
@@ -1376,14 +1376,14 @@ void rtw_msleep_os(int ms)
 
 #ifdef PLATFORM_LINUX
 
-	msleep((unsigned int)ms);
+  	msleep((unsigned int)ms);
 
-#endif
+#endif	
 #ifdef PLATFORM_FREEBSD
-       //Delay for delay microseconds
+       //Delay for delay microseconds 
 	DELAY(ms*1000);
 	return ;
-#endif
+#endif	
 #ifdef PLATFORM_WINDOWS
 
 	NdisMSleep(ms*1000); //(us)*1000=(ms)
@@ -1396,20 +1396,20 @@ void rtw_usleep_os(int us)
 {
 
 #ifdef PLATFORM_LINUX
-
+  	
       // msleep((unsigned int)us);
       if ( 1 < (us/1000) )
                 msleep(1);
       else
 		msleep( (us/1000) + 1);
 
-#endif
+#endif	
 #ifdef PLATFORM_FREEBSD
-	//Delay for delay microseconds
+	//Delay for delay microseconds 
 	DELAY(us);
 
 	return ;
-#endif
+#endif	
 #ifdef PLATFORM_WINDOWS
 
 	NdisMSleep(us); //(us)
@@ -1435,7 +1435,7 @@ void _rtw_mdelay_os(int ms, const char *func, const int line)
 
 #if defined(PLATFORM_LINUX)
 
-	mdelay((unsigned long)ms);
+   	mdelay((unsigned long)ms); 
 
 #elif defined(PLATFORM_WINDOWS)
 
@@ -1454,15 +1454,15 @@ void _rtw_udelay_os(int us, const char *func, const int line)
 		rtw_usleep_os(us);
 		return;
 	}
-	#endif
+	#endif 
 
 
 	DBG_871X("%s:%d %s(%d)\n", func, line, __FUNCTION__, us);
-
-
+	
+	
 #if defined(PLATFORM_LINUX)
 
-      udelay((unsigned long)us);
+      udelay((unsigned long)us); 
 
 #elif defined(PLATFORM_WINDOWS)
 
@@ -1477,13 +1477,13 @@ void rtw_mdelay_os(int ms)
 
 #ifdef PLATFORM_LINUX
 
-	mdelay((unsigned long)ms);
+   	mdelay((unsigned long)ms); 
 
-#endif
+#endif	
 #ifdef PLATFORM_FREEBSD
 	DELAY(ms*1000);
 	return ;
-#endif
+#endif	
 #ifdef PLATFORM_WINDOWS
 
 	NdisStallExecution(ms*1000); //(us)*1000=(ms)
@@ -1497,14 +1497,14 @@ void rtw_udelay_os(int us)
 
 #ifdef PLATFORM_LINUX
 
-      udelay((unsigned long)us);
+      udelay((unsigned long)us); 
 
-#endif
+#endif	
 #ifdef PLATFORM_FREEBSD
-	//Delay for delay microseconds
+	//Delay for delay microseconds 
 	DELAY(us);
 	return ;
-#endif
+#endif		
 #ifdef PLATFORM_WINDOWS
 
 	NdisStallExecution(us); //(us)
@@ -1705,19 +1705,19 @@ inline int ATOMIC_DEC_RETURN(ATOMIC_T *v)
 * @param mode please refer to linux document
 * @return Linux specific error code
 */
-static int openFile(struct file **fpp, char *path, int flag, int mode)
-{
-	struct file *fp;
-
-	fp=filp_open(path, flag, mode);
+static int openFile(struct file **fpp, char *path, int flag, int mode) 
+{ 
+	struct file *fp; 
+ 
+	fp=filp_open(path, flag, mode); 
 	if(IS_ERR(fp)) {
 		*fpp=NULL;
 		return PTR_ERR(fp);
 	}
 	else {
-		*fpp=fp;
+		*fpp=fp; 
 		return 0;
-	}
+	}	
 }
 
 /*
@@ -1725,17 +1725,17 @@ static int openFile(struct file **fpp, char *path, int flag, int mode)
 * @param fp the pointer of struct file to close
 * @return always 0
 */
-static int closeFile(struct file *fp)
-{
+static int closeFile(struct file *fp) 
+{ 
 	filp_close(fp,NULL);
-	return 0;
+	return 0; 
 }
 
-static int readFile(struct file *fp,char *buf,int len)
-{
+static int readFile(struct file *fp,char *buf,int len) 
+{ 
 	int rlen=0, sum=0;
-
-	if (!fp->f_op || !fp->f_op->read)
+	
+	if (!fp->f_op || !fp->f_op->read) 
 		return -EPERM;
 
 	while(sum<len) {
@@ -1747,17 +1747,17 @@ static int readFile(struct file *fp,char *buf,int len)
 		else
 			break;
 	}
-
+	
 	return  sum;
 
 }
 
-static int writeFile(struct file *fp,char *buf,int len)
-{
+static int writeFile(struct file *fp,char *buf,int len) 
+{ 
 	int wlen=0, sum=0;
-
-	if (!fp->f_op || !fp->f_op->write)
-		return -EPERM;
+	
+	if (!fp->f_op || !fp->f_op->write) 
+		return -EPERM; 
 
 	while(sum<len) {
 		wlen=fp->f_op->write(fp,buf+sum,len-sum, &fp->f_pos);
@@ -1779,25 +1779,25 @@ static int writeFile(struct file *fp,char *buf,int len)
 * @return Linux specific error code
 */
 static int isFileReadable(char *path)
-{
+{ 
 	struct file *fp;
 	int ret = 0;
 	mm_segment_t oldfs;
 	char buf;
-
-	fp=filp_open(path, O_RDONLY, 0);
+ 
+	fp=filp_open(path, O_RDONLY, 0); 
 	if(IS_ERR(fp)) {
 		ret = PTR_ERR(fp);
 	}
 	else {
 		oldfs = get_fs(); set_fs(get_ds());
-
+		
 		if(1!=readFile(fp, &buf, 1))
 			ret = PTR_ERR(fp);
-
+		
 		set_fs(oldfs);
 		filp_close(fp,NULL);
-	}
+	}	
 	return ret;
 }
 
@@ -1822,9 +1822,9 @@ static int retriveFromFile(char *path, u8* buf, u32 sz)
 			ret=readFile(fp, buf, sz);
 			set_fs(oldfs);
 			closeFile(fp);
-
+			
 			DBG_871X("%s readFile, ret:%d\n",__FUNCTION__, ret);
-
+			
 		} else {
 			DBG_871X("%s openFile path:%s Fail, ret:%d\n",__FUNCTION__, path, ret);
 		}
@@ -1847,7 +1847,7 @@ static int storeToFile(char *path, u8* buf, u32 sz)
 	int ret =0;
 	mm_segment_t oldfs;
 	struct file *fp;
-
+	
 	if(path && buf) {
 		if( 0 == (ret=openFile(&fp, path, O_CREAT|O_WRONLY, 0666)) ) {
 			DBG_871X("%s openFile path:%s fp=%p\n",__FUNCTION__, path ,fp);
@@ -1858,10 +1858,10 @@ static int storeToFile(char *path, u8* buf, u32 sz)
 			closeFile(fp);
 
 			DBG_871X("%s writeFile, ret:%d\n",__FUNCTION__, ret);
-
+			
 		} else {
 			DBG_871X("%s openFile path:%s Fail, ret:%d\n",__FUNCTION__, path, ret);
-		}
+		}	
 	} else {
 		DBG_871X("%s NULL pointer\n",__FUNCTION__);
 		ret =  -EINVAL;
@@ -1938,7 +1938,7 @@ struct net_device *rtw_alloc_etherdev_with_old_priv(int sizeof_priv, void *old_p
 #endif
 	if (!pnetdev)
 		goto RETURN;
-
+	
 	pnpi = netdev_priv(pnetdev);
 	pnpi->priv=old_priv;
 	pnpi->sizeof_priv=sizeof_priv;
@@ -1959,16 +1959,16 @@ struct net_device *rtw_alloc_etherdev(int sizeof_priv)
 #endif
 	if (!pnetdev)
 		goto RETURN;
-
+	
 	pnpi = netdev_priv(pnetdev);
-
+	
 	pnpi->priv = rtw_zvmalloc(sizeof_priv);
 	if (!pnpi->priv) {
 		free_netdev(pnetdev);
 		pnetdev = NULL;
 		goto RETURN;
 	}
-
+	
 	pnpi->sizeof_priv=sizeof_priv;
 RETURN:
 	return pnetdev;
@@ -1977,10 +1977,10 @@ struct net_device *rtw_alloc_etherdev(int sizeof_priv)
 void rtw_free_netdev(struct net_device * netdev)
 {
 	struct rtw_netdev_priv_indicator *pnpi;
-
+	
 	if(!netdev)
 		goto RETURN;
-
+	
 	pnpi = netdev_priv(netdev);
 
 	if(!pnpi->priv)
@@ -1994,7 +1994,7 @@ void rtw_free_netdev(struct net_device * netdev)
 }
 
 /*
-* Jeff: this function should be called under ioctl (rtnl_lock is accquired) while
+* Jeff: this function should be called under ioctl (rtnl_lock is accquired) while 
 * LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26)
 */
 int rtw_change_ifname(_adapter *padapter, const char *ifname)
@@ -2008,7 +2008,7 @@ int rtw_change_ifname(_adapter *padapter, const char *ifname)
 		goto error;
 
 	rereg_priv = &padapter->rereg_nd_name_priv;
-
+	
 	//free the old_pnetdev
 	if(rereg_priv->old_pnetdev) {
 		free_netdev(rereg_priv->old_pnetdev);
@@ -2055,29 +2055,29 @@ int rtw_change_ifname(_adapter *padapter, const char *ifname)
 	return 0;
 
 error:
-
+	
 	return -1;
-
+	
 }
 #endif
 #endif //MEM_ALLOC_REFINE_ADAPTOR
 
 #ifdef PLATFORM_FREEBSD
 /*
- * Copy a buffer from userspace and write into kernel address
+ * Copy a buffer from userspace and write into kernel address 
  * space.
  *
- * This emulation just calls the FreeBSD copyin function (to
+ * This emulation just calls the FreeBSD copyin function (to 
  * copy data from user space buffer into a kernel space buffer)
  * and is designed to be used with the above io_write_wrapper.
  *
  * This function should return the number of bytes not copied.
- * I.e. success results in a zero value.
+ * I.e. success results in a zero value. 
  * Negative error values are not returned.
  */
 unsigned long
 copy_from_user(void *to, const void *from, unsigned long n)
-{
+{      
         if ( copyin(from, to, n) != 0 ) {
                 /* Any errors will be treated as a failure
                    to copy any of the requested bytes */
@@ -2108,7 +2108,7 @@ int rtw_change_ifname(_adapter *padapter, const char *ifname)
  *
  * usb_register and usb_deregister simply call these functions.
  */
-int
+int 
 usb_register(struct usb_driver *driver)
 {
         rtw_usb_linux_register(driver);
@@ -2116,7 +2116,7 @@ int rtw_change_ifname(_adapter *padapter, const char *ifname)
 }
 
 
-int
+int 
 usb_deregister(struct usb_driver *driver)
 {
         rtw_usb_linux_deregister(driver);
@@ -2297,3 +2297,4 @@ void rtw_cbuf_free(struct rtw_cbuf *cbuf)
 {
 	rtw_mfree((u8*)cbuf, sizeof(*cbuf) + sizeof(void*)*cbuf->size);
 }
+
-- 
1.9.1

