From 07b0e905350d7808462e8b0e71b60ecd406cbc4e Mon Sep 17 00:00:00 2001
From: Phil Elwell <phil@raspberrypi.org>
Date: Thu, 14 Jun 2018 15:07:26 +0100
Subject: [PATCH] of: configfs: Use of_overlay_fdt_apply API call

The published API to the dynamic overlay application mechanism now
takes a Flattened Device Tree blob as input so that it can manage the
lifetime of the unflattened tree. Conveniently, the new API call -
of_overlay_fdt_apply - is virtually a drop-in replacement for
create_overlay, which can now be deleted.

Signed-off-by: Phil Elwell <phil@raspberrypi.org>
---
 drivers/of/configfs.c | 28 ++++++++--------------------
 1 file changed, 8 insertions(+), 20 deletions(-)

diff --git a/drivers/of/configfs.c b/drivers/of/configfs.c
index 64caba77a719..45c19bd14864 100644
--- a/drivers/of/configfs.c
+++ b/drivers/of/configfs.c
@@ -43,21 +43,6 @@ struct cfs_overlay_item {
 	void			*mem;
 };
 
-static int create_overlay(struct cfs_overlay_item *overlay, void *blob)
-{
-	int err;
-
-	/* FIXME */
-	err = of_overlay_fdt_apply(blob, overlay->dtbo_size, &overlay->ov_id);
-	if (err < 0) {
-		pr_err("%s: Failed to create overlay (err=%d)\n",
-		       __func__, err);
-		return err;
-	}
-
-	return err;
-}
-
 static inline struct cfs_overlay_item
 		*to_cfs_overlay_item(struct config_item *item)
 {
@@ -97,7 +82,8 @@ static ssize_t cfs_overlay_item_path_store(struct config_item *item,
 		goto out_err;
 
 	overlay->dtbo_size = overlay->fw->size;
-	err = create_overlay(overlay, (void *)overlay->fw->data);
+	err = of_overlay_fdt_apply((void *)overlay->fw->data,
+				   (u32)overlay->fw->size, &overlay->ov_id);
 	if (err < 0)
 		goto out_err;
 
@@ -116,7 +102,7 @@ static ssize_t cfs_overlay_item_path_store(struct config_item *item,
 static ssize_t cfs_overlay_item_status_show(struct config_item *item,
 					    char *page)
 {
-	return sprintf(page, "%s\n", to_cfs_overlay_item(item)->ov_id >= 0 ?
+	return sprintf(page, "%s\n", to_cfs_overlay_item(item)->ov_id > 0 ?
 					"applied" : "unapplied");
 }
 
@@ -168,7 +154,8 @@ ssize_t cfs_overlay_item_dtbo_write(struct config_item *item,
 
 	overlay->dtbo_size = count;
 
-	err = create_overlay(overlay, overlay->dtbo);
+	err = of_overlay_fdt_apply(overlay->dtbo, overlay->dtbo_size,
+				   &overlay->ov_id);
 	if (err < 0)
 		goto out_err;
 
@@ -178,6 +165,7 @@ ssize_t cfs_overlay_item_dtbo_write(struct config_item *item,
 	kfree(overlay->dtbo);
 	overlay->dtbo = NULL;
 	overlay->dtbo_size = 0;
+	overlay->ov_id = 0;
 
 	return err;
 }
@@ -193,7 +181,7 @@ static void cfs_overlay_release(struct config_item *item)
 {
 	struct cfs_overlay_item *overlay = to_cfs_overlay_item(item);
 
-	if (overlay->ov_id >= 0)
+	if (overlay->ov_id > 0)
 		of_overlay_remove(&overlay->ov_id);
 	if (overlay->fw)
 		release_firmware(overlay->fw);
@@ -223,7 +211,7 @@ static struct config_item
 	overlay = kzalloc(sizeof(*overlay), GFP_KERNEL);
 	if (!overlay)
 		return ERR_PTR(-ENOMEM);
-	overlay->ov_id = -1;
+
 	config_item_init_type_name(&overlay->item, name, &cfs_overlay_type);
 
 	return &overlay->item;
-- 
2.32.0

