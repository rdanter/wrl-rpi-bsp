From 1b1a2fe54d4a789a21d8d976a60a5b92e71728c2 Mon Sep 17 00:00:00 2001
From: Dom Cobley <popcornmix@gmail.com>
Date: Thu, 27 Jan 2022 14:32:27 +0000
Subject: [PATCH 1349/2201] Revert "drm/vc4: Add support for DRM_FORMAT_P030 to
 vc4 planes"

This reverts commit 63a31c81af9518d53b351dc8c2f24773cda77dfc.
---
 drivers/gpu/drm/vc4/vc4_plane.c | 79 +++++++++------------------------
 1 file changed, 22 insertions(+), 57 deletions(-)

diff --git a/drivers/gpu/drm/vc4/vc4_plane.c b/drivers/gpu/drm/vc4/vc4_plane.c
index 046ac1fff467..45cfcc725a91 100644
--- a/drivers/gpu/drm/vc4/vc4_plane.c
+++ b/drivers/gpu/drm/vc4/vc4_plane.c
@@ -33,7 +33,6 @@ static const struct hvs_format {
 	u32 hvs; /* HVS_FORMAT_* */
 	u32 pixel_order;
 	u32 pixel_order_hvs5;
-	bool hvs5_only;
 } hvs_formats[] = {
 	{
 		.drm = DRM_FORMAT_XRGB8888,
@@ -129,12 +128,6 @@ static const struct hvs_format {
 		.hvs = HVS_PIXEL_FORMAT_YCBCR_YUV422_2PLANE,
 		.pixel_order = HVS_PIXEL_ORDER_XYCRCB,
 	},
-	{
-		.drm = DRM_FORMAT_P030,
-		.hvs = HVS_PIXEL_FORMAT_YCBCR_10BIT,
-		.pixel_order = HVS_PIXEL_ORDER_XYCBCR,
-		.hvs5_only = true,
-	},
 };
 
 static const struct hvs_format *vc4_get_hvs_format(u32 drm_format)
@@ -857,33 +850,27 @@ static int vc4_plane_mode_set(struct drm_plane *plane,
 		uint32_t param = fourcc_mod_broadcom_param(fb->modifier);
 		u32 tile_w, tile, x_off, pix_per_tile;
 
-		if (fb->format->format == DRM_FORMAT_P030) {
-			hvs_format = HVS_PIXEL_FORMAT_YCBCR_10BIT;
+		hvs_format = HVS_PIXEL_FORMAT_H264;
+
+		switch (base_format_mod) {
+		case DRM_FORMAT_MOD_BROADCOM_SAND64:
+			tiling = SCALER_CTL0_TILING_64B;
+			tile_w = 64;
+			break;
+		case DRM_FORMAT_MOD_BROADCOM_SAND128:
 			tiling = SCALER_CTL0_TILING_128B;
-			tile_w = 96;
-		} else {
-			hvs_format = HVS_PIXEL_FORMAT_H264;
-
-			switch (base_format_mod) {
-			case DRM_FORMAT_MOD_BROADCOM_SAND64:
-				tiling = SCALER_CTL0_TILING_64B;
-				tile_w = 64;
-				break;
-			case DRM_FORMAT_MOD_BROADCOM_SAND128:
-				tiling = SCALER_CTL0_TILING_128B;
-				tile_w = 128;
-				break;
-			case DRM_FORMAT_MOD_BROADCOM_SAND256:
-				tiling = SCALER_CTL0_TILING_256B_OR_T;
-				tile_w = 256;
-				break;
-			default:
-				break;
-			}
+			tile_w = 128;
+			break;
+		case DRM_FORMAT_MOD_BROADCOM_SAND256:
+			tiling = SCALER_CTL0_TILING_256B_OR_T;
+			tile_w = 256;
+			break;
+		default:
+			break;
 		}
+
 		if (param > SCALER_TILE_HEIGHT_MASK) {
-			DRM_DEBUG_KMS("SAND height too large (%d)\n",
-				      param);
+			DRM_DEBUG_KMS("SAND height too large (%d)\n", param);
 			return -EINVAL;
 		}
 
@@ -893,13 +880,6 @@ static int vc4_plane_mode_set(struct drm_plane *plane,
 
 		/* Adjust the base pointer to the first pixel to be scanned
 		 * out.
-		 *
-		 * For P030, y_ptr [31:4] is the 128bit word for the start pixel
-		 * y_ptr [3:0] is the pixel (0-11) contained within that 128bit
-		 * word that should be taken as the first pixel.
-		 * Ditto uv_ptr [31:4] vs [3:0], however [3:0] contains the
-		 * element within the 128bit word, eg for pixel 3 the value
-		 * should be 6.
 		 */
 		for (i = 0; i < num_planes; i++) {
 			vc4_state->offsets[i] += param * tile_w * tile;
@@ -1051,8 +1031,7 @@ static int vc4_plane_mode_set(struct drm_plane *plane,
 
 	/* Pitch word 1/2 */
 	for (i = 1; i < num_planes; i++) {
-		if (hvs_format != HVS_PIXEL_FORMAT_H264 &&
-		    hvs_format != HVS_PIXEL_FORMAT_YCBCR_10BIT) {
+		if (hvs_format != HVS_PIXEL_FORMAT_H264) {
 			vc4_dlist_write(vc4_state,
 					VC4_SET_FIELD(fb->pitches[i],
 						      SCALER_SRC_PITCH));
@@ -1417,13 +1396,6 @@ static bool vc4_format_mod_supported(struct drm_plane *plane,
 		default:
 			return false;
 		}
-	case DRM_FORMAT_P030:
-		switch (fourcc_mod_broadcom_mod(modifier)) {
-		case DRM_FORMAT_MOD_BROADCOM_SAND128:
-			return true;
-		default:
-			return false;
-		}
 	case DRM_FORMAT_RGBX1010102:
 	case DRM_FORMAT_BGRX1010102:
 	case DRM_FORMAT_RGBA1010102:
@@ -1456,11 +1428,8 @@ struct drm_plane *vc4_plane_init(struct drm_device *dev,
 	struct drm_plane *plane = NULL;
 	struct vc4_plane *vc4_plane;
 	u32 formats[ARRAY_SIZE(hvs_formats)];
-	int num_formats = 0;
 	int ret = 0;
 	unsigned i;
-	bool hvs5 = of_device_is_compatible(dev->dev->of_node,
-					    "brcm,bcm2711-vc5");
 	static const uint64_t modifiers[] = {
 		DRM_FORMAT_MOD_BROADCOM_VC4_T_TILED,
 		DRM_FORMAT_MOD_BROADCOM_SAND128,
@@ -1475,17 +1444,13 @@ struct drm_plane *vc4_plane_init(struct drm_device *dev,
 	if (!vc4_plane)
 		return ERR_PTR(-ENOMEM);
 
-	for (i = 0; i < ARRAY_SIZE(hvs_formats); i++) {
-		if (!hvs_formats[i].hvs5_only || hvs5) {
-			formats[num_formats] = hvs_formats[i].drm;
-			num_formats++;
-		}
-	}
+	for (i = 0; i < ARRAY_SIZE(hvs_formats); i++)
+		formats[i] = hvs_formats[i].drm;
 
 	plane = &vc4_plane->base;
 	ret = drm_universal_plane_init(dev, plane, 0,
 				       &vc4_plane_funcs,
-				       formats, num_formats,
+				       formats, ARRAY_SIZE(formats),
 				       modifiers, type, NULL);
 	if (ret)
 		return ERR_PTR(ret);
-- 
2.17.1

