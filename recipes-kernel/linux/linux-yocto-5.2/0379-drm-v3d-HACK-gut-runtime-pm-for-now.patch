From 610baa80add5f1e99c7f7e6fc844a9fcf07dd6e6 Mon Sep 17 00:00:00 2001
From: Eric Anholt <eric@anholt.net>
Date: Mon, 14 Jan 2019 15:13:17 -0800
Subject: [PATCH 379/587] drm/v3d: HACK: gut runtime pm for now.

Something is still unstable -- on starting a new glxgears from an idle
X11, I get an MMU violation in high addresses.  The CTS also failed
quite quickly.  With this, CTS progresses for an hour before OOMing
(allocating some big buffers when my board only has 600MB available to
Linux)

Signed-off-by: Eric Anholt <eric@anholt.net>
---
 drivers/gpu/drm/v3d/v3d_debugfs.c | 16 +---------------
 drivers/gpu/drm/v3d/v3d_drv.c     |  9 ---------
 drivers/gpu/drm/v3d/v3d_gem.c     | 20 --------------------
 3 files changed, 1 insertion(+), 44 deletions(-)

diff --git a/drivers/gpu/drm/v3d/v3d_debugfs.c b/drivers/gpu/drm/v3d/v3d_debugfs.c
index a24af2d2f574..b15051df2dbb 100644
--- a/drivers/gpu/drm/v3d/v3d_debugfs.c
+++ b/drivers/gpu/drm/v3d/v3d_debugfs.c
@@ -4,7 +4,6 @@
 #include <linux/circ_buf.h>
 #include <linux/ctype.h>
 #include <linux/debugfs.h>
-#include <linux/pm_runtime.h>
 #include <linux/seq_file.h>
 #include <drm/drmP.h>
 
@@ -100,11 +99,8 @@ static int v3d_v3d_debugfs_ident(struct seq_file *m, void *unused)
 	struct drm_device *dev = node->minor->dev;
 	struct v3d_dev *v3d = to_v3d_dev(dev);
 	u32 ident0, ident1, ident2, ident3, cores;
-	int ret, core;
+	int core;
 
-	ret = pm_runtime_get_sync(v3d->dev);
-	if (ret < 0)
-		return ret;
 
 	ident0 = V3D_READ(V3D_HUB_IDENT0);
 	ident1 = V3D_READ(V3D_HUB_IDENT1);
@@ -157,9 +153,6 @@ static int v3d_v3d_debugfs_ident(struct seq_file *m, void *unused)
 			   (misccfg & V3D_MISCCFG_OVRTMUOUT) != 0);
 	}
 
-	pm_runtime_mark_last_busy(v3d->dev);
-	pm_runtime_put_autosuspend(v3d->dev);
-
 	return 0;
 }
 
@@ -187,11 +180,6 @@ static int v3d_measure_clock(struct seq_file *m, void *unused)
 	uint32_t cycles;
 	int core = 0;
 	int measure_ms = 1000;
-	int ret;
-
-	ret = pm_runtime_get_sync(v3d->dev);
-	if (ret < 0)
-		return ret;
 
 	if (v3d->ver >= 40) {
 		V3D_CORE_WRITE(core, V3D_V4_PCTR_0_SRC_0_3,
@@ -215,8 +203,6 @@ static int v3d_measure_clock(struct seq_file *m, void *unused)
 		   cycles / (measure_ms * 1000),
 		   (cycles / (measure_ms * 100)) % 10);
 
-	pm_runtime_mark_last_busy(v3d->dev);
-	pm_runtime_put_autosuspend(v3d->dev);
 
 	return 0;
 }
diff --git a/drivers/gpu/drm/v3d/v3d_drv.c b/drivers/gpu/drm/v3d/v3d_drv.c
index 8bf8e2a8d27a..bca6ed754fcb 100644
--- a/drivers/gpu/drm/v3d/v3d_drv.c
+++ b/drivers/gpu/drm/v3d/v3d_drv.c
@@ -75,7 +75,6 @@ static int v3d_get_param_ioctl(struct drm_device *dev, void *data,
 {
 	struct v3d_dev *v3d = to_v3d_dev(dev);
 	struct drm_v3d_get_param *args = data;
-	int ret;
 	static const u32 reg_map[] = {
 		[DRM_V3D_PARAM_V3D_UIFCFG] = V3D_HUB_UIFCFG,
 		[DRM_V3D_PARAM_V3D_HUB_IDENT1] = V3D_HUB_IDENT1,
@@ -101,17 +100,12 @@ static int v3d_get_param_ioctl(struct drm_device *dev, void *data,
 		if (args->value != 0)
 			return -EINVAL;
 
-		ret = pm_runtime_get_sync(v3d->dev);
-		if (ret < 0)
-			return ret;
 		if (args->param >= DRM_V3D_PARAM_V3D_CORE0_IDENT0 &&
 		    args->param <= DRM_V3D_PARAM_V3D_CORE0_IDENT2) {
 			args->value = V3D_CORE_READ(0, offset);
 		} else {
 			args->value = V3D_READ(offset);
 		}
-		pm_runtime_mark_last_busy(v3d->dev);
-		pm_runtime_put_autosuspend(v3d->dev);
 		return 0;
 	}
 
@@ -291,9 +285,6 @@ static int v3d_platform_drm_probe(struct platform_device *pdev)
 		goto dev_free;
 	}
 
-	pm_runtime_use_autosuspend(dev);
-	pm_runtime_set_autosuspend_delay(dev, 50);
-	pm_runtime_enable(dev);
 
 	ret = drm_dev_init(&v3d->drm, &v3d_drm_driver, dev);
 	if (ret)
diff --git a/drivers/gpu/drm/v3d/v3d_gem.c b/drivers/gpu/drm/v3d/v3d_gem.c
index 93ff8fcbe475..d024ea738dfb 100644
--- a/drivers/gpu/drm/v3d/v3d_gem.c
+++ b/drivers/gpu/drm/v3d/v3d_gem.c
@@ -333,7 +333,6 @@ v3d_exec_cleanup(struct kref *ref)
 {
 	struct v3d_exec_info *exec = container_of(ref, struct v3d_exec_info,
 						  refcount);
-	struct v3d_dev *v3d = exec->v3d;
 	unsigned int i;
 	struct v3d_bo *bo, *save;
 
@@ -354,9 +353,6 @@ v3d_exec_cleanup(struct kref *ref)
 		drm_gem_object_put_unlocked(&bo->base.base);
 	}
 
-	pm_runtime_mark_last_busy(v3d->dev);
-	pm_runtime_put_autosuspend(v3d->dev);
-
 	kfree(exec);
 }
 
@@ -370,7 +366,6 @@ v3d_tfu_job_cleanup(struct kref *ref)
 {
 	struct v3d_tfu_job *job = container_of(ref, struct v3d_tfu_job,
 					       refcount);
-	struct v3d_dev *v3d = job->v3d;
 	unsigned int i;
 
 	dma_fence_put(job->in_fence);
@@ -381,9 +376,6 @@ v3d_tfu_job_cleanup(struct kref *ref)
 			drm_gem_object_put_unlocked(&job->bo[i]->base.base);
 	}
 
-	pm_runtime_mark_last_busy(v3d->dev);
-	pm_runtime_put_autosuspend(v3d->dev);
-
 	kfree(job);
 }
 
@@ -460,12 +452,6 @@ v3d_submit_cl_ioctl(struct drm_device *dev, void *data,
 	if (!exec)
 		return -ENOMEM;
 
-	ret = pm_runtime_get_sync(v3d->dev);
-	if (ret < 0) {
-		kfree(exec);
-		return ret;
-	}
-
 	kref_init(&exec->refcount);
 
 	ret = drm_syncobj_find_fence(file_priv, args->in_sync_bcl,
@@ -583,12 +569,6 @@ v3d_submit_tfu_ioctl(struct drm_device *dev, void *data,
 	if (!job)
 		return -ENOMEM;
 
-	ret = pm_runtime_get_sync(v3d->dev);
-	if (ret < 0) {
-		kfree(job);
-		return ret;
-	}
-
 	kref_init(&job->refcount);
 
 	ret = drm_syncobj_find_fence(file_priv, args->in_sync,
-- 
2.17.1

